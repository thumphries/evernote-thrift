{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-missing-fields #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-----------------------------------------------------------------
-- Autogenerated by Thrift Compiler (0.11.0)                      --
--                                                             --
-- DO NOT EDIT UNLESS YOU ARE SURE YOU KNOW WHAT YOU ARE DOING --
-----------------------------------------------------------------

module UserStore_Types where
import Prelude (($), (.), (>>=), (==), (++))
import qualified Prelude as P
import qualified Control.Exception as X
import qualified Control.Monad as M ( liftM, ap, when )
import Data.Functor ( (<$>) )
import qualified Data.ByteString.Lazy as LBS
import qualified Data.Hashable as H
import qualified Data.Int as I
import qualified Data.Maybe as M (catMaybes)
import qualified Data.Text.Lazy.Encoding as E ( decodeUtf8, encodeUtf8 )
import qualified Data.Text.Lazy as LT
import qualified GHC.Generics as G (Generic)
import qualified Data.Typeable as TY ( Typeable )
import qualified Data.HashMap.Strict as Map
import qualified Data.HashSet as Set
import qualified Data.Vector as Vector
import qualified Test.QuickCheck.Arbitrary as QC ( Arbitrary(..) )
import qualified Test.QuickCheck as QC ( elements )

import qualified Thrift as T
import qualified Thrift.Types as T
import qualified Thrift.Arbitraries as T

import qualified Types_Types
import qualified Errors_Types


data PublicUserInfo = PublicUserInfo  { publicUserInfo_userId :: I.Int32
  , publicUserInfo_serviceLevel :: P.Maybe Types_Types.ServiceLevel
  , publicUserInfo_username :: P.Maybe LT.Text
  , publicUserInfo_noteStoreUrl :: P.Maybe LT.Text
  , publicUserInfo_webApiUrlPrefix :: P.Maybe LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable PublicUserInfo where
  hashWithSalt salt record = salt   `H.hashWithSalt` publicUserInfo_userId record   `H.hashWithSalt` publicUserInfo_serviceLevel record   `H.hashWithSalt` publicUserInfo_username record   `H.hashWithSalt` publicUserInfo_noteStoreUrl record   `H.hashWithSalt` publicUserInfo_webApiUrlPrefix record  
instance QC.Arbitrary PublicUserInfo where 
  arbitrary = M.liftM PublicUserInfo (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_PublicUserInfo = []
             | P.otherwise = M.catMaybes
    [ if obj == default_PublicUserInfo{publicUserInfo_userId = publicUserInfo_userId obj} then P.Nothing else P.Just $ default_PublicUserInfo{publicUserInfo_userId = publicUserInfo_userId obj}
    , if obj == default_PublicUserInfo{publicUserInfo_serviceLevel = publicUserInfo_serviceLevel obj} then P.Nothing else P.Just $ default_PublicUserInfo{publicUserInfo_serviceLevel = publicUserInfo_serviceLevel obj}
    , if obj == default_PublicUserInfo{publicUserInfo_username = publicUserInfo_username obj} then P.Nothing else P.Just $ default_PublicUserInfo{publicUserInfo_username = publicUserInfo_username obj}
    , if obj == default_PublicUserInfo{publicUserInfo_noteStoreUrl = publicUserInfo_noteStoreUrl obj} then P.Nothing else P.Just $ default_PublicUserInfo{publicUserInfo_noteStoreUrl = publicUserInfo_noteStoreUrl obj}
    , if obj == default_PublicUserInfo{publicUserInfo_webApiUrlPrefix = publicUserInfo_webApiUrlPrefix obj} then P.Nothing else P.Just $ default_PublicUserInfo{publicUserInfo_webApiUrlPrefix = publicUserInfo_webApiUrlPrefix obj}
    ]
from_PublicUserInfo :: PublicUserInfo -> T.ThriftVal
from_PublicUserInfo record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2 -> P.Just (1, ("userId",T.TI32 _v2))) $ publicUserInfo_userId record
  , (\_v2 -> (4, ("username",T.TString $ E.encodeUtf8 _v2))) <$> publicUserInfo_username record
  , (\_v2 -> (5, ("noteStoreUrl",T.TString $ E.encodeUtf8 _v2))) <$> publicUserInfo_noteStoreUrl record
  , (\_v2 -> (6, ("webApiUrlPrefix",T.TString $ E.encodeUtf8 _v2))) <$> publicUserInfo_webApiUrlPrefix record
  , (\_v2 -> (7, ("serviceLevel",T.TI32 $ P.fromIntegral $ P.fromEnum _v2))) <$> publicUserInfo_serviceLevel record
  ]
write_PublicUserInfo :: T.Protocol p => p -> PublicUserInfo -> P.IO ()
write_PublicUserInfo oprot record = T.writeVal oprot $ from_PublicUserInfo record
encode_PublicUserInfo :: T.StatelessProtocol p => p -> PublicUserInfo -> LBS.ByteString
encode_PublicUserInfo oprot record = T.serializeVal oprot $ from_PublicUserInfo record
to_PublicUserInfo :: T.ThriftVal -> PublicUserInfo
to_PublicUserInfo (T.TStruct fields) = PublicUserInfo{
  publicUserInfo_userId = P.maybe (P.error "Missing required field: userId") (\(_,_val4) -> (case _val4 of {T.TI32 _val5 -> _val5; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  publicUserInfo_serviceLevel = P.maybe (P.Nothing) (\(_,_val4) -> P.Just (case _val4 of {T.TI32 _val6 -> P.toEnum $ P.fromIntegral _val6; _ -> P.error "wrong type"})) (Map.lookup (7) fields),
  publicUserInfo_username = P.maybe (P.Nothing) (\(_,_val4) -> P.Just (case _val4 of {T.TString _val7 -> E.decodeUtf8 _val7; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  publicUserInfo_noteStoreUrl = P.maybe (P.Nothing) (\(_,_val4) -> P.Just (case _val4 of {T.TString _val8 -> E.decodeUtf8 _val8; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  publicUserInfo_webApiUrlPrefix = P.maybe (P.Nothing) (\(_,_val4) -> P.Just (case _val4 of {T.TString _val9 -> E.decodeUtf8 _val9; _ -> P.error "wrong type"})) (Map.lookup (6) fields)
  }
to_PublicUserInfo _ = P.error "not a struct"
read_PublicUserInfo :: T.Protocol p => p -> P.IO PublicUserInfo
read_PublicUserInfo iprot = to_PublicUserInfo <$> T.readVal iprot (T.T_STRUCT typemap_PublicUserInfo)
decode_PublicUserInfo :: T.StatelessProtocol p => p -> LBS.ByteString -> PublicUserInfo
decode_PublicUserInfo iprot bs = to_PublicUserInfo $ T.deserializeVal iprot (T.T_STRUCT typemap_PublicUserInfo) bs
typemap_PublicUserInfo :: T.TypeMap
typemap_PublicUserInfo = Map.fromList [(1,("userId",T.T_I32)),(4,("username",T.T_STRING)),(5,("noteStoreUrl",T.T_STRING)),(6,("webApiUrlPrefix",T.T_STRING)),(7,("serviceLevel",T.T_I32))]
default_PublicUserInfo :: PublicUserInfo
default_PublicUserInfo = PublicUserInfo{
  publicUserInfo_userId = 0,
  publicUserInfo_username = P.Nothing,
  publicUserInfo_noteStoreUrl = P.Nothing,
  publicUserInfo_webApiUrlPrefix = P.Nothing,
  publicUserInfo_serviceLevel = P.Nothing}
data UserUrls = UserUrls  { userUrls_noteStoreUrl :: P.Maybe LT.Text
  , userUrls_webApiUrlPrefix :: P.Maybe LT.Text
  , userUrls_userStoreUrl :: P.Maybe LT.Text
  , userUrls_utilityUrl :: P.Maybe LT.Text
  , userUrls_messageStoreUrl :: P.Maybe LT.Text
  , userUrls_userWebSocketUrl :: P.Maybe LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UserUrls where
  hashWithSalt salt record = salt   `H.hashWithSalt` userUrls_noteStoreUrl record   `H.hashWithSalt` userUrls_webApiUrlPrefix record   `H.hashWithSalt` userUrls_userStoreUrl record   `H.hashWithSalt` userUrls_utilityUrl record   `H.hashWithSalt` userUrls_messageStoreUrl record   `H.hashWithSalt` userUrls_userWebSocketUrl record  
instance QC.Arbitrary UserUrls where 
  arbitrary = M.liftM UserUrls (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_UserUrls = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UserUrls{userUrls_noteStoreUrl = userUrls_noteStoreUrl obj} then P.Nothing else P.Just $ default_UserUrls{userUrls_noteStoreUrl = userUrls_noteStoreUrl obj}
    , if obj == default_UserUrls{userUrls_webApiUrlPrefix = userUrls_webApiUrlPrefix obj} then P.Nothing else P.Just $ default_UserUrls{userUrls_webApiUrlPrefix = userUrls_webApiUrlPrefix obj}
    , if obj == default_UserUrls{userUrls_userStoreUrl = userUrls_userStoreUrl obj} then P.Nothing else P.Just $ default_UserUrls{userUrls_userStoreUrl = userUrls_userStoreUrl obj}
    , if obj == default_UserUrls{userUrls_utilityUrl = userUrls_utilityUrl obj} then P.Nothing else P.Just $ default_UserUrls{userUrls_utilityUrl = userUrls_utilityUrl obj}
    , if obj == default_UserUrls{userUrls_messageStoreUrl = userUrls_messageStoreUrl obj} then P.Nothing else P.Just $ default_UserUrls{userUrls_messageStoreUrl = userUrls_messageStoreUrl obj}
    , if obj == default_UserUrls{userUrls_userWebSocketUrl = userUrls_userWebSocketUrl obj} then P.Nothing else P.Just $ default_UserUrls{userUrls_userWebSocketUrl = userUrls_userWebSocketUrl obj}
    ]
from_UserUrls :: UserUrls -> T.ThriftVal
from_UserUrls record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v12 -> (1, ("noteStoreUrl",T.TString $ E.encodeUtf8 _v12))) <$> userUrls_noteStoreUrl record
  , (\_v12 -> (2, ("webApiUrlPrefix",T.TString $ E.encodeUtf8 _v12))) <$> userUrls_webApiUrlPrefix record
  , (\_v12 -> (3, ("userStoreUrl",T.TString $ E.encodeUtf8 _v12))) <$> userUrls_userStoreUrl record
  , (\_v12 -> (4, ("utilityUrl",T.TString $ E.encodeUtf8 _v12))) <$> userUrls_utilityUrl record
  , (\_v12 -> (5, ("messageStoreUrl",T.TString $ E.encodeUtf8 _v12))) <$> userUrls_messageStoreUrl record
  , (\_v12 -> (6, ("userWebSocketUrl",T.TString $ E.encodeUtf8 _v12))) <$> userUrls_userWebSocketUrl record
  ]
write_UserUrls :: T.Protocol p => p -> UserUrls -> P.IO ()
write_UserUrls oprot record = T.writeVal oprot $ from_UserUrls record
encode_UserUrls :: T.StatelessProtocol p => p -> UserUrls -> LBS.ByteString
encode_UserUrls oprot record = T.serializeVal oprot $ from_UserUrls record
to_UserUrls :: T.ThriftVal -> UserUrls
to_UserUrls (T.TStruct fields) = UserUrls{
  userUrls_noteStoreUrl = P.maybe (P.Nothing) (\(_,_val14) -> P.Just (case _val14 of {T.TString _val15 -> E.decodeUtf8 _val15; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  userUrls_webApiUrlPrefix = P.maybe (P.Nothing) (\(_,_val14) -> P.Just (case _val14 of {T.TString _val16 -> E.decodeUtf8 _val16; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  userUrls_userStoreUrl = P.maybe (P.Nothing) (\(_,_val14) -> P.Just (case _val14 of {T.TString _val17 -> E.decodeUtf8 _val17; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  userUrls_utilityUrl = P.maybe (P.Nothing) (\(_,_val14) -> P.Just (case _val14 of {T.TString _val18 -> E.decodeUtf8 _val18; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  userUrls_messageStoreUrl = P.maybe (P.Nothing) (\(_,_val14) -> P.Just (case _val14 of {T.TString _val19 -> E.decodeUtf8 _val19; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  userUrls_userWebSocketUrl = P.maybe (P.Nothing) (\(_,_val14) -> P.Just (case _val14 of {T.TString _val20 -> E.decodeUtf8 _val20; _ -> P.error "wrong type"})) (Map.lookup (6) fields)
  }
to_UserUrls _ = P.error "not a struct"
read_UserUrls :: T.Protocol p => p -> P.IO UserUrls
read_UserUrls iprot = to_UserUrls <$> T.readVal iprot (T.T_STRUCT typemap_UserUrls)
decode_UserUrls :: T.StatelessProtocol p => p -> LBS.ByteString -> UserUrls
decode_UserUrls iprot bs = to_UserUrls $ T.deserializeVal iprot (T.T_STRUCT typemap_UserUrls) bs
typemap_UserUrls :: T.TypeMap
typemap_UserUrls = Map.fromList [(1,("noteStoreUrl",T.T_STRING)),(2,("webApiUrlPrefix",T.T_STRING)),(3,("userStoreUrl",T.T_STRING)),(4,("utilityUrl",T.T_STRING)),(5,("messageStoreUrl",T.T_STRING)),(6,("userWebSocketUrl",T.T_STRING))]
default_UserUrls :: UserUrls
default_UserUrls = UserUrls{
  userUrls_noteStoreUrl = P.Nothing,
  userUrls_webApiUrlPrefix = P.Nothing,
  userUrls_userStoreUrl = P.Nothing,
  userUrls_utilityUrl = P.Nothing,
  userUrls_messageStoreUrl = P.Nothing,
  userUrls_userWebSocketUrl = P.Nothing}
data AuthenticationResult = AuthenticationResult  { authenticationResult_currentTime :: I.Int64
  , authenticationResult_authenticationToken :: LT.Text
  , authenticationResult_expiration :: I.Int64
  , authenticationResult_user :: P.Maybe Types_Types.User
  , authenticationResult_publicUserInfo :: P.Maybe PublicUserInfo
  , authenticationResult_noteStoreUrl :: P.Maybe LT.Text
  , authenticationResult_webApiUrlPrefix :: P.Maybe LT.Text
  , authenticationResult_secondFactorRequired :: P.Maybe P.Bool
  , authenticationResult_secondFactorDeliveryHint :: P.Maybe LT.Text
  , authenticationResult_urls :: P.Maybe UserUrls
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable AuthenticationResult where
  hashWithSalt salt record = salt   `H.hashWithSalt` authenticationResult_currentTime record   `H.hashWithSalt` authenticationResult_authenticationToken record   `H.hashWithSalt` authenticationResult_expiration record   `H.hashWithSalt` authenticationResult_user record   `H.hashWithSalt` authenticationResult_publicUserInfo record   `H.hashWithSalt` authenticationResult_noteStoreUrl record   `H.hashWithSalt` authenticationResult_webApiUrlPrefix record   `H.hashWithSalt` authenticationResult_secondFactorRequired record   `H.hashWithSalt` authenticationResult_secondFactorDeliveryHint record   `H.hashWithSalt` authenticationResult_urls record  
instance QC.Arbitrary AuthenticationResult where 
  arbitrary = M.liftM AuthenticationResult (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_AuthenticationResult = []
             | P.otherwise = M.catMaybes
    [ if obj == default_AuthenticationResult{authenticationResult_currentTime = authenticationResult_currentTime obj} then P.Nothing else P.Just $ default_AuthenticationResult{authenticationResult_currentTime = authenticationResult_currentTime obj}
    , if obj == default_AuthenticationResult{authenticationResult_authenticationToken = authenticationResult_authenticationToken obj} then P.Nothing else P.Just $ default_AuthenticationResult{authenticationResult_authenticationToken = authenticationResult_authenticationToken obj}
    , if obj == default_AuthenticationResult{authenticationResult_expiration = authenticationResult_expiration obj} then P.Nothing else P.Just $ default_AuthenticationResult{authenticationResult_expiration = authenticationResult_expiration obj}
    , if obj == default_AuthenticationResult{authenticationResult_user = authenticationResult_user obj} then P.Nothing else P.Just $ default_AuthenticationResult{authenticationResult_user = authenticationResult_user obj}
    , if obj == default_AuthenticationResult{authenticationResult_publicUserInfo = authenticationResult_publicUserInfo obj} then P.Nothing else P.Just $ default_AuthenticationResult{authenticationResult_publicUserInfo = authenticationResult_publicUserInfo obj}
    , if obj == default_AuthenticationResult{authenticationResult_noteStoreUrl = authenticationResult_noteStoreUrl obj} then P.Nothing else P.Just $ default_AuthenticationResult{authenticationResult_noteStoreUrl = authenticationResult_noteStoreUrl obj}
    , if obj == default_AuthenticationResult{authenticationResult_webApiUrlPrefix = authenticationResult_webApiUrlPrefix obj} then P.Nothing else P.Just $ default_AuthenticationResult{authenticationResult_webApiUrlPrefix = authenticationResult_webApiUrlPrefix obj}
    , if obj == default_AuthenticationResult{authenticationResult_secondFactorRequired = authenticationResult_secondFactorRequired obj} then P.Nothing else P.Just $ default_AuthenticationResult{authenticationResult_secondFactorRequired = authenticationResult_secondFactorRequired obj}
    , if obj == default_AuthenticationResult{authenticationResult_secondFactorDeliveryHint = authenticationResult_secondFactorDeliveryHint obj} then P.Nothing else P.Just $ default_AuthenticationResult{authenticationResult_secondFactorDeliveryHint = authenticationResult_secondFactorDeliveryHint obj}
    , if obj == default_AuthenticationResult{authenticationResult_urls = authenticationResult_urls obj} then P.Nothing else P.Just $ default_AuthenticationResult{authenticationResult_urls = authenticationResult_urls obj}
    ]
from_AuthenticationResult :: AuthenticationResult -> T.ThriftVal
from_AuthenticationResult record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v23 -> P.Just (1, ("currentTime",T.TI64 _v23))) $ authenticationResult_currentTime record
  , (\_v23 -> P.Just (2, ("authenticationToken",T.TString $ E.encodeUtf8 _v23))) $ authenticationResult_authenticationToken record
  , (\_v23 -> P.Just (3, ("expiration",T.TI64 _v23))) $ authenticationResult_expiration record
  , (\_v23 -> (4, ("user",Types_Types.from_User _v23))) <$> authenticationResult_user record
  , (\_v23 -> (5, ("publicUserInfo",from_PublicUserInfo _v23))) <$> authenticationResult_publicUserInfo record
  , (\_v23 -> (6, ("noteStoreUrl",T.TString $ E.encodeUtf8 _v23))) <$> authenticationResult_noteStoreUrl record
  , (\_v23 -> (7, ("webApiUrlPrefix",T.TString $ E.encodeUtf8 _v23))) <$> authenticationResult_webApiUrlPrefix record
  , (\_v23 -> (8, ("secondFactorRequired",T.TBool _v23))) <$> authenticationResult_secondFactorRequired record
  , (\_v23 -> (9, ("secondFactorDeliveryHint",T.TString $ E.encodeUtf8 _v23))) <$> authenticationResult_secondFactorDeliveryHint record
  , (\_v23 -> (10, ("urls",from_UserUrls _v23))) <$> authenticationResult_urls record
  ]
write_AuthenticationResult :: T.Protocol p => p -> AuthenticationResult -> P.IO ()
write_AuthenticationResult oprot record = T.writeVal oprot $ from_AuthenticationResult record
encode_AuthenticationResult :: T.StatelessProtocol p => p -> AuthenticationResult -> LBS.ByteString
encode_AuthenticationResult oprot record = T.serializeVal oprot $ from_AuthenticationResult record
to_AuthenticationResult :: T.ThriftVal -> AuthenticationResult
to_AuthenticationResult (T.TStruct fields) = AuthenticationResult{
  authenticationResult_currentTime = P.maybe (P.error "Missing required field: currentTime") (\(_,_val25) -> (case _val25 of {T.TI64 _val26 -> _val26; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  authenticationResult_authenticationToken = P.maybe (P.error "Missing required field: authenticationToken") (\(_,_val25) -> (case _val25 of {T.TString _val27 -> E.decodeUtf8 _val27; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  authenticationResult_expiration = P.maybe (P.error "Missing required field: expiration") (\(_,_val25) -> (case _val25 of {T.TI64 _val28 -> _val28; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  authenticationResult_user = P.maybe (P.Nothing) (\(_,_val25) -> P.Just (case _val25 of {T.TStruct _val29 -> (Types_Types.to_User (T.TStruct _val29)); _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  authenticationResult_publicUserInfo = P.maybe (P.Nothing) (\(_,_val25) -> P.Just (case _val25 of {T.TStruct _val30 -> (to_PublicUserInfo (T.TStruct _val30)); _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  authenticationResult_noteStoreUrl = P.maybe (P.Nothing) (\(_,_val25) -> P.Just (case _val25 of {T.TString _val31 -> E.decodeUtf8 _val31; _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  authenticationResult_webApiUrlPrefix = P.maybe (P.Nothing) (\(_,_val25) -> P.Just (case _val25 of {T.TString _val32 -> E.decodeUtf8 _val32; _ -> P.error "wrong type"})) (Map.lookup (7) fields),
  authenticationResult_secondFactorRequired = P.maybe (P.Nothing) (\(_,_val25) -> P.Just (case _val25 of {T.TBool _val33 -> _val33; _ -> P.error "wrong type"})) (Map.lookup (8) fields),
  authenticationResult_secondFactorDeliveryHint = P.maybe (P.Nothing) (\(_,_val25) -> P.Just (case _val25 of {T.TString _val34 -> E.decodeUtf8 _val34; _ -> P.error "wrong type"})) (Map.lookup (9) fields),
  authenticationResult_urls = P.maybe (P.Nothing) (\(_,_val25) -> P.Just (case _val25 of {T.TStruct _val35 -> (to_UserUrls (T.TStruct _val35)); _ -> P.error "wrong type"})) (Map.lookup (10) fields)
  }
to_AuthenticationResult _ = P.error "not a struct"
read_AuthenticationResult :: T.Protocol p => p -> P.IO AuthenticationResult
read_AuthenticationResult iprot = to_AuthenticationResult <$> T.readVal iprot (T.T_STRUCT typemap_AuthenticationResult)
decode_AuthenticationResult :: T.StatelessProtocol p => p -> LBS.ByteString -> AuthenticationResult
decode_AuthenticationResult iprot bs = to_AuthenticationResult $ T.deserializeVal iprot (T.T_STRUCT typemap_AuthenticationResult) bs
typemap_AuthenticationResult :: T.TypeMap
typemap_AuthenticationResult = Map.fromList [(1,("currentTime",T.T_I64)),(2,("authenticationToken",T.T_STRING)),(3,("expiration",T.T_I64)),(4,("user",(T.T_STRUCT Types_Types.typemap_User))),(5,("publicUserInfo",(T.T_STRUCT typemap_PublicUserInfo))),(6,("noteStoreUrl",T.T_STRING)),(7,("webApiUrlPrefix",T.T_STRING)),(8,("secondFactorRequired",T.T_BOOL)),(9,("secondFactorDeliveryHint",T.T_STRING)),(10,("urls",(T.T_STRUCT typemap_UserUrls)))]
default_AuthenticationResult :: AuthenticationResult
default_AuthenticationResult = AuthenticationResult{
  authenticationResult_currentTime = 0,
  authenticationResult_authenticationToken = "",
  authenticationResult_expiration = 0,
  authenticationResult_user = P.Nothing,
  authenticationResult_publicUserInfo = P.Nothing,
  authenticationResult_noteStoreUrl = P.Nothing,
  authenticationResult_webApiUrlPrefix = P.Nothing,
  authenticationResult_secondFactorRequired = P.Nothing,
  authenticationResult_secondFactorDeliveryHint = P.Nothing,
  authenticationResult_urls = P.Nothing}
data BootstrapSettings = BootstrapSettings  { bootstrapSettings_serviceHost :: LT.Text
  , bootstrapSettings_marketingUrl :: LT.Text
  , bootstrapSettings_supportUrl :: LT.Text
  , bootstrapSettings_accountEmailDomain :: LT.Text
  , bootstrapSettings_enableFacebookSharing :: P.Maybe P.Bool
  , bootstrapSettings_enableGiftSubscriptions :: P.Maybe P.Bool
  , bootstrapSettings_enableSupportTickets :: P.Maybe P.Bool
  , bootstrapSettings_enableSharedNotebooks :: P.Maybe P.Bool
  , bootstrapSettings_enableSingleNoteSharing :: P.Maybe P.Bool
  , bootstrapSettings_enableSponsoredAccounts :: P.Maybe P.Bool
  , bootstrapSettings_enableTwitterSharing :: P.Maybe P.Bool
  , bootstrapSettings_enableLinkedInSharing :: P.Maybe P.Bool
  , bootstrapSettings_enablePublicNotebooks :: P.Maybe P.Bool
  , bootstrapSettings_enableGoogle :: P.Maybe P.Bool
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable BootstrapSettings where
  hashWithSalt salt record = salt   `H.hashWithSalt` bootstrapSettings_serviceHost record   `H.hashWithSalt` bootstrapSettings_marketingUrl record   `H.hashWithSalt` bootstrapSettings_supportUrl record   `H.hashWithSalt` bootstrapSettings_accountEmailDomain record   `H.hashWithSalt` bootstrapSettings_enableFacebookSharing record   `H.hashWithSalt` bootstrapSettings_enableGiftSubscriptions record   `H.hashWithSalt` bootstrapSettings_enableSupportTickets record   `H.hashWithSalt` bootstrapSettings_enableSharedNotebooks record   `H.hashWithSalt` bootstrapSettings_enableSingleNoteSharing record   `H.hashWithSalt` bootstrapSettings_enableSponsoredAccounts record   `H.hashWithSalt` bootstrapSettings_enableTwitterSharing record   `H.hashWithSalt` bootstrapSettings_enableLinkedInSharing record   `H.hashWithSalt` bootstrapSettings_enablePublicNotebooks record   `H.hashWithSalt` bootstrapSettings_enableGoogle record  
instance QC.Arbitrary BootstrapSettings where 
  arbitrary = M.liftM BootstrapSettings (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_BootstrapSettings = []
             | P.otherwise = M.catMaybes
    [ if obj == default_BootstrapSettings{bootstrapSettings_serviceHost = bootstrapSettings_serviceHost obj} then P.Nothing else P.Just $ default_BootstrapSettings{bootstrapSettings_serviceHost = bootstrapSettings_serviceHost obj}
    , if obj == default_BootstrapSettings{bootstrapSettings_marketingUrl = bootstrapSettings_marketingUrl obj} then P.Nothing else P.Just $ default_BootstrapSettings{bootstrapSettings_marketingUrl = bootstrapSettings_marketingUrl obj}
    , if obj == default_BootstrapSettings{bootstrapSettings_supportUrl = bootstrapSettings_supportUrl obj} then P.Nothing else P.Just $ default_BootstrapSettings{bootstrapSettings_supportUrl = bootstrapSettings_supportUrl obj}
    , if obj == default_BootstrapSettings{bootstrapSettings_accountEmailDomain = bootstrapSettings_accountEmailDomain obj} then P.Nothing else P.Just $ default_BootstrapSettings{bootstrapSettings_accountEmailDomain = bootstrapSettings_accountEmailDomain obj}
    , if obj == default_BootstrapSettings{bootstrapSettings_enableFacebookSharing = bootstrapSettings_enableFacebookSharing obj} then P.Nothing else P.Just $ default_BootstrapSettings{bootstrapSettings_enableFacebookSharing = bootstrapSettings_enableFacebookSharing obj}
    , if obj == default_BootstrapSettings{bootstrapSettings_enableGiftSubscriptions = bootstrapSettings_enableGiftSubscriptions obj} then P.Nothing else P.Just $ default_BootstrapSettings{bootstrapSettings_enableGiftSubscriptions = bootstrapSettings_enableGiftSubscriptions obj}
    , if obj == default_BootstrapSettings{bootstrapSettings_enableSupportTickets = bootstrapSettings_enableSupportTickets obj} then P.Nothing else P.Just $ default_BootstrapSettings{bootstrapSettings_enableSupportTickets = bootstrapSettings_enableSupportTickets obj}
    , if obj == default_BootstrapSettings{bootstrapSettings_enableSharedNotebooks = bootstrapSettings_enableSharedNotebooks obj} then P.Nothing else P.Just $ default_BootstrapSettings{bootstrapSettings_enableSharedNotebooks = bootstrapSettings_enableSharedNotebooks obj}
    , if obj == default_BootstrapSettings{bootstrapSettings_enableSingleNoteSharing = bootstrapSettings_enableSingleNoteSharing obj} then P.Nothing else P.Just $ default_BootstrapSettings{bootstrapSettings_enableSingleNoteSharing = bootstrapSettings_enableSingleNoteSharing obj}
    , if obj == default_BootstrapSettings{bootstrapSettings_enableSponsoredAccounts = bootstrapSettings_enableSponsoredAccounts obj} then P.Nothing else P.Just $ default_BootstrapSettings{bootstrapSettings_enableSponsoredAccounts = bootstrapSettings_enableSponsoredAccounts obj}
    , if obj == default_BootstrapSettings{bootstrapSettings_enableTwitterSharing = bootstrapSettings_enableTwitterSharing obj} then P.Nothing else P.Just $ default_BootstrapSettings{bootstrapSettings_enableTwitterSharing = bootstrapSettings_enableTwitterSharing obj}
    , if obj == default_BootstrapSettings{bootstrapSettings_enableLinkedInSharing = bootstrapSettings_enableLinkedInSharing obj} then P.Nothing else P.Just $ default_BootstrapSettings{bootstrapSettings_enableLinkedInSharing = bootstrapSettings_enableLinkedInSharing obj}
    , if obj == default_BootstrapSettings{bootstrapSettings_enablePublicNotebooks = bootstrapSettings_enablePublicNotebooks obj} then P.Nothing else P.Just $ default_BootstrapSettings{bootstrapSettings_enablePublicNotebooks = bootstrapSettings_enablePublicNotebooks obj}
    , if obj == default_BootstrapSettings{bootstrapSettings_enableGoogle = bootstrapSettings_enableGoogle obj} then P.Nothing else P.Just $ default_BootstrapSettings{bootstrapSettings_enableGoogle = bootstrapSettings_enableGoogle obj}
    ]
from_BootstrapSettings :: BootstrapSettings -> T.ThriftVal
from_BootstrapSettings record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v38 -> P.Just (1, ("serviceHost",T.TString $ E.encodeUtf8 _v38))) $ bootstrapSettings_serviceHost record
  , (\_v38 -> P.Just (2, ("marketingUrl",T.TString $ E.encodeUtf8 _v38))) $ bootstrapSettings_marketingUrl record
  , (\_v38 -> P.Just (3, ("supportUrl",T.TString $ E.encodeUtf8 _v38))) $ bootstrapSettings_supportUrl record
  , (\_v38 -> P.Just (4, ("accountEmailDomain",T.TString $ E.encodeUtf8 _v38))) $ bootstrapSettings_accountEmailDomain record
  , (\_v38 -> (5, ("enableFacebookSharing",T.TBool _v38))) <$> bootstrapSettings_enableFacebookSharing record
  , (\_v38 -> (6, ("enableGiftSubscriptions",T.TBool _v38))) <$> bootstrapSettings_enableGiftSubscriptions record
  , (\_v38 -> (7, ("enableSupportTickets",T.TBool _v38))) <$> bootstrapSettings_enableSupportTickets record
  , (\_v38 -> (8, ("enableSharedNotebooks",T.TBool _v38))) <$> bootstrapSettings_enableSharedNotebooks record
  , (\_v38 -> (9, ("enableSingleNoteSharing",T.TBool _v38))) <$> bootstrapSettings_enableSingleNoteSharing record
  , (\_v38 -> (10, ("enableSponsoredAccounts",T.TBool _v38))) <$> bootstrapSettings_enableSponsoredAccounts record
  , (\_v38 -> (11, ("enableTwitterSharing",T.TBool _v38))) <$> bootstrapSettings_enableTwitterSharing record
  , (\_v38 -> (12, ("enableLinkedInSharing",T.TBool _v38))) <$> bootstrapSettings_enableLinkedInSharing record
  , (\_v38 -> (13, ("enablePublicNotebooks",T.TBool _v38))) <$> bootstrapSettings_enablePublicNotebooks record
  , (\_v38 -> (16, ("enableGoogle",T.TBool _v38))) <$> bootstrapSettings_enableGoogle record
  ]
write_BootstrapSettings :: T.Protocol p => p -> BootstrapSettings -> P.IO ()
write_BootstrapSettings oprot record = T.writeVal oprot $ from_BootstrapSettings record
encode_BootstrapSettings :: T.StatelessProtocol p => p -> BootstrapSettings -> LBS.ByteString
encode_BootstrapSettings oprot record = T.serializeVal oprot $ from_BootstrapSettings record
to_BootstrapSettings :: T.ThriftVal -> BootstrapSettings
to_BootstrapSettings (T.TStruct fields) = BootstrapSettings{
  bootstrapSettings_serviceHost = P.maybe (P.error "Missing required field: serviceHost") (\(_,_val40) -> (case _val40 of {T.TString _val41 -> E.decodeUtf8 _val41; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  bootstrapSettings_marketingUrl = P.maybe (P.error "Missing required field: marketingUrl") (\(_,_val40) -> (case _val40 of {T.TString _val42 -> E.decodeUtf8 _val42; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  bootstrapSettings_supportUrl = P.maybe (P.error "Missing required field: supportUrl") (\(_,_val40) -> (case _val40 of {T.TString _val43 -> E.decodeUtf8 _val43; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  bootstrapSettings_accountEmailDomain = P.maybe (P.error "Missing required field: accountEmailDomain") (\(_,_val40) -> (case _val40 of {T.TString _val44 -> E.decodeUtf8 _val44; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  bootstrapSettings_enableFacebookSharing = P.maybe (P.Nothing) (\(_,_val40) -> P.Just (case _val40 of {T.TBool _val45 -> _val45; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  bootstrapSettings_enableGiftSubscriptions = P.maybe (P.Nothing) (\(_,_val40) -> P.Just (case _val40 of {T.TBool _val46 -> _val46; _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  bootstrapSettings_enableSupportTickets = P.maybe (P.Nothing) (\(_,_val40) -> P.Just (case _val40 of {T.TBool _val47 -> _val47; _ -> P.error "wrong type"})) (Map.lookup (7) fields),
  bootstrapSettings_enableSharedNotebooks = P.maybe (P.Nothing) (\(_,_val40) -> P.Just (case _val40 of {T.TBool _val48 -> _val48; _ -> P.error "wrong type"})) (Map.lookup (8) fields),
  bootstrapSettings_enableSingleNoteSharing = P.maybe (P.Nothing) (\(_,_val40) -> P.Just (case _val40 of {T.TBool _val49 -> _val49; _ -> P.error "wrong type"})) (Map.lookup (9) fields),
  bootstrapSettings_enableSponsoredAccounts = P.maybe (P.Nothing) (\(_,_val40) -> P.Just (case _val40 of {T.TBool _val50 -> _val50; _ -> P.error "wrong type"})) (Map.lookup (10) fields),
  bootstrapSettings_enableTwitterSharing = P.maybe (P.Nothing) (\(_,_val40) -> P.Just (case _val40 of {T.TBool _val51 -> _val51; _ -> P.error "wrong type"})) (Map.lookup (11) fields),
  bootstrapSettings_enableLinkedInSharing = P.maybe (P.Nothing) (\(_,_val40) -> P.Just (case _val40 of {T.TBool _val52 -> _val52; _ -> P.error "wrong type"})) (Map.lookup (12) fields),
  bootstrapSettings_enablePublicNotebooks = P.maybe (P.Nothing) (\(_,_val40) -> P.Just (case _val40 of {T.TBool _val53 -> _val53; _ -> P.error "wrong type"})) (Map.lookup (13) fields),
  bootstrapSettings_enableGoogle = P.maybe (P.Nothing) (\(_,_val40) -> P.Just (case _val40 of {T.TBool _val54 -> _val54; _ -> P.error "wrong type"})) (Map.lookup (16) fields)
  }
to_BootstrapSettings _ = P.error "not a struct"
read_BootstrapSettings :: T.Protocol p => p -> P.IO BootstrapSettings
read_BootstrapSettings iprot = to_BootstrapSettings <$> T.readVal iprot (T.T_STRUCT typemap_BootstrapSettings)
decode_BootstrapSettings :: T.StatelessProtocol p => p -> LBS.ByteString -> BootstrapSettings
decode_BootstrapSettings iprot bs = to_BootstrapSettings $ T.deserializeVal iprot (T.T_STRUCT typemap_BootstrapSettings) bs
typemap_BootstrapSettings :: T.TypeMap
typemap_BootstrapSettings = Map.fromList [(1,("serviceHost",T.T_STRING)),(2,("marketingUrl",T.T_STRING)),(3,("supportUrl",T.T_STRING)),(4,("accountEmailDomain",T.T_STRING)),(5,("enableFacebookSharing",T.T_BOOL)),(6,("enableGiftSubscriptions",T.T_BOOL)),(7,("enableSupportTickets",T.T_BOOL)),(8,("enableSharedNotebooks",T.T_BOOL)),(9,("enableSingleNoteSharing",T.T_BOOL)),(10,("enableSponsoredAccounts",T.T_BOOL)),(11,("enableTwitterSharing",T.T_BOOL)),(12,("enableLinkedInSharing",T.T_BOOL)),(13,("enablePublicNotebooks",T.T_BOOL)),(16,("enableGoogle",T.T_BOOL))]
default_BootstrapSettings :: BootstrapSettings
default_BootstrapSettings = BootstrapSettings{
  bootstrapSettings_serviceHost = "",
  bootstrapSettings_marketingUrl = "",
  bootstrapSettings_supportUrl = "",
  bootstrapSettings_accountEmailDomain = "",
  bootstrapSettings_enableFacebookSharing = P.Nothing,
  bootstrapSettings_enableGiftSubscriptions = P.Nothing,
  bootstrapSettings_enableSupportTickets = P.Nothing,
  bootstrapSettings_enableSharedNotebooks = P.Nothing,
  bootstrapSettings_enableSingleNoteSharing = P.Nothing,
  bootstrapSettings_enableSponsoredAccounts = P.Nothing,
  bootstrapSettings_enableTwitterSharing = P.Nothing,
  bootstrapSettings_enableLinkedInSharing = P.Nothing,
  bootstrapSettings_enablePublicNotebooks = P.Nothing,
  bootstrapSettings_enableGoogle = P.Nothing}
data BootstrapProfile = BootstrapProfile  { bootstrapProfile_name :: LT.Text
  , bootstrapProfile_settings :: BootstrapSettings
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable BootstrapProfile where
  hashWithSalt salt record = salt   `H.hashWithSalt` bootstrapProfile_name record   `H.hashWithSalt` bootstrapProfile_settings record  
instance QC.Arbitrary BootstrapProfile where 
  arbitrary = M.liftM BootstrapProfile (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_BootstrapProfile = []
             | P.otherwise = M.catMaybes
    [ if obj == default_BootstrapProfile{bootstrapProfile_name = bootstrapProfile_name obj} then P.Nothing else P.Just $ default_BootstrapProfile{bootstrapProfile_name = bootstrapProfile_name obj}
    , if obj == default_BootstrapProfile{bootstrapProfile_settings = bootstrapProfile_settings obj} then P.Nothing else P.Just $ default_BootstrapProfile{bootstrapProfile_settings = bootstrapProfile_settings obj}
    ]
from_BootstrapProfile :: BootstrapProfile -> T.ThriftVal
from_BootstrapProfile record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v57 -> P.Just (1, ("name",T.TString $ E.encodeUtf8 _v57))) $ bootstrapProfile_name record
  , (\_v57 -> P.Just (2, ("settings",from_BootstrapSettings _v57))) $ bootstrapProfile_settings record
  ]
write_BootstrapProfile :: T.Protocol p => p -> BootstrapProfile -> P.IO ()
write_BootstrapProfile oprot record = T.writeVal oprot $ from_BootstrapProfile record
encode_BootstrapProfile :: T.StatelessProtocol p => p -> BootstrapProfile -> LBS.ByteString
encode_BootstrapProfile oprot record = T.serializeVal oprot $ from_BootstrapProfile record
to_BootstrapProfile :: T.ThriftVal -> BootstrapProfile
to_BootstrapProfile (T.TStruct fields) = BootstrapProfile{
  bootstrapProfile_name = P.maybe (P.error "Missing required field: name") (\(_,_val59) -> (case _val59 of {T.TString _val60 -> E.decodeUtf8 _val60; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  bootstrapProfile_settings = P.maybe (P.error "Missing required field: settings") (\(_,_val59) -> (case _val59 of {T.TStruct _val61 -> (to_BootstrapSettings (T.TStruct _val61)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_BootstrapProfile _ = P.error "not a struct"
read_BootstrapProfile :: T.Protocol p => p -> P.IO BootstrapProfile
read_BootstrapProfile iprot = to_BootstrapProfile <$> T.readVal iprot (T.T_STRUCT typemap_BootstrapProfile)
decode_BootstrapProfile :: T.StatelessProtocol p => p -> LBS.ByteString -> BootstrapProfile
decode_BootstrapProfile iprot bs = to_BootstrapProfile $ T.deserializeVal iprot (T.T_STRUCT typemap_BootstrapProfile) bs
typemap_BootstrapProfile :: T.TypeMap
typemap_BootstrapProfile = Map.fromList [(1,("name",T.T_STRING)),(2,("settings",(T.T_STRUCT typemap_BootstrapSettings)))]
default_BootstrapProfile :: BootstrapProfile
default_BootstrapProfile = BootstrapProfile{
  bootstrapProfile_name = "",
  bootstrapProfile_settings = default_BootstrapSettings}
data BootstrapInfo = BootstrapInfo  { bootstrapInfo_profiles :: (Vector.Vector BootstrapProfile)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable BootstrapInfo where
  hashWithSalt salt record = salt   `H.hashWithSalt` bootstrapInfo_profiles record  
instance QC.Arbitrary BootstrapInfo where 
  arbitrary = M.liftM BootstrapInfo (QC.arbitrary)
  shrink obj | obj == default_BootstrapInfo = []
             | P.otherwise = M.catMaybes
    [ if obj == default_BootstrapInfo{bootstrapInfo_profiles = bootstrapInfo_profiles obj} then P.Nothing else P.Just $ default_BootstrapInfo{bootstrapInfo_profiles = bootstrapInfo_profiles obj}
    ]
from_BootstrapInfo :: BootstrapInfo -> T.ThriftVal
from_BootstrapInfo record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v64 -> P.Just (1, ("profiles",T.TList (T.T_STRUCT typemap_BootstrapProfile) $ P.map (\_v66 -> from_BootstrapProfile _v66) $ Vector.toList _v64))) $ bootstrapInfo_profiles record
  ]
write_BootstrapInfo :: T.Protocol p => p -> BootstrapInfo -> P.IO ()
write_BootstrapInfo oprot record = T.writeVal oprot $ from_BootstrapInfo record
encode_BootstrapInfo :: T.StatelessProtocol p => p -> BootstrapInfo -> LBS.ByteString
encode_BootstrapInfo oprot record = T.serializeVal oprot $ from_BootstrapInfo record
to_BootstrapInfo :: T.ThriftVal -> BootstrapInfo
to_BootstrapInfo (T.TStruct fields) = BootstrapInfo{
  bootstrapInfo_profiles = P.maybe (P.error "Missing required field: profiles") (\(_,_val68) -> (case _val68 of {T.TList _ _val69 -> (Vector.fromList $ P.map (\_v70 -> (case _v70 of {T.TStruct _val71 -> (to_BootstrapProfile (T.TStruct _val71)); _ -> P.error "wrong type"})) _val69); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_BootstrapInfo _ = P.error "not a struct"
read_BootstrapInfo :: T.Protocol p => p -> P.IO BootstrapInfo
read_BootstrapInfo iprot = to_BootstrapInfo <$> T.readVal iprot (T.T_STRUCT typemap_BootstrapInfo)
decode_BootstrapInfo :: T.StatelessProtocol p => p -> LBS.ByteString -> BootstrapInfo
decode_BootstrapInfo iprot bs = to_BootstrapInfo $ T.deserializeVal iprot (T.T_STRUCT typemap_BootstrapInfo) bs
typemap_BootstrapInfo :: T.TypeMap
typemap_BootstrapInfo = Map.fromList [(1,("profiles",(T.T_LIST (T.T_STRUCT typemap_BootstrapProfile))))]
default_BootstrapInfo :: BootstrapInfo
default_BootstrapInfo = BootstrapInfo{
  bootstrapInfo_profiles = Vector.empty}
