{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-missing-fields #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-----------------------------------------------------------------
-- Autogenerated by Thrift Compiler (0.11.0)                      --
--                                                             --
-- DO NOT EDIT UNLESS YOU ARE SURE YOU KNOW WHAT YOU ARE DOING --
-----------------------------------------------------------------

module UserStore where
import Prelude (($), (.), (>>=), (==), (++))
import qualified Prelude as P
import qualified Control.Exception as X
import qualified Control.Monad as M ( liftM, ap, when )
import Data.Functor ( (<$>) )
import qualified Data.ByteString.Lazy as LBS
import qualified Data.Hashable as H
import qualified Data.Int as I
import qualified Data.Maybe as M (catMaybes)
import qualified Data.Text.Lazy.Encoding as E ( decodeUtf8, encodeUtf8 )
import qualified Data.Text.Lazy as LT
import qualified GHC.Generics as G (Generic)
import qualified Data.Typeable as TY ( Typeable )
import qualified Data.HashMap.Strict as Map
import qualified Data.HashSet as Set
import qualified Data.Vector as Vector
import qualified Test.QuickCheck.Arbitrary as QC ( Arbitrary(..) )
import qualified Test.QuickCheck as QC ( elements )

import qualified Thrift as T
import qualified Thrift.Types as T
import qualified Thrift.Arbitraries as T

import qualified Types_Types
import qualified Errors_Types


import UserStore_Types
import qualified UserStore_Iface as Iface
-- HELPER FUNCTIONS AND STRUCTURES --

data CheckVersion_args = CheckVersion_args  { checkVersion_args_clientName :: LT.Text
  , checkVersion_args_edamVersionMajor :: I.Int16
  , checkVersion_args_edamVersionMinor :: I.Int16
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable CheckVersion_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` checkVersion_args_clientName record   `H.hashWithSalt` checkVersion_args_edamVersionMajor record   `H.hashWithSalt` checkVersion_args_edamVersionMinor record  
instance QC.Arbitrary CheckVersion_args where 
  arbitrary = M.liftM CheckVersion_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_CheckVersion_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_CheckVersion_args{checkVersion_args_clientName = checkVersion_args_clientName obj} then P.Nothing else P.Just $ default_CheckVersion_args{checkVersion_args_clientName = checkVersion_args_clientName obj}
    , if obj == default_CheckVersion_args{checkVersion_args_edamVersionMajor = checkVersion_args_edamVersionMajor obj} then P.Nothing else P.Just $ default_CheckVersion_args{checkVersion_args_edamVersionMajor = checkVersion_args_edamVersionMajor obj}
    , if obj == default_CheckVersion_args{checkVersion_args_edamVersionMinor = checkVersion_args_edamVersionMinor obj} then P.Nothing else P.Just $ default_CheckVersion_args{checkVersion_args_edamVersionMinor = checkVersion_args_edamVersionMinor obj}
    ]
from_CheckVersion_args :: CheckVersion_args -> T.ThriftVal
from_CheckVersion_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v74 -> P.Just (1, ("clientName",T.TString $ E.encodeUtf8 _v74))) $ checkVersion_args_clientName record
  , (\_v74 -> P.Just (2, ("edamVersionMajor",T.TI16 _v74))) $ checkVersion_args_edamVersionMajor record
  , (\_v74 -> P.Just (3, ("edamVersionMinor",T.TI16 _v74))) $ checkVersion_args_edamVersionMinor record
  ]
write_CheckVersion_args :: T.Protocol p => p -> CheckVersion_args -> P.IO ()
write_CheckVersion_args oprot record = T.writeVal oprot $ from_CheckVersion_args record
encode_CheckVersion_args :: T.StatelessProtocol p => p -> CheckVersion_args -> LBS.ByteString
encode_CheckVersion_args oprot record = T.serializeVal oprot $ from_CheckVersion_args record
to_CheckVersion_args :: T.ThriftVal -> CheckVersion_args
to_CheckVersion_args (T.TStruct fields) = CheckVersion_args{
  checkVersion_args_clientName = P.maybe (checkVersion_args_clientName default_CheckVersion_args) (\(_,_val76) -> (case _val76 of {T.TString _val77 -> E.decodeUtf8 _val77; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  checkVersion_args_edamVersionMajor = P.maybe (checkVersion_args_edamVersionMajor default_CheckVersion_args) (\(_,_val76) -> (case _val76 of {T.TI16 _val78 -> _val78; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  checkVersion_args_edamVersionMinor = P.maybe (checkVersion_args_edamVersionMinor default_CheckVersion_args) (\(_,_val76) -> (case _val76 of {T.TI16 _val79 -> _val79; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_CheckVersion_args _ = P.error "not a struct"
read_CheckVersion_args :: T.Protocol p => p -> P.IO CheckVersion_args
read_CheckVersion_args iprot = to_CheckVersion_args <$> T.readVal iprot (T.T_STRUCT typemap_CheckVersion_args)
decode_CheckVersion_args :: T.StatelessProtocol p => p -> LBS.ByteString -> CheckVersion_args
decode_CheckVersion_args iprot bs = to_CheckVersion_args $ T.deserializeVal iprot (T.T_STRUCT typemap_CheckVersion_args) bs
typemap_CheckVersion_args :: T.TypeMap
typemap_CheckVersion_args = Map.fromList [(1,("clientName",T.T_STRING)),(2,("edamVersionMajor",T.T_I16)),(3,("edamVersionMinor",T.T_I16))]
default_CheckVersion_args :: CheckVersion_args
default_CheckVersion_args = CheckVersion_args{
  checkVersion_args_clientName = "",
  checkVersion_args_edamVersionMajor = (1),
  checkVersion_args_edamVersionMinor = (28)}
data CheckVersion_result = CheckVersion_result  { checkVersion_result_success :: P.Bool
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable CheckVersion_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` checkVersion_result_success record  
instance QC.Arbitrary CheckVersion_result where 
  arbitrary = M.liftM CheckVersion_result (QC.arbitrary)
  shrink obj | obj == default_CheckVersion_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_CheckVersion_result{checkVersion_result_success = checkVersion_result_success obj} then P.Nothing else P.Just $ default_CheckVersion_result{checkVersion_result_success = checkVersion_result_success obj}
    ]
from_CheckVersion_result :: CheckVersion_result -> T.ThriftVal
from_CheckVersion_result record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v82 -> P.Just (0, ("success",T.TBool _v82))) $ checkVersion_result_success record
  ]
write_CheckVersion_result :: T.Protocol p => p -> CheckVersion_result -> P.IO ()
write_CheckVersion_result oprot record = T.writeVal oprot $ from_CheckVersion_result record
encode_CheckVersion_result :: T.StatelessProtocol p => p -> CheckVersion_result -> LBS.ByteString
encode_CheckVersion_result oprot record = T.serializeVal oprot $ from_CheckVersion_result record
to_CheckVersion_result :: T.ThriftVal -> CheckVersion_result
to_CheckVersion_result (T.TStruct fields) = CheckVersion_result{
  checkVersion_result_success = P.maybe (checkVersion_result_success default_CheckVersion_result) (\(_,_val84) -> (case _val84 of {T.TBool _val85 -> _val85; _ -> P.error "wrong type"})) (Map.lookup (0) fields)
  }
to_CheckVersion_result _ = P.error "not a struct"
read_CheckVersion_result :: T.Protocol p => p -> P.IO CheckVersion_result
read_CheckVersion_result iprot = to_CheckVersion_result <$> T.readVal iprot (T.T_STRUCT typemap_CheckVersion_result)
decode_CheckVersion_result :: T.StatelessProtocol p => p -> LBS.ByteString -> CheckVersion_result
decode_CheckVersion_result iprot bs = to_CheckVersion_result $ T.deserializeVal iprot (T.T_STRUCT typemap_CheckVersion_result) bs
typemap_CheckVersion_result :: T.TypeMap
typemap_CheckVersion_result = Map.fromList [(0,("success",T.T_BOOL))]
default_CheckVersion_result :: CheckVersion_result
default_CheckVersion_result = CheckVersion_result{
  checkVersion_result_success = P.False}
data GetBootstrapInfo_args = GetBootstrapInfo_args  { getBootstrapInfo_args_locale :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetBootstrapInfo_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getBootstrapInfo_args_locale record  
instance QC.Arbitrary GetBootstrapInfo_args where 
  arbitrary = M.liftM GetBootstrapInfo_args (QC.arbitrary)
  shrink obj | obj == default_GetBootstrapInfo_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetBootstrapInfo_args{getBootstrapInfo_args_locale = getBootstrapInfo_args_locale obj} then P.Nothing else P.Just $ default_GetBootstrapInfo_args{getBootstrapInfo_args_locale = getBootstrapInfo_args_locale obj}
    ]
from_GetBootstrapInfo_args :: GetBootstrapInfo_args -> T.ThriftVal
from_GetBootstrapInfo_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v88 -> P.Just (1, ("locale",T.TString $ E.encodeUtf8 _v88))) $ getBootstrapInfo_args_locale record
  ]
write_GetBootstrapInfo_args :: T.Protocol p => p -> GetBootstrapInfo_args -> P.IO ()
write_GetBootstrapInfo_args oprot record = T.writeVal oprot $ from_GetBootstrapInfo_args record
encode_GetBootstrapInfo_args :: T.StatelessProtocol p => p -> GetBootstrapInfo_args -> LBS.ByteString
encode_GetBootstrapInfo_args oprot record = T.serializeVal oprot $ from_GetBootstrapInfo_args record
to_GetBootstrapInfo_args :: T.ThriftVal -> GetBootstrapInfo_args
to_GetBootstrapInfo_args (T.TStruct fields) = GetBootstrapInfo_args{
  getBootstrapInfo_args_locale = P.maybe (getBootstrapInfo_args_locale default_GetBootstrapInfo_args) (\(_,_val90) -> (case _val90 of {T.TString _val91 -> E.decodeUtf8 _val91; _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetBootstrapInfo_args _ = P.error "not a struct"
read_GetBootstrapInfo_args :: T.Protocol p => p -> P.IO GetBootstrapInfo_args
read_GetBootstrapInfo_args iprot = to_GetBootstrapInfo_args <$> T.readVal iprot (T.T_STRUCT typemap_GetBootstrapInfo_args)
decode_GetBootstrapInfo_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetBootstrapInfo_args
decode_GetBootstrapInfo_args iprot bs = to_GetBootstrapInfo_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetBootstrapInfo_args) bs
typemap_GetBootstrapInfo_args :: T.TypeMap
typemap_GetBootstrapInfo_args = Map.fromList [(1,("locale",T.T_STRING))]
default_GetBootstrapInfo_args :: GetBootstrapInfo_args
default_GetBootstrapInfo_args = GetBootstrapInfo_args{
  getBootstrapInfo_args_locale = ""}
data GetBootstrapInfo_result = GetBootstrapInfo_result  { getBootstrapInfo_result_success :: BootstrapInfo
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetBootstrapInfo_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getBootstrapInfo_result_success record  
instance QC.Arbitrary GetBootstrapInfo_result where 
  arbitrary = M.liftM GetBootstrapInfo_result (QC.arbitrary)
  shrink obj | obj == default_GetBootstrapInfo_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetBootstrapInfo_result{getBootstrapInfo_result_success = getBootstrapInfo_result_success obj} then P.Nothing else P.Just $ default_GetBootstrapInfo_result{getBootstrapInfo_result_success = getBootstrapInfo_result_success obj}
    ]
from_GetBootstrapInfo_result :: GetBootstrapInfo_result -> T.ThriftVal
from_GetBootstrapInfo_result record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v94 -> P.Just (0, ("success",from_BootstrapInfo _v94))) $ getBootstrapInfo_result_success record
  ]
write_GetBootstrapInfo_result :: T.Protocol p => p -> GetBootstrapInfo_result -> P.IO ()
write_GetBootstrapInfo_result oprot record = T.writeVal oprot $ from_GetBootstrapInfo_result record
encode_GetBootstrapInfo_result :: T.StatelessProtocol p => p -> GetBootstrapInfo_result -> LBS.ByteString
encode_GetBootstrapInfo_result oprot record = T.serializeVal oprot $ from_GetBootstrapInfo_result record
to_GetBootstrapInfo_result :: T.ThriftVal -> GetBootstrapInfo_result
to_GetBootstrapInfo_result (T.TStruct fields) = GetBootstrapInfo_result{
  getBootstrapInfo_result_success = P.maybe (getBootstrapInfo_result_success default_GetBootstrapInfo_result) (\(_,_val96) -> (case _val96 of {T.TStruct _val97 -> (to_BootstrapInfo (T.TStruct _val97)); _ -> P.error "wrong type"})) (Map.lookup (0) fields)
  }
to_GetBootstrapInfo_result _ = P.error "not a struct"
read_GetBootstrapInfo_result :: T.Protocol p => p -> P.IO GetBootstrapInfo_result
read_GetBootstrapInfo_result iprot = to_GetBootstrapInfo_result <$> T.readVal iprot (T.T_STRUCT typemap_GetBootstrapInfo_result)
decode_GetBootstrapInfo_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetBootstrapInfo_result
decode_GetBootstrapInfo_result iprot bs = to_GetBootstrapInfo_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetBootstrapInfo_result) bs
typemap_GetBootstrapInfo_result :: T.TypeMap
typemap_GetBootstrapInfo_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_BootstrapInfo)))]
default_GetBootstrapInfo_result :: GetBootstrapInfo_result
default_GetBootstrapInfo_result = GetBootstrapInfo_result{
  getBootstrapInfo_result_success = default_BootstrapInfo}
data AuthenticateLongSession_args = AuthenticateLongSession_args  { authenticateLongSession_args_username :: LT.Text
  , authenticateLongSession_args_password :: LT.Text
  , authenticateLongSession_args_consumerKey :: LT.Text
  , authenticateLongSession_args_consumerSecret :: LT.Text
  , authenticateLongSession_args_deviceIdentifier :: LT.Text
  , authenticateLongSession_args_deviceDescription :: LT.Text
  , authenticateLongSession_args_supportsTwoFactor :: P.Bool
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable AuthenticateLongSession_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` authenticateLongSession_args_username record   `H.hashWithSalt` authenticateLongSession_args_password record   `H.hashWithSalt` authenticateLongSession_args_consumerKey record   `H.hashWithSalt` authenticateLongSession_args_consumerSecret record   `H.hashWithSalt` authenticateLongSession_args_deviceIdentifier record   `H.hashWithSalt` authenticateLongSession_args_deviceDescription record   `H.hashWithSalt` authenticateLongSession_args_supportsTwoFactor record  
instance QC.Arbitrary AuthenticateLongSession_args where 
  arbitrary = M.liftM AuthenticateLongSession_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_AuthenticateLongSession_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_AuthenticateLongSession_args{authenticateLongSession_args_username = authenticateLongSession_args_username obj} then P.Nothing else P.Just $ default_AuthenticateLongSession_args{authenticateLongSession_args_username = authenticateLongSession_args_username obj}
    , if obj == default_AuthenticateLongSession_args{authenticateLongSession_args_password = authenticateLongSession_args_password obj} then P.Nothing else P.Just $ default_AuthenticateLongSession_args{authenticateLongSession_args_password = authenticateLongSession_args_password obj}
    , if obj == default_AuthenticateLongSession_args{authenticateLongSession_args_consumerKey = authenticateLongSession_args_consumerKey obj} then P.Nothing else P.Just $ default_AuthenticateLongSession_args{authenticateLongSession_args_consumerKey = authenticateLongSession_args_consumerKey obj}
    , if obj == default_AuthenticateLongSession_args{authenticateLongSession_args_consumerSecret = authenticateLongSession_args_consumerSecret obj} then P.Nothing else P.Just $ default_AuthenticateLongSession_args{authenticateLongSession_args_consumerSecret = authenticateLongSession_args_consumerSecret obj}
    , if obj == default_AuthenticateLongSession_args{authenticateLongSession_args_deviceIdentifier = authenticateLongSession_args_deviceIdentifier obj} then P.Nothing else P.Just $ default_AuthenticateLongSession_args{authenticateLongSession_args_deviceIdentifier = authenticateLongSession_args_deviceIdentifier obj}
    , if obj == default_AuthenticateLongSession_args{authenticateLongSession_args_deviceDescription = authenticateLongSession_args_deviceDescription obj} then P.Nothing else P.Just $ default_AuthenticateLongSession_args{authenticateLongSession_args_deviceDescription = authenticateLongSession_args_deviceDescription obj}
    , if obj == default_AuthenticateLongSession_args{authenticateLongSession_args_supportsTwoFactor = authenticateLongSession_args_supportsTwoFactor obj} then P.Nothing else P.Just $ default_AuthenticateLongSession_args{authenticateLongSession_args_supportsTwoFactor = authenticateLongSession_args_supportsTwoFactor obj}
    ]
from_AuthenticateLongSession_args :: AuthenticateLongSession_args -> T.ThriftVal
from_AuthenticateLongSession_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v100 -> P.Just (1, ("username",T.TString $ E.encodeUtf8 _v100))) $ authenticateLongSession_args_username record
  , (\_v100 -> P.Just (2, ("password",T.TString $ E.encodeUtf8 _v100))) $ authenticateLongSession_args_password record
  , (\_v100 -> P.Just (3, ("consumerKey",T.TString $ E.encodeUtf8 _v100))) $ authenticateLongSession_args_consumerKey record
  , (\_v100 -> P.Just (4, ("consumerSecret",T.TString $ E.encodeUtf8 _v100))) $ authenticateLongSession_args_consumerSecret record
  , (\_v100 -> P.Just (5, ("deviceIdentifier",T.TString $ E.encodeUtf8 _v100))) $ authenticateLongSession_args_deviceIdentifier record
  , (\_v100 -> P.Just (6, ("deviceDescription",T.TString $ E.encodeUtf8 _v100))) $ authenticateLongSession_args_deviceDescription record
  , (\_v100 -> P.Just (7, ("supportsTwoFactor",T.TBool _v100))) $ authenticateLongSession_args_supportsTwoFactor record
  ]
write_AuthenticateLongSession_args :: T.Protocol p => p -> AuthenticateLongSession_args -> P.IO ()
write_AuthenticateLongSession_args oprot record = T.writeVal oprot $ from_AuthenticateLongSession_args record
encode_AuthenticateLongSession_args :: T.StatelessProtocol p => p -> AuthenticateLongSession_args -> LBS.ByteString
encode_AuthenticateLongSession_args oprot record = T.serializeVal oprot $ from_AuthenticateLongSession_args record
to_AuthenticateLongSession_args :: T.ThriftVal -> AuthenticateLongSession_args
to_AuthenticateLongSession_args (T.TStruct fields) = AuthenticateLongSession_args{
  authenticateLongSession_args_username = P.maybe (authenticateLongSession_args_username default_AuthenticateLongSession_args) (\(_,_val102) -> (case _val102 of {T.TString _val103 -> E.decodeUtf8 _val103; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  authenticateLongSession_args_password = P.maybe (authenticateLongSession_args_password default_AuthenticateLongSession_args) (\(_,_val102) -> (case _val102 of {T.TString _val104 -> E.decodeUtf8 _val104; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  authenticateLongSession_args_consumerKey = P.maybe (authenticateLongSession_args_consumerKey default_AuthenticateLongSession_args) (\(_,_val102) -> (case _val102 of {T.TString _val105 -> E.decodeUtf8 _val105; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  authenticateLongSession_args_consumerSecret = P.maybe (authenticateLongSession_args_consumerSecret default_AuthenticateLongSession_args) (\(_,_val102) -> (case _val102 of {T.TString _val106 -> E.decodeUtf8 _val106; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  authenticateLongSession_args_deviceIdentifier = P.maybe (authenticateLongSession_args_deviceIdentifier default_AuthenticateLongSession_args) (\(_,_val102) -> (case _val102 of {T.TString _val107 -> E.decodeUtf8 _val107; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  authenticateLongSession_args_deviceDescription = P.maybe (authenticateLongSession_args_deviceDescription default_AuthenticateLongSession_args) (\(_,_val102) -> (case _val102 of {T.TString _val108 -> E.decodeUtf8 _val108; _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  authenticateLongSession_args_supportsTwoFactor = P.maybe (authenticateLongSession_args_supportsTwoFactor default_AuthenticateLongSession_args) (\(_,_val102) -> (case _val102 of {T.TBool _val109 -> _val109; _ -> P.error "wrong type"})) (Map.lookup (7) fields)
  }
to_AuthenticateLongSession_args _ = P.error "not a struct"
read_AuthenticateLongSession_args :: T.Protocol p => p -> P.IO AuthenticateLongSession_args
read_AuthenticateLongSession_args iprot = to_AuthenticateLongSession_args <$> T.readVal iprot (T.T_STRUCT typemap_AuthenticateLongSession_args)
decode_AuthenticateLongSession_args :: T.StatelessProtocol p => p -> LBS.ByteString -> AuthenticateLongSession_args
decode_AuthenticateLongSession_args iprot bs = to_AuthenticateLongSession_args $ T.deserializeVal iprot (T.T_STRUCT typemap_AuthenticateLongSession_args) bs
typemap_AuthenticateLongSession_args :: T.TypeMap
typemap_AuthenticateLongSession_args = Map.fromList [(1,("username",T.T_STRING)),(2,("password",T.T_STRING)),(3,("consumerKey",T.T_STRING)),(4,("consumerSecret",T.T_STRING)),(5,("deviceIdentifier",T.T_STRING)),(6,("deviceDescription",T.T_STRING)),(7,("supportsTwoFactor",T.T_BOOL))]
default_AuthenticateLongSession_args :: AuthenticateLongSession_args
default_AuthenticateLongSession_args = AuthenticateLongSession_args{
  authenticateLongSession_args_username = "",
  authenticateLongSession_args_password = "",
  authenticateLongSession_args_consumerKey = "",
  authenticateLongSession_args_consumerSecret = "",
  authenticateLongSession_args_deviceIdentifier = "",
  authenticateLongSession_args_deviceDescription = "",
  authenticateLongSession_args_supportsTwoFactor = P.False}
data AuthenticateLongSession_result = AuthenticateLongSession_result  { authenticateLongSession_result_success :: AuthenticationResult
  , authenticateLongSession_result_userException :: P.Maybe Errors_Types.EDAMUserException
  , authenticateLongSession_result_systemException :: P.Maybe Errors_Types.EDAMSystemException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable AuthenticateLongSession_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` authenticateLongSession_result_success record   `H.hashWithSalt` authenticateLongSession_result_userException record   `H.hashWithSalt` authenticateLongSession_result_systemException record  
instance QC.Arbitrary AuthenticateLongSession_result where 
  arbitrary = M.liftM AuthenticateLongSession_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_AuthenticateLongSession_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_AuthenticateLongSession_result{authenticateLongSession_result_success = authenticateLongSession_result_success obj} then P.Nothing else P.Just $ default_AuthenticateLongSession_result{authenticateLongSession_result_success = authenticateLongSession_result_success obj}
    , if obj == default_AuthenticateLongSession_result{authenticateLongSession_result_userException = authenticateLongSession_result_userException obj} then P.Nothing else P.Just $ default_AuthenticateLongSession_result{authenticateLongSession_result_userException = authenticateLongSession_result_userException obj}
    , if obj == default_AuthenticateLongSession_result{authenticateLongSession_result_systemException = authenticateLongSession_result_systemException obj} then P.Nothing else P.Just $ default_AuthenticateLongSession_result{authenticateLongSession_result_systemException = authenticateLongSession_result_systemException obj}
    ]
from_AuthenticateLongSession_result :: AuthenticateLongSession_result -> T.ThriftVal
from_AuthenticateLongSession_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v112 -> (1, ("userException",Errors_Types.from_EDAMUserException _v112))) <$> authenticateLongSession_result_userException record, (\_v112 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v112))) <$> authenticateLongSession_result_systemException record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v112 -> P.Just (0, ("success",from_AuthenticationResult _v112))) $ authenticateLongSession_result_success record
    , (\_v112 -> (1, ("userException",Errors_Types.from_EDAMUserException _v112))) <$> authenticateLongSession_result_userException record
    , (\_v112 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v112))) <$> authenticateLongSession_result_systemException record
    ]
    )
write_AuthenticateLongSession_result :: T.Protocol p => p -> AuthenticateLongSession_result -> P.IO ()
write_AuthenticateLongSession_result oprot record = T.writeVal oprot $ from_AuthenticateLongSession_result record
encode_AuthenticateLongSession_result :: T.StatelessProtocol p => p -> AuthenticateLongSession_result -> LBS.ByteString
encode_AuthenticateLongSession_result oprot record = T.serializeVal oprot $ from_AuthenticateLongSession_result record
to_AuthenticateLongSession_result :: T.ThriftVal -> AuthenticateLongSession_result
to_AuthenticateLongSession_result (T.TStruct fields) = AuthenticateLongSession_result{
  authenticateLongSession_result_success = P.maybe (authenticateLongSession_result_success default_AuthenticateLongSession_result) (\(_,_val114) -> (case _val114 of {T.TStruct _val115 -> (to_AuthenticationResult (T.TStruct _val115)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  authenticateLongSession_result_userException = P.maybe (P.Nothing) (\(_,_val114) -> P.Just (case _val114 of {T.TStruct _val116 -> (Errors_Types.to_EDAMUserException (T.TStruct _val116)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  authenticateLongSession_result_systemException = P.maybe (P.Nothing) (\(_,_val114) -> P.Just (case _val114 of {T.TStruct _val117 -> (Errors_Types.to_EDAMSystemException (T.TStruct _val117)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_AuthenticateLongSession_result _ = P.error "not a struct"
read_AuthenticateLongSession_result :: T.Protocol p => p -> P.IO AuthenticateLongSession_result
read_AuthenticateLongSession_result iprot = to_AuthenticateLongSession_result <$> T.readVal iprot (T.T_STRUCT typemap_AuthenticateLongSession_result)
decode_AuthenticateLongSession_result :: T.StatelessProtocol p => p -> LBS.ByteString -> AuthenticateLongSession_result
decode_AuthenticateLongSession_result iprot bs = to_AuthenticateLongSession_result $ T.deserializeVal iprot (T.T_STRUCT typemap_AuthenticateLongSession_result) bs
typemap_AuthenticateLongSession_result :: T.TypeMap
typemap_AuthenticateLongSession_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_AuthenticationResult))),(1,("userException",(T.T_STRUCT Errors_Types.typemap_EDAMUserException))),(2,("systemException",(T.T_STRUCT Errors_Types.typemap_EDAMSystemException)))]
default_AuthenticateLongSession_result :: AuthenticateLongSession_result
default_AuthenticateLongSession_result = AuthenticateLongSession_result{
  authenticateLongSession_result_success = default_AuthenticationResult,
  authenticateLongSession_result_userException = P.Nothing,
  authenticateLongSession_result_systemException = P.Nothing}
data CompleteTwoFactorAuthentication_args = CompleteTwoFactorAuthentication_args  { completeTwoFactorAuthentication_args_authenticationToken :: LT.Text
  , completeTwoFactorAuthentication_args_oneTimeCode :: LT.Text
  , completeTwoFactorAuthentication_args_deviceIdentifier :: LT.Text
  , completeTwoFactorAuthentication_args_deviceDescription :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable CompleteTwoFactorAuthentication_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` completeTwoFactorAuthentication_args_authenticationToken record   `H.hashWithSalt` completeTwoFactorAuthentication_args_oneTimeCode record   `H.hashWithSalt` completeTwoFactorAuthentication_args_deviceIdentifier record   `H.hashWithSalt` completeTwoFactorAuthentication_args_deviceDescription record  
instance QC.Arbitrary CompleteTwoFactorAuthentication_args where 
  arbitrary = M.liftM CompleteTwoFactorAuthentication_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_CompleteTwoFactorAuthentication_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_CompleteTwoFactorAuthentication_args{completeTwoFactorAuthentication_args_authenticationToken = completeTwoFactorAuthentication_args_authenticationToken obj} then P.Nothing else P.Just $ default_CompleteTwoFactorAuthentication_args{completeTwoFactorAuthentication_args_authenticationToken = completeTwoFactorAuthentication_args_authenticationToken obj}
    , if obj == default_CompleteTwoFactorAuthentication_args{completeTwoFactorAuthentication_args_oneTimeCode = completeTwoFactorAuthentication_args_oneTimeCode obj} then P.Nothing else P.Just $ default_CompleteTwoFactorAuthentication_args{completeTwoFactorAuthentication_args_oneTimeCode = completeTwoFactorAuthentication_args_oneTimeCode obj}
    , if obj == default_CompleteTwoFactorAuthentication_args{completeTwoFactorAuthentication_args_deviceIdentifier = completeTwoFactorAuthentication_args_deviceIdentifier obj} then P.Nothing else P.Just $ default_CompleteTwoFactorAuthentication_args{completeTwoFactorAuthentication_args_deviceIdentifier = completeTwoFactorAuthentication_args_deviceIdentifier obj}
    , if obj == default_CompleteTwoFactorAuthentication_args{completeTwoFactorAuthentication_args_deviceDescription = completeTwoFactorAuthentication_args_deviceDescription obj} then P.Nothing else P.Just $ default_CompleteTwoFactorAuthentication_args{completeTwoFactorAuthentication_args_deviceDescription = completeTwoFactorAuthentication_args_deviceDescription obj}
    ]
from_CompleteTwoFactorAuthentication_args :: CompleteTwoFactorAuthentication_args -> T.ThriftVal
from_CompleteTwoFactorAuthentication_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v120 -> P.Just (1, ("authenticationToken",T.TString $ E.encodeUtf8 _v120))) $ completeTwoFactorAuthentication_args_authenticationToken record
  , (\_v120 -> P.Just (2, ("oneTimeCode",T.TString $ E.encodeUtf8 _v120))) $ completeTwoFactorAuthentication_args_oneTimeCode record
  , (\_v120 -> P.Just (3, ("deviceIdentifier",T.TString $ E.encodeUtf8 _v120))) $ completeTwoFactorAuthentication_args_deviceIdentifier record
  , (\_v120 -> P.Just (4, ("deviceDescription",T.TString $ E.encodeUtf8 _v120))) $ completeTwoFactorAuthentication_args_deviceDescription record
  ]
write_CompleteTwoFactorAuthentication_args :: T.Protocol p => p -> CompleteTwoFactorAuthentication_args -> P.IO ()
write_CompleteTwoFactorAuthentication_args oprot record = T.writeVal oprot $ from_CompleteTwoFactorAuthentication_args record
encode_CompleteTwoFactorAuthentication_args :: T.StatelessProtocol p => p -> CompleteTwoFactorAuthentication_args -> LBS.ByteString
encode_CompleteTwoFactorAuthentication_args oprot record = T.serializeVal oprot $ from_CompleteTwoFactorAuthentication_args record
to_CompleteTwoFactorAuthentication_args :: T.ThriftVal -> CompleteTwoFactorAuthentication_args
to_CompleteTwoFactorAuthentication_args (T.TStruct fields) = CompleteTwoFactorAuthentication_args{
  completeTwoFactorAuthentication_args_authenticationToken = P.maybe (completeTwoFactorAuthentication_args_authenticationToken default_CompleteTwoFactorAuthentication_args) (\(_,_val122) -> (case _val122 of {T.TString _val123 -> E.decodeUtf8 _val123; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  completeTwoFactorAuthentication_args_oneTimeCode = P.maybe (completeTwoFactorAuthentication_args_oneTimeCode default_CompleteTwoFactorAuthentication_args) (\(_,_val122) -> (case _val122 of {T.TString _val124 -> E.decodeUtf8 _val124; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  completeTwoFactorAuthentication_args_deviceIdentifier = P.maybe (completeTwoFactorAuthentication_args_deviceIdentifier default_CompleteTwoFactorAuthentication_args) (\(_,_val122) -> (case _val122 of {T.TString _val125 -> E.decodeUtf8 _val125; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  completeTwoFactorAuthentication_args_deviceDescription = P.maybe (completeTwoFactorAuthentication_args_deviceDescription default_CompleteTwoFactorAuthentication_args) (\(_,_val122) -> (case _val122 of {T.TString _val126 -> E.decodeUtf8 _val126; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_CompleteTwoFactorAuthentication_args _ = P.error "not a struct"
read_CompleteTwoFactorAuthentication_args :: T.Protocol p => p -> P.IO CompleteTwoFactorAuthentication_args
read_CompleteTwoFactorAuthentication_args iprot = to_CompleteTwoFactorAuthentication_args <$> T.readVal iprot (T.T_STRUCT typemap_CompleteTwoFactorAuthentication_args)
decode_CompleteTwoFactorAuthentication_args :: T.StatelessProtocol p => p -> LBS.ByteString -> CompleteTwoFactorAuthentication_args
decode_CompleteTwoFactorAuthentication_args iprot bs = to_CompleteTwoFactorAuthentication_args $ T.deserializeVal iprot (T.T_STRUCT typemap_CompleteTwoFactorAuthentication_args) bs
typemap_CompleteTwoFactorAuthentication_args :: T.TypeMap
typemap_CompleteTwoFactorAuthentication_args = Map.fromList [(1,("authenticationToken",T.T_STRING)),(2,("oneTimeCode",T.T_STRING)),(3,("deviceIdentifier",T.T_STRING)),(4,("deviceDescription",T.T_STRING))]
default_CompleteTwoFactorAuthentication_args :: CompleteTwoFactorAuthentication_args
default_CompleteTwoFactorAuthentication_args = CompleteTwoFactorAuthentication_args{
  completeTwoFactorAuthentication_args_authenticationToken = "",
  completeTwoFactorAuthentication_args_oneTimeCode = "",
  completeTwoFactorAuthentication_args_deviceIdentifier = "",
  completeTwoFactorAuthentication_args_deviceDescription = ""}
data CompleteTwoFactorAuthentication_result = CompleteTwoFactorAuthentication_result  { completeTwoFactorAuthentication_result_success :: AuthenticationResult
  , completeTwoFactorAuthentication_result_userException :: P.Maybe Errors_Types.EDAMUserException
  , completeTwoFactorAuthentication_result_systemException :: P.Maybe Errors_Types.EDAMSystemException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable CompleteTwoFactorAuthentication_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` completeTwoFactorAuthentication_result_success record   `H.hashWithSalt` completeTwoFactorAuthentication_result_userException record   `H.hashWithSalt` completeTwoFactorAuthentication_result_systemException record  
instance QC.Arbitrary CompleteTwoFactorAuthentication_result where 
  arbitrary = M.liftM CompleteTwoFactorAuthentication_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_CompleteTwoFactorAuthentication_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_CompleteTwoFactorAuthentication_result{completeTwoFactorAuthentication_result_success = completeTwoFactorAuthentication_result_success obj} then P.Nothing else P.Just $ default_CompleteTwoFactorAuthentication_result{completeTwoFactorAuthentication_result_success = completeTwoFactorAuthentication_result_success obj}
    , if obj == default_CompleteTwoFactorAuthentication_result{completeTwoFactorAuthentication_result_userException = completeTwoFactorAuthentication_result_userException obj} then P.Nothing else P.Just $ default_CompleteTwoFactorAuthentication_result{completeTwoFactorAuthentication_result_userException = completeTwoFactorAuthentication_result_userException obj}
    , if obj == default_CompleteTwoFactorAuthentication_result{completeTwoFactorAuthentication_result_systemException = completeTwoFactorAuthentication_result_systemException obj} then P.Nothing else P.Just $ default_CompleteTwoFactorAuthentication_result{completeTwoFactorAuthentication_result_systemException = completeTwoFactorAuthentication_result_systemException obj}
    ]
from_CompleteTwoFactorAuthentication_result :: CompleteTwoFactorAuthentication_result -> T.ThriftVal
from_CompleteTwoFactorAuthentication_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v129 -> (1, ("userException",Errors_Types.from_EDAMUserException _v129))) <$> completeTwoFactorAuthentication_result_userException record, (\_v129 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v129))) <$> completeTwoFactorAuthentication_result_systemException record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v129 -> P.Just (0, ("success",from_AuthenticationResult _v129))) $ completeTwoFactorAuthentication_result_success record
    , (\_v129 -> (1, ("userException",Errors_Types.from_EDAMUserException _v129))) <$> completeTwoFactorAuthentication_result_userException record
    , (\_v129 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v129))) <$> completeTwoFactorAuthentication_result_systemException record
    ]
    )
write_CompleteTwoFactorAuthentication_result :: T.Protocol p => p -> CompleteTwoFactorAuthentication_result -> P.IO ()
write_CompleteTwoFactorAuthentication_result oprot record = T.writeVal oprot $ from_CompleteTwoFactorAuthentication_result record
encode_CompleteTwoFactorAuthentication_result :: T.StatelessProtocol p => p -> CompleteTwoFactorAuthentication_result -> LBS.ByteString
encode_CompleteTwoFactorAuthentication_result oprot record = T.serializeVal oprot $ from_CompleteTwoFactorAuthentication_result record
to_CompleteTwoFactorAuthentication_result :: T.ThriftVal -> CompleteTwoFactorAuthentication_result
to_CompleteTwoFactorAuthentication_result (T.TStruct fields) = CompleteTwoFactorAuthentication_result{
  completeTwoFactorAuthentication_result_success = P.maybe (completeTwoFactorAuthentication_result_success default_CompleteTwoFactorAuthentication_result) (\(_,_val131) -> (case _val131 of {T.TStruct _val132 -> (to_AuthenticationResult (T.TStruct _val132)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  completeTwoFactorAuthentication_result_userException = P.maybe (P.Nothing) (\(_,_val131) -> P.Just (case _val131 of {T.TStruct _val133 -> (Errors_Types.to_EDAMUserException (T.TStruct _val133)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  completeTwoFactorAuthentication_result_systemException = P.maybe (P.Nothing) (\(_,_val131) -> P.Just (case _val131 of {T.TStruct _val134 -> (Errors_Types.to_EDAMSystemException (T.TStruct _val134)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_CompleteTwoFactorAuthentication_result _ = P.error "not a struct"
read_CompleteTwoFactorAuthentication_result :: T.Protocol p => p -> P.IO CompleteTwoFactorAuthentication_result
read_CompleteTwoFactorAuthentication_result iprot = to_CompleteTwoFactorAuthentication_result <$> T.readVal iprot (T.T_STRUCT typemap_CompleteTwoFactorAuthentication_result)
decode_CompleteTwoFactorAuthentication_result :: T.StatelessProtocol p => p -> LBS.ByteString -> CompleteTwoFactorAuthentication_result
decode_CompleteTwoFactorAuthentication_result iprot bs = to_CompleteTwoFactorAuthentication_result $ T.deserializeVal iprot (T.T_STRUCT typemap_CompleteTwoFactorAuthentication_result) bs
typemap_CompleteTwoFactorAuthentication_result :: T.TypeMap
typemap_CompleteTwoFactorAuthentication_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_AuthenticationResult))),(1,("userException",(T.T_STRUCT Errors_Types.typemap_EDAMUserException))),(2,("systemException",(T.T_STRUCT Errors_Types.typemap_EDAMSystemException)))]
default_CompleteTwoFactorAuthentication_result :: CompleteTwoFactorAuthentication_result
default_CompleteTwoFactorAuthentication_result = CompleteTwoFactorAuthentication_result{
  completeTwoFactorAuthentication_result_success = default_AuthenticationResult,
  completeTwoFactorAuthentication_result_userException = P.Nothing,
  completeTwoFactorAuthentication_result_systemException = P.Nothing}
data RevokeLongSession_args = RevokeLongSession_args  { revokeLongSession_args_authenticationToken :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RevokeLongSession_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` revokeLongSession_args_authenticationToken record  
instance QC.Arbitrary RevokeLongSession_args where 
  arbitrary = M.liftM RevokeLongSession_args (QC.arbitrary)
  shrink obj | obj == default_RevokeLongSession_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RevokeLongSession_args{revokeLongSession_args_authenticationToken = revokeLongSession_args_authenticationToken obj} then P.Nothing else P.Just $ default_RevokeLongSession_args{revokeLongSession_args_authenticationToken = revokeLongSession_args_authenticationToken obj}
    ]
from_RevokeLongSession_args :: RevokeLongSession_args -> T.ThriftVal
from_RevokeLongSession_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v137 -> P.Just (1, ("authenticationToken",T.TString $ E.encodeUtf8 _v137))) $ revokeLongSession_args_authenticationToken record
  ]
write_RevokeLongSession_args :: T.Protocol p => p -> RevokeLongSession_args -> P.IO ()
write_RevokeLongSession_args oprot record = T.writeVal oprot $ from_RevokeLongSession_args record
encode_RevokeLongSession_args :: T.StatelessProtocol p => p -> RevokeLongSession_args -> LBS.ByteString
encode_RevokeLongSession_args oprot record = T.serializeVal oprot $ from_RevokeLongSession_args record
to_RevokeLongSession_args :: T.ThriftVal -> RevokeLongSession_args
to_RevokeLongSession_args (T.TStruct fields) = RevokeLongSession_args{
  revokeLongSession_args_authenticationToken = P.maybe (revokeLongSession_args_authenticationToken default_RevokeLongSession_args) (\(_,_val139) -> (case _val139 of {T.TString _val140 -> E.decodeUtf8 _val140; _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_RevokeLongSession_args _ = P.error "not a struct"
read_RevokeLongSession_args :: T.Protocol p => p -> P.IO RevokeLongSession_args
read_RevokeLongSession_args iprot = to_RevokeLongSession_args <$> T.readVal iprot (T.T_STRUCT typemap_RevokeLongSession_args)
decode_RevokeLongSession_args :: T.StatelessProtocol p => p -> LBS.ByteString -> RevokeLongSession_args
decode_RevokeLongSession_args iprot bs = to_RevokeLongSession_args $ T.deserializeVal iprot (T.T_STRUCT typemap_RevokeLongSession_args) bs
typemap_RevokeLongSession_args :: T.TypeMap
typemap_RevokeLongSession_args = Map.fromList [(1,("authenticationToken",T.T_STRING))]
default_RevokeLongSession_args :: RevokeLongSession_args
default_RevokeLongSession_args = RevokeLongSession_args{
  revokeLongSession_args_authenticationToken = ""}
data RevokeLongSession_result = RevokeLongSession_result  { revokeLongSession_result_userException :: P.Maybe Errors_Types.EDAMUserException
  , revokeLongSession_result_systemException :: P.Maybe Errors_Types.EDAMSystemException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RevokeLongSession_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` revokeLongSession_result_userException record   `H.hashWithSalt` revokeLongSession_result_systemException record  
instance QC.Arbitrary RevokeLongSession_result where 
  arbitrary = M.liftM RevokeLongSession_result (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_RevokeLongSession_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RevokeLongSession_result{revokeLongSession_result_userException = revokeLongSession_result_userException obj} then P.Nothing else P.Just $ default_RevokeLongSession_result{revokeLongSession_result_userException = revokeLongSession_result_userException obj}
    , if obj == default_RevokeLongSession_result{revokeLongSession_result_systemException = revokeLongSession_result_systemException obj} then P.Nothing else P.Just $ default_RevokeLongSession_result{revokeLongSession_result_systemException = revokeLongSession_result_systemException obj}
    ]
from_RevokeLongSession_result :: RevokeLongSession_result -> T.ThriftVal
from_RevokeLongSession_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v143 -> (1, ("userException",Errors_Types.from_EDAMUserException _v143))) <$> revokeLongSession_result_userException record, (\_v143 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v143))) <$> revokeLongSession_result_systemException record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v143 -> (1, ("userException",Errors_Types.from_EDAMUserException _v143))) <$> revokeLongSession_result_userException record
    , (\_v143 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v143))) <$> revokeLongSession_result_systemException record
    ]
    )
write_RevokeLongSession_result :: T.Protocol p => p -> RevokeLongSession_result -> P.IO ()
write_RevokeLongSession_result oprot record = T.writeVal oprot $ from_RevokeLongSession_result record
encode_RevokeLongSession_result :: T.StatelessProtocol p => p -> RevokeLongSession_result -> LBS.ByteString
encode_RevokeLongSession_result oprot record = T.serializeVal oprot $ from_RevokeLongSession_result record
to_RevokeLongSession_result :: T.ThriftVal -> RevokeLongSession_result
to_RevokeLongSession_result (T.TStruct fields) = RevokeLongSession_result{
  revokeLongSession_result_userException = P.maybe (P.Nothing) (\(_,_val145) -> P.Just (case _val145 of {T.TStruct _val146 -> (Errors_Types.to_EDAMUserException (T.TStruct _val146)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  revokeLongSession_result_systemException = P.maybe (P.Nothing) (\(_,_val145) -> P.Just (case _val145 of {T.TStruct _val147 -> (Errors_Types.to_EDAMSystemException (T.TStruct _val147)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_RevokeLongSession_result _ = P.error "not a struct"
read_RevokeLongSession_result :: T.Protocol p => p -> P.IO RevokeLongSession_result
read_RevokeLongSession_result iprot = to_RevokeLongSession_result <$> T.readVal iprot (T.T_STRUCT typemap_RevokeLongSession_result)
decode_RevokeLongSession_result :: T.StatelessProtocol p => p -> LBS.ByteString -> RevokeLongSession_result
decode_RevokeLongSession_result iprot bs = to_RevokeLongSession_result $ T.deserializeVal iprot (T.T_STRUCT typemap_RevokeLongSession_result) bs
typemap_RevokeLongSession_result :: T.TypeMap
typemap_RevokeLongSession_result = Map.fromList [(1,("userException",(T.T_STRUCT Errors_Types.typemap_EDAMUserException))),(2,("systemException",(T.T_STRUCT Errors_Types.typemap_EDAMSystemException)))]
default_RevokeLongSession_result :: RevokeLongSession_result
default_RevokeLongSession_result = RevokeLongSession_result{
  revokeLongSession_result_userException = P.Nothing,
  revokeLongSession_result_systemException = P.Nothing}
data AuthenticateToBusiness_args = AuthenticateToBusiness_args  { authenticateToBusiness_args_authenticationToken :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable AuthenticateToBusiness_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` authenticateToBusiness_args_authenticationToken record  
instance QC.Arbitrary AuthenticateToBusiness_args where 
  arbitrary = M.liftM AuthenticateToBusiness_args (QC.arbitrary)
  shrink obj | obj == default_AuthenticateToBusiness_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_AuthenticateToBusiness_args{authenticateToBusiness_args_authenticationToken = authenticateToBusiness_args_authenticationToken obj} then P.Nothing else P.Just $ default_AuthenticateToBusiness_args{authenticateToBusiness_args_authenticationToken = authenticateToBusiness_args_authenticationToken obj}
    ]
from_AuthenticateToBusiness_args :: AuthenticateToBusiness_args -> T.ThriftVal
from_AuthenticateToBusiness_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v150 -> P.Just (1, ("authenticationToken",T.TString $ E.encodeUtf8 _v150))) $ authenticateToBusiness_args_authenticationToken record
  ]
write_AuthenticateToBusiness_args :: T.Protocol p => p -> AuthenticateToBusiness_args -> P.IO ()
write_AuthenticateToBusiness_args oprot record = T.writeVal oprot $ from_AuthenticateToBusiness_args record
encode_AuthenticateToBusiness_args :: T.StatelessProtocol p => p -> AuthenticateToBusiness_args -> LBS.ByteString
encode_AuthenticateToBusiness_args oprot record = T.serializeVal oprot $ from_AuthenticateToBusiness_args record
to_AuthenticateToBusiness_args :: T.ThriftVal -> AuthenticateToBusiness_args
to_AuthenticateToBusiness_args (T.TStruct fields) = AuthenticateToBusiness_args{
  authenticateToBusiness_args_authenticationToken = P.maybe (authenticateToBusiness_args_authenticationToken default_AuthenticateToBusiness_args) (\(_,_val152) -> (case _val152 of {T.TString _val153 -> E.decodeUtf8 _val153; _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_AuthenticateToBusiness_args _ = P.error "not a struct"
read_AuthenticateToBusiness_args :: T.Protocol p => p -> P.IO AuthenticateToBusiness_args
read_AuthenticateToBusiness_args iprot = to_AuthenticateToBusiness_args <$> T.readVal iprot (T.T_STRUCT typemap_AuthenticateToBusiness_args)
decode_AuthenticateToBusiness_args :: T.StatelessProtocol p => p -> LBS.ByteString -> AuthenticateToBusiness_args
decode_AuthenticateToBusiness_args iprot bs = to_AuthenticateToBusiness_args $ T.deserializeVal iprot (T.T_STRUCT typemap_AuthenticateToBusiness_args) bs
typemap_AuthenticateToBusiness_args :: T.TypeMap
typemap_AuthenticateToBusiness_args = Map.fromList [(1,("authenticationToken",T.T_STRING))]
default_AuthenticateToBusiness_args :: AuthenticateToBusiness_args
default_AuthenticateToBusiness_args = AuthenticateToBusiness_args{
  authenticateToBusiness_args_authenticationToken = ""}
data AuthenticateToBusiness_result = AuthenticateToBusiness_result  { authenticateToBusiness_result_success :: AuthenticationResult
  , authenticateToBusiness_result_userException :: P.Maybe Errors_Types.EDAMUserException
  , authenticateToBusiness_result_systemException :: P.Maybe Errors_Types.EDAMSystemException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable AuthenticateToBusiness_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` authenticateToBusiness_result_success record   `H.hashWithSalt` authenticateToBusiness_result_userException record   `H.hashWithSalt` authenticateToBusiness_result_systemException record  
instance QC.Arbitrary AuthenticateToBusiness_result where 
  arbitrary = M.liftM AuthenticateToBusiness_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_AuthenticateToBusiness_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_AuthenticateToBusiness_result{authenticateToBusiness_result_success = authenticateToBusiness_result_success obj} then P.Nothing else P.Just $ default_AuthenticateToBusiness_result{authenticateToBusiness_result_success = authenticateToBusiness_result_success obj}
    , if obj == default_AuthenticateToBusiness_result{authenticateToBusiness_result_userException = authenticateToBusiness_result_userException obj} then P.Nothing else P.Just $ default_AuthenticateToBusiness_result{authenticateToBusiness_result_userException = authenticateToBusiness_result_userException obj}
    , if obj == default_AuthenticateToBusiness_result{authenticateToBusiness_result_systemException = authenticateToBusiness_result_systemException obj} then P.Nothing else P.Just $ default_AuthenticateToBusiness_result{authenticateToBusiness_result_systemException = authenticateToBusiness_result_systemException obj}
    ]
from_AuthenticateToBusiness_result :: AuthenticateToBusiness_result -> T.ThriftVal
from_AuthenticateToBusiness_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v156 -> (1, ("userException",Errors_Types.from_EDAMUserException _v156))) <$> authenticateToBusiness_result_userException record, (\_v156 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v156))) <$> authenticateToBusiness_result_systemException record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v156 -> P.Just (0, ("success",from_AuthenticationResult _v156))) $ authenticateToBusiness_result_success record
    , (\_v156 -> (1, ("userException",Errors_Types.from_EDAMUserException _v156))) <$> authenticateToBusiness_result_userException record
    , (\_v156 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v156))) <$> authenticateToBusiness_result_systemException record
    ]
    )
write_AuthenticateToBusiness_result :: T.Protocol p => p -> AuthenticateToBusiness_result -> P.IO ()
write_AuthenticateToBusiness_result oprot record = T.writeVal oprot $ from_AuthenticateToBusiness_result record
encode_AuthenticateToBusiness_result :: T.StatelessProtocol p => p -> AuthenticateToBusiness_result -> LBS.ByteString
encode_AuthenticateToBusiness_result oprot record = T.serializeVal oprot $ from_AuthenticateToBusiness_result record
to_AuthenticateToBusiness_result :: T.ThriftVal -> AuthenticateToBusiness_result
to_AuthenticateToBusiness_result (T.TStruct fields) = AuthenticateToBusiness_result{
  authenticateToBusiness_result_success = P.maybe (authenticateToBusiness_result_success default_AuthenticateToBusiness_result) (\(_,_val158) -> (case _val158 of {T.TStruct _val159 -> (to_AuthenticationResult (T.TStruct _val159)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  authenticateToBusiness_result_userException = P.maybe (P.Nothing) (\(_,_val158) -> P.Just (case _val158 of {T.TStruct _val160 -> (Errors_Types.to_EDAMUserException (T.TStruct _val160)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  authenticateToBusiness_result_systemException = P.maybe (P.Nothing) (\(_,_val158) -> P.Just (case _val158 of {T.TStruct _val161 -> (Errors_Types.to_EDAMSystemException (T.TStruct _val161)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_AuthenticateToBusiness_result _ = P.error "not a struct"
read_AuthenticateToBusiness_result :: T.Protocol p => p -> P.IO AuthenticateToBusiness_result
read_AuthenticateToBusiness_result iprot = to_AuthenticateToBusiness_result <$> T.readVal iprot (T.T_STRUCT typemap_AuthenticateToBusiness_result)
decode_AuthenticateToBusiness_result :: T.StatelessProtocol p => p -> LBS.ByteString -> AuthenticateToBusiness_result
decode_AuthenticateToBusiness_result iprot bs = to_AuthenticateToBusiness_result $ T.deserializeVal iprot (T.T_STRUCT typemap_AuthenticateToBusiness_result) bs
typemap_AuthenticateToBusiness_result :: T.TypeMap
typemap_AuthenticateToBusiness_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_AuthenticationResult))),(1,("userException",(T.T_STRUCT Errors_Types.typemap_EDAMUserException))),(2,("systemException",(T.T_STRUCT Errors_Types.typemap_EDAMSystemException)))]
default_AuthenticateToBusiness_result :: AuthenticateToBusiness_result
default_AuthenticateToBusiness_result = AuthenticateToBusiness_result{
  authenticateToBusiness_result_success = default_AuthenticationResult,
  authenticateToBusiness_result_userException = P.Nothing,
  authenticateToBusiness_result_systemException = P.Nothing}
data GetUser_args = GetUser_args  { getUser_args_authenticationToken :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetUser_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getUser_args_authenticationToken record  
instance QC.Arbitrary GetUser_args where 
  arbitrary = M.liftM GetUser_args (QC.arbitrary)
  shrink obj | obj == default_GetUser_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetUser_args{getUser_args_authenticationToken = getUser_args_authenticationToken obj} then P.Nothing else P.Just $ default_GetUser_args{getUser_args_authenticationToken = getUser_args_authenticationToken obj}
    ]
from_GetUser_args :: GetUser_args -> T.ThriftVal
from_GetUser_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v164 -> P.Just (1, ("authenticationToken",T.TString $ E.encodeUtf8 _v164))) $ getUser_args_authenticationToken record
  ]
write_GetUser_args :: T.Protocol p => p -> GetUser_args -> P.IO ()
write_GetUser_args oprot record = T.writeVal oprot $ from_GetUser_args record
encode_GetUser_args :: T.StatelessProtocol p => p -> GetUser_args -> LBS.ByteString
encode_GetUser_args oprot record = T.serializeVal oprot $ from_GetUser_args record
to_GetUser_args :: T.ThriftVal -> GetUser_args
to_GetUser_args (T.TStruct fields) = GetUser_args{
  getUser_args_authenticationToken = P.maybe (getUser_args_authenticationToken default_GetUser_args) (\(_,_val166) -> (case _val166 of {T.TString _val167 -> E.decodeUtf8 _val167; _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetUser_args _ = P.error "not a struct"
read_GetUser_args :: T.Protocol p => p -> P.IO GetUser_args
read_GetUser_args iprot = to_GetUser_args <$> T.readVal iprot (T.T_STRUCT typemap_GetUser_args)
decode_GetUser_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetUser_args
decode_GetUser_args iprot bs = to_GetUser_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetUser_args) bs
typemap_GetUser_args :: T.TypeMap
typemap_GetUser_args = Map.fromList [(1,("authenticationToken",T.T_STRING))]
default_GetUser_args :: GetUser_args
default_GetUser_args = GetUser_args{
  getUser_args_authenticationToken = ""}
data GetUser_result = GetUser_result  { getUser_result_success :: Types_Types.User
  , getUser_result_userException :: P.Maybe Errors_Types.EDAMUserException
  , getUser_result_systemException :: P.Maybe Errors_Types.EDAMSystemException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetUser_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getUser_result_success record   `H.hashWithSalt` getUser_result_userException record   `H.hashWithSalt` getUser_result_systemException record  
instance QC.Arbitrary GetUser_result where 
  arbitrary = M.liftM GetUser_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetUser_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetUser_result{getUser_result_success = getUser_result_success obj} then P.Nothing else P.Just $ default_GetUser_result{getUser_result_success = getUser_result_success obj}
    , if obj == default_GetUser_result{getUser_result_userException = getUser_result_userException obj} then P.Nothing else P.Just $ default_GetUser_result{getUser_result_userException = getUser_result_userException obj}
    , if obj == default_GetUser_result{getUser_result_systemException = getUser_result_systemException obj} then P.Nothing else P.Just $ default_GetUser_result{getUser_result_systemException = getUser_result_systemException obj}
    ]
from_GetUser_result :: GetUser_result -> T.ThriftVal
from_GetUser_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v170 -> (1, ("userException",Errors_Types.from_EDAMUserException _v170))) <$> getUser_result_userException record, (\_v170 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v170))) <$> getUser_result_systemException record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v170 -> P.Just (0, ("success",Types_Types.from_User _v170))) $ getUser_result_success record
    , (\_v170 -> (1, ("userException",Errors_Types.from_EDAMUserException _v170))) <$> getUser_result_userException record
    , (\_v170 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v170))) <$> getUser_result_systemException record
    ]
    )
write_GetUser_result :: T.Protocol p => p -> GetUser_result -> P.IO ()
write_GetUser_result oprot record = T.writeVal oprot $ from_GetUser_result record
encode_GetUser_result :: T.StatelessProtocol p => p -> GetUser_result -> LBS.ByteString
encode_GetUser_result oprot record = T.serializeVal oprot $ from_GetUser_result record
to_GetUser_result :: T.ThriftVal -> GetUser_result
to_GetUser_result (T.TStruct fields) = GetUser_result{
  getUser_result_success = P.maybe (getUser_result_success default_GetUser_result) (\(_,_val172) -> (case _val172 of {T.TStruct _val173 -> (Types_Types.to_User (T.TStruct _val173)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getUser_result_userException = P.maybe (P.Nothing) (\(_,_val172) -> P.Just (case _val172 of {T.TStruct _val174 -> (Errors_Types.to_EDAMUserException (T.TStruct _val174)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  getUser_result_systemException = P.maybe (P.Nothing) (\(_,_val172) -> P.Just (case _val172 of {T.TStruct _val175 -> (Errors_Types.to_EDAMSystemException (T.TStruct _val175)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_GetUser_result _ = P.error "not a struct"
read_GetUser_result :: T.Protocol p => p -> P.IO GetUser_result
read_GetUser_result iprot = to_GetUser_result <$> T.readVal iprot (T.T_STRUCT typemap_GetUser_result)
decode_GetUser_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetUser_result
decode_GetUser_result iprot bs = to_GetUser_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetUser_result) bs
typemap_GetUser_result :: T.TypeMap
typemap_GetUser_result = Map.fromList [(0,("success",(T.T_STRUCT Types_Types.typemap_User))),(1,("userException",(T.T_STRUCT Errors_Types.typemap_EDAMUserException))),(2,("systemException",(T.T_STRUCT Errors_Types.typemap_EDAMSystemException)))]
default_GetUser_result :: GetUser_result
default_GetUser_result = GetUser_result{
  getUser_result_success = Types_Types.default_User,
  getUser_result_userException = P.Nothing,
  getUser_result_systemException = P.Nothing}
data GetPublicUserInfo_args = GetPublicUserInfo_args  { getPublicUserInfo_args_username :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetPublicUserInfo_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getPublicUserInfo_args_username record  
instance QC.Arbitrary GetPublicUserInfo_args where 
  arbitrary = M.liftM GetPublicUserInfo_args (QC.arbitrary)
  shrink obj | obj == default_GetPublicUserInfo_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetPublicUserInfo_args{getPublicUserInfo_args_username = getPublicUserInfo_args_username obj} then P.Nothing else P.Just $ default_GetPublicUserInfo_args{getPublicUserInfo_args_username = getPublicUserInfo_args_username obj}
    ]
from_GetPublicUserInfo_args :: GetPublicUserInfo_args -> T.ThriftVal
from_GetPublicUserInfo_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v178 -> P.Just (1, ("username",T.TString $ E.encodeUtf8 _v178))) $ getPublicUserInfo_args_username record
  ]
write_GetPublicUserInfo_args :: T.Protocol p => p -> GetPublicUserInfo_args -> P.IO ()
write_GetPublicUserInfo_args oprot record = T.writeVal oprot $ from_GetPublicUserInfo_args record
encode_GetPublicUserInfo_args :: T.StatelessProtocol p => p -> GetPublicUserInfo_args -> LBS.ByteString
encode_GetPublicUserInfo_args oprot record = T.serializeVal oprot $ from_GetPublicUserInfo_args record
to_GetPublicUserInfo_args :: T.ThriftVal -> GetPublicUserInfo_args
to_GetPublicUserInfo_args (T.TStruct fields) = GetPublicUserInfo_args{
  getPublicUserInfo_args_username = P.maybe (getPublicUserInfo_args_username default_GetPublicUserInfo_args) (\(_,_val180) -> (case _val180 of {T.TString _val181 -> E.decodeUtf8 _val181; _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetPublicUserInfo_args _ = P.error "not a struct"
read_GetPublicUserInfo_args :: T.Protocol p => p -> P.IO GetPublicUserInfo_args
read_GetPublicUserInfo_args iprot = to_GetPublicUserInfo_args <$> T.readVal iprot (T.T_STRUCT typemap_GetPublicUserInfo_args)
decode_GetPublicUserInfo_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetPublicUserInfo_args
decode_GetPublicUserInfo_args iprot bs = to_GetPublicUserInfo_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetPublicUserInfo_args) bs
typemap_GetPublicUserInfo_args :: T.TypeMap
typemap_GetPublicUserInfo_args = Map.fromList [(1,("username",T.T_STRING))]
default_GetPublicUserInfo_args :: GetPublicUserInfo_args
default_GetPublicUserInfo_args = GetPublicUserInfo_args{
  getPublicUserInfo_args_username = ""}
data GetPublicUserInfo_result = GetPublicUserInfo_result  { getPublicUserInfo_result_success :: PublicUserInfo
  , getPublicUserInfo_result_notFoundException :: P.Maybe Errors_Types.EDAMNotFoundException
  , getPublicUserInfo_result_systemException :: P.Maybe Errors_Types.EDAMSystemException
  , getPublicUserInfo_result_userException :: P.Maybe Errors_Types.EDAMUserException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetPublicUserInfo_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getPublicUserInfo_result_success record   `H.hashWithSalt` getPublicUserInfo_result_notFoundException record   `H.hashWithSalt` getPublicUserInfo_result_systemException record   `H.hashWithSalt` getPublicUserInfo_result_userException record  
instance QC.Arbitrary GetPublicUserInfo_result where 
  arbitrary = M.liftM GetPublicUserInfo_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetPublicUserInfo_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetPublicUserInfo_result{getPublicUserInfo_result_success = getPublicUserInfo_result_success obj} then P.Nothing else P.Just $ default_GetPublicUserInfo_result{getPublicUserInfo_result_success = getPublicUserInfo_result_success obj}
    , if obj == default_GetPublicUserInfo_result{getPublicUserInfo_result_notFoundException = getPublicUserInfo_result_notFoundException obj} then P.Nothing else P.Just $ default_GetPublicUserInfo_result{getPublicUserInfo_result_notFoundException = getPublicUserInfo_result_notFoundException obj}
    , if obj == default_GetPublicUserInfo_result{getPublicUserInfo_result_systemException = getPublicUserInfo_result_systemException obj} then P.Nothing else P.Just $ default_GetPublicUserInfo_result{getPublicUserInfo_result_systemException = getPublicUserInfo_result_systemException obj}
    , if obj == default_GetPublicUserInfo_result{getPublicUserInfo_result_userException = getPublicUserInfo_result_userException obj} then P.Nothing else P.Just $ default_GetPublicUserInfo_result{getPublicUserInfo_result_userException = getPublicUserInfo_result_userException obj}
    ]
from_GetPublicUserInfo_result :: GetPublicUserInfo_result -> T.ThriftVal
from_GetPublicUserInfo_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v184 -> (1, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v184))) <$> getPublicUserInfo_result_notFoundException record, (\_v184 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v184))) <$> getPublicUserInfo_result_systemException record, (\_v184 -> (3, ("userException",Errors_Types.from_EDAMUserException _v184))) <$> getPublicUserInfo_result_userException record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v184 -> P.Just (0, ("success",from_PublicUserInfo _v184))) $ getPublicUserInfo_result_success record
    , (\_v184 -> (1, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v184))) <$> getPublicUserInfo_result_notFoundException record
    , (\_v184 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v184))) <$> getPublicUserInfo_result_systemException record
    , (\_v184 -> (3, ("userException",Errors_Types.from_EDAMUserException _v184))) <$> getPublicUserInfo_result_userException record
    ]
    )
write_GetPublicUserInfo_result :: T.Protocol p => p -> GetPublicUserInfo_result -> P.IO ()
write_GetPublicUserInfo_result oprot record = T.writeVal oprot $ from_GetPublicUserInfo_result record
encode_GetPublicUserInfo_result :: T.StatelessProtocol p => p -> GetPublicUserInfo_result -> LBS.ByteString
encode_GetPublicUserInfo_result oprot record = T.serializeVal oprot $ from_GetPublicUserInfo_result record
to_GetPublicUserInfo_result :: T.ThriftVal -> GetPublicUserInfo_result
to_GetPublicUserInfo_result (T.TStruct fields) = GetPublicUserInfo_result{
  getPublicUserInfo_result_success = P.maybe (getPublicUserInfo_result_success default_GetPublicUserInfo_result) (\(_,_val186) -> (case _val186 of {T.TStruct _val187 -> (to_PublicUserInfo (T.TStruct _val187)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getPublicUserInfo_result_notFoundException = P.maybe (P.Nothing) (\(_,_val186) -> P.Just (case _val186 of {T.TStruct _val188 -> (Errors_Types.to_EDAMNotFoundException (T.TStruct _val188)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  getPublicUserInfo_result_systemException = P.maybe (P.Nothing) (\(_,_val186) -> P.Just (case _val186 of {T.TStruct _val189 -> (Errors_Types.to_EDAMSystemException (T.TStruct _val189)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  getPublicUserInfo_result_userException = P.maybe (P.Nothing) (\(_,_val186) -> P.Just (case _val186 of {T.TStruct _val190 -> (Errors_Types.to_EDAMUserException (T.TStruct _val190)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_GetPublicUserInfo_result _ = P.error "not a struct"
read_GetPublicUserInfo_result :: T.Protocol p => p -> P.IO GetPublicUserInfo_result
read_GetPublicUserInfo_result iprot = to_GetPublicUserInfo_result <$> T.readVal iprot (T.T_STRUCT typemap_GetPublicUserInfo_result)
decode_GetPublicUserInfo_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetPublicUserInfo_result
decode_GetPublicUserInfo_result iprot bs = to_GetPublicUserInfo_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetPublicUserInfo_result) bs
typemap_GetPublicUserInfo_result :: T.TypeMap
typemap_GetPublicUserInfo_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_PublicUserInfo))),(1,("notFoundException",(T.T_STRUCT Errors_Types.typemap_EDAMNotFoundException))),(2,("systemException",(T.T_STRUCT Errors_Types.typemap_EDAMSystemException))),(3,("userException",(T.T_STRUCT Errors_Types.typemap_EDAMUserException)))]
default_GetPublicUserInfo_result :: GetPublicUserInfo_result
default_GetPublicUserInfo_result = GetPublicUserInfo_result{
  getPublicUserInfo_result_success = default_PublicUserInfo,
  getPublicUserInfo_result_notFoundException = P.Nothing,
  getPublicUserInfo_result_systemException = P.Nothing,
  getPublicUserInfo_result_userException = P.Nothing}
data GetUserUrls_args = GetUserUrls_args  { getUserUrls_args_authenticationToken :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetUserUrls_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getUserUrls_args_authenticationToken record  
instance QC.Arbitrary GetUserUrls_args where 
  arbitrary = M.liftM GetUserUrls_args (QC.arbitrary)
  shrink obj | obj == default_GetUserUrls_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetUserUrls_args{getUserUrls_args_authenticationToken = getUserUrls_args_authenticationToken obj} then P.Nothing else P.Just $ default_GetUserUrls_args{getUserUrls_args_authenticationToken = getUserUrls_args_authenticationToken obj}
    ]
from_GetUserUrls_args :: GetUserUrls_args -> T.ThriftVal
from_GetUserUrls_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v193 -> P.Just (1, ("authenticationToken",T.TString $ E.encodeUtf8 _v193))) $ getUserUrls_args_authenticationToken record
  ]
write_GetUserUrls_args :: T.Protocol p => p -> GetUserUrls_args -> P.IO ()
write_GetUserUrls_args oprot record = T.writeVal oprot $ from_GetUserUrls_args record
encode_GetUserUrls_args :: T.StatelessProtocol p => p -> GetUserUrls_args -> LBS.ByteString
encode_GetUserUrls_args oprot record = T.serializeVal oprot $ from_GetUserUrls_args record
to_GetUserUrls_args :: T.ThriftVal -> GetUserUrls_args
to_GetUserUrls_args (T.TStruct fields) = GetUserUrls_args{
  getUserUrls_args_authenticationToken = P.maybe (getUserUrls_args_authenticationToken default_GetUserUrls_args) (\(_,_val195) -> (case _val195 of {T.TString _val196 -> E.decodeUtf8 _val196; _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetUserUrls_args _ = P.error "not a struct"
read_GetUserUrls_args :: T.Protocol p => p -> P.IO GetUserUrls_args
read_GetUserUrls_args iprot = to_GetUserUrls_args <$> T.readVal iprot (T.T_STRUCT typemap_GetUserUrls_args)
decode_GetUserUrls_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetUserUrls_args
decode_GetUserUrls_args iprot bs = to_GetUserUrls_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetUserUrls_args) bs
typemap_GetUserUrls_args :: T.TypeMap
typemap_GetUserUrls_args = Map.fromList [(1,("authenticationToken",T.T_STRING))]
default_GetUserUrls_args :: GetUserUrls_args
default_GetUserUrls_args = GetUserUrls_args{
  getUserUrls_args_authenticationToken = ""}
data GetUserUrls_result = GetUserUrls_result  { getUserUrls_result_success :: UserUrls
  , getUserUrls_result_userException :: P.Maybe Errors_Types.EDAMUserException
  , getUserUrls_result_systemException :: P.Maybe Errors_Types.EDAMSystemException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetUserUrls_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getUserUrls_result_success record   `H.hashWithSalt` getUserUrls_result_userException record   `H.hashWithSalt` getUserUrls_result_systemException record  
instance QC.Arbitrary GetUserUrls_result where 
  arbitrary = M.liftM GetUserUrls_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetUserUrls_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetUserUrls_result{getUserUrls_result_success = getUserUrls_result_success obj} then P.Nothing else P.Just $ default_GetUserUrls_result{getUserUrls_result_success = getUserUrls_result_success obj}
    , if obj == default_GetUserUrls_result{getUserUrls_result_userException = getUserUrls_result_userException obj} then P.Nothing else P.Just $ default_GetUserUrls_result{getUserUrls_result_userException = getUserUrls_result_userException obj}
    , if obj == default_GetUserUrls_result{getUserUrls_result_systemException = getUserUrls_result_systemException obj} then P.Nothing else P.Just $ default_GetUserUrls_result{getUserUrls_result_systemException = getUserUrls_result_systemException obj}
    ]
from_GetUserUrls_result :: GetUserUrls_result -> T.ThriftVal
from_GetUserUrls_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v199 -> (1, ("userException",Errors_Types.from_EDAMUserException _v199))) <$> getUserUrls_result_userException record, (\_v199 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v199))) <$> getUserUrls_result_systemException record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v199 -> P.Just (0, ("success",from_UserUrls _v199))) $ getUserUrls_result_success record
    , (\_v199 -> (1, ("userException",Errors_Types.from_EDAMUserException _v199))) <$> getUserUrls_result_userException record
    , (\_v199 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v199))) <$> getUserUrls_result_systemException record
    ]
    )
write_GetUserUrls_result :: T.Protocol p => p -> GetUserUrls_result -> P.IO ()
write_GetUserUrls_result oprot record = T.writeVal oprot $ from_GetUserUrls_result record
encode_GetUserUrls_result :: T.StatelessProtocol p => p -> GetUserUrls_result -> LBS.ByteString
encode_GetUserUrls_result oprot record = T.serializeVal oprot $ from_GetUserUrls_result record
to_GetUserUrls_result :: T.ThriftVal -> GetUserUrls_result
to_GetUserUrls_result (T.TStruct fields) = GetUserUrls_result{
  getUserUrls_result_success = P.maybe (getUserUrls_result_success default_GetUserUrls_result) (\(_,_val201) -> (case _val201 of {T.TStruct _val202 -> (to_UserUrls (T.TStruct _val202)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getUserUrls_result_userException = P.maybe (P.Nothing) (\(_,_val201) -> P.Just (case _val201 of {T.TStruct _val203 -> (Errors_Types.to_EDAMUserException (T.TStruct _val203)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  getUserUrls_result_systemException = P.maybe (P.Nothing) (\(_,_val201) -> P.Just (case _val201 of {T.TStruct _val204 -> (Errors_Types.to_EDAMSystemException (T.TStruct _val204)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_GetUserUrls_result _ = P.error "not a struct"
read_GetUserUrls_result :: T.Protocol p => p -> P.IO GetUserUrls_result
read_GetUserUrls_result iprot = to_GetUserUrls_result <$> T.readVal iprot (T.T_STRUCT typemap_GetUserUrls_result)
decode_GetUserUrls_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetUserUrls_result
decode_GetUserUrls_result iprot bs = to_GetUserUrls_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetUserUrls_result) bs
typemap_GetUserUrls_result :: T.TypeMap
typemap_GetUserUrls_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_UserUrls))),(1,("userException",(T.T_STRUCT Errors_Types.typemap_EDAMUserException))),(2,("systemException",(T.T_STRUCT Errors_Types.typemap_EDAMSystemException)))]
default_GetUserUrls_result :: GetUserUrls_result
default_GetUserUrls_result = GetUserUrls_result{
  getUserUrls_result_success = default_UserUrls,
  getUserUrls_result_userException = P.Nothing,
  getUserUrls_result_systemException = P.Nothing}
data InviteToBusiness_args = InviteToBusiness_args  { inviteToBusiness_args_authenticationToken :: LT.Text
  , inviteToBusiness_args_emailAddress :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable InviteToBusiness_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` inviteToBusiness_args_authenticationToken record   `H.hashWithSalt` inviteToBusiness_args_emailAddress record  
instance QC.Arbitrary InviteToBusiness_args where 
  arbitrary = M.liftM InviteToBusiness_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_InviteToBusiness_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_InviteToBusiness_args{inviteToBusiness_args_authenticationToken = inviteToBusiness_args_authenticationToken obj} then P.Nothing else P.Just $ default_InviteToBusiness_args{inviteToBusiness_args_authenticationToken = inviteToBusiness_args_authenticationToken obj}
    , if obj == default_InviteToBusiness_args{inviteToBusiness_args_emailAddress = inviteToBusiness_args_emailAddress obj} then P.Nothing else P.Just $ default_InviteToBusiness_args{inviteToBusiness_args_emailAddress = inviteToBusiness_args_emailAddress obj}
    ]
from_InviteToBusiness_args :: InviteToBusiness_args -> T.ThriftVal
from_InviteToBusiness_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v207 -> P.Just (1, ("authenticationToken",T.TString $ E.encodeUtf8 _v207))) $ inviteToBusiness_args_authenticationToken record
  , (\_v207 -> P.Just (2, ("emailAddress",T.TString $ E.encodeUtf8 _v207))) $ inviteToBusiness_args_emailAddress record
  ]
write_InviteToBusiness_args :: T.Protocol p => p -> InviteToBusiness_args -> P.IO ()
write_InviteToBusiness_args oprot record = T.writeVal oprot $ from_InviteToBusiness_args record
encode_InviteToBusiness_args :: T.StatelessProtocol p => p -> InviteToBusiness_args -> LBS.ByteString
encode_InviteToBusiness_args oprot record = T.serializeVal oprot $ from_InviteToBusiness_args record
to_InviteToBusiness_args :: T.ThriftVal -> InviteToBusiness_args
to_InviteToBusiness_args (T.TStruct fields) = InviteToBusiness_args{
  inviteToBusiness_args_authenticationToken = P.maybe (inviteToBusiness_args_authenticationToken default_InviteToBusiness_args) (\(_,_val209) -> (case _val209 of {T.TString _val210 -> E.decodeUtf8 _val210; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  inviteToBusiness_args_emailAddress = P.maybe (inviteToBusiness_args_emailAddress default_InviteToBusiness_args) (\(_,_val209) -> (case _val209 of {T.TString _val211 -> E.decodeUtf8 _val211; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_InviteToBusiness_args _ = P.error "not a struct"
read_InviteToBusiness_args :: T.Protocol p => p -> P.IO InviteToBusiness_args
read_InviteToBusiness_args iprot = to_InviteToBusiness_args <$> T.readVal iprot (T.T_STRUCT typemap_InviteToBusiness_args)
decode_InviteToBusiness_args :: T.StatelessProtocol p => p -> LBS.ByteString -> InviteToBusiness_args
decode_InviteToBusiness_args iprot bs = to_InviteToBusiness_args $ T.deserializeVal iprot (T.T_STRUCT typemap_InviteToBusiness_args) bs
typemap_InviteToBusiness_args :: T.TypeMap
typemap_InviteToBusiness_args = Map.fromList [(1,("authenticationToken",T.T_STRING)),(2,("emailAddress",T.T_STRING))]
default_InviteToBusiness_args :: InviteToBusiness_args
default_InviteToBusiness_args = InviteToBusiness_args{
  inviteToBusiness_args_authenticationToken = "",
  inviteToBusiness_args_emailAddress = ""}
data InviteToBusiness_result = InviteToBusiness_result  { inviteToBusiness_result_userException :: P.Maybe Errors_Types.EDAMUserException
  , inviteToBusiness_result_systemException :: P.Maybe Errors_Types.EDAMSystemException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable InviteToBusiness_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` inviteToBusiness_result_userException record   `H.hashWithSalt` inviteToBusiness_result_systemException record  
instance QC.Arbitrary InviteToBusiness_result where 
  arbitrary = M.liftM InviteToBusiness_result (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_InviteToBusiness_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_InviteToBusiness_result{inviteToBusiness_result_userException = inviteToBusiness_result_userException obj} then P.Nothing else P.Just $ default_InviteToBusiness_result{inviteToBusiness_result_userException = inviteToBusiness_result_userException obj}
    , if obj == default_InviteToBusiness_result{inviteToBusiness_result_systemException = inviteToBusiness_result_systemException obj} then P.Nothing else P.Just $ default_InviteToBusiness_result{inviteToBusiness_result_systemException = inviteToBusiness_result_systemException obj}
    ]
from_InviteToBusiness_result :: InviteToBusiness_result -> T.ThriftVal
from_InviteToBusiness_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v214 -> (1, ("userException",Errors_Types.from_EDAMUserException _v214))) <$> inviteToBusiness_result_userException record, (\_v214 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v214))) <$> inviteToBusiness_result_systemException record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v214 -> (1, ("userException",Errors_Types.from_EDAMUserException _v214))) <$> inviteToBusiness_result_userException record
    , (\_v214 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v214))) <$> inviteToBusiness_result_systemException record
    ]
    )
write_InviteToBusiness_result :: T.Protocol p => p -> InviteToBusiness_result -> P.IO ()
write_InviteToBusiness_result oprot record = T.writeVal oprot $ from_InviteToBusiness_result record
encode_InviteToBusiness_result :: T.StatelessProtocol p => p -> InviteToBusiness_result -> LBS.ByteString
encode_InviteToBusiness_result oprot record = T.serializeVal oprot $ from_InviteToBusiness_result record
to_InviteToBusiness_result :: T.ThriftVal -> InviteToBusiness_result
to_InviteToBusiness_result (T.TStruct fields) = InviteToBusiness_result{
  inviteToBusiness_result_userException = P.maybe (P.Nothing) (\(_,_val216) -> P.Just (case _val216 of {T.TStruct _val217 -> (Errors_Types.to_EDAMUserException (T.TStruct _val217)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  inviteToBusiness_result_systemException = P.maybe (P.Nothing) (\(_,_val216) -> P.Just (case _val216 of {T.TStruct _val218 -> (Errors_Types.to_EDAMSystemException (T.TStruct _val218)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_InviteToBusiness_result _ = P.error "not a struct"
read_InviteToBusiness_result :: T.Protocol p => p -> P.IO InviteToBusiness_result
read_InviteToBusiness_result iprot = to_InviteToBusiness_result <$> T.readVal iprot (T.T_STRUCT typemap_InviteToBusiness_result)
decode_InviteToBusiness_result :: T.StatelessProtocol p => p -> LBS.ByteString -> InviteToBusiness_result
decode_InviteToBusiness_result iprot bs = to_InviteToBusiness_result $ T.deserializeVal iprot (T.T_STRUCT typemap_InviteToBusiness_result) bs
typemap_InviteToBusiness_result :: T.TypeMap
typemap_InviteToBusiness_result = Map.fromList [(1,("userException",(T.T_STRUCT Errors_Types.typemap_EDAMUserException))),(2,("systemException",(T.T_STRUCT Errors_Types.typemap_EDAMSystemException)))]
default_InviteToBusiness_result :: InviteToBusiness_result
default_InviteToBusiness_result = InviteToBusiness_result{
  inviteToBusiness_result_userException = P.Nothing,
  inviteToBusiness_result_systemException = P.Nothing}
data RemoveFromBusiness_args = RemoveFromBusiness_args  { removeFromBusiness_args_authenticationToken :: LT.Text
  , removeFromBusiness_args_emailAddress :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RemoveFromBusiness_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` removeFromBusiness_args_authenticationToken record   `H.hashWithSalt` removeFromBusiness_args_emailAddress record  
instance QC.Arbitrary RemoveFromBusiness_args where 
  arbitrary = M.liftM RemoveFromBusiness_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_RemoveFromBusiness_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RemoveFromBusiness_args{removeFromBusiness_args_authenticationToken = removeFromBusiness_args_authenticationToken obj} then P.Nothing else P.Just $ default_RemoveFromBusiness_args{removeFromBusiness_args_authenticationToken = removeFromBusiness_args_authenticationToken obj}
    , if obj == default_RemoveFromBusiness_args{removeFromBusiness_args_emailAddress = removeFromBusiness_args_emailAddress obj} then P.Nothing else P.Just $ default_RemoveFromBusiness_args{removeFromBusiness_args_emailAddress = removeFromBusiness_args_emailAddress obj}
    ]
from_RemoveFromBusiness_args :: RemoveFromBusiness_args -> T.ThriftVal
from_RemoveFromBusiness_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v221 -> P.Just (1, ("authenticationToken",T.TString $ E.encodeUtf8 _v221))) $ removeFromBusiness_args_authenticationToken record
  , (\_v221 -> P.Just (2, ("emailAddress",T.TString $ E.encodeUtf8 _v221))) $ removeFromBusiness_args_emailAddress record
  ]
write_RemoveFromBusiness_args :: T.Protocol p => p -> RemoveFromBusiness_args -> P.IO ()
write_RemoveFromBusiness_args oprot record = T.writeVal oprot $ from_RemoveFromBusiness_args record
encode_RemoveFromBusiness_args :: T.StatelessProtocol p => p -> RemoveFromBusiness_args -> LBS.ByteString
encode_RemoveFromBusiness_args oprot record = T.serializeVal oprot $ from_RemoveFromBusiness_args record
to_RemoveFromBusiness_args :: T.ThriftVal -> RemoveFromBusiness_args
to_RemoveFromBusiness_args (T.TStruct fields) = RemoveFromBusiness_args{
  removeFromBusiness_args_authenticationToken = P.maybe (removeFromBusiness_args_authenticationToken default_RemoveFromBusiness_args) (\(_,_val223) -> (case _val223 of {T.TString _val224 -> E.decodeUtf8 _val224; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  removeFromBusiness_args_emailAddress = P.maybe (removeFromBusiness_args_emailAddress default_RemoveFromBusiness_args) (\(_,_val223) -> (case _val223 of {T.TString _val225 -> E.decodeUtf8 _val225; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_RemoveFromBusiness_args _ = P.error "not a struct"
read_RemoveFromBusiness_args :: T.Protocol p => p -> P.IO RemoveFromBusiness_args
read_RemoveFromBusiness_args iprot = to_RemoveFromBusiness_args <$> T.readVal iprot (T.T_STRUCT typemap_RemoveFromBusiness_args)
decode_RemoveFromBusiness_args :: T.StatelessProtocol p => p -> LBS.ByteString -> RemoveFromBusiness_args
decode_RemoveFromBusiness_args iprot bs = to_RemoveFromBusiness_args $ T.deserializeVal iprot (T.T_STRUCT typemap_RemoveFromBusiness_args) bs
typemap_RemoveFromBusiness_args :: T.TypeMap
typemap_RemoveFromBusiness_args = Map.fromList [(1,("authenticationToken",T.T_STRING)),(2,("emailAddress",T.T_STRING))]
default_RemoveFromBusiness_args :: RemoveFromBusiness_args
default_RemoveFromBusiness_args = RemoveFromBusiness_args{
  removeFromBusiness_args_authenticationToken = "",
  removeFromBusiness_args_emailAddress = ""}
data RemoveFromBusiness_result = RemoveFromBusiness_result  { removeFromBusiness_result_userException :: P.Maybe Errors_Types.EDAMUserException
  , removeFromBusiness_result_systemException :: P.Maybe Errors_Types.EDAMSystemException
  , removeFromBusiness_result_notFoundException :: P.Maybe Errors_Types.EDAMNotFoundException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RemoveFromBusiness_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` removeFromBusiness_result_userException record   `H.hashWithSalt` removeFromBusiness_result_systemException record   `H.hashWithSalt` removeFromBusiness_result_notFoundException record  
instance QC.Arbitrary RemoveFromBusiness_result where 
  arbitrary = M.liftM RemoveFromBusiness_result (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_RemoveFromBusiness_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RemoveFromBusiness_result{removeFromBusiness_result_userException = removeFromBusiness_result_userException obj} then P.Nothing else P.Just $ default_RemoveFromBusiness_result{removeFromBusiness_result_userException = removeFromBusiness_result_userException obj}
    , if obj == default_RemoveFromBusiness_result{removeFromBusiness_result_systemException = removeFromBusiness_result_systemException obj} then P.Nothing else P.Just $ default_RemoveFromBusiness_result{removeFromBusiness_result_systemException = removeFromBusiness_result_systemException obj}
    , if obj == default_RemoveFromBusiness_result{removeFromBusiness_result_notFoundException = removeFromBusiness_result_notFoundException obj} then P.Nothing else P.Just $ default_RemoveFromBusiness_result{removeFromBusiness_result_notFoundException = removeFromBusiness_result_notFoundException obj}
    ]
from_RemoveFromBusiness_result :: RemoveFromBusiness_result -> T.ThriftVal
from_RemoveFromBusiness_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v228 -> (1, ("userException",Errors_Types.from_EDAMUserException _v228))) <$> removeFromBusiness_result_userException record, (\_v228 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v228))) <$> removeFromBusiness_result_systemException record, (\_v228 -> (3, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v228))) <$> removeFromBusiness_result_notFoundException record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v228 -> (1, ("userException",Errors_Types.from_EDAMUserException _v228))) <$> removeFromBusiness_result_userException record
    , (\_v228 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v228))) <$> removeFromBusiness_result_systemException record
    , (\_v228 -> (3, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v228))) <$> removeFromBusiness_result_notFoundException record
    ]
    )
write_RemoveFromBusiness_result :: T.Protocol p => p -> RemoveFromBusiness_result -> P.IO ()
write_RemoveFromBusiness_result oprot record = T.writeVal oprot $ from_RemoveFromBusiness_result record
encode_RemoveFromBusiness_result :: T.StatelessProtocol p => p -> RemoveFromBusiness_result -> LBS.ByteString
encode_RemoveFromBusiness_result oprot record = T.serializeVal oprot $ from_RemoveFromBusiness_result record
to_RemoveFromBusiness_result :: T.ThriftVal -> RemoveFromBusiness_result
to_RemoveFromBusiness_result (T.TStruct fields) = RemoveFromBusiness_result{
  removeFromBusiness_result_userException = P.maybe (P.Nothing) (\(_,_val230) -> P.Just (case _val230 of {T.TStruct _val231 -> (Errors_Types.to_EDAMUserException (T.TStruct _val231)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  removeFromBusiness_result_systemException = P.maybe (P.Nothing) (\(_,_val230) -> P.Just (case _val230 of {T.TStruct _val232 -> (Errors_Types.to_EDAMSystemException (T.TStruct _val232)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  removeFromBusiness_result_notFoundException = P.maybe (P.Nothing) (\(_,_val230) -> P.Just (case _val230 of {T.TStruct _val233 -> (Errors_Types.to_EDAMNotFoundException (T.TStruct _val233)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_RemoveFromBusiness_result _ = P.error "not a struct"
read_RemoveFromBusiness_result :: T.Protocol p => p -> P.IO RemoveFromBusiness_result
read_RemoveFromBusiness_result iprot = to_RemoveFromBusiness_result <$> T.readVal iprot (T.T_STRUCT typemap_RemoveFromBusiness_result)
decode_RemoveFromBusiness_result :: T.StatelessProtocol p => p -> LBS.ByteString -> RemoveFromBusiness_result
decode_RemoveFromBusiness_result iprot bs = to_RemoveFromBusiness_result $ T.deserializeVal iprot (T.T_STRUCT typemap_RemoveFromBusiness_result) bs
typemap_RemoveFromBusiness_result :: T.TypeMap
typemap_RemoveFromBusiness_result = Map.fromList [(1,("userException",(T.T_STRUCT Errors_Types.typemap_EDAMUserException))),(2,("systemException",(T.T_STRUCT Errors_Types.typemap_EDAMSystemException))),(3,("notFoundException",(T.T_STRUCT Errors_Types.typemap_EDAMNotFoundException)))]
default_RemoveFromBusiness_result :: RemoveFromBusiness_result
default_RemoveFromBusiness_result = RemoveFromBusiness_result{
  removeFromBusiness_result_userException = P.Nothing,
  removeFromBusiness_result_systemException = P.Nothing,
  removeFromBusiness_result_notFoundException = P.Nothing}
data UpdateBusinessUserIdentifier_args = UpdateBusinessUserIdentifier_args  { updateBusinessUserIdentifier_args_authenticationToken :: LT.Text
  , updateBusinessUserIdentifier_args_oldEmailAddress :: LT.Text
  , updateBusinessUserIdentifier_args_newEmailAddress :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateBusinessUserIdentifier_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateBusinessUserIdentifier_args_authenticationToken record   `H.hashWithSalt` updateBusinessUserIdentifier_args_oldEmailAddress record   `H.hashWithSalt` updateBusinessUserIdentifier_args_newEmailAddress record  
instance QC.Arbitrary UpdateBusinessUserIdentifier_args where 
  arbitrary = M.liftM UpdateBusinessUserIdentifier_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_UpdateBusinessUserIdentifier_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateBusinessUserIdentifier_args{updateBusinessUserIdentifier_args_authenticationToken = updateBusinessUserIdentifier_args_authenticationToken obj} then P.Nothing else P.Just $ default_UpdateBusinessUserIdentifier_args{updateBusinessUserIdentifier_args_authenticationToken = updateBusinessUserIdentifier_args_authenticationToken obj}
    , if obj == default_UpdateBusinessUserIdentifier_args{updateBusinessUserIdentifier_args_oldEmailAddress = updateBusinessUserIdentifier_args_oldEmailAddress obj} then P.Nothing else P.Just $ default_UpdateBusinessUserIdentifier_args{updateBusinessUserIdentifier_args_oldEmailAddress = updateBusinessUserIdentifier_args_oldEmailAddress obj}
    , if obj == default_UpdateBusinessUserIdentifier_args{updateBusinessUserIdentifier_args_newEmailAddress = updateBusinessUserIdentifier_args_newEmailAddress obj} then P.Nothing else P.Just $ default_UpdateBusinessUserIdentifier_args{updateBusinessUserIdentifier_args_newEmailAddress = updateBusinessUserIdentifier_args_newEmailAddress obj}
    ]
from_UpdateBusinessUserIdentifier_args :: UpdateBusinessUserIdentifier_args -> T.ThriftVal
from_UpdateBusinessUserIdentifier_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v236 -> P.Just (1, ("authenticationToken",T.TString $ E.encodeUtf8 _v236))) $ updateBusinessUserIdentifier_args_authenticationToken record
  , (\_v236 -> P.Just (2, ("oldEmailAddress",T.TString $ E.encodeUtf8 _v236))) $ updateBusinessUserIdentifier_args_oldEmailAddress record
  , (\_v236 -> P.Just (3, ("newEmailAddress",T.TString $ E.encodeUtf8 _v236))) $ updateBusinessUserIdentifier_args_newEmailAddress record
  ]
write_UpdateBusinessUserIdentifier_args :: T.Protocol p => p -> UpdateBusinessUserIdentifier_args -> P.IO ()
write_UpdateBusinessUserIdentifier_args oprot record = T.writeVal oprot $ from_UpdateBusinessUserIdentifier_args record
encode_UpdateBusinessUserIdentifier_args :: T.StatelessProtocol p => p -> UpdateBusinessUserIdentifier_args -> LBS.ByteString
encode_UpdateBusinessUserIdentifier_args oprot record = T.serializeVal oprot $ from_UpdateBusinessUserIdentifier_args record
to_UpdateBusinessUserIdentifier_args :: T.ThriftVal -> UpdateBusinessUserIdentifier_args
to_UpdateBusinessUserIdentifier_args (T.TStruct fields) = UpdateBusinessUserIdentifier_args{
  updateBusinessUserIdentifier_args_authenticationToken = P.maybe (updateBusinessUserIdentifier_args_authenticationToken default_UpdateBusinessUserIdentifier_args) (\(_,_val238) -> (case _val238 of {T.TString _val239 -> E.decodeUtf8 _val239; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  updateBusinessUserIdentifier_args_oldEmailAddress = P.maybe (updateBusinessUserIdentifier_args_oldEmailAddress default_UpdateBusinessUserIdentifier_args) (\(_,_val238) -> (case _val238 of {T.TString _val240 -> E.decodeUtf8 _val240; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  updateBusinessUserIdentifier_args_newEmailAddress = P.maybe (updateBusinessUserIdentifier_args_newEmailAddress default_UpdateBusinessUserIdentifier_args) (\(_,_val238) -> (case _val238 of {T.TString _val241 -> E.decodeUtf8 _val241; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_UpdateBusinessUserIdentifier_args _ = P.error "not a struct"
read_UpdateBusinessUserIdentifier_args :: T.Protocol p => p -> P.IO UpdateBusinessUserIdentifier_args
read_UpdateBusinessUserIdentifier_args iprot = to_UpdateBusinessUserIdentifier_args <$> T.readVal iprot (T.T_STRUCT typemap_UpdateBusinessUserIdentifier_args)
decode_UpdateBusinessUserIdentifier_args :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateBusinessUserIdentifier_args
decode_UpdateBusinessUserIdentifier_args iprot bs = to_UpdateBusinessUserIdentifier_args $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateBusinessUserIdentifier_args) bs
typemap_UpdateBusinessUserIdentifier_args :: T.TypeMap
typemap_UpdateBusinessUserIdentifier_args = Map.fromList [(1,("authenticationToken",T.T_STRING)),(2,("oldEmailAddress",T.T_STRING)),(3,("newEmailAddress",T.T_STRING))]
default_UpdateBusinessUserIdentifier_args :: UpdateBusinessUserIdentifier_args
default_UpdateBusinessUserIdentifier_args = UpdateBusinessUserIdentifier_args{
  updateBusinessUserIdentifier_args_authenticationToken = "",
  updateBusinessUserIdentifier_args_oldEmailAddress = "",
  updateBusinessUserIdentifier_args_newEmailAddress = ""}
data UpdateBusinessUserIdentifier_result = UpdateBusinessUserIdentifier_result  { updateBusinessUserIdentifier_result_userException :: P.Maybe Errors_Types.EDAMUserException
  , updateBusinessUserIdentifier_result_systemException :: P.Maybe Errors_Types.EDAMSystemException
  , updateBusinessUserIdentifier_result_notFoundException :: P.Maybe Errors_Types.EDAMNotFoundException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateBusinessUserIdentifier_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateBusinessUserIdentifier_result_userException record   `H.hashWithSalt` updateBusinessUserIdentifier_result_systemException record   `H.hashWithSalt` updateBusinessUserIdentifier_result_notFoundException record  
instance QC.Arbitrary UpdateBusinessUserIdentifier_result where 
  arbitrary = M.liftM UpdateBusinessUserIdentifier_result (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_UpdateBusinessUserIdentifier_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateBusinessUserIdentifier_result{updateBusinessUserIdentifier_result_userException = updateBusinessUserIdentifier_result_userException obj} then P.Nothing else P.Just $ default_UpdateBusinessUserIdentifier_result{updateBusinessUserIdentifier_result_userException = updateBusinessUserIdentifier_result_userException obj}
    , if obj == default_UpdateBusinessUserIdentifier_result{updateBusinessUserIdentifier_result_systemException = updateBusinessUserIdentifier_result_systemException obj} then P.Nothing else P.Just $ default_UpdateBusinessUserIdentifier_result{updateBusinessUserIdentifier_result_systemException = updateBusinessUserIdentifier_result_systemException obj}
    , if obj == default_UpdateBusinessUserIdentifier_result{updateBusinessUserIdentifier_result_notFoundException = updateBusinessUserIdentifier_result_notFoundException obj} then P.Nothing else P.Just $ default_UpdateBusinessUserIdentifier_result{updateBusinessUserIdentifier_result_notFoundException = updateBusinessUserIdentifier_result_notFoundException obj}
    ]
from_UpdateBusinessUserIdentifier_result :: UpdateBusinessUserIdentifier_result -> T.ThriftVal
from_UpdateBusinessUserIdentifier_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v244 -> (1, ("userException",Errors_Types.from_EDAMUserException _v244))) <$> updateBusinessUserIdentifier_result_userException record, (\_v244 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v244))) <$> updateBusinessUserIdentifier_result_systemException record, (\_v244 -> (3, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v244))) <$> updateBusinessUserIdentifier_result_notFoundException record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v244 -> (1, ("userException",Errors_Types.from_EDAMUserException _v244))) <$> updateBusinessUserIdentifier_result_userException record
    , (\_v244 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v244))) <$> updateBusinessUserIdentifier_result_systemException record
    , (\_v244 -> (3, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v244))) <$> updateBusinessUserIdentifier_result_notFoundException record
    ]
    )
write_UpdateBusinessUserIdentifier_result :: T.Protocol p => p -> UpdateBusinessUserIdentifier_result -> P.IO ()
write_UpdateBusinessUserIdentifier_result oprot record = T.writeVal oprot $ from_UpdateBusinessUserIdentifier_result record
encode_UpdateBusinessUserIdentifier_result :: T.StatelessProtocol p => p -> UpdateBusinessUserIdentifier_result -> LBS.ByteString
encode_UpdateBusinessUserIdentifier_result oprot record = T.serializeVal oprot $ from_UpdateBusinessUserIdentifier_result record
to_UpdateBusinessUserIdentifier_result :: T.ThriftVal -> UpdateBusinessUserIdentifier_result
to_UpdateBusinessUserIdentifier_result (T.TStruct fields) = UpdateBusinessUserIdentifier_result{
  updateBusinessUserIdentifier_result_userException = P.maybe (P.Nothing) (\(_,_val246) -> P.Just (case _val246 of {T.TStruct _val247 -> (Errors_Types.to_EDAMUserException (T.TStruct _val247)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  updateBusinessUserIdentifier_result_systemException = P.maybe (P.Nothing) (\(_,_val246) -> P.Just (case _val246 of {T.TStruct _val248 -> (Errors_Types.to_EDAMSystemException (T.TStruct _val248)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  updateBusinessUserIdentifier_result_notFoundException = P.maybe (P.Nothing) (\(_,_val246) -> P.Just (case _val246 of {T.TStruct _val249 -> (Errors_Types.to_EDAMNotFoundException (T.TStruct _val249)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_UpdateBusinessUserIdentifier_result _ = P.error "not a struct"
read_UpdateBusinessUserIdentifier_result :: T.Protocol p => p -> P.IO UpdateBusinessUserIdentifier_result
read_UpdateBusinessUserIdentifier_result iprot = to_UpdateBusinessUserIdentifier_result <$> T.readVal iprot (T.T_STRUCT typemap_UpdateBusinessUserIdentifier_result)
decode_UpdateBusinessUserIdentifier_result :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateBusinessUserIdentifier_result
decode_UpdateBusinessUserIdentifier_result iprot bs = to_UpdateBusinessUserIdentifier_result $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateBusinessUserIdentifier_result) bs
typemap_UpdateBusinessUserIdentifier_result :: T.TypeMap
typemap_UpdateBusinessUserIdentifier_result = Map.fromList [(1,("userException",(T.T_STRUCT Errors_Types.typemap_EDAMUserException))),(2,("systemException",(T.T_STRUCT Errors_Types.typemap_EDAMSystemException))),(3,("notFoundException",(T.T_STRUCT Errors_Types.typemap_EDAMNotFoundException)))]
default_UpdateBusinessUserIdentifier_result :: UpdateBusinessUserIdentifier_result
default_UpdateBusinessUserIdentifier_result = UpdateBusinessUserIdentifier_result{
  updateBusinessUserIdentifier_result_userException = P.Nothing,
  updateBusinessUserIdentifier_result_systemException = P.Nothing,
  updateBusinessUserIdentifier_result_notFoundException = P.Nothing}
data ListBusinessUsers_args = ListBusinessUsers_args  { listBusinessUsers_args_authenticationToken :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ListBusinessUsers_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` listBusinessUsers_args_authenticationToken record  
instance QC.Arbitrary ListBusinessUsers_args where 
  arbitrary = M.liftM ListBusinessUsers_args (QC.arbitrary)
  shrink obj | obj == default_ListBusinessUsers_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ListBusinessUsers_args{listBusinessUsers_args_authenticationToken = listBusinessUsers_args_authenticationToken obj} then P.Nothing else P.Just $ default_ListBusinessUsers_args{listBusinessUsers_args_authenticationToken = listBusinessUsers_args_authenticationToken obj}
    ]
from_ListBusinessUsers_args :: ListBusinessUsers_args -> T.ThriftVal
from_ListBusinessUsers_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v252 -> P.Just (1, ("authenticationToken",T.TString $ E.encodeUtf8 _v252))) $ listBusinessUsers_args_authenticationToken record
  ]
write_ListBusinessUsers_args :: T.Protocol p => p -> ListBusinessUsers_args -> P.IO ()
write_ListBusinessUsers_args oprot record = T.writeVal oprot $ from_ListBusinessUsers_args record
encode_ListBusinessUsers_args :: T.StatelessProtocol p => p -> ListBusinessUsers_args -> LBS.ByteString
encode_ListBusinessUsers_args oprot record = T.serializeVal oprot $ from_ListBusinessUsers_args record
to_ListBusinessUsers_args :: T.ThriftVal -> ListBusinessUsers_args
to_ListBusinessUsers_args (T.TStruct fields) = ListBusinessUsers_args{
  listBusinessUsers_args_authenticationToken = P.maybe (listBusinessUsers_args_authenticationToken default_ListBusinessUsers_args) (\(_,_val254) -> (case _val254 of {T.TString _val255 -> E.decodeUtf8 _val255; _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_ListBusinessUsers_args _ = P.error "not a struct"
read_ListBusinessUsers_args :: T.Protocol p => p -> P.IO ListBusinessUsers_args
read_ListBusinessUsers_args iprot = to_ListBusinessUsers_args <$> T.readVal iprot (T.T_STRUCT typemap_ListBusinessUsers_args)
decode_ListBusinessUsers_args :: T.StatelessProtocol p => p -> LBS.ByteString -> ListBusinessUsers_args
decode_ListBusinessUsers_args iprot bs = to_ListBusinessUsers_args $ T.deserializeVal iprot (T.T_STRUCT typemap_ListBusinessUsers_args) bs
typemap_ListBusinessUsers_args :: T.TypeMap
typemap_ListBusinessUsers_args = Map.fromList [(1,("authenticationToken",T.T_STRING))]
default_ListBusinessUsers_args :: ListBusinessUsers_args
default_ListBusinessUsers_args = ListBusinessUsers_args{
  listBusinessUsers_args_authenticationToken = ""}
data ListBusinessUsers_result = ListBusinessUsers_result  { listBusinessUsers_result_success :: (Vector.Vector Types_Types.UserProfile)
  , listBusinessUsers_result_userException :: P.Maybe Errors_Types.EDAMUserException
  , listBusinessUsers_result_systemException :: P.Maybe Errors_Types.EDAMSystemException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ListBusinessUsers_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` listBusinessUsers_result_success record   `H.hashWithSalt` listBusinessUsers_result_userException record   `H.hashWithSalt` listBusinessUsers_result_systemException record  
instance QC.Arbitrary ListBusinessUsers_result where 
  arbitrary = M.liftM ListBusinessUsers_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_ListBusinessUsers_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ListBusinessUsers_result{listBusinessUsers_result_success = listBusinessUsers_result_success obj} then P.Nothing else P.Just $ default_ListBusinessUsers_result{listBusinessUsers_result_success = listBusinessUsers_result_success obj}
    , if obj == default_ListBusinessUsers_result{listBusinessUsers_result_userException = listBusinessUsers_result_userException obj} then P.Nothing else P.Just $ default_ListBusinessUsers_result{listBusinessUsers_result_userException = listBusinessUsers_result_userException obj}
    , if obj == default_ListBusinessUsers_result{listBusinessUsers_result_systemException = listBusinessUsers_result_systemException obj} then P.Nothing else P.Just $ default_ListBusinessUsers_result{listBusinessUsers_result_systemException = listBusinessUsers_result_systemException obj}
    ]
from_ListBusinessUsers_result :: ListBusinessUsers_result -> T.ThriftVal
from_ListBusinessUsers_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v258 -> (1, ("userException",Errors_Types.from_EDAMUserException _v258))) <$> listBusinessUsers_result_userException record, (\_v258 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v258))) <$> listBusinessUsers_result_systemException record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v258 -> P.Just (0, ("success",T.TList (T.T_STRUCT Types_Types.typemap_UserProfile) $ P.map (\_v260 -> Types_Types.from_UserProfile _v260) $ Vector.toList _v258))) $ listBusinessUsers_result_success record
    , (\_v258 -> (1, ("userException",Errors_Types.from_EDAMUserException _v258))) <$> listBusinessUsers_result_userException record
    , (\_v258 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v258))) <$> listBusinessUsers_result_systemException record
    ]
    )
write_ListBusinessUsers_result :: T.Protocol p => p -> ListBusinessUsers_result -> P.IO ()
write_ListBusinessUsers_result oprot record = T.writeVal oprot $ from_ListBusinessUsers_result record
encode_ListBusinessUsers_result :: T.StatelessProtocol p => p -> ListBusinessUsers_result -> LBS.ByteString
encode_ListBusinessUsers_result oprot record = T.serializeVal oprot $ from_ListBusinessUsers_result record
to_ListBusinessUsers_result :: T.ThriftVal -> ListBusinessUsers_result
to_ListBusinessUsers_result (T.TStruct fields) = ListBusinessUsers_result{
  listBusinessUsers_result_success = P.maybe (listBusinessUsers_result_success default_ListBusinessUsers_result) (\(_,_val262) -> (case _val262 of {T.TList _ _val263 -> (Vector.fromList $ P.map (\_v264 -> (case _v264 of {T.TStruct _val265 -> (Types_Types.to_UserProfile (T.TStruct _val265)); _ -> P.error "wrong type"})) _val263); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  listBusinessUsers_result_userException = P.maybe (P.Nothing) (\(_,_val262) -> P.Just (case _val262 of {T.TStruct _val266 -> (Errors_Types.to_EDAMUserException (T.TStruct _val266)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  listBusinessUsers_result_systemException = P.maybe (P.Nothing) (\(_,_val262) -> P.Just (case _val262 of {T.TStruct _val267 -> (Errors_Types.to_EDAMSystemException (T.TStruct _val267)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_ListBusinessUsers_result _ = P.error "not a struct"
read_ListBusinessUsers_result :: T.Protocol p => p -> P.IO ListBusinessUsers_result
read_ListBusinessUsers_result iprot = to_ListBusinessUsers_result <$> T.readVal iprot (T.T_STRUCT typemap_ListBusinessUsers_result)
decode_ListBusinessUsers_result :: T.StatelessProtocol p => p -> LBS.ByteString -> ListBusinessUsers_result
decode_ListBusinessUsers_result iprot bs = to_ListBusinessUsers_result $ T.deserializeVal iprot (T.T_STRUCT typemap_ListBusinessUsers_result) bs
typemap_ListBusinessUsers_result :: T.TypeMap
typemap_ListBusinessUsers_result = Map.fromList [(0,("success",(T.T_LIST (T.T_STRUCT Types_Types.typemap_UserProfile)))),(1,("userException",(T.T_STRUCT Errors_Types.typemap_EDAMUserException))),(2,("systemException",(T.T_STRUCT Errors_Types.typemap_EDAMSystemException)))]
default_ListBusinessUsers_result :: ListBusinessUsers_result
default_ListBusinessUsers_result = ListBusinessUsers_result{
  listBusinessUsers_result_success = Vector.empty,
  listBusinessUsers_result_userException = P.Nothing,
  listBusinessUsers_result_systemException = P.Nothing}
data ListBusinessInvitations_args = ListBusinessInvitations_args  { listBusinessInvitations_args_authenticationToken :: LT.Text
  , listBusinessInvitations_args_includeRequestedInvitations :: P.Bool
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ListBusinessInvitations_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` listBusinessInvitations_args_authenticationToken record   `H.hashWithSalt` listBusinessInvitations_args_includeRequestedInvitations record  
instance QC.Arbitrary ListBusinessInvitations_args where 
  arbitrary = M.liftM ListBusinessInvitations_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_ListBusinessInvitations_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ListBusinessInvitations_args{listBusinessInvitations_args_authenticationToken = listBusinessInvitations_args_authenticationToken obj} then P.Nothing else P.Just $ default_ListBusinessInvitations_args{listBusinessInvitations_args_authenticationToken = listBusinessInvitations_args_authenticationToken obj}
    , if obj == default_ListBusinessInvitations_args{listBusinessInvitations_args_includeRequestedInvitations = listBusinessInvitations_args_includeRequestedInvitations obj} then P.Nothing else P.Just $ default_ListBusinessInvitations_args{listBusinessInvitations_args_includeRequestedInvitations = listBusinessInvitations_args_includeRequestedInvitations obj}
    ]
from_ListBusinessInvitations_args :: ListBusinessInvitations_args -> T.ThriftVal
from_ListBusinessInvitations_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v270 -> P.Just (1, ("authenticationToken",T.TString $ E.encodeUtf8 _v270))) $ listBusinessInvitations_args_authenticationToken record
  , (\_v270 -> P.Just (2, ("includeRequestedInvitations",T.TBool _v270))) $ listBusinessInvitations_args_includeRequestedInvitations record
  ]
write_ListBusinessInvitations_args :: T.Protocol p => p -> ListBusinessInvitations_args -> P.IO ()
write_ListBusinessInvitations_args oprot record = T.writeVal oprot $ from_ListBusinessInvitations_args record
encode_ListBusinessInvitations_args :: T.StatelessProtocol p => p -> ListBusinessInvitations_args -> LBS.ByteString
encode_ListBusinessInvitations_args oprot record = T.serializeVal oprot $ from_ListBusinessInvitations_args record
to_ListBusinessInvitations_args :: T.ThriftVal -> ListBusinessInvitations_args
to_ListBusinessInvitations_args (T.TStruct fields) = ListBusinessInvitations_args{
  listBusinessInvitations_args_authenticationToken = P.maybe (listBusinessInvitations_args_authenticationToken default_ListBusinessInvitations_args) (\(_,_val272) -> (case _val272 of {T.TString _val273 -> E.decodeUtf8 _val273; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  listBusinessInvitations_args_includeRequestedInvitations = P.maybe (listBusinessInvitations_args_includeRequestedInvitations default_ListBusinessInvitations_args) (\(_,_val272) -> (case _val272 of {T.TBool _val274 -> _val274; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_ListBusinessInvitations_args _ = P.error "not a struct"
read_ListBusinessInvitations_args :: T.Protocol p => p -> P.IO ListBusinessInvitations_args
read_ListBusinessInvitations_args iprot = to_ListBusinessInvitations_args <$> T.readVal iprot (T.T_STRUCT typemap_ListBusinessInvitations_args)
decode_ListBusinessInvitations_args :: T.StatelessProtocol p => p -> LBS.ByteString -> ListBusinessInvitations_args
decode_ListBusinessInvitations_args iprot bs = to_ListBusinessInvitations_args $ T.deserializeVal iprot (T.T_STRUCT typemap_ListBusinessInvitations_args) bs
typemap_ListBusinessInvitations_args :: T.TypeMap
typemap_ListBusinessInvitations_args = Map.fromList [(1,("authenticationToken",T.T_STRING)),(2,("includeRequestedInvitations",T.T_BOOL))]
default_ListBusinessInvitations_args :: ListBusinessInvitations_args
default_ListBusinessInvitations_args = ListBusinessInvitations_args{
  listBusinessInvitations_args_authenticationToken = "",
  listBusinessInvitations_args_includeRequestedInvitations = P.False}
data ListBusinessInvitations_result = ListBusinessInvitations_result  { listBusinessInvitations_result_success :: (Vector.Vector Types_Types.BusinessInvitation)
  , listBusinessInvitations_result_userException :: P.Maybe Errors_Types.EDAMUserException
  , listBusinessInvitations_result_systemException :: P.Maybe Errors_Types.EDAMSystemException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ListBusinessInvitations_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` listBusinessInvitations_result_success record   `H.hashWithSalt` listBusinessInvitations_result_userException record   `H.hashWithSalt` listBusinessInvitations_result_systemException record  
instance QC.Arbitrary ListBusinessInvitations_result where 
  arbitrary = M.liftM ListBusinessInvitations_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_ListBusinessInvitations_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ListBusinessInvitations_result{listBusinessInvitations_result_success = listBusinessInvitations_result_success obj} then P.Nothing else P.Just $ default_ListBusinessInvitations_result{listBusinessInvitations_result_success = listBusinessInvitations_result_success obj}
    , if obj == default_ListBusinessInvitations_result{listBusinessInvitations_result_userException = listBusinessInvitations_result_userException obj} then P.Nothing else P.Just $ default_ListBusinessInvitations_result{listBusinessInvitations_result_userException = listBusinessInvitations_result_userException obj}
    , if obj == default_ListBusinessInvitations_result{listBusinessInvitations_result_systemException = listBusinessInvitations_result_systemException obj} then P.Nothing else P.Just $ default_ListBusinessInvitations_result{listBusinessInvitations_result_systemException = listBusinessInvitations_result_systemException obj}
    ]
from_ListBusinessInvitations_result :: ListBusinessInvitations_result -> T.ThriftVal
from_ListBusinessInvitations_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v277 -> (1, ("userException",Errors_Types.from_EDAMUserException _v277))) <$> listBusinessInvitations_result_userException record, (\_v277 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v277))) <$> listBusinessInvitations_result_systemException record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v277 -> P.Just (0, ("success",T.TList (T.T_STRUCT Types_Types.typemap_BusinessInvitation) $ P.map (\_v279 -> Types_Types.from_BusinessInvitation _v279) $ Vector.toList _v277))) $ listBusinessInvitations_result_success record
    , (\_v277 -> (1, ("userException",Errors_Types.from_EDAMUserException _v277))) <$> listBusinessInvitations_result_userException record
    , (\_v277 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v277))) <$> listBusinessInvitations_result_systemException record
    ]
    )
write_ListBusinessInvitations_result :: T.Protocol p => p -> ListBusinessInvitations_result -> P.IO ()
write_ListBusinessInvitations_result oprot record = T.writeVal oprot $ from_ListBusinessInvitations_result record
encode_ListBusinessInvitations_result :: T.StatelessProtocol p => p -> ListBusinessInvitations_result -> LBS.ByteString
encode_ListBusinessInvitations_result oprot record = T.serializeVal oprot $ from_ListBusinessInvitations_result record
to_ListBusinessInvitations_result :: T.ThriftVal -> ListBusinessInvitations_result
to_ListBusinessInvitations_result (T.TStruct fields) = ListBusinessInvitations_result{
  listBusinessInvitations_result_success = P.maybe (listBusinessInvitations_result_success default_ListBusinessInvitations_result) (\(_,_val281) -> (case _val281 of {T.TList _ _val282 -> (Vector.fromList $ P.map (\_v283 -> (case _v283 of {T.TStruct _val284 -> (Types_Types.to_BusinessInvitation (T.TStruct _val284)); _ -> P.error "wrong type"})) _val282); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  listBusinessInvitations_result_userException = P.maybe (P.Nothing) (\(_,_val281) -> P.Just (case _val281 of {T.TStruct _val285 -> (Errors_Types.to_EDAMUserException (T.TStruct _val285)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  listBusinessInvitations_result_systemException = P.maybe (P.Nothing) (\(_,_val281) -> P.Just (case _val281 of {T.TStruct _val286 -> (Errors_Types.to_EDAMSystemException (T.TStruct _val286)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_ListBusinessInvitations_result _ = P.error "not a struct"
read_ListBusinessInvitations_result :: T.Protocol p => p -> P.IO ListBusinessInvitations_result
read_ListBusinessInvitations_result iprot = to_ListBusinessInvitations_result <$> T.readVal iprot (T.T_STRUCT typemap_ListBusinessInvitations_result)
decode_ListBusinessInvitations_result :: T.StatelessProtocol p => p -> LBS.ByteString -> ListBusinessInvitations_result
decode_ListBusinessInvitations_result iprot bs = to_ListBusinessInvitations_result $ T.deserializeVal iprot (T.T_STRUCT typemap_ListBusinessInvitations_result) bs
typemap_ListBusinessInvitations_result :: T.TypeMap
typemap_ListBusinessInvitations_result = Map.fromList [(0,("success",(T.T_LIST (T.T_STRUCT Types_Types.typemap_BusinessInvitation)))),(1,("userException",(T.T_STRUCT Errors_Types.typemap_EDAMUserException))),(2,("systemException",(T.T_STRUCT Errors_Types.typemap_EDAMSystemException)))]
default_ListBusinessInvitations_result :: ListBusinessInvitations_result
default_ListBusinessInvitations_result = ListBusinessInvitations_result{
  listBusinessInvitations_result_success = Vector.empty,
  listBusinessInvitations_result_userException = P.Nothing,
  listBusinessInvitations_result_systemException = P.Nothing}
data GetAccountLimits_args = GetAccountLimits_args  { getAccountLimits_args_serviceLevel :: Types_Types.ServiceLevel
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetAccountLimits_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getAccountLimits_args_serviceLevel record  
instance QC.Arbitrary GetAccountLimits_args where 
  arbitrary = M.liftM GetAccountLimits_args (QC.arbitrary)
  shrink obj | obj == default_GetAccountLimits_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetAccountLimits_args{getAccountLimits_args_serviceLevel = getAccountLimits_args_serviceLevel obj} then P.Nothing else P.Just $ default_GetAccountLimits_args{getAccountLimits_args_serviceLevel = getAccountLimits_args_serviceLevel obj}
    ]
from_GetAccountLimits_args :: GetAccountLimits_args -> T.ThriftVal
from_GetAccountLimits_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v289 -> P.Just (1, ("serviceLevel",T.TI32 $ P.fromIntegral $ P.fromEnum _v289))) $ getAccountLimits_args_serviceLevel record
  ]
write_GetAccountLimits_args :: T.Protocol p => p -> GetAccountLimits_args -> P.IO ()
write_GetAccountLimits_args oprot record = T.writeVal oprot $ from_GetAccountLimits_args record
encode_GetAccountLimits_args :: T.StatelessProtocol p => p -> GetAccountLimits_args -> LBS.ByteString
encode_GetAccountLimits_args oprot record = T.serializeVal oprot $ from_GetAccountLimits_args record
to_GetAccountLimits_args :: T.ThriftVal -> GetAccountLimits_args
to_GetAccountLimits_args (T.TStruct fields) = GetAccountLimits_args{
  getAccountLimits_args_serviceLevel = P.maybe (getAccountLimits_args_serviceLevel default_GetAccountLimits_args) (\(_,_val291) -> (case _val291 of {T.TI32 _val292 -> P.toEnum $ P.fromIntegral _val292; _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetAccountLimits_args _ = P.error "not a struct"
read_GetAccountLimits_args :: T.Protocol p => p -> P.IO GetAccountLimits_args
read_GetAccountLimits_args iprot = to_GetAccountLimits_args <$> T.readVal iprot (T.T_STRUCT typemap_GetAccountLimits_args)
decode_GetAccountLimits_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetAccountLimits_args
decode_GetAccountLimits_args iprot bs = to_GetAccountLimits_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetAccountLimits_args) bs
typemap_GetAccountLimits_args :: T.TypeMap
typemap_GetAccountLimits_args = Map.fromList [(1,("serviceLevel",T.T_I32))]
default_GetAccountLimits_args :: GetAccountLimits_args
default_GetAccountLimits_args = GetAccountLimits_args{
  getAccountLimits_args_serviceLevel = (P.toEnum 0)}
data GetAccountLimits_result = GetAccountLimits_result  { getAccountLimits_result_success :: Types_Types.AccountLimits
  , getAccountLimits_result_userException :: P.Maybe Errors_Types.EDAMUserException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetAccountLimits_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getAccountLimits_result_success record   `H.hashWithSalt` getAccountLimits_result_userException record  
instance QC.Arbitrary GetAccountLimits_result where 
  arbitrary = M.liftM GetAccountLimits_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetAccountLimits_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetAccountLimits_result{getAccountLimits_result_success = getAccountLimits_result_success obj} then P.Nothing else P.Just $ default_GetAccountLimits_result{getAccountLimits_result_success = getAccountLimits_result_success obj}
    , if obj == default_GetAccountLimits_result{getAccountLimits_result_userException = getAccountLimits_result_userException obj} then P.Nothing else P.Just $ default_GetAccountLimits_result{getAccountLimits_result_userException = getAccountLimits_result_userException obj}
    ]
from_GetAccountLimits_result :: GetAccountLimits_result -> T.ThriftVal
from_GetAccountLimits_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v295 -> (1, ("userException",Errors_Types.from_EDAMUserException _v295))) <$> getAccountLimits_result_userException record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v295 -> P.Just (0, ("success",Types_Types.from_AccountLimits _v295))) $ getAccountLimits_result_success record
    , (\_v295 -> (1, ("userException",Errors_Types.from_EDAMUserException _v295))) <$> getAccountLimits_result_userException record
    ]
    )
write_GetAccountLimits_result :: T.Protocol p => p -> GetAccountLimits_result -> P.IO ()
write_GetAccountLimits_result oprot record = T.writeVal oprot $ from_GetAccountLimits_result record
encode_GetAccountLimits_result :: T.StatelessProtocol p => p -> GetAccountLimits_result -> LBS.ByteString
encode_GetAccountLimits_result oprot record = T.serializeVal oprot $ from_GetAccountLimits_result record
to_GetAccountLimits_result :: T.ThriftVal -> GetAccountLimits_result
to_GetAccountLimits_result (T.TStruct fields) = GetAccountLimits_result{
  getAccountLimits_result_success = P.maybe (getAccountLimits_result_success default_GetAccountLimits_result) (\(_,_val297) -> (case _val297 of {T.TStruct _val298 -> (Types_Types.to_AccountLimits (T.TStruct _val298)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getAccountLimits_result_userException = P.maybe (P.Nothing) (\(_,_val297) -> P.Just (case _val297 of {T.TStruct _val299 -> (Errors_Types.to_EDAMUserException (T.TStruct _val299)); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetAccountLimits_result _ = P.error "not a struct"
read_GetAccountLimits_result :: T.Protocol p => p -> P.IO GetAccountLimits_result
read_GetAccountLimits_result iprot = to_GetAccountLimits_result <$> T.readVal iprot (T.T_STRUCT typemap_GetAccountLimits_result)
decode_GetAccountLimits_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetAccountLimits_result
decode_GetAccountLimits_result iprot bs = to_GetAccountLimits_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetAccountLimits_result) bs
typemap_GetAccountLimits_result :: T.TypeMap
typemap_GetAccountLimits_result = Map.fromList [(0,("success",(T.T_STRUCT Types_Types.typemap_AccountLimits))),(1,("userException",(T.T_STRUCT Errors_Types.typemap_EDAMUserException)))]
default_GetAccountLimits_result :: GetAccountLimits_result
default_GetAccountLimits_result = GetAccountLimits_result{
  getAccountLimits_result_success = Types_Types.default_AccountLimits,
  getAccountLimits_result_userException = P.Nothing}
process_checkVersion (seqid, iprot, oprot, handler) = do
  args <- read_CheckVersion_args iprot
  (X.catch
    (do
      val <- Iface.checkVersion handler (checkVersion_args_clientName args) (checkVersion_args_edamVersionMajor args) (checkVersion_args_edamVersionMinor args)
      let res = default_CheckVersion_result{checkVersion_result_success = val}
      T.writeMessage oprot ("checkVersion", T.M_REPLY, seqid) $
        write_CheckVersion_result oprot res)
    ((\_ -> do
      T.writeMessage oprot ("checkVersion", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getBootstrapInfo (seqid, iprot, oprot, handler) = do
  args <- read_GetBootstrapInfo_args iprot
  (X.catch
    (do
      val <- Iface.getBootstrapInfo handler (getBootstrapInfo_args_locale args)
      let res = default_GetBootstrapInfo_result{getBootstrapInfo_result_success = val}
      T.writeMessage oprot ("getBootstrapInfo", T.M_REPLY, seqid) $
        write_GetBootstrapInfo_result oprot res)
    ((\_ -> do
      T.writeMessage oprot ("getBootstrapInfo", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_authenticateLongSession (seqid, iprot, oprot, handler) = do
  args <- read_AuthenticateLongSession_args iprot
  (X.catch
    (X.catch
      (X.catch
        (do
          val <- Iface.authenticateLongSession handler (authenticateLongSession_args_username args) (authenticateLongSession_args_password args) (authenticateLongSession_args_consumerKey args) (authenticateLongSession_args_consumerSecret args) (authenticateLongSession_args_deviceIdentifier args) (authenticateLongSession_args_deviceDescription args) (authenticateLongSession_args_supportsTwoFactor args)
          let res = default_AuthenticateLongSession_result{authenticateLongSession_result_success = val}
          T.writeMessage oprot ("authenticateLongSession", T.M_REPLY, seqid) $
            write_AuthenticateLongSession_result oprot res)
        (\e  -> do
          let res = default_AuthenticateLongSession_result{authenticateLongSession_result_userException = P.Just e}
          T.writeMessage oprot ("authenticateLongSession", T.M_REPLY, seqid) $
            write_AuthenticateLongSession_result oprot res))
      (\e  -> do
        let res = default_AuthenticateLongSession_result{authenticateLongSession_result_systemException = P.Just e}
        T.writeMessage oprot ("authenticateLongSession", T.M_REPLY, seqid) $
          write_AuthenticateLongSession_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("authenticateLongSession", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_completeTwoFactorAuthentication (seqid, iprot, oprot, handler) = do
  args <- read_CompleteTwoFactorAuthentication_args iprot
  (X.catch
    (X.catch
      (X.catch
        (do
          val <- Iface.completeTwoFactorAuthentication handler (completeTwoFactorAuthentication_args_authenticationToken args) (completeTwoFactorAuthentication_args_oneTimeCode args) (completeTwoFactorAuthentication_args_deviceIdentifier args) (completeTwoFactorAuthentication_args_deviceDescription args)
          let res = default_CompleteTwoFactorAuthentication_result{completeTwoFactorAuthentication_result_success = val}
          T.writeMessage oprot ("completeTwoFactorAuthentication", T.M_REPLY, seqid) $
            write_CompleteTwoFactorAuthentication_result oprot res)
        (\e  -> do
          let res = default_CompleteTwoFactorAuthentication_result{completeTwoFactorAuthentication_result_userException = P.Just e}
          T.writeMessage oprot ("completeTwoFactorAuthentication", T.M_REPLY, seqid) $
            write_CompleteTwoFactorAuthentication_result oprot res))
      (\e  -> do
        let res = default_CompleteTwoFactorAuthentication_result{completeTwoFactorAuthentication_result_systemException = P.Just e}
        T.writeMessage oprot ("completeTwoFactorAuthentication", T.M_REPLY, seqid) $
          write_CompleteTwoFactorAuthentication_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("completeTwoFactorAuthentication", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_revokeLongSession (seqid, iprot, oprot, handler) = do
  args <- read_RevokeLongSession_args iprot
  (X.catch
    (X.catch
      (X.catch
        (do
          Iface.revokeLongSession handler (revokeLongSession_args_authenticationToken args)
          let res = default_RevokeLongSession_result
          T.writeMessage oprot ("revokeLongSession", T.M_REPLY, seqid) $
            write_RevokeLongSession_result oprot res)
        (\e  -> do
          let res = default_RevokeLongSession_result{revokeLongSession_result_userException = P.Just e}
          T.writeMessage oprot ("revokeLongSession", T.M_REPLY, seqid) $
            write_RevokeLongSession_result oprot res))
      (\e  -> do
        let res = default_RevokeLongSession_result{revokeLongSession_result_systemException = P.Just e}
        T.writeMessage oprot ("revokeLongSession", T.M_REPLY, seqid) $
          write_RevokeLongSession_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("revokeLongSession", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_authenticateToBusiness (seqid, iprot, oprot, handler) = do
  args <- read_AuthenticateToBusiness_args iprot
  (X.catch
    (X.catch
      (X.catch
        (do
          val <- Iface.authenticateToBusiness handler (authenticateToBusiness_args_authenticationToken args)
          let res = default_AuthenticateToBusiness_result{authenticateToBusiness_result_success = val}
          T.writeMessage oprot ("authenticateToBusiness", T.M_REPLY, seqid) $
            write_AuthenticateToBusiness_result oprot res)
        (\e  -> do
          let res = default_AuthenticateToBusiness_result{authenticateToBusiness_result_userException = P.Just e}
          T.writeMessage oprot ("authenticateToBusiness", T.M_REPLY, seqid) $
            write_AuthenticateToBusiness_result oprot res))
      (\e  -> do
        let res = default_AuthenticateToBusiness_result{authenticateToBusiness_result_systemException = P.Just e}
        T.writeMessage oprot ("authenticateToBusiness", T.M_REPLY, seqid) $
          write_AuthenticateToBusiness_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("authenticateToBusiness", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getUser (seqid, iprot, oprot, handler) = do
  args <- read_GetUser_args iprot
  (X.catch
    (X.catch
      (X.catch
        (do
          val <- Iface.getUser handler (getUser_args_authenticationToken args)
          let res = default_GetUser_result{getUser_result_success = val}
          T.writeMessage oprot ("getUser", T.M_REPLY, seqid) $
            write_GetUser_result oprot res)
        (\e  -> do
          let res = default_GetUser_result{getUser_result_userException = P.Just e}
          T.writeMessage oprot ("getUser", T.M_REPLY, seqid) $
            write_GetUser_result oprot res))
      (\e  -> do
        let res = default_GetUser_result{getUser_result_systemException = P.Just e}
        T.writeMessage oprot ("getUser", T.M_REPLY, seqid) $
          write_GetUser_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getUser", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getPublicUserInfo (seqid, iprot, oprot, handler) = do
  args <- read_GetPublicUserInfo_args iprot
  (X.catch
    (X.catch
      (X.catch
        (X.catch
          (do
            val <- Iface.getPublicUserInfo handler (getPublicUserInfo_args_username args)
            let res = default_GetPublicUserInfo_result{getPublicUserInfo_result_success = val}
            T.writeMessage oprot ("getPublicUserInfo", T.M_REPLY, seqid) $
              write_GetPublicUserInfo_result oprot res)
          (\e  -> do
            let res = default_GetPublicUserInfo_result{getPublicUserInfo_result_notFoundException = P.Just e}
            T.writeMessage oprot ("getPublicUserInfo", T.M_REPLY, seqid) $
              write_GetPublicUserInfo_result oprot res))
        (\e  -> do
          let res = default_GetPublicUserInfo_result{getPublicUserInfo_result_systemException = P.Just e}
          T.writeMessage oprot ("getPublicUserInfo", T.M_REPLY, seqid) $
            write_GetPublicUserInfo_result oprot res))
      (\e  -> do
        let res = default_GetPublicUserInfo_result{getPublicUserInfo_result_userException = P.Just e}
        T.writeMessage oprot ("getPublicUserInfo", T.M_REPLY, seqid) $
          write_GetPublicUserInfo_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getPublicUserInfo", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getUserUrls (seqid, iprot, oprot, handler) = do
  args <- read_GetUserUrls_args iprot
  (X.catch
    (X.catch
      (X.catch
        (do
          val <- Iface.getUserUrls handler (getUserUrls_args_authenticationToken args)
          let res = default_GetUserUrls_result{getUserUrls_result_success = val}
          T.writeMessage oprot ("getUserUrls", T.M_REPLY, seqid) $
            write_GetUserUrls_result oprot res)
        (\e  -> do
          let res = default_GetUserUrls_result{getUserUrls_result_userException = P.Just e}
          T.writeMessage oprot ("getUserUrls", T.M_REPLY, seqid) $
            write_GetUserUrls_result oprot res))
      (\e  -> do
        let res = default_GetUserUrls_result{getUserUrls_result_systemException = P.Just e}
        T.writeMessage oprot ("getUserUrls", T.M_REPLY, seqid) $
          write_GetUserUrls_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getUserUrls", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_inviteToBusiness (seqid, iprot, oprot, handler) = do
  args <- read_InviteToBusiness_args iprot
  (X.catch
    (X.catch
      (X.catch
        (do
          Iface.inviteToBusiness handler (inviteToBusiness_args_authenticationToken args) (inviteToBusiness_args_emailAddress args)
          let res = default_InviteToBusiness_result
          T.writeMessage oprot ("inviteToBusiness", T.M_REPLY, seqid) $
            write_InviteToBusiness_result oprot res)
        (\e  -> do
          let res = default_InviteToBusiness_result{inviteToBusiness_result_userException = P.Just e}
          T.writeMessage oprot ("inviteToBusiness", T.M_REPLY, seqid) $
            write_InviteToBusiness_result oprot res))
      (\e  -> do
        let res = default_InviteToBusiness_result{inviteToBusiness_result_systemException = P.Just e}
        T.writeMessage oprot ("inviteToBusiness", T.M_REPLY, seqid) $
          write_InviteToBusiness_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("inviteToBusiness", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_removeFromBusiness (seqid, iprot, oprot, handler) = do
  args <- read_RemoveFromBusiness_args iprot
  (X.catch
    (X.catch
      (X.catch
        (X.catch
          (do
            Iface.removeFromBusiness handler (removeFromBusiness_args_authenticationToken args) (removeFromBusiness_args_emailAddress args)
            let res = default_RemoveFromBusiness_result
            T.writeMessage oprot ("removeFromBusiness", T.M_REPLY, seqid) $
              write_RemoveFromBusiness_result oprot res)
          (\e  -> do
            let res = default_RemoveFromBusiness_result{removeFromBusiness_result_userException = P.Just e}
            T.writeMessage oprot ("removeFromBusiness", T.M_REPLY, seqid) $
              write_RemoveFromBusiness_result oprot res))
        (\e  -> do
          let res = default_RemoveFromBusiness_result{removeFromBusiness_result_systemException = P.Just e}
          T.writeMessage oprot ("removeFromBusiness", T.M_REPLY, seqid) $
            write_RemoveFromBusiness_result oprot res))
      (\e  -> do
        let res = default_RemoveFromBusiness_result{removeFromBusiness_result_notFoundException = P.Just e}
        T.writeMessage oprot ("removeFromBusiness", T.M_REPLY, seqid) $
          write_RemoveFromBusiness_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("removeFromBusiness", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_updateBusinessUserIdentifier (seqid, iprot, oprot, handler) = do
  args <- read_UpdateBusinessUserIdentifier_args iprot
  (X.catch
    (X.catch
      (X.catch
        (X.catch
          (do
            Iface.updateBusinessUserIdentifier handler (updateBusinessUserIdentifier_args_authenticationToken args) (updateBusinessUserIdentifier_args_oldEmailAddress args) (updateBusinessUserIdentifier_args_newEmailAddress args)
            let res = default_UpdateBusinessUserIdentifier_result
            T.writeMessage oprot ("updateBusinessUserIdentifier", T.M_REPLY, seqid) $
              write_UpdateBusinessUserIdentifier_result oprot res)
          (\e  -> do
            let res = default_UpdateBusinessUserIdentifier_result{updateBusinessUserIdentifier_result_userException = P.Just e}
            T.writeMessage oprot ("updateBusinessUserIdentifier", T.M_REPLY, seqid) $
              write_UpdateBusinessUserIdentifier_result oprot res))
        (\e  -> do
          let res = default_UpdateBusinessUserIdentifier_result{updateBusinessUserIdentifier_result_systemException = P.Just e}
          T.writeMessage oprot ("updateBusinessUserIdentifier", T.M_REPLY, seqid) $
            write_UpdateBusinessUserIdentifier_result oprot res))
      (\e  -> do
        let res = default_UpdateBusinessUserIdentifier_result{updateBusinessUserIdentifier_result_notFoundException = P.Just e}
        T.writeMessage oprot ("updateBusinessUserIdentifier", T.M_REPLY, seqid) $
          write_UpdateBusinessUserIdentifier_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("updateBusinessUserIdentifier", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_listBusinessUsers (seqid, iprot, oprot, handler) = do
  args <- read_ListBusinessUsers_args iprot
  (X.catch
    (X.catch
      (X.catch
        (do
          val <- Iface.listBusinessUsers handler (listBusinessUsers_args_authenticationToken args)
          let res = default_ListBusinessUsers_result{listBusinessUsers_result_success = val}
          T.writeMessage oprot ("listBusinessUsers", T.M_REPLY, seqid) $
            write_ListBusinessUsers_result oprot res)
        (\e  -> do
          let res = default_ListBusinessUsers_result{listBusinessUsers_result_userException = P.Just e}
          T.writeMessage oprot ("listBusinessUsers", T.M_REPLY, seqid) $
            write_ListBusinessUsers_result oprot res))
      (\e  -> do
        let res = default_ListBusinessUsers_result{listBusinessUsers_result_systemException = P.Just e}
        T.writeMessage oprot ("listBusinessUsers", T.M_REPLY, seqid) $
          write_ListBusinessUsers_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("listBusinessUsers", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_listBusinessInvitations (seqid, iprot, oprot, handler) = do
  args <- read_ListBusinessInvitations_args iprot
  (X.catch
    (X.catch
      (X.catch
        (do
          val <- Iface.listBusinessInvitations handler (listBusinessInvitations_args_authenticationToken args) (listBusinessInvitations_args_includeRequestedInvitations args)
          let res = default_ListBusinessInvitations_result{listBusinessInvitations_result_success = val}
          T.writeMessage oprot ("listBusinessInvitations", T.M_REPLY, seqid) $
            write_ListBusinessInvitations_result oprot res)
        (\e  -> do
          let res = default_ListBusinessInvitations_result{listBusinessInvitations_result_userException = P.Just e}
          T.writeMessage oprot ("listBusinessInvitations", T.M_REPLY, seqid) $
            write_ListBusinessInvitations_result oprot res))
      (\e  -> do
        let res = default_ListBusinessInvitations_result{listBusinessInvitations_result_systemException = P.Just e}
        T.writeMessage oprot ("listBusinessInvitations", T.M_REPLY, seqid) $
          write_ListBusinessInvitations_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("listBusinessInvitations", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getAccountLimits (seqid, iprot, oprot, handler) = do
  args <- read_GetAccountLimits_args iprot
  (X.catch
    (X.catch
      (do
        val <- Iface.getAccountLimits handler (getAccountLimits_args_serviceLevel args)
        let res = default_GetAccountLimits_result{getAccountLimits_result_success = val}
        T.writeMessage oprot ("getAccountLimits", T.M_REPLY, seqid) $
          write_GetAccountLimits_result oprot res)
      (\e  -> do
        let res = default_GetAccountLimits_result{getAccountLimits_result_userException = P.Just e}
        T.writeMessage oprot ("getAccountLimits", T.M_REPLY, seqid) $
          write_GetAccountLimits_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getAccountLimits", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
proc_ handler (iprot,oprot) (name,typ,seqid) = case name of
  "checkVersion" -> process_checkVersion (seqid,iprot,oprot,handler)
  "getBootstrapInfo" -> process_getBootstrapInfo (seqid,iprot,oprot,handler)
  "authenticateLongSession" -> process_authenticateLongSession (seqid,iprot,oprot,handler)
  "completeTwoFactorAuthentication" -> process_completeTwoFactorAuthentication (seqid,iprot,oprot,handler)
  "revokeLongSession" -> process_revokeLongSession (seqid,iprot,oprot,handler)
  "authenticateToBusiness" -> process_authenticateToBusiness (seqid,iprot,oprot,handler)
  "getUser" -> process_getUser (seqid,iprot,oprot,handler)
  "getPublicUserInfo" -> process_getPublicUserInfo (seqid,iprot,oprot,handler)
  "getUserUrls" -> process_getUserUrls (seqid,iprot,oprot,handler)
  "inviteToBusiness" -> process_inviteToBusiness (seqid,iprot,oprot,handler)
  "removeFromBusiness" -> process_removeFromBusiness (seqid,iprot,oprot,handler)
  "updateBusinessUserIdentifier" -> process_updateBusinessUserIdentifier (seqid,iprot,oprot,handler)
  "listBusinessUsers" -> process_listBusinessUsers (seqid,iprot,oprot,handler)
  "listBusinessInvitations" -> process_listBusinessInvitations (seqid,iprot,oprot,handler)
  "getAccountLimits" -> process_getAccountLimits (seqid,iprot,oprot,handler)
  _ -> do
    _ <- T.readVal iprot (T.T_STRUCT Map.empty)
    T.writeMessage oprot (name,T.M_EXCEPTION,seqid) $
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN_METHOD ("Unknown function " ++ LT.unpack name))
process handler (iprot, oprot) = do
  T.readMessage iprot (
    proc_ handler (iprot,oprot))
  P.return P.True
