{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-missing-fields #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-----------------------------------------------------------------
-- Autogenerated by Thrift Compiler (0.11.0)                      --
--                                                             --
-- DO NOT EDIT UNLESS YOU ARE SURE YOU KNOW WHAT YOU ARE DOING --
-----------------------------------------------------------------

module UserStore_Client(checkVersion,getBootstrapInfo,authenticateLongSession,completeTwoFactorAuthentication,revokeLongSession,authenticateToBusiness,getUser,getPublicUserInfo,getUserUrls,inviteToBusiness,removeFromBusiness,updateBusinessUserIdentifier,listBusinessUsers,listBusinessInvitations,getAccountLimits) where
import qualified Data.IORef as R
import Prelude (($), (.), (>>=), (==), (++))
import qualified Prelude as P
import qualified Control.Exception as X
import qualified Control.Monad as M ( liftM, ap, when )
import Data.Functor ( (<$>) )
import qualified Data.ByteString.Lazy as LBS
import qualified Data.Hashable as H
import qualified Data.Int as I
import qualified Data.Maybe as M (catMaybes)
import qualified Data.Text.Lazy.Encoding as E ( decodeUtf8, encodeUtf8 )
import qualified Data.Text.Lazy as LT
import qualified GHC.Generics as G (Generic)
import qualified Data.Typeable as TY ( Typeable )
import qualified Data.HashMap.Strict as Map
import qualified Data.HashSet as Set
import qualified Data.Vector as Vector
import qualified Test.QuickCheck.Arbitrary as QC ( Arbitrary(..) )
import qualified Test.QuickCheck as QC ( elements )

import qualified Thrift as T
import qualified Thrift.Types as T
import qualified Thrift.Arbitraries as T

import qualified Types_Types
import qualified Errors_Types


import UserStore_Types
import UserStore
seqid = R.newIORef 0
checkVersion (ip,op) arg_clientName arg_edamVersionMajor arg_edamVersionMinor = do
  send_checkVersion op arg_clientName arg_edamVersionMajor arg_edamVersionMinor
  recv_checkVersion ip
send_checkVersion op arg_clientName arg_edamVersionMajor arg_edamVersionMinor = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessage op ("checkVersion", T.M_CALL, seqn) $
    write_CheckVersion_args op (CheckVersion_args{checkVersion_args_clientName=arg_clientName,checkVersion_args_edamVersionMajor=arg_edamVersionMajor,checkVersion_args_edamVersionMinor=arg_edamVersionMinor})
recv_checkVersion ip = do
  T.readMessage ip $ \(fname, mtype, rseqid) -> do
    M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; X.throw exn }
    res <- read_CheckVersion_result ip
    P.return $ checkVersion_result_success res
getBootstrapInfo (ip,op) arg_locale = do
  send_getBootstrapInfo op arg_locale
  recv_getBootstrapInfo ip
send_getBootstrapInfo op arg_locale = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessage op ("getBootstrapInfo", T.M_CALL, seqn) $
    write_GetBootstrapInfo_args op (GetBootstrapInfo_args{getBootstrapInfo_args_locale=arg_locale})
recv_getBootstrapInfo ip = do
  T.readMessage ip $ \(fname, mtype, rseqid) -> do
    M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; X.throw exn }
    res <- read_GetBootstrapInfo_result ip
    P.return $ getBootstrapInfo_result_success res
authenticateLongSession (ip,op) arg_username arg_password arg_consumerKey arg_consumerSecret arg_deviceIdentifier arg_deviceDescription arg_supportsTwoFactor = do
  send_authenticateLongSession op arg_username arg_password arg_consumerKey arg_consumerSecret arg_deviceIdentifier arg_deviceDescription arg_supportsTwoFactor
  recv_authenticateLongSession ip
send_authenticateLongSession op arg_username arg_password arg_consumerKey arg_consumerSecret arg_deviceIdentifier arg_deviceDescription arg_supportsTwoFactor = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessage op ("authenticateLongSession", T.M_CALL, seqn) $
    write_AuthenticateLongSession_args op (AuthenticateLongSession_args{authenticateLongSession_args_username=arg_username,authenticateLongSession_args_password=arg_password,authenticateLongSession_args_consumerKey=arg_consumerKey,authenticateLongSession_args_consumerSecret=arg_consumerSecret,authenticateLongSession_args_deviceIdentifier=arg_deviceIdentifier,authenticateLongSession_args_deviceDescription=arg_deviceDescription,authenticateLongSession_args_supportsTwoFactor=arg_supportsTwoFactor})
recv_authenticateLongSession ip = do
  T.readMessage ip $ \(fname, mtype, rseqid) -> do
    M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; X.throw exn }
    res <- read_AuthenticateLongSession_result ip
    P.maybe (P.return ()) X.throw (authenticateLongSession_result_userException res)
    P.maybe (P.return ()) X.throw (authenticateLongSession_result_systemException res)
    P.return $ authenticateLongSession_result_success res
completeTwoFactorAuthentication (ip,op) arg_authenticationToken arg_oneTimeCode arg_deviceIdentifier arg_deviceDescription = do
  send_completeTwoFactorAuthentication op arg_authenticationToken arg_oneTimeCode arg_deviceIdentifier arg_deviceDescription
  recv_completeTwoFactorAuthentication ip
send_completeTwoFactorAuthentication op arg_authenticationToken arg_oneTimeCode arg_deviceIdentifier arg_deviceDescription = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessage op ("completeTwoFactorAuthentication", T.M_CALL, seqn) $
    write_CompleteTwoFactorAuthentication_args op (CompleteTwoFactorAuthentication_args{completeTwoFactorAuthentication_args_authenticationToken=arg_authenticationToken,completeTwoFactorAuthentication_args_oneTimeCode=arg_oneTimeCode,completeTwoFactorAuthentication_args_deviceIdentifier=arg_deviceIdentifier,completeTwoFactorAuthentication_args_deviceDescription=arg_deviceDescription})
recv_completeTwoFactorAuthentication ip = do
  T.readMessage ip $ \(fname, mtype, rseqid) -> do
    M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; X.throw exn }
    res <- read_CompleteTwoFactorAuthentication_result ip
    P.maybe (P.return ()) X.throw (completeTwoFactorAuthentication_result_userException res)
    P.maybe (P.return ()) X.throw (completeTwoFactorAuthentication_result_systemException res)
    P.return $ completeTwoFactorAuthentication_result_success res
revokeLongSession (ip,op) arg_authenticationToken = do
  send_revokeLongSession op arg_authenticationToken
  recv_revokeLongSession ip
send_revokeLongSession op arg_authenticationToken = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessage op ("revokeLongSession", T.M_CALL, seqn) $
    write_RevokeLongSession_args op (RevokeLongSession_args{revokeLongSession_args_authenticationToken=arg_authenticationToken})
recv_revokeLongSession ip = do
  T.readMessage ip $ \(fname, mtype, rseqid) -> do
    M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; X.throw exn }
    res <- read_RevokeLongSession_result ip
    P.maybe (P.return ()) X.throw (revokeLongSession_result_userException res)
    P.maybe (P.return ()) X.throw (revokeLongSession_result_systemException res)
    P.return ()
authenticateToBusiness (ip,op) arg_authenticationToken = do
  send_authenticateToBusiness op arg_authenticationToken
  recv_authenticateToBusiness ip
send_authenticateToBusiness op arg_authenticationToken = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessage op ("authenticateToBusiness", T.M_CALL, seqn) $
    write_AuthenticateToBusiness_args op (AuthenticateToBusiness_args{authenticateToBusiness_args_authenticationToken=arg_authenticationToken})
recv_authenticateToBusiness ip = do
  T.readMessage ip $ \(fname, mtype, rseqid) -> do
    M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; X.throw exn }
    res <- read_AuthenticateToBusiness_result ip
    P.maybe (P.return ()) X.throw (authenticateToBusiness_result_userException res)
    P.maybe (P.return ()) X.throw (authenticateToBusiness_result_systemException res)
    P.return $ authenticateToBusiness_result_success res
getUser (ip,op) arg_authenticationToken = do
  send_getUser op arg_authenticationToken
  recv_getUser ip
send_getUser op arg_authenticationToken = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessage op ("getUser", T.M_CALL, seqn) $
    write_GetUser_args op (GetUser_args{getUser_args_authenticationToken=arg_authenticationToken})
recv_getUser ip = do
  T.readMessage ip $ \(fname, mtype, rseqid) -> do
    M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; X.throw exn }
    res <- read_GetUser_result ip
    P.maybe (P.return ()) X.throw (getUser_result_userException res)
    P.maybe (P.return ()) X.throw (getUser_result_systemException res)
    P.return $ getUser_result_success res
getPublicUserInfo (ip,op) arg_username = do
  send_getPublicUserInfo op arg_username
  recv_getPublicUserInfo ip
send_getPublicUserInfo op arg_username = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessage op ("getPublicUserInfo", T.M_CALL, seqn) $
    write_GetPublicUserInfo_args op (GetPublicUserInfo_args{getPublicUserInfo_args_username=arg_username})
recv_getPublicUserInfo ip = do
  T.readMessage ip $ \(fname, mtype, rseqid) -> do
    M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; X.throw exn }
    res <- read_GetPublicUserInfo_result ip
    P.maybe (P.return ()) X.throw (getPublicUserInfo_result_notFoundException res)
    P.maybe (P.return ()) X.throw (getPublicUserInfo_result_systemException res)
    P.maybe (P.return ()) X.throw (getPublicUserInfo_result_userException res)
    P.return $ getPublicUserInfo_result_success res
getUserUrls (ip,op) arg_authenticationToken = do
  send_getUserUrls op arg_authenticationToken
  recv_getUserUrls ip
send_getUserUrls op arg_authenticationToken = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessage op ("getUserUrls", T.M_CALL, seqn) $
    write_GetUserUrls_args op (GetUserUrls_args{getUserUrls_args_authenticationToken=arg_authenticationToken})
recv_getUserUrls ip = do
  T.readMessage ip $ \(fname, mtype, rseqid) -> do
    M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; X.throw exn }
    res <- read_GetUserUrls_result ip
    P.maybe (P.return ()) X.throw (getUserUrls_result_userException res)
    P.maybe (P.return ()) X.throw (getUserUrls_result_systemException res)
    P.return $ getUserUrls_result_success res
inviteToBusiness (ip,op) arg_authenticationToken arg_emailAddress = do
  send_inviteToBusiness op arg_authenticationToken arg_emailAddress
  recv_inviteToBusiness ip
send_inviteToBusiness op arg_authenticationToken arg_emailAddress = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessage op ("inviteToBusiness", T.M_CALL, seqn) $
    write_InviteToBusiness_args op (InviteToBusiness_args{inviteToBusiness_args_authenticationToken=arg_authenticationToken,inviteToBusiness_args_emailAddress=arg_emailAddress})
recv_inviteToBusiness ip = do
  T.readMessage ip $ \(fname, mtype, rseqid) -> do
    M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; X.throw exn }
    res <- read_InviteToBusiness_result ip
    P.maybe (P.return ()) X.throw (inviteToBusiness_result_userException res)
    P.maybe (P.return ()) X.throw (inviteToBusiness_result_systemException res)
    P.return ()
removeFromBusiness (ip,op) arg_authenticationToken arg_emailAddress = do
  send_removeFromBusiness op arg_authenticationToken arg_emailAddress
  recv_removeFromBusiness ip
send_removeFromBusiness op arg_authenticationToken arg_emailAddress = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessage op ("removeFromBusiness", T.M_CALL, seqn) $
    write_RemoveFromBusiness_args op (RemoveFromBusiness_args{removeFromBusiness_args_authenticationToken=arg_authenticationToken,removeFromBusiness_args_emailAddress=arg_emailAddress})
recv_removeFromBusiness ip = do
  T.readMessage ip $ \(fname, mtype, rseqid) -> do
    M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; X.throw exn }
    res <- read_RemoveFromBusiness_result ip
    P.maybe (P.return ()) X.throw (removeFromBusiness_result_userException res)
    P.maybe (P.return ()) X.throw (removeFromBusiness_result_systemException res)
    P.maybe (P.return ()) X.throw (removeFromBusiness_result_notFoundException res)
    P.return ()
updateBusinessUserIdentifier (ip,op) arg_authenticationToken arg_oldEmailAddress arg_newEmailAddress = do
  send_updateBusinessUserIdentifier op arg_authenticationToken arg_oldEmailAddress arg_newEmailAddress
  recv_updateBusinessUserIdentifier ip
send_updateBusinessUserIdentifier op arg_authenticationToken arg_oldEmailAddress arg_newEmailAddress = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessage op ("updateBusinessUserIdentifier", T.M_CALL, seqn) $
    write_UpdateBusinessUserIdentifier_args op (UpdateBusinessUserIdentifier_args{updateBusinessUserIdentifier_args_authenticationToken=arg_authenticationToken,updateBusinessUserIdentifier_args_oldEmailAddress=arg_oldEmailAddress,updateBusinessUserIdentifier_args_newEmailAddress=arg_newEmailAddress})
recv_updateBusinessUserIdentifier ip = do
  T.readMessage ip $ \(fname, mtype, rseqid) -> do
    M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; X.throw exn }
    res <- read_UpdateBusinessUserIdentifier_result ip
    P.maybe (P.return ()) X.throw (updateBusinessUserIdentifier_result_userException res)
    P.maybe (P.return ()) X.throw (updateBusinessUserIdentifier_result_systemException res)
    P.maybe (P.return ()) X.throw (updateBusinessUserIdentifier_result_notFoundException res)
    P.return ()
listBusinessUsers (ip,op) arg_authenticationToken = do
  send_listBusinessUsers op arg_authenticationToken
  recv_listBusinessUsers ip
send_listBusinessUsers op arg_authenticationToken = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessage op ("listBusinessUsers", T.M_CALL, seqn) $
    write_ListBusinessUsers_args op (ListBusinessUsers_args{listBusinessUsers_args_authenticationToken=arg_authenticationToken})
recv_listBusinessUsers ip = do
  T.readMessage ip $ \(fname, mtype, rseqid) -> do
    M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; X.throw exn }
    res <- read_ListBusinessUsers_result ip
    P.maybe (P.return ()) X.throw (listBusinessUsers_result_userException res)
    P.maybe (P.return ()) X.throw (listBusinessUsers_result_systemException res)
    P.return $ listBusinessUsers_result_success res
listBusinessInvitations (ip,op) arg_authenticationToken arg_includeRequestedInvitations = do
  send_listBusinessInvitations op arg_authenticationToken arg_includeRequestedInvitations
  recv_listBusinessInvitations ip
send_listBusinessInvitations op arg_authenticationToken arg_includeRequestedInvitations = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessage op ("listBusinessInvitations", T.M_CALL, seqn) $
    write_ListBusinessInvitations_args op (ListBusinessInvitations_args{listBusinessInvitations_args_authenticationToken=arg_authenticationToken,listBusinessInvitations_args_includeRequestedInvitations=arg_includeRequestedInvitations})
recv_listBusinessInvitations ip = do
  T.readMessage ip $ \(fname, mtype, rseqid) -> do
    M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; X.throw exn }
    res <- read_ListBusinessInvitations_result ip
    P.maybe (P.return ()) X.throw (listBusinessInvitations_result_userException res)
    P.maybe (P.return ()) X.throw (listBusinessInvitations_result_systemException res)
    P.return $ listBusinessInvitations_result_success res
getAccountLimits (ip,op) arg_serviceLevel = do
  send_getAccountLimits op arg_serviceLevel
  recv_getAccountLimits ip
send_getAccountLimits op arg_serviceLevel = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessage op ("getAccountLimits", T.M_CALL, seqn) $
    write_GetAccountLimits_args op (GetAccountLimits_args{getAccountLimits_args_serviceLevel=arg_serviceLevel})
recv_getAccountLimits ip = do
  T.readMessage ip $ \(fname, mtype, rseqid) -> do
    M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; X.throw exn }
    res <- read_GetAccountLimits_result ip
    P.maybe (P.return ()) X.throw (getAccountLimits_result_userException res)
    P.return $ getAccountLimits_result_success res
