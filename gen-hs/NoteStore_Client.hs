{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-missing-fields #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-----------------------------------------------------------------
-- Autogenerated by Thrift Compiler (0.11.0)                      --
--                                                             --
-- DO NOT EDIT UNLESS YOU ARE SURE YOU KNOW WHAT YOU ARE DOING --
-----------------------------------------------------------------

module NoteStore_Client(getSyncState,getFilteredSyncChunk,getLinkedNotebookSyncState,getLinkedNotebookSyncChunk,listNotebooks,listAccessibleBusinessNotebooks,getNotebook,getDefaultNotebook,createNotebook,updateNotebook,expungeNotebook,listTags,listTagsByNotebook,getTag,createTag,updateTag,untagAll,expungeTag,listSearches,getSearch,createSearch,updateSearch,expungeSearch,findNoteOffset,findNotesMetadata,findNoteCounts,getNoteWithResultSpec,getNote,getNoteApplicationData,getNoteApplicationDataEntry,setNoteApplicationDataEntry,unsetNoteApplicationDataEntry,getNoteContent,getNoteSearchText,getResourceSearchText,getNoteTagNames,createNote,updateNote,deleteNote,expungeNote,copyNote,listNoteVersions,getNoteVersion,getResource,getResourceApplicationData,getResourceApplicationDataEntry,setResourceApplicationDataEntry,unsetResourceApplicationDataEntry,updateResource,getResourceData,getResourceByHash,getResourceRecognition,getResourceAlternateData,getResourceAttributes,getPublicNotebook,shareNotebook,createOrUpdateNotebookShares,updateSharedNotebook,setNotebookRecipientSettings,listSharedNotebooks,createLinkedNotebook,updateLinkedNotebook,listLinkedNotebooks,expungeLinkedNotebook,authenticateToSharedNotebook,getSharedNotebookByAuth,emailNote,shareNote,stopSharingNote,authenticateToSharedNote,findRelated,updateNoteIfUsnMatches,manageNotebookShares,getNotebookShares) where
import qualified Data.IORef as R
import Prelude (($), (.), (>>=), (==), (++))
import qualified Prelude as P
import qualified Control.Exception as X
import qualified Control.Monad as M ( liftM, ap, when )
import Data.Functor ( (<$>) )
import qualified Data.ByteString.Lazy as LBS
import qualified Data.Hashable as H
import qualified Data.Int as I
import qualified Data.Maybe as M (catMaybes)
import qualified Data.Text.Lazy.Encoding as E ( decodeUtf8, encodeUtf8 )
import qualified Data.Text.Lazy as LT
import qualified GHC.Generics as G (Generic)
import qualified Data.Typeable as TY ( Typeable )
import qualified Data.HashMap.Strict as Map
import qualified Data.HashSet as Set
import qualified Data.Vector as Vector
import qualified Test.QuickCheck.Arbitrary as QC ( Arbitrary(..) )
import qualified Test.QuickCheck as QC ( elements )

import qualified Thrift as T
import qualified Thrift.Types as T
import qualified Thrift.Arbitraries as T

import qualified UserStore_Types
import qualified Types_Types
import qualified Errors_Types
import qualified Limits_Types


import NoteStore_Types
import NoteStore
seqid = R.newIORef 0
getSyncState (ip,op) arg_authenticationToken = do
  send_getSyncState op arg_authenticationToken
  recv_getSyncState ip
send_getSyncState op arg_authenticationToken = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessage op ("getSyncState", T.M_CALL, seqn) $
    write_GetSyncState_args op (GetSyncState_args{getSyncState_args_authenticationToken=arg_authenticationToken})
recv_getSyncState ip = do
  T.readMessage ip $ \(fname, mtype, rseqid) -> do
    M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; X.throw exn }
    res <- read_GetSyncState_result ip
    P.maybe (P.return ()) X.throw (getSyncState_result_userException res)
    P.maybe (P.return ()) X.throw (getSyncState_result_systemException res)
    P.return $ getSyncState_result_success res
getFilteredSyncChunk (ip,op) arg_authenticationToken arg_afterUSN arg_maxEntries arg_filter = do
  send_getFilteredSyncChunk op arg_authenticationToken arg_afterUSN arg_maxEntries arg_filter
  recv_getFilteredSyncChunk ip
send_getFilteredSyncChunk op arg_authenticationToken arg_afterUSN arg_maxEntries arg_filter = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessage op ("getFilteredSyncChunk", T.M_CALL, seqn) $
    write_GetFilteredSyncChunk_args op (GetFilteredSyncChunk_args{getFilteredSyncChunk_args_authenticationToken=arg_authenticationToken,getFilteredSyncChunk_args_afterUSN=arg_afterUSN,getFilteredSyncChunk_args_maxEntries=arg_maxEntries,getFilteredSyncChunk_args_filter=arg_filter})
recv_getFilteredSyncChunk ip = do
  T.readMessage ip $ \(fname, mtype, rseqid) -> do
    M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; X.throw exn }
    res <- read_GetFilteredSyncChunk_result ip
    P.maybe (P.return ()) X.throw (getFilteredSyncChunk_result_userException res)
    P.maybe (P.return ()) X.throw (getFilteredSyncChunk_result_systemException res)
    P.return $ getFilteredSyncChunk_result_success res
getLinkedNotebookSyncState (ip,op) arg_authenticationToken arg_linkedNotebook = do
  send_getLinkedNotebookSyncState op arg_authenticationToken arg_linkedNotebook
  recv_getLinkedNotebookSyncState ip
send_getLinkedNotebookSyncState op arg_authenticationToken arg_linkedNotebook = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessage op ("getLinkedNotebookSyncState", T.M_CALL, seqn) $
    write_GetLinkedNotebookSyncState_args op (GetLinkedNotebookSyncState_args{getLinkedNotebookSyncState_args_authenticationToken=arg_authenticationToken,getLinkedNotebookSyncState_args_linkedNotebook=arg_linkedNotebook})
recv_getLinkedNotebookSyncState ip = do
  T.readMessage ip $ \(fname, mtype, rseqid) -> do
    M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; X.throw exn }
    res <- read_GetLinkedNotebookSyncState_result ip
    P.maybe (P.return ()) X.throw (getLinkedNotebookSyncState_result_userException res)
    P.maybe (P.return ()) X.throw (getLinkedNotebookSyncState_result_systemException res)
    P.maybe (P.return ()) X.throw (getLinkedNotebookSyncState_result_notFoundException res)
    P.return $ getLinkedNotebookSyncState_result_success res
getLinkedNotebookSyncChunk (ip,op) arg_authenticationToken arg_linkedNotebook arg_afterUSN arg_maxEntries arg_fullSyncOnly = do
  send_getLinkedNotebookSyncChunk op arg_authenticationToken arg_linkedNotebook arg_afterUSN arg_maxEntries arg_fullSyncOnly
  recv_getLinkedNotebookSyncChunk ip
send_getLinkedNotebookSyncChunk op arg_authenticationToken arg_linkedNotebook arg_afterUSN arg_maxEntries arg_fullSyncOnly = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessage op ("getLinkedNotebookSyncChunk", T.M_CALL, seqn) $
    write_GetLinkedNotebookSyncChunk_args op (GetLinkedNotebookSyncChunk_args{getLinkedNotebookSyncChunk_args_authenticationToken=arg_authenticationToken,getLinkedNotebookSyncChunk_args_linkedNotebook=arg_linkedNotebook,getLinkedNotebookSyncChunk_args_afterUSN=arg_afterUSN,getLinkedNotebookSyncChunk_args_maxEntries=arg_maxEntries,getLinkedNotebookSyncChunk_args_fullSyncOnly=arg_fullSyncOnly})
recv_getLinkedNotebookSyncChunk ip = do
  T.readMessage ip $ \(fname, mtype, rseqid) -> do
    M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; X.throw exn }
    res <- read_GetLinkedNotebookSyncChunk_result ip
    P.maybe (P.return ()) X.throw (getLinkedNotebookSyncChunk_result_userException res)
    P.maybe (P.return ()) X.throw (getLinkedNotebookSyncChunk_result_systemException res)
    P.maybe (P.return ()) X.throw (getLinkedNotebookSyncChunk_result_notFoundException res)
    P.return $ getLinkedNotebookSyncChunk_result_success res
listNotebooks (ip,op) arg_authenticationToken = do
  send_listNotebooks op arg_authenticationToken
  recv_listNotebooks ip
send_listNotebooks op arg_authenticationToken = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessage op ("listNotebooks", T.M_CALL, seqn) $
    write_ListNotebooks_args op (ListNotebooks_args{listNotebooks_args_authenticationToken=arg_authenticationToken})
recv_listNotebooks ip = do
  T.readMessage ip $ \(fname, mtype, rseqid) -> do
    M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; X.throw exn }
    res <- read_ListNotebooks_result ip
    P.maybe (P.return ()) X.throw (listNotebooks_result_userException res)
    P.maybe (P.return ()) X.throw (listNotebooks_result_systemException res)
    P.return $ listNotebooks_result_success res
listAccessibleBusinessNotebooks (ip,op) arg_authenticationToken = do
  send_listAccessibleBusinessNotebooks op arg_authenticationToken
  recv_listAccessibleBusinessNotebooks ip
send_listAccessibleBusinessNotebooks op arg_authenticationToken = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessage op ("listAccessibleBusinessNotebooks", T.M_CALL, seqn) $
    write_ListAccessibleBusinessNotebooks_args op (ListAccessibleBusinessNotebooks_args{listAccessibleBusinessNotebooks_args_authenticationToken=arg_authenticationToken})
recv_listAccessibleBusinessNotebooks ip = do
  T.readMessage ip $ \(fname, mtype, rseqid) -> do
    M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; X.throw exn }
    res <- read_ListAccessibleBusinessNotebooks_result ip
    P.maybe (P.return ()) X.throw (listAccessibleBusinessNotebooks_result_userException res)
    P.maybe (P.return ()) X.throw (listAccessibleBusinessNotebooks_result_systemException res)
    P.return $ listAccessibleBusinessNotebooks_result_success res
getNotebook (ip,op) arg_authenticationToken arg_guid = do
  send_getNotebook op arg_authenticationToken arg_guid
  recv_getNotebook ip
send_getNotebook op arg_authenticationToken arg_guid = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessage op ("getNotebook", T.M_CALL, seqn) $
    write_GetNotebook_args op (GetNotebook_args{getNotebook_args_authenticationToken=arg_authenticationToken,getNotebook_args_guid=arg_guid})
recv_getNotebook ip = do
  T.readMessage ip $ \(fname, mtype, rseqid) -> do
    M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; X.throw exn }
    res <- read_GetNotebook_result ip
    P.maybe (P.return ()) X.throw (getNotebook_result_userException res)
    P.maybe (P.return ()) X.throw (getNotebook_result_systemException res)
    P.maybe (P.return ()) X.throw (getNotebook_result_notFoundException res)
    P.return $ getNotebook_result_success res
getDefaultNotebook (ip,op) arg_authenticationToken = do
  send_getDefaultNotebook op arg_authenticationToken
  recv_getDefaultNotebook ip
send_getDefaultNotebook op arg_authenticationToken = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessage op ("getDefaultNotebook", T.M_CALL, seqn) $
    write_GetDefaultNotebook_args op (GetDefaultNotebook_args{getDefaultNotebook_args_authenticationToken=arg_authenticationToken})
recv_getDefaultNotebook ip = do
  T.readMessage ip $ \(fname, mtype, rseqid) -> do
    M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; X.throw exn }
    res <- read_GetDefaultNotebook_result ip
    P.maybe (P.return ()) X.throw (getDefaultNotebook_result_userException res)
    P.maybe (P.return ()) X.throw (getDefaultNotebook_result_systemException res)
    P.return $ getDefaultNotebook_result_success res
createNotebook (ip,op) arg_authenticationToken arg_notebook = do
  send_createNotebook op arg_authenticationToken arg_notebook
  recv_createNotebook ip
send_createNotebook op arg_authenticationToken arg_notebook = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessage op ("createNotebook", T.M_CALL, seqn) $
    write_CreateNotebook_args op (CreateNotebook_args{createNotebook_args_authenticationToken=arg_authenticationToken,createNotebook_args_notebook=arg_notebook})
recv_createNotebook ip = do
  T.readMessage ip $ \(fname, mtype, rseqid) -> do
    M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; X.throw exn }
    res <- read_CreateNotebook_result ip
    P.maybe (P.return ()) X.throw (createNotebook_result_userException res)
    P.maybe (P.return ()) X.throw (createNotebook_result_systemException res)
    P.return $ createNotebook_result_success res
updateNotebook (ip,op) arg_authenticationToken arg_notebook = do
  send_updateNotebook op arg_authenticationToken arg_notebook
  recv_updateNotebook ip
send_updateNotebook op arg_authenticationToken arg_notebook = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessage op ("updateNotebook", T.M_CALL, seqn) $
    write_UpdateNotebook_args op (UpdateNotebook_args{updateNotebook_args_authenticationToken=arg_authenticationToken,updateNotebook_args_notebook=arg_notebook})
recv_updateNotebook ip = do
  T.readMessage ip $ \(fname, mtype, rseqid) -> do
    M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; X.throw exn }
    res <- read_UpdateNotebook_result ip
    P.maybe (P.return ()) X.throw (updateNotebook_result_userException res)
    P.maybe (P.return ()) X.throw (updateNotebook_result_systemException res)
    P.maybe (P.return ()) X.throw (updateNotebook_result_notFoundException res)
    P.return $ updateNotebook_result_success res
expungeNotebook (ip,op) arg_authenticationToken arg_guid = do
  send_expungeNotebook op arg_authenticationToken arg_guid
  recv_expungeNotebook ip
send_expungeNotebook op arg_authenticationToken arg_guid = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessage op ("expungeNotebook", T.M_CALL, seqn) $
    write_ExpungeNotebook_args op (ExpungeNotebook_args{expungeNotebook_args_authenticationToken=arg_authenticationToken,expungeNotebook_args_guid=arg_guid})
recv_expungeNotebook ip = do
  T.readMessage ip $ \(fname, mtype, rseqid) -> do
    M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; X.throw exn }
    res <- read_ExpungeNotebook_result ip
    P.maybe (P.return ()) X.throw (expungeNotebook_result_userException res)
    P.maybe (P.return ()) X.throw (expungeNotebook_result_systemException res)
    P.maybe (P.return ()) X.throw (expungeNotebook_result_notFoundException res)
    P.return $ expungeNotebook_result_success res
listTags (ip,op) arg_authenticationToken = do
  send_listTags op arg_authenticationToken
  recv_listTags ip
send_listTags op arg_authenticationToken = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessage op ("listTags", T.M_CALL, seqn) $
    write_ListTags_args op (ListTags_args{listTags_args_authenticationToken=arg_authenticationToken})
recv_listTags ip = do
  T.readMessage ip $ \(fname, mtype, rseqid) -> do
    M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; X.throw exn }
    res <- read_ListTags_result ip
    P.maybe (P.return ()) X.throw (listTags_result_userException res)
    P.maybe (P.return ()) X.throw (listTags_result_systemException res)
    P.return $ listTags_result_success res
listTagsByNotebook (ip,op) arg_authenticationToken arg_notebookGuid = do
  send_listTagsByNotebook op arg_authenticationToken arg_notebookGuid
  recv_listTagsByNotebook ip
send_listTagsByNotebook op arg_authenticationToken arg_notebookGuid = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessage op ("listTagsByNotebook", T.M_CALL, seqn) $
    write_ListTagsByNotebook_args op (ListTagsByNotebook_args{listTagsByNotebook_args_authenticationToken=arg_authenticationToken,listTagsByNotebook_args_notebookGuid=arg_notebookGuid})
recv_listTagsByNotebook ip = do
  T.readMessage ip $ \(fname, mtype, rseqid) -> do
    M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; X.throw exn }
    res <- read_ListTagsByNotebook_result ip
    P.maybe (P.return ()) X.throw (listTagsByNotebook_result_userException res)
    P.maybe (P.return ()) X.throw (listTagsByNotebook_result_systemException res)
    P.maybe (P.return ()) X.throw (listTagsByNotebook_result_notFoundException res)
    P.return $ listTagsByNotebook_result_success res
getTag (ip,op) arg_authenticationToken arg_guid = do
  send_getTag op arg_authenticationToken arg_guid
  recv_getTag ip
send_getTag op arg_authenticationToken arg_guid = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessage op ("getTag", T.M_CALL, seqn) $
    write_GetTag_args op (GetTag_args{getTag_args_authenticationToken=arg_authenticationToken,getTag_args_guid=arg_guid})
recv_getTag ip = do
  T.readMessage ip $ \(fname, mtype, rseqid) -> do
    M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; X.throw exn }
    res <- read_GetTag_result ip
    P.maybe (P.return ()) X.throw (getTag_result_userException res)
    P.maybe (P.return ()) X.throw (getTag_result_systemException res)
    P.maybe (P.return ()) X.throw (getTag_result_notFoundException res)
    P.return $ getTag_result_success res
createTag (ip,op) arg_authenticationToken arg_tag = do
  send_createTag op arg_authenticationToken arg_tag
  recv_createTag ip
send_createTag op arg_authenticationToken arg_tag = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessage op ("createTag", T.M_CALL, seqn) $
    write_CreateTag_args op (CreateTag_args{createTag_args_authenticationToken=arg_authenticationToken,createTag_args_tag=arg_tag})
recv_createTag ip = do
  T.readMessage ip $ \(fname, mtype, rseqid) -> do
    M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; X.throw exn }
    res <- read_CreateTag_result ip
    P.maybe (P.return ()) X.throw (createTag_result_userException res)
    P.maybe (P.return ()) X.throw (createTag_result_systemException res)
    P.maybe (P.return ()) X.throw (createTag_result_notFoundException res)
    P.return $ createTag_result_success res
updateTag (ip,op) arg_authenticationToken arg_tag = do
  send_updateTag op arg_authenticationToken arg_tag
  recv_updateTag ip
send_updateTag op arg_authenticationToken arg_tag = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessage op ("updateTag", T.M_CALL, seqn) $
    write_UpdateTag_args op (UpdateTag_args{updateTag_args_authenticationToken=arg_authenticationToken,updateTag_args_tag=arg_tag})
recv_updateTag ip = do
  T.readMessage ip $ \(fname, mtype, rseqid) -> do
    M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; X.throw exn }
    res <- read_UpdateTag_result ip
    P.maybe (P.return ()) X.throw (updateTag_result_userException res)
    P.maybe (P.return ()) X.throw (updateTag_result_systemException res)
    P.maybe (P.return ()) X.throw (updateTag_result_notFoundException res)
    P.return $ updateTag_result_success res
untagAll (ip,op) arg_authenticationToken arg_guid = do
  send_untagAll op arg_authenticationToken arg_guid
  recv_untagAll ip
send_untagAll op arg_authenticationToken arg_guid = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessage op ("untagAll", T.M_CALL, seqn) $
    write_UntagAll_args op (UntagAll_args{untagAll_args_authenticationToken=arg_authenticationToken,untagAll_args_guid=arg_guid})
recv_untagAll ip = do
  T.readMessage ip $ \(fname, mtype, rseqid) -> do
    M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; X.throw exn }
    res <- read_UntagAll_result ip
    P.maybe (P.return ()) X.throw (untagAll_result_userException res)
    P.maybe (P.return ()) X.throw (untagAll_result_systemException res)
    P.maybe (P.return ()) X.throw (untagAll_result_notFoundException res)
    P.return ()
expungeTag (ip,op) arg_authenticationToken arg_guid = do
  send_expungeTag op arg_authenticationToken arg_guid
  recv_expungeTag ip
send_expungeTag op arg_authenticationToken arg_guid = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessage op ("expungeTag", T.M_CALL, seqn) $
    write_ExpungeTag_args op (ExpungeTag_args{expungeTag_args_authenticationToken=arg_authenticationToken,expungeTag_args_guid=arg_guid})
recv_expungeTag ip = do
  T.readMessage ip $ \(fname, mtype, rseqid) -> do
    M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; X.throw exn }
    res <- read_ExpungeTag_result ip
    P.maybe (P.return ()) X.throw (expungeTag_result_userException res)
    P.maybe (P.return ()) X.throw (expungeTag_result_systemException res)
    P.maybe (P.return ()) X.throw (expungeTag_result_notFoundException res)
    P.return $ expungeTag_result_success res
listSearches (ip,op) arg_authenticationToken = do
  send_listSearches op arg_authenticationToken
  recv_listSearches ip
send_listSearches op arg_authenticationToken = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessage op ("listSearches", T.M_CALL, seqn) $
    write_ListSearches_args op (ListSearches_args{listSearches_args_authenticationToken=arg_authenticationToken})
recv_listSearches ip = do
  T.readMessage ip $ \(fname, mtype, rseqid) -> do
    M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; X.throw exn }
    res <- read_ListSearches_result ip
    P.maybe (P.return ()) X.throw (listSearches_result_userException res)
    P.maybe (P.return ()) X.throw (listSearches_result_systemException res)
    P.return $ listSearches_result_success res
getSearch (ip,op) arg_authenticationToken arg_guid = do
  send_getSearch op arg_authenticationToken arg_guid
  recv_getSearch ip
send_getSearch op arg_authenticationToken arg_guid = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessage op ("getSearch", T.M_CALL, seqn) $
    write_GetSearch_args op (GetSearch_args{getSearch_args_authenticationToken=arg_authenticationToken,getSearch_args_guid=arg_guid})
recv_getSearch ip = do
  T.readMessage ip $ \(fname, mtype, rseqid) -> do
    M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; X.throw exn }
    res <- read_GetSearch_result ip
    P.maybe (P.return ()) X.throw (getSearch_result_userException res)
    P.maybe (P.return ()) X.throw (getSearch_result_systemException res)
    P.maybe (P.return ()) X.throw (getSearch_result_notFoundException res)
    P.return $ getSearch_result_success res
createSearch (ip,op) arg_authenticationToken arg_search = do
  send_createSearch op arg_authenticationToken arg_search
  recv_createSearch ip
send_createSearch op arg_authenticationToken arg_search = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessage op ("createSearch", T.M_CALL, seqn) $
    write_CreateSearch_args op (CreateSearch_args{createSearch_args_authenticationToken=arg_authenticationToken,createSearch_args_search=arg_search})
recv_createSearch ip = do
  T.readMessage ip $ \(fname, mtype, rseqid) -> do
    M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; X.throw exn }
    res <- read_CreateSearch_result ip
    P.maybe (P.return ()) X.throw (createSearch_result_userException res)
    P.maybe (P.return ()) X.throw (createSearch_result_systemException res)
    P.return $ createSearch_result_success res
updateSearch (ip,op) arg_authenticationToken arg_search = do
  send_updateSearch op arg_authenticationToken arg_search
  recv_updateSearch ip
send_updateSearch op arg_authenticationToken arg_search = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessage op ("updateSearch", T.M_CALL, seqn) $
    write_UpdateSearch_args op (UpdateSearch_args{updateSearch_args_authenticationToken=arg_authenticationToken,updateSearch_args_search=arg_search})
recv_updateSearch ip = do
  T.readMessage ip $ \(fname, mtype, rseqid) -> do
    M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; X.throw exn }
    res <- read_UpdateSearch_result ip
    P.maybe (P.return ()) X.throw (updateSearch_result_userException res)
    P.maybe (P.return ()) X.throw (updateSearch_result_systemException res)
    P.maybe (P.return ()) X.throw (updateSearch_result_notFoundException res)
    P.return $ updateSearch_result_success res
expungeSearch (ip,op) arg_authenticationToken arg_guid = do
  send_expungeSearch op arg_authenticationToken arg_guid
  recv_expungeSearch ip
send_expungeSearch op arg_authenticationToken arg_guid = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessage op ("expungeSearch", T.M_CALL, seqn) $
    write_ExpungeSearch_args op (ExpungeSearch_args{expungeSearch_args_authenticationToken=arg_authenticationToken,expungeSearch_args_guid=arg_guid})
recv_expungeSearch ip = do
  T.readMessage ip $ \(fname, mtype, rseqid) -> do
    M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; X.throw exn }
    res <- read_ExpungeSearch_result ip
    P.maybe (P.return ()) X.throw (expungeSearch_result_userException res)
    P.maybe (P.return ()) X.throw (expungeSearch_result_systemException res)
    P.maybe (P.return ()) X.throw (expungeSearch_result_notFoundException res)
    P.return $ expungeSearch_result_success res
findNoteOffset (ip,op) arg_authenticationToken arg_filter arg_guid = do
  send_findNoteOffset op arg_authenticationToken arg_filter arg_guid
  recv_findNoteOffset ip
send_findNoteOffset op arg_authenticationToken arg_filter arg_guid = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessage op ("findNoteOffset", T.M_CALL, seqn) $
    write_FindNoteOffset_args op (FindNoteOffset_args{findNoteOffset_args_authenticationToken=arg_authenticationToken,findNoteOffset_args_filter=arg_filter,findNoteOffset_args_guid=arg_guid})
recv_findNoteOffset ip = do
  T.readMessage ip $ \(fname, mtype, rseqid) -> do
    M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; X.throw exn }
    res <- read_FindNoteOffset_result ip
    P.maybe (P.return ()) X.throw (findNoteOffset_result_userException res)
    P.maybe (P.return ()) X.throw (findNoteOffset_result_systemException res)
    P.maybe (P.return ()) X.throw (findNoteOffset_result_notFoundException res)
    P.return $ findNoteOffset_result_success res
findNotesMetadata (ip,op) arg_authenticationToken arg_filter arg_offset arg_maxNotes arg_resultSpec = do
  send_findNotesMetadata op arg_authenticationToken arg_filter arg_offset arg_maxNotes arg_resultSpec
  recv_findNotesMetadata ip
send_findNotesMetadata op arg_authenticationToken arg_filter arg_offset arg_maxNotes arg_resultSpec = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessage op ("findNotesMetadata", T.M_CALL, seqn) $
    write_FindNotesMetadata_args op (FindNotesMetadata_args{findNotesMetadata_args_authenticationToken=arg_authenticationToken,findNotesMetadata_args_filter=arg_filter,findNotesMetadata_args_offset=arg_offset,findNotesMetadata_args_maxNotes=arg_maxNotes,findNotesMetadata_args_resultSpec=arg_resultSpec})
recv_findNotesMetadata ip = do
  T.readMessage ip $ \(fname, mtype, rseqid) -> do
    M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; X.throw exn }
    res <- read_FindNotesMetadata_result ip
    P.maybe (P.return ()) X.throw (findNotesMetadata_result_userException res)
    P.maybe (P.return ()) X.throw (findNotesMetadata_result_systemException res)
    P.maybe (P.return ()) X.throw (findNotesMetadata_result_notFoundException res)
    P.return $ findNotesMetadata_result_success res
findNoteCounts (ip,op) arg_authenticationToken arg_filter arg_withTrash = do
  send_findNoteCounts op arg_authenticationToken arg_filter arg_withTrash
  recv_findNoteCounts ip
send_findNoteCounts op arg_authenticationToken arg_filter arg_withTrash = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessage op ("findNoteCounts", T.M_CALL, seqn) $
    write_FindNoteCounts_args op (FindNoteCounts_args{findNoteCounts_args_authenticationToken=arg_authenticationToken,findNoteCounts_args_filter=arg_filter,findNoteCounts_args_withTrash=arg_withTrash})
recv_findNoteCounts ip = do
  T.readMessage ip $ \(fname, mtype, rseqid) -> do
    M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; X.throw exn }
    res <- read_FindNoteCounts_result ip
    P.maybe (P.return ()) X.throw (findNoteCounts_result_userException res)
    P.maybe (P.return ()) X.throw (findNoteCounts_result_systemException res)
    P.maybe (P.return ()) X.throw (findNoteCounts_result_notFoundException res)
    P.return $ findNoteCounts_result_success res
getNoteWithResultSpec (ip,op) arg_authenticationToken arg_guid arg_resultSpec = do
  send_getNoteWithResultSpec op arg_authenticationToken arg_guid arg_resultSpec
  recv_getNoteWithResultSpec ip
send_getNoteWithResultSpec op arg_authenticationToken arg_guid arg_resultSpec = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessage op ("getNoteWithResultSpec", T.M_CALL, seqn) $
    write_GetNoteWithResultSpec_args op (GetNoteWithResultSpec_args{getNoteWithResultSpec_args_authenticationToken=arg_authenticationToken,getNoteWithResultSpec_args_guid=arg_guid,getNoteWithResultSpec_args_resultSpec=arg_resultSpec})
recv_getNoteWithResultSpec ip = do
  T.readMessage ip $ \(fname, mtype, rseqid) -> do
    M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; X.throw exn }
    res <- read_GetNoteWithResultSpec_result ip
    P.maybe (P.return ()) X.throw (getNoteWithResultSpec_result_userException res)
    P.maybe (P.return ()) X.throw (getNoteWithResultSpec_result_systemException res)
    P.maybe (P.return ()) X.throw (getNoteWithResultSpec_result_notFoundException res)
    P.return $ getNoteWithResultSpec_result_success res
getNote (ip,op) arg_authenticationToken arg_guid arg_withContent arg_withResourcesData arg_withResourcesRecognition arg_withResourcesAlternateData = do
  send_getNote op arg_authenticationToken arg_guid arg_withContent arg_withResourcesData arg_withResourcesRecognition arg_withResourcesAlternateData
  recv_getNote ip
send_getNote op arg_authenticationToken arg_guid arg_withContent arg_withResourcesData arg_withResourcesRecognition arg_withResourcesAlternateData = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessage op ("getNote", T.M_CALL, seqn) $
    write_GetNote_args op (GetNote_args{getNote_args_authenticationToken=arg_authenticationToken,getNote_args_guid=arg_guid,getNote_args_withContent=arg_withContent,getNote_args_withResourcesData=arg_withResourcesData,getNote_args_withResourcesRecognition=arg_withResourcesRecognition,getNote_args_withResourcesAlternateData=arg_withResourcesAlternateData})
recv_getNote ip = do
  T.readMessage ip $ \(fname, mtype, rseqid) -> do
    M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; X.throw exn }
    res <- read_GetNote_result ip
    P.maybe (P.return ()) X.throw (getNote_result_userException res)
    P.maybe (P.return ()) X.throw (getNote_result_systemException res)
    P.maybe (P.return ()) X.throw (getNote_result_notFoundException res)
    P.return $ getNote_result_success res
getNoteApplicationData (ip,op) arg_authenticationToken arg_guid = do
  send_getNoteApplicationData op arg_authenticationToken arg_guid
  recv_getNoteApplicationData ip
send_getNoteApplicationData op arg_authenticationToken arg_guid = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessage op ("getNoteApplicationData", T.M_CALL, seqn) $
    write_GetNoteApplicationData_args op (GetNoteApplicationData_args{getNoteApplicationData_args_authenticationToken=arg_authenticationToken,getNoteApplicationData_args_guid=arg_guid})
recv_getNoteApplicationData ip = do
  T.readMessage ip $ \(fname, mtype, rseqid) -> do
    M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; X.throw exn }
    res <- read_GetNoteApplicationData_result ip
    P.maybe (P.return ()) X.throw (getNoteApplicationData_result_userException res)
    P.maybe (P.return ()) X.throw (getNoteApplicationData_result_systemException res)
    P.maybe (P.return ()) X.throw (getNoteApplicationData_result_notFoundException res)
    P.return $ getNoteApplicationData_result_success res
getNoteApplicationDataEntry (ip,op) arg_authenticationToken arg_guid arg_key = do
  send_getNoteApplicationDataEntry op arg_authenticationToken arg_guid arg_key
  recv_getNoteApplicationDataEntry ip
send_getNoteApplicationDataEntry op arg_authenticationToken arg_guid arg_key = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessage op ("getNoteApplicationDataEntry", T.M_CALL, seqn) $
    write_GetNoteApplicationDataEntry_args op (GetNoteApplicationDataEntry_args{getNoteApplicationDataEntry_args_authenticationToken=arg_authenticationToken,getNoteApplicationDataEntry_args_guid=arg_guid,getNoteApplicationDataEntry_args_key=arg_key})
recv_getNoteApplicationDataEntry ip = do
  T.readMessage ip $ \(fname, mtype, rseqid) -> do
    M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; X.throw exn }
    res <- read_GetNoteApplicationDataEntry_result ip
    P.maybe (P.return ()) X.throw (getNoteApplicationDataEntry_result_userException res)
    P.maybe (P.return ()) X.throw (getNoteApplicationDataEntry_result_systemException res)
    P.maybe (P.return ()) X.throw (getNoteApplicationDataEntry_result_notFoundException res)
    P.return $ getNoteApplicationDataEntry_result_success res
setNoteApplicationDataEntry (ip,op) arg_authenticationToken arg_guid arg_key arg_value = do
  send_setNoteApplicationDataEntry op arg_authenticationToken arg_guid arg_key arg_value
  recv_setNoteApplicationDataEntry ip
send_setNoteApplicationDataEntry op arg_authenticationToken arg_guid arg_key arg_value = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessage op ("setNoteApplicationDataEntry", T.M_CALL, seqn) $
    write_SetNoteApplicationDataEntry_args op (SetNoteApplicationDataEntry_args{setNoteApplicationDataEntry_args_authenticationToken=arg_authenticationToken,setNoteApplicationDataEntry_args_guid=arg_guid,setNoteApplicationDataEntry_args_key=arg_key,setNoteApplicationDataEntry_args_value=arg_value})
recv_setNoteApplicationDataEntry ip = do
  T.readMessage ip $ \(fname, mtype, rseqid) -> do
    M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; X.throw exn }
    res <- read_SetNoteApplicationDataEntry_result ip
    P.maybe (P.return ()) X.throw (setNoteApplicationDataEntry_result_userException res)
    P.maybe (P.return ()) X.throw (setNoteApplicationDataEntry_result_systemException res)
    P.maybe (P.return ()) X.throw (setNoteApplicationDataEntry_result_notFoundException res)
    P.return $ setNoteApplicationDataEntry_result_success res
unsetNoteApplicationDataEntry (ip,op) arg_authenticationToken arg_guid arg_key = do
  send_unsetNoteApplicationDataEntry op arg_authenticationToken arg_guid arg_key
  recv_unsetNoteApplicationDataEntry ip
send_unsetNoteApplicationDataEntry op arg_authenticationToken arg_guid arg_key = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessage op ("unsetNoteApplicationDataEntry", T.M_CALL, seqn) $
    write_UnsetNoteApplicationDataEntry_args op (UnsetNoteApplicationDataEntry_args{unsetNoteApplicationDataEntry_args_authenticationToken=arg_authenticationToken,unsetNoteApplicationDataEntry_args_guid=arg_guid,unsetNoteApplicationDataEntry_args_key=arg_key})
recv_unsetNoteApplicationDataEntry ip = do
  T.readMessage ip $ \(fname, mtype, rseqid) -> do
    M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; X.throw exn }
    res <- read_UnsetNoteApplicationDataEntry_result ip
    P.maybe (P.return ()) X.throw (unsetNoteApplicationDataEntry_result_userException res)
    P.maybe (P.return ()) X.throw (unsetNoteApplicationDataEntry_result_systemException res)
    P.maybe (P.return ()) X.throw (unsetNoteApplicationDataEntry_result_notFoundException res)
    P.return $ unsetNoteApplicationDataEntry_result_success res
getNoteContent (ip,op) arg_authenticationToken arg_guid = do
  send_getNoteContent op arg_authenticationToken arg_guid
  recv_getNoteContent ip
send_getNoteContent op arg_authenticationToken arg_guid = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessage op ("getNoteContent", T.M_CALL, seqn) $
    write_GetNoteContent_args op (GetNoteContent_args{getNoteContent_args_authenticationToken=arg_authenticationToken,getNoteContent_args_guid=arg_guid})
recv_getNoteContent ip = do
  T.readMessage ip $ \(fname, mtype, rseqid) -> do
    M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; X.throw exn }
    res <- read_GetNoteContent_result ip
    P.maybe (P.return ()) X.throw (getNoteContent_result_userException res)
    P.maybe (P.return ()) X.throw (getNoteContent_result_systemException res)
    P.maybe (P.return ()) X.throw (getNoteContent_result_notFoundException res)
    P.return $ getNoteContent_result_success res
getNoteSearchText (ip,op) arg_authenticationToken arg_guid arg_noteOnly arg_tokenizeForIndexing = do
  send_getNoteSearchText op arg_authenticationToken arg_guid arg_noteOnly arg_tokenizeForIndexing
  recv_getNoteSearchText ip
send_getNoteSearchText op arg_authenticationToken arg_guid arg_noteOnly arg_tokenizeForIndexing = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessage op ("getNoteSearchText", T.M_CALL, seqn) $
    write_GetNoteSearchText_args op (GetNoteSearchText_args{getNoteSearchText_args_authenticationToken=arg_authenticationToken,getNoteSearchText_args_guid=arg_guid,getNoteSearchText_args_noteOnly=arg_noteOnly,getNoteSearchText_args_tokenizeForIndexing=arg_tokenizeForIndexing})
recv_getNoteSearchText ip = do
  T.readMessage ip $ \(fname, mtype, rseqid) -> do
    M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; X.throw exn }
    res <- read_GetNoteSearchText_result ip
    P.maybe (P.return ()) X.throw (getNoteSearchText_result_userException res)
    P.maybe (P.return ()) X.throw (getNoteSearchText_result_systemException res)
    P.maybe (P.return ()) X.throw (getNoteSearchText_result_notFoundException res)
    P.return $ getNoteSearchText_result_success res
getResourceSearchText (ip,op) arg_authenticationToken arg_guid = do
  send_getResourceSearchText op arg_authenticationToken arg_guid
  recv_getResourceSearchText ip
send_getResourceSearchText op arg_authenticationToken arg_guid = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessage op ("getResourceSearchText", T.M_CALL, seqn) $
    write_GetResourceSearchText_args op (GetResourceSearchText_args{getResourceSearchText_args_authenticationToken=arg_authenticationToken,getResourceSearchText_args_guid=arg_guid})
recv_getResourceSearchText ip = do
  T.readMessage ip $ \(fname, mtype, rseqid) -> do
    M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; X.throw exn }
    res <- read_GetResourceSearchText_result ip
    P.maybe (P.return ()) X.throw (getResourceSearchText_result_userException res)
    P.maybe (P.return ()) X.throw (getResourceSearchText_result_systemException res)
    P.maybe (P.return ()) X.throw (getResourceSearchText_result_notFoundException res)
    P.return $ getResourceSearchText_result_success res
getNoteTagNames (ip,op) arg_authenticationToken arg_guid = do
  send_getNoteTagNames op arg_authenticationToken arg_guid
  recv_getNoteTagNames ip
send_getNoteTagNames op arg_authenticationToken arg_guid = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessage op ("getNoteTagNames", T.M_CALL, seqn) $
    write_GetNoteTagNames_args op (GetNoteTagNames_args{getNoteTagNames_args_authenticationToken=arg_authenticationToken,getNoteTagNames_args_guid=arg_guid})
recv_getNoteTagNames ip = do
  T.readMessage ip $ \(fname, mtype, rseqid) -> do
    M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; X.throw exn }
    res <- read_GetNoteTagNames_result ip
    P.maybe (P.return ()) X.throw (getNoteTagNames_result_userException res)
    P.maybe (P.return ()) X.throw (getNoteTagNames_result_systemException res)
    P.maybe (P.return ()) X.throw (getNoteTagNames_result_notFoundException res)
    P.return $ getNoteTagNames_result_success res
createNote (ip,op) arg_authenticationToken arg_note = do
  send_createNote op arg_authenticationToken arg_note
  recv_createNote ip
send_createNote op arg_authenticationToken arg_note = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessage op ("createNote", T.M_CALL, seqn) $
    write_CreateNote_args op (CreateNote_args{createNote_args_authenticationToken=arg_authenticationToken,createNote_args_note=arg_note})
recv_createNote ip = do
  T.readMessage ip $ \(fname, mtype, rseqid) -> do
    M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; X.throw exn }
    res <- read_CreateNote_result ip
    P.maybe (P.return ()) X.throw (createNote_result_userException res)
    P.maybe (P.return ()) X.throw (createNote_result_systemException res)
    P.maybe (P.return ()) X.throw (createNote_result_notFoundException res)
    P.return $ createNote_result_success res
updateNote (ip,op) arg_authenticationToken arg_note = do
  send_updateNote op arg_authenticationToken arg_note
  recv_updateNote ip
send_updateNote op arg_authenticationToken arg_note = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessage op ("updateNote", T.M_CALL, seqn) $
    write_UpdateNote_args op (UpdateNote_args{updateNote_args_authenticationToken=arg_authenticationToken,updateNote_args_note=arg_note})
recv_updateNote ip = do
  T.readMessage ip $ \(fname, mtype, rseqid) -> do
    M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; X.throw exn }
    res <- read_UpdateNote_result ip
    P.maybe (P.return ()) X.throw (updateNote_result_userException res)
    P.maybe (P.return ()) X.throw (updateNote_result_systemException res)
    P.maybe (P.return ()) X.throw (updateNote_result_notFoundException res)
    P.return $ updateNote_result_success res
deleteNote (ip,op) arg_authenticationToken arg_guid = do
  send_deleteNote op arg_authenticationToken arg_guid
  recv_deleteNote ip
send_deleteNote op arg_authenticationToken arg_guid = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessage op ("deleteNote", T.M_CALL, seqn) $
    write_DeleteNote_args op (DeleteNote_args{deleteNote_args_authenticationToken=arg_authenticationToken,deleteNote_args_guid=arg_guid})
recv_deleteNote ip = do
  T.readMessage ip $ \(fname, mtype, rseqid) -> do
    M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; X.throw exn }
    res <- read_DeleteNote_result ip
    P.maybe (P.return ()) X.throw (deleteNote_result_userException res)
    P.maybe (P.return ()) X.throw (deleteNote_result_systemException res)
    P.maybe (P.return ()) X.throw (deleteNote_result_notFoundException res)
    P.return $ deleteNote_result_success res
expungeNote (ip,op) arg_authenticationToken arg_guid = do
  send_expungeNote op arg_authenticationToken arg_guid
  recv_expungeNote ip
send_expungeNote op arg_authenticationToken arg_guid = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessage op ("expungeNote", T.M_CALL, seqn) $
    write_ExpungeNote_args op (ExpungeNote_args{expungeNote_args_authenticationToken=arg_authenticationToken,expungeNote_args_guid=arg_guid})
recv_expungeNote ip = do
  T.readMessage ip $ \(fname, mtype, rseqid) -> do
    M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; X.throw exn }
    res <- read_ExpungeNote_result ip
    P.maybe (P.return ()) X.throw (expungeNote_result_userException res)
    P.maybe (P.return ()) X.throw (expungeNote_result_systemException res)
    P.maybe (P.return ()) X.throw (expungeNote_result_notFoundException res)
    P.return $ expungeNote_result_success res
copyNote (ip,op) arg_authenticationToken arg_noteGuid arg_toNotebookGuid = do
  send_copyNote op arg_authenticationToken arg_noteGuid arg_toNotebookGuid
  recv_copyNote ip
send_copyNote op arg_authenticationToken arg_noteGuid arg_toNotebookGuid = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessage op ("copyNote", T.M_CALL, seqn) $
    write_CopyNote_args op (CopyNote_args{copyNote_args_authenticationToken=arg_authenticationToken,copyNote_args_noteGuid=arg_noteGuid,copyNote_args_toNotebookGuid=arg_toNotebookGuid})
recv_copyNote ip = do
  T.readMessage ip $ \(fname, mtype, rseqid) -> do
    M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; X.throw exn }
    res <- read_CopyNote_result ip
    P.maybe (P.return ()) X.throw (copyNote_result_userException res)
    P.maybe (P.return ()) X.throw (copyNote_result_systemException res)
    P.maybe (P.return ()) X.throw (copyNote_result_notFoundException res)
    P.return $ copyNote_result_success res
listNoteVersions (ip,op) arg_authenticationToken arg_noteGuid = do
  send_listNoteVersions op arg_authenticationToken arg_noteGuid
  recv_listNoteVersions ip
send_listNoteVersions op arg_authenticationToken arg_noteGuid = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessage op ("listNoteVersions", T.M_CALL, seqn) $
    write_ListNoteVersions_args op (ListNoteVersions_args{listNoteVersions_args_authenticationToken=arg_authenticationToken,listNoteVersions_args_noteGuid=arg_noteGuid})
recv_listNoteVersions ip = do
  T.readMessage ip $ \(fname, mtype, rseqid) -> do
    M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; X.throw exn }
    res <- read_ListNoteVersions_result ip
    P.maybe (P.return ()) X.throw (listNoteVersions_result_userException res)
    P.maybe (P.return ()) X.throw (listNoteVersions_result_systemException res)
    P.maybe (P.return ()) X.throw (listNoteVersions_result_notFoundException res)
    P.return $ listNoteVersions_result_success res
getNoteVersion (ip,op) arg_authenticationToken arg_noteGuid arg_updateSequenceNum arg_withResourcesData arg_withResourcesRecognition arg_withResourcesAlternateData = do
  send_getNoteVersion op arg_authenticationToken arg_noteGuid arg_updateSequenceNum arg_withResourcesData arg_withResourcesRecognition arg_withResourcesAlternateData
  recv_getNoteVersion ip
send_getNoteVersion op arg_authenticationToken arg_noteGuid arg_updateSequenceNum arg_withResourcesData arg_withResourcesRecognition arg_withResourcesAlternateData = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessage op ("getNoteVersion", T.M_CALL, seqn) $
    write_GetNoteVersion_args op (GetNoteVersion_args{getNoteVersion_args_authenticationToken=arg_authenticationToken,getNoteVersion_args_noteGuid=arg_noteGuid,getNoteVersion_args_updateSequenceNum=arg_updateSequenceNum,getNoteVersion_args_withResourcesData=arg_withResourcesData,getNoteVersion_args_withResourcesRecognition=arg_withResourcesRecognition,getNoteVersion_args_withResourcesAlternateData=arg_withResourcesAlternateData})
recv_getNoteVersion ip = do
  T.readMessage ip $ \(fname, mtype, rseqid) -> do
    M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; X.throw exn }
    res <- read_GetNoteVersion_result ip
    P.maybe (P.return ()) X.throw (getNoteVersion_result_userException res)
    P.maybe (P.return ()) X.throw (getNoteVersion_result_systemException res)
    P.maybe (P.return ()) X.throw (getNoteVersion_result_notFoundException res)
    P.return $ getNoteVersion_result_success res
getResource (ip,op) arg_authenticationToken arg_guid arg_withData arg_withRecognition arg_withAttributes arg_withAlternateData = do
  send_getResource op arg_authenticationToken arg_guid arg_withData arg_withRecognition arg_withAttributes arg_withAlternateData
  recv_getResource ip
send_getResource op arg_authenticationToken arg_guid arg_withData arg_withRecognition arg_withAttributes arg_withAlternateData = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessage op ("getResource", T.M_CALL, seqn) $
    write_GetResource_args op (GetResource_args{getResource_args_authenticationToken=arg_authenticationToken,getResource_args_guid=arg_guid,getResource_args_withData=arg_withData,getResource_args_withRecognition=arg_withRecognition,getResource_args_withAttributes=arg_withAttributes,getResource_args_withAlternateData=arg_withAlternateData})
recv_getResource ip = do
  T.readMessage ip $ \(fname, mtype, rseqid) -> do
    M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; X.throw exn }
    res <- read_GetResource_result ip
    P.maybe (P.return ()) X.throw (getResource_result_userException res)
    P.maybe (P.return ()) X.throw (getResource_result_systemException res)
    P.maybe (P.return ()) X.throw (getResource_result_notFoundException res)
    P.return $ getResource_result_success res
getResourceApplicationData (ip,op) arg_authenticationToken arg_guid = do
  send_getResourceApplicationData op arg_authenticationToken arg_guid
  recv_getResourceApplicationData ip
send_getResourceApplicationData op arg_authenticationToken arg_guid = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessage op ("getResourceApplicationData", T.M_CALL, seqn) $
    write_GetResourceApplicationData_args op (GetResourceApplicationData_args{getResourceApplicationData_args_authenticationToken=arg_authenticationToken,getResourceApplicationData_args_guid=arg_guid})
recv_getResourceApplicationData ip = do
  T.readMessage ip $ \(fname, mtype, rseqid) -> do
    M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; X.throw exn }
    res <- read_GetResourceApplicationData_result ip
    P.maybe (P.return ()) X.throw (getResourceApplicationData_result_userException res)
    P.maybe (P.return ()) X.throw (getResourceApplicationData_result_systemException res)
    P.maybe (P.return ()) X.throw (getResourceApplicationData_result_notFoundException res)
    P.return $ getResourceApplicationData_result_success res
getResourceApplicationDataEntry (ip,op) arg_authenticationToken arg_guid arg_key = do
  send_getResourceApplicationDataEntry op arg_authenticationToken arg_guid arg_key
  recv_getResourceApplicationDataEntry ip
send_getResourceApplicationDataEntry op arg_authenticationToken arg_guid arg_key = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessage op ("getResourceApplicationDataEntry", T.M_CALL, seqn) $
    write_GetResourceApplicationDataEntry_args op (GetResourceApplicationDataEntry_args{getResourceApplicationDataEntry_args_authenticationToken=arg_authenticationToken,getResourceApplicationDataEntry_args_guid=arg_guid,getResourceApplicationDataEntry_args_key=arg_key})
recv_getResourceApplicationDataEntry ip = do
  T.readMessage ip $ \(fname, mtype, rseqid) -> do
    M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; X.throw exn }
    res <- read_GetResourceApplicationDataEntry_result ip
    P.maybe (P.return ()) X.throw (getResourceApplicationDataEntry_result_userException res)
    P.maybe (P.return ()) X.throw (getResourceApplicationDataEntry_result_systemException res)
    P.maybe (P.return ()) X.throw (getResourceApplicationDataEntry_result_notFoundException res)
    P.return $ getResourceApplicationDataEntry_result_success res
setResourceApplicationDataEntry (ip,op) arg_authenticationToken arg_guid arg_key arg_value = do
  send_setResourceApplicationDataEntry op arg_authenticationToken arg_guid arg_key arg_value
  recv_setResourceApplicationDataEntry ip
send_setResourceApplicationDataEntry op arg_authenticationToken arg_guid arg_key arg_value = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessage op ("setResourceApplicationDataEntry", T.M_CALL, seqn) $
    write_SetResourceApplicationDataEntry_args op (SetResourceApplicationDataEntry_args{setResourceApplicationDataEntry_args_authenticationToken=arg_authenticationToken,setResourceApplicationDataEntry_args_guid=arg_guid,setResourceApplicationDataEntry_args_key=arg_key,setResourceApplicationDataEntry_args_value=arg_value})
recv_setResourceApplicationDataEntry ip = do
  T.readMessage ip $ \(fname, mtype, rseqid) -> do
    M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; X.throw exn }
    res <- read_SetResourceApplicationDataEntry_result ip
    P.maybe (P.return ()) X.throw (setResourceApplicationDataEntry_result_userException res)
    P.maybe (P.return ()) X.throw (setResourceApplicationDataEntry_result_systemException res)
    P.maybe (P.return ()) X.throw (setResourceApplicationDataEntry_result_notFoundException res)
    P.return $ setResourceApplicationDataEntry_result_success res
unsetResourceApplicationDataEntry (ip,op) arg_authenticationToken arg_guid arg_key = do
  send_unsetResourceApplicationDataEntry op arg_authenticationToken arg_guid arg_key
  recv_unsetResourceApplicationDataEntry ip
send_unsetResourceApplicationDataEntry op arg_authenticationToken arg_guid arg_key = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessage op ("unsetResourceApplicationDataEntry", T.M_CALL, seqn) $
    write_UnsetResourceApplicationDataEntry_args op (UnsetResourceApplicationDataEntry_args{unsetResourceApplicationDataEntry_args_authenticationToken=arg_authenticationToken,unsetResourceApplicationDataEntry_args_guid=arg_guid,unsetResourceApplicationDataEntry_args_key=arg_key})
recv_unsetResourceApplicationDataEntry ip = do
  T.readMessage ip $ \(fname, mtype, rseqid) -> do
    M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; X.throw exn }
    res <- read_UnsetResourceApplicationDataEntry_result ip
    P.maybe (P.return ()) X.throw (unsetResourceApplicationDataEntry_result_userException res)
    P.maybe (P.return ()) X.throw (unsetResourceApplicationDataEntry_result_systemException res)
    P.maybe (P.return ()) X.throw (unsetResourceApplicationDataEntry_result_notFoundException res)
    P.return $ unsetResourceApplicationDataEntry_result_success res
updateResource (ip,op) arg_authenticationToken arg_resource = do
  send_updateResource op arg_authenticationToken arg_resource
  recv_updateResource ip
send_updateResource op arg_authenticationToken arg_resource = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessage op ("updateResource", T.M_CALL, seqn) $
    write_UpdateResource_args op (UpdateResource_args{updateResource_args_authenticationToken=arg_authenticationToken,updateResource_args_resource=arg_resource})
recv_updateResource ip = do
  T.readMessage ip $ \(fname, mtype, rseqid) -> do
    M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; X.throw exn }
    res <- read_UpdateResource_result ip
    P.maybe (P.return ()) X.throw (updateResource_result_userException res)
    P.maybe (P.return ()) X.throw (updateResource_result_systemException res)
    P.maybe (P.return ()) X.throw (updateResource_result_notFoundException res)
    P.return $ updateResource_result_success res
getResourceData (ip,op) arg_authenticationToken arg_guid = do
  send_getResourceData op arg_authenticationToken arg_guid
  recv_getResourceData ip
send_getResourceData op arg_authenticationToken arg_guid = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessage op ("getResourceData", T.M_CALL, seqn) $
    write_GetResourceData_args op (GetResourceData_args{getResourceData_args_authenticationToken=arg_authenticationToken,getResourceData_args_guid=arg_guid})
recv_getResourceData ip = do
  T.readMessage ip $ \(fname, mtype, rseqid) -> do
    M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; X.throw exn }
    res <- read_GetResourceData_result ip
    P.maybe (P.return ()) X.throw (getResourceData_result_userException res)
    P.maybe (P.return ()) X.throw (getResourceData_result_systemException res)
    P.maybe (P.return ()) X.throw (getResourceData_result_notFoundException res)
    P.return $ getResourceData_result_success res
getResourceByHash (ip,op) arg_authenticationToken arg_noteGuid arg_contentHash arg_withData arg_withRecognition arg_withAlternateData = do
  send_getResourceByHash op arg_authenticationToken arg_noteGuid arg_contentHash arg_withData arg_withRecognition arg_withAlternateData
  recv_getResourceByHash ip
send_getResourceByHash op arg_authenticationToken arg_noteGuid arg_contentHash arg_withData arg_withRecognition arg_withAlternateData = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessage op ("getResourceByHash", T.M_CALL, seqn) $
    write_GetResourceByHash_args op (GetResourceByHash_args{getResourceByHash_args_authenticationToken=arg_authenticationToken,getResourceByHash_args_noteGuid=arg_noteGuid,getResourceByHash_args_contentHash=arg_contentHash,getResourceByHash_args_withData=arg_withData,getResourceByHash_args_withRecognition=arg_withRecognition,getResourceByHash_args_withAlternateData=arg_withAlternateData})
recv_getResourceByHash ip = do
  T.readMessage ip $ \(fname, mtype, rseqid) -> do
    M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; X.throw exn }
    res <- read_GetResourceByHash_result ip
    P.maybe (P.return ()) X.throw (getResourceByHash_result_userException res)
    P.maybe (P.return ()) X.throw (getResourceByHash_result_systemException res)
    P.maybe (P.return ()) X.throw (getResourceByHash_result_notFoundException res)
    P.return $ getResourceByHash_result_success res
getResourceRecognition (ip,op) arg_authenticationToken arg_guid = do
  send_getResourceRecognition op arg_authenticationToken arg_guid
  recv_getResourceRecognition ip
send_getResourceRecognition op arg_authenticationToken arg_guid = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessage op ("getResourceRecognition", T.M_CALL, seqn) $
    write_GetResourceRecognition_args op (GetResourceRecognition_args{getResourceRecognition_args_authenticationToken=arg_authenticationToken,getResourceRecognition_args_guid=arg_guid})
recv_getResourceRecognition ip = do
  T.readMessage ip $ \(fname, mtype, rseqid) -> do
    M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; X.throw exn }
    res <- read_GetResourceRecognition_result ip
    P.maybe (P.return ()) X.throw (getResourceRecognition_result_userException res)
    P.maybe (P.return ()) X.throw (getResourceRecognition_result_systemException res)
    P.maybe (P.return ()) X.throw (getResourceRecognition_result_notFoundException res)
    P.return $ getResourceRecognition_result_success res
getResourceAlternateData (ip,op) arg_authenticationToken arg_guid = do
  send_getResourceAlternateData op arg_authenticationToken arg_guid
  recv_getResourceAlternateData ip
send_getResourceAlternateData op arg_authenticationToken arg_guid = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessage op ("getResourceAlternateData", T.M_CALL, seqn) $
    write_GetResourceAlternateData_args op (GetResourceAlternateData_args{getResourceAlternateData_args_authenticationToken=arg_authenticationToken,getResourceAlternateData_args_guid=arg_guid})
recv_getResourceAlternateData ip = do
  T.readMessage ip $ \(fname, mtype, rseqid) -> do
    M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; X.throw exn }
    res <- read_GetResourceAlternateData_result ip
    P.maybe (P.return ()) X.throw (getResourceAlternateData_result_userException res)
    P.maybe (P.return ()) X.throw (getResourceAlternateData_result_systemException res)
    P.maybe (P.return ()) X.throw (getResourceAlternateData_result_notFoundException res)
    P.return $ getResourceAlternateData_result_success res
getResourceAttributes (ip,op) arg_authenticationToken arg_guid = do
  send_getResourceAttributes op arg_authenticationToken arg_guid
  recv_getResourceAttributes ip
send_getResourceAttributes op arg_authenticationToken arg_guid = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessage op ("getResourceAttributes", T.M_CALL, seqn) $
    write_GetResourceAttributes_args op (GetResourceAttributes_args{getResourceAttributes_args_authenticationToken=arg_authenticationToken,getResourceAttributes_args_guid=arg_guid})
recv_getResourceAttributes ip = do
  T.readMessage ip $ \(fname, mtype, rseqid) -> do
    M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; X.throw exn }
    res <- read_GetResourceAttributes_result ip
    P.maybe (P.return ()) X.throw (getResourceAttributes_result_userException res)
    P.maybe (P.return ()) X.throw (getResourceAttributes_result_systemException res)
    P.maybe (P.return ()) X.throw (getResourceAttributes_result_notFoundException res)
    P.return $ getResourceAttributes_result_success res
getPublicNotebook (ip,op) arg_userId arg_publicUri = do
  send_getPublicNotebook op arg_userId arg_publicUri
  recv_getPublicNotebook ip
send_getPublicNotebook op arg_userId arg_publicUri = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessage op ("getPublicNotebook", T.M_CALL, seqn) $
    write_GetPublicNotebook_args op (GetPublicNotebook_args{getPublicNotebook_args_userId=arg_userId,getPublicNotebook_args_publicUri=arg_publicUri})
recv_getPublicNotebook ip = do
  T.readMessage ip $ \(fname, mtype, rseqid) -> do
    M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; X.throw exn }
    res <- read_GetPublicNotebook_result ip
    P.maybe (P.return ()) X.throw (getPublicNotebook_result_systemException res)
    P.maybe (P.return ()) X.throw (getPublicNotebook_result_notFoundException res)
    P.return $ getPublicNotebook_result_success res
shareNotebook (ip,op) arg_authenticationToken arg_sharedNotebook arg_message = do
  send_shareNotebook op arg_authenticationToken arg_sharedNotebook arg_message
  recv_shareNotebook ip
send_shareNotebook op arg_authenticationToken arg_sharedNotebook arg_message = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessage op ("shareNotebook", T.M_CALL, seqn) $
    write_ShareNotebook_args op (ShareNotebook_args{shareNotebook_args_authenticationToken=arg_authenticationToken,shareNotebook_args_sharedNotebook=arg_sharedNotebook,shareNotebook_args_message=arg_message})
recv_shareNotebook ip = do
  T.readMessage ip $ \(fname, mtype, rseqid) -> do
    M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; X.throw exn }
    res <- read_ShareNotebook_result ip
    P.maybe (P.return ()) X.throw (shareNotebook_result_userException res)
    P.maybe (P.return ()) X.throw (shareNotebook_result_notFoundException res)
    P.maybe (P.return ()) X.throw (shareNotebook_result_systemException res)
    P.return $ shareNotebook_result_success res
createOrUpdateNotebookShares (ip,op) arg_authenticationToken arg_shareTemplate = do
  send_createOrUpdateNotebookShares op arg_authenticationToken arg_shareTemplate
  recv_createOrUpdateNotebookShares ip
send_createOrUpdateNotebookShares op arg_authenticationToken arg_shareTemplate = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessage op ("createOrUpdateNotebookShares", T.M_CALL, seqn) $
    write_CreateOrUpdateNotebookShares_args op (CreateOrUpdateNotebookShares_args{createOrUpdateNotebookShares_args_authenticationToken=arg_authenticationToken,createOrUpdateNotebookShares_args_shareTemplate=arg_shareTemplate})
recv_createOrUpdateNotebookShares ip = do
  T.readMessage ip $ \(fname, mtype, rseqid) -> do
    M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; X.throw exn }
    res <- read_CreateOrUpdateNotebookShares_result ip
    P.maybe (P.return ()) X.throw (createOrUpdateNotebookShares_result_userException res)
    P.maybe (P.return ()) X.throw (createOrUpdateNotebookShares_result_notFoundException res)
    P.maybe (P.return ()) X.throw (createOrUpdateNotebookShares_result_systemException res)
    P.maybe (P.return ()) X.throw (createOrUpdateNotebookShares_result_invalidContactsException res)
    P.return $ createOrUpdateNotebookShares_result_success res
updateSharedNotebook (ip,op) arg_authenticationToken arg_sharedNotebook = do
  send_updateSharedNotebook op arg_authenticationToken arg_sharedNotebook
  recv_updateSharedNotebook ip
send_updateSharedNotebook op arg_authenticationToken arg_sharedNotebook = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessage op ("updateSharedNotebook", T.M_CALL, seqn) $
    write_UpdateSharedNotebook_args op (UpdateSharedNotebook_args{updateSharedNotebook_args_authenticationToken=arg_authenticationToken,updateSharedNotebook_args_sharedNotebook=arg_sharedNotebook})
recv_updateSharedNotebook ip = do
  T.readMessage ip $ \(fname, mtype, rseqid) -> do
    M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; X.throw exn }
    res <- read_UpdateSharedNotebook_result ip
    P.maybe (P.return ()) X.throw (updateSharedNotebook_result_userException res)
    P.maybe (P.return ()) X.throw (updateSharedNotebook_result_notFoundException res)
    P.maybe (P.return ()) X.throw (updateSharedNotebook_result_systemException res)
    P.return $ updateSharedNotebook_result_success res
setNotebookRecipientSettings (ip,op) arg_authenticationToken arg_notebookGuid arg_recipientSettings = do
  send_setNotebookRecipientSettings op arg_authenticationToken arg_notebookGuid arg_recipientSettings
  recv_setNotebookRecipientSettings ip
send_setNotebookRecipientSettings op arg_authenticationToken arg_notebookGuid arg_recipientSettings = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessage op ("setNotebookRecipientSettings", T.M_CALL, seqn) $
    write_SetNotebookRecipientSettings_args op (SetNotebookRecipientSettings_args{setNotebookRecipientSettings_args_authenticationToken=arg_authenticationToken,setNotebookRecipientSettings_args_notebookGuid=arg_notebookGuid,setNotebookRecipientSettings_args_recipientSettings=arg_recipientSettings})
recv_setNotebookRecipientSettings ip = do
  T.readMessage ip $ \(fname, mtype, rseqid) -> do
    M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; X.throw exn }
    res <- read_SetNotebookRecipientSettings_result ip
    P.maybe (P.return ()) X.throw (setNotebookRecipientSettings_result_userException res)
    P.maybe (P.return ()) X.throw (setNotebookRecipientSettings_result_notFoundException res)
    P.maybe (P.return ()) X.throw (setNotebookRecipientSettings_result_systemException res)
    P.return $ setNotebookRecipientSettings_result_success res
listSharedNotebooks (ip,op) arg_authenticationToken = do
  send_listSharedNotebooks op arg_authenticationToken
  recv_listSharedNotebooks ip
send_listSharedNotebooks op arg_authenticationToken = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessage op ("listSharedNotebooks", T.M_CALL, seqn) $
    write_ListSharedNotebooks_args op (ListSharedNotebooks_args{listSharedNotebooks_args_authenticationToken=arg_authenticationToken})
recv_listSharedNotebooks ip = do
  T.readMessage ip $ \(fname, mtype, rseqid) -> do
    M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; X.throw exn }
    res <- read_ListSharedNotebooks_result ip
    P.maybe (P.return ()) X.throw (listSharedNotebooks_result_userException res)
    P.maybe (P.return ()) X.throw (listSharedNotebooks_result_notFoundException res)
    P.maybe (P.return ()) X.throw (listSharedNotebooks_result_systemException res)
    P.return $ listSharedNotebooks_result_success res
createLinkedNotebook (ip,op) arg_authenticationToken arg_linkedNotebook = do
  send_createLinkedNotebook op arg_authenticationToken arg_linkedNotebook
  recv_createLinkedNotebook ip
send_createLinkedNotebook op arg_authenticationToken arg_linkedNotebook = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessage op ("createLinkedNotebook", T.M_CALL, seqn) $
    write_CreateLinkedNotebook_args op (CreateLinkedNotebook_args{createLinkedNotebook_args_authenticationToken=arg_authenticationToken,createLinkedNotebook_args_linkedNotebook=arg_linkedNotebook})
recv_createLinkedNotebook ip = do
  T.readMessage ip $ \(fname, mtype, rseqid) -> do
    M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; X.throw exn }
    res <- read_CreateLinkedNotebook_result ip
    P.maybe (P.return ()) X.throw (createLinkedNotebook_result_userException res)
    P.maybe (P.return ()) X.throw (createLinkedNotebook_result_notFoundException res)
    P.maybe (P.return ()) X.throw (createLinkedNotebook_result_systemException res)
    P.return $ createLinkedNotebook_result_success res
updateLinkedNotebook (ip,op) arg_authenticationToken arg_linkedNotebook = do
  send_updateLinkedNotebook op arg_authenticationToken arg_linkedNotebook
  recv_updateLinkedNotebook ip
send_updateLinkedNotebook op arg_authenticationToken arg_linkedNotebook = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessage op ("updateLinkedNotebook", T.M_CALL, seqn) $
    write_UpdateLinkedNotebook_args op (UpdateLinkedNotebook_args{updateLinkedNotebook_args_authenticationToken=arg_authenticationToken,updateLinkedNotebook_args_linkedNotebook=arg_linkedNotebook})
recv_updateLinkedNotebook ip = do
  T.readMessage ip $ \(fname, mtype, rseqid) -> do
    M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; X.throw exn }
    res <- read_UpdateLinkedNotebook_result ip
    P.maybe (P.return ()) X.throw (updateLinkedNotebook_result_userException res)
    P.maybe (P.return ()) X.throw (updateLinkedNotebook_result_notFoundException res)
    P.maybe (P.return ()) X.throw (updateLinkedNotebook_result_systemException res)
    P.return $ updateLinkedNotebook_result_success res
listLinkedNotebooks (ip,op) arg_authenticationToken = do
  send_listLinkedNotebooks op arg_authenticationToken
  recv_listLinkedNotebooks ip
send_listLinkedNotebooks op arg_authenticationToken = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessage op ("listLinkedNotebooks", T.M_CALL, seqn) $
    write_ListLinkedNotebooks_args op (ListLinkedNotebooks_args{listLinkedNotebooks_args_authenticationToken=arg_authenticationToken})
recv_listLinkedNotebooks ip = do
  T.readMessage ip $ \(fname, mtype, rseqid) -> do
    M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; X.throw exn }
    res <- read_ListLinkedNotebooks_result ip
    P.maybe (P.return ()) X.throw (listLinkedNotebooks_result_userException res)
    P.maybe (P.return ()) X.throw (listLinkedNotebooks_result_notFoundException res)
    P.maybe (P.return ()) X.throw (listLinkedNotebooks_result_systemException res)
    P.return $ listLinkedNotebooks_result_success res
expungeLinkedNotebook (ip,op) arg_authenticationToken arg_guid = do
  send_expungeLinkedNotebook op arg_authenticationToken arg_guid
  recv_expungeLinkedNotebook ip
send_expungeLinkedNotebook op arg_authenticationToken arg_guid = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessage op ("expungeLinkedNotebook", T.M_CALL, seqn) $
    write_ExpungeLinkedNotebook_args op (ExpungeLinkedNotebook_args{expungeLinkedNotebook_args_authenticationToken=arg_authenticationToken,expungeLinkedNotebook_args_guid=arg_guid})
recv_expungeLinkedNotebook ip = do
  T.readMessage ip $ \(fname, mtype, rseqid) -> do
    M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; X.throw exn }
    res <- read_ExpungeLinkedNotebook_result ip
    P.maybe (P.return ()) X.throw (expungeLinkedNotebook_result_userException res)
    P.maybe (P.return ()) X.throw (expungeLinkedNotebook_result_notFoundException res)
    P.maybe (P.return ()) X.throw (expungeLinkedNotebook_result_systemException res)
    P.return $ expungeLinkedNotebook_result_success res
authenticateToSharedNotebook (ip,op) arg_shareKeyOrGlobalId arg_authenticationToken = do
  send_authenticateToSharedNotebook op arg_shareKeyOrGlobalId arg_authenticationToken
  recv_authenticateToSharedNotebook ip
send_authenticateToSharedNotebook op arg_shareKeyOrGlobalId arg_authenticationToken = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessage op ("authenticateToSharedNotebook", T.M_CALL, seqn) $
    write_AuthenticateToSharedNotebook_args op (AuthenticateToSharedNotebook_args{authenticateToSharedNotebook_args_shareKeyOrGlobalId=arg_shareKeyOrGlobalId,authenticateToSharedNotebook_args_authenticationToken=arg_authenticationToken})
recv_authenticateToSharedNotebook ip = do
  T.readMessage ip $ \(fname, mtype, rseqid) -> do
    M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; X.throw exn }
    res <- read_AuthenticateToSharedNotebook_result ip
    P.maybe (P.return ()) X.throw (authenticateToSharedNotebook_result_userException res)
    P.maybe (P.return ()) X.throw (authenticateToSharedNotebook_result_notFoundException res)
    P.maybe (P.return ()) X.throw (authenticateToSharedNotebook_result_systemException res)
    P.return $ authenticateToSharedNotebook_result_success res
getSharedNotebookByAuth (ip,op) arg_authenticationToken = do
  send_getSharedNotebookByAuth op arg_authenticationToken
  recv_getSharedNotebookByAuth ip
send_getSharedNotebookByAuth op arg_authenticationToken = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessage op ("getSharedNotebookByAuth", T.M_CALL, seqn) $
    write_GetSharedNotebookByAuth_args op (GetSharedNotebookByAuth_args{getSharedNotebookByAuth_args_authenticationToken=arg_authenticationToken})
recv_getSharedNotebookByAuth ip = do
  T.readMessage ip $ \(fname, mtype, rseqid) -> do
    M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; X.throw exn }
    res <- read_GetSharedNotebookByAuth_result ip
    P.maybe (P.return ()) X.throw (getSharedNotebookByAuth_result_userException res)
    P.maybe (P.return ()) X.throw (getSharedNotebookByAuth_result_notFoundException res)
    P.maybe (P.return ()) X.throw (getSharedNotebookByAuth_result_systemException res)
    P.return $ getSharedNotebookByAuth_result_success res
emailNote (ip,op) arg_authenticationToken arg_parameters = do
  send_emailNote op arg_authenticationToken arg_parameters
  recv_emailNote ip
send_emailNote op arg_authenticationToken arg_parameters = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessage op ("emailNote", T.M_CALL, seqn) $
    write_EmailNote_args op (EmailNote_args{emailNote_args_authenticationToken=arg_authenticationToken,emailNote_args_parameters=arg_parameters})
recv_emailNote ip = do
  T.readMessage ip $ \(fname, mtype, rseqid) -> do
    M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; X.throw exn }
    res <- read_EmailNote_result ip
    P.maybe (P.return ()) X.throw (emailNote_result_userException res)
    P.maybe (P.return ()) X.throw (emailNote_result_notFoundException res)
    P.maybe (P.return ()) X.throw (emailNote_result_systemException res)
    P.return ()
shareNote (ip,op) arg_authenticationToken arg_guid = do
  send_shareNote op arg_authenticationToken arg_guid
  recv_shareNote ip
send_shareNote op arg_authenticationToken arg_guid = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessage op ("shareNote", T.M_CALL, seqn) $
    write_ShareNote_args op (ShareNote_args{shareNote_args_authenticationToken=arg_authenticationToken,shareNote_args_guid=arg_guid})
recv_shareNote ip = do
  T.readMessage ip $ \(fname, mtype, rseqid) -> do
    M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; X.throw exn }
    res <- read_ShareNote_result ip
    P.maybe (P.return ()) X.throw (shareNote_result_userException res)
    P.maybe (P.return ()) X.throw (shareNote_result_notFoundException res)
    P.maybe (P.return ()) X.throw (shareNote_result_systemException res)
    P.return $ shareNote_result_success res
stopSharingNote (ip,op) arg_authenticationToken arg_guid = do
  send_stopSharingNote op arg_authenticationToken arg_guid
  recv_stopSharingNote ip
send_stopSharingNote op arg_authenticationToken arg_guid = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessage op ("stopSharingNote", T.M_CALL, seqn) $
    write_StopSharingNote_args op (StopSharingNote_args{stopSharingNote_args_authenticationToken=arg_authenticationToken,stopSharingNote_args_guid=arg_guid})
recv_stopSharingNote ip = do
  T.readMessage ip $ \(fname, mtype, rseqid) -> do
    M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; X.throw exn }
    res <- read_StopSharingNote_result ip
    P.maybe (P.return ()) X.throw (stopSharingNote_result_userException res)
    P.maybe (P.return ()) X.throw (stopSharingNote_result_notFoundException res)
    P.maybe (P.return ()) X.throw (stopSharingNote_result_systemException res)
    P.return ()
authenticateToSharedNote (ip,op) arg_guid arg_noteKey arg_authenticationToken = do
  send_authenticateToSharedNote op arg_guid arg_noteKey arg_authenticationToken
  recv_authenticateToSharedNote ip
send_authenticateToSharedNote op arg_guid arg_noteKey arg_authenticationToken = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessage op ("authenticateToSharedNote", T.M_CALL, seqn) $
    write_AuthenticateToSharedNote_args op (AuthenticateToSharedNote_args{authenticateToSharedNote_args_guid=arg_guid,authenticateToSharedNote_args_noteKey=arg_noteKey,authenticateToSharedNote_args_authenticationToken=arg_authenticationToken})
recv_authenticateToSharedNote ip = do
  T.readMessage ip $ \(fname, mtype, rseqid) -> do
    M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; X.throw exn }
    res <- read_AuthenticateToSharedNote_result ip
    P.maybe (P.return ()) X.throw (authenticateToSharedNote_result_userException res)
    P.maybe (P.return ()) X.throw (authenticateToSharedNote_result_notFoundException res)
    P.maybe (P.return ()) X.throw (authenticateToSharedNote_result_systemException res)
    P.return $ authenticateToSharedNote_result_success res
findRelated (ip,op) arg_authenticationToken arg_query arg_resultSpec = do
  send_findRelated op arg_authenticationToken arg_query arg_resultSpec
  recv_findRelated ip
send_findRelated op arg_authenticationToken arg_query arg_resultSpec = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessage op ("findRelated", T.M_CALL, seqn) $
    write_FindRelated_args op (FindRelated_args{findRelated_args_authenticationToken=arg_authenticationToken,findRelated_args_query=arg_query,findRelated_args_resultSpec=arg_resultSpec})
recv_findRelated ip = do
  T.readMessage ip $ \(fname, mtype, rseqid) -> do
    M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; X.throw exn }
    res <- read_FindRelated_result ip
    P.maybe (P.return ()) X.throw (findRelated_result_userException res)
    P.maybe (P.return ()) X.throw (findRelated_result_systemException res)
    P.maybe (P.return ()) X.throw (findRelated_result_notFoundException res)
    P.return $ findRelated_result_success res
updateNoteIfUsnMatches (ip,op) arg_authenticationToken arg_note = do
  send_updateNoteIfUsnMatches op arg_authenticationToken arg_note
  recv_updateNoteIfUsnMatches ip
send_updateNoteIfUsnMatches op arg_authenticationToken arg_note = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessage op ("updateNoteIfUsnMatches", T.M_CALL, seqn) $
    write_UpdateNoteIfUsnMatches_args op (UpdateNoteIfUsnMatches_args{updateNoteIfUsnMatches_args_authenticationToken=arg_authenticationToken,updateNoteIfUsnMatches_args_note=arg_note})
recv_updateNoteIfUsnMatches ip = do
  T.readMessage ip $ \(fname, mtype, rseqid) -> do
    M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; X.throw exn }
    res <- read_UpdateNoteIfUsnMatches_result ip
    P.maybe (P.return ()) X.throw (updateNoteIfUsnMatches_result_userException res)
    P.maybe (P.return ()) X.throw (updateNoteIfUsnMatches_result_notFoundException res)
    P.maybe (P.return ()) X.throw (updateNoteIfUsnMatches_result_systemException res)
    P.return $ updateNoteIfUsnMatches_result_success res
manageNotebookShares (ip,op) arg_authenticationToken arg_parameters = do
  send_manageNotebookShares op arg_authenticationToken arg_parameters
  recv_manageNotebookShares ip
send_manageNotebookShares op arg_authenticationToken arg_parameters = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessage op ("manageNotebookShares", T.M_CALL, seqn) $
    write_ManageNotebookShares_args op (ManageNotebookShares_args{manageNotebookShares_args_authenticationToken=arg_authenticationToken,manageNotebookShares_args_parameters=arg_parameters})
recv_manageNotebookShares ip = do
  T.readMessage ip $ \(fname, mtype, rseqid) -> do
    M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; X.throw exn }
    res <- read_ManageNotebookShares_result ip
    P.maybe (P.return ()) X.throw (manageNotebookShares_result_userException res)
    P.maybe (P.return ()) X.throw (manageNotebookShares_result_notFoundException res)
    P.maybe (P.return ()) X.throw (manageNotebookShares_result_systemException res)
    P.return $ manageNotebookShares_result_success res
getNotebookShares (ip,op) arg_authenticationToken arg_notebookGuid = do
  send_getNotebookShares op arg_authenticationToken arg_notebookGuid
  recv_getNotebookShares ip
send_getNotebookShares op arg_authenticationToken arg_notebookGuid = do
  seq <- seqid
  seqn <- R.readIORef seq
  T.writeMessage op ("getNotebookShares", T.M_CALL, seqn) $
    write_GetNotebookShares_args op (GetNotebookShares_args{getNotebookShares_args_authenticationToken=arg_authenticationToken,getNotebookShares_args_notebookGuid=arg_notebookGuid})
recv_getNotebookShares ip = do
  T.readMessage ip $ \(fname, mtype, rseqid) -> do
    M.when (mtype == T.M_EXCEPTION) $ do { exn <- T.readAppExn ip ; X.throw exn }
    res <- read_GetNotebookShares_result ip
    P.maybe (P.return ()) X.throw (getNotebookShares_result_userException res)
    P.maybe (P.return ()) X.throw (getNotebookShares_result_notFoundException res)
    P.maybe (P.return ()) X.throw (getNotebookShares_result_systemException res)
    P.return $ getNotebookShares_result_success res
