{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-missing-fields #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-----------------------------------------------------------------
-- Autogenerated by Thrift Compiler (0.11.0)                      --
--                                                             --
-- DO NOT EDIT UNLESS YOU ARE SURE YOU KNOW WHAT YOU ARE DOING --
-----------------------------------------------------------------

module NoteStore_Types where
import Prelude (($), (.), (>>=), (==), (++))
import qualified Prelude as P
import qualified Control.Exception as X
import qualified Control.Monad as M ( liftM, ap, when )
import Data.Functor ( (<$>) )
import qualified Data.ByteString.Lazy as LBS
import qualified Data.Hashable as H
import qualified Data.Int as I
import qualified Data.Maybe as M (catMaybes)
import qualified Data.Text.Lazy.Encoding as E ( decodeUtf8, encodeUtf8 )
import qualified Data.Text.Lazy as LT
import qualified GHC.Generics as G (Generic)
import qualified Data.Typeable as TY ( Typeable )
import qualified Data.HashMap.Strict as Map
import qualified Data.HashSet as Set
import qualified Data.Vector as Vector
import qualified Test.QuickCheck.Arbitrary as QC ( Arbitrary(..) )
import qualified Test.QuickCheck as QC ( elements )

import qualified Thrift as T
import qualified Thrift.Types as T
import qualified Thrift.Arbitraries as T

import qualified UserStore_Types
import qualified Types_Types
import qualified Errors_Types
import qualified Limits_Types


data ShareRelationshipPrivilegeLevel = READ_NOTEBOOK|READ_NOTEBOOK_PLUS_ACTIVITY|MODIFY_NOTEBOOK_PLUS_ACTIVITY|FULL_ACCESS  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum ShareRelationshipPrivilegeLevel where
  fromEnum t = case t of
    READ_NOTEBOOK -> 0
    READ_NOTEBOOK_PLUS_ACTIVITY -> 10
    MODIFY_NOTEBOOK_PLUS_ACTIVITY -> 20
    FULL_ACCESS -> 30
  toEnum t = case t of
    0 -> READ_NOTEBOOK
    10 -> READ_NOTEBOOK_PLUS_ACTIVITY
    20 -> MODIFY_NOTEBOOK_PLUS_ACTIVITY
    30 -> FULL_ACCESS
    _ -> X.throw T.ThriftException
instance H.Hashable ShareRelationshipPrivilegeLevel where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary ShareRelationshipPrivilegeLevel where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data SyncState = SyncState  { syncState_currentTime :: I.Int64
  , syncState_fullSyncBefore :: I.Int64
  , syncState_updateCount :: I.Int32
  , syncState_uploaded :: P.Maybe I.Int64
  , syncState_userLastUpdated :: P.Maybe I.Int64
  , syncState_userMaxMessageEventId :: P.Maybe I.Int64
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SyncState where
  hashWithSalt salt record = salt   `H.hashWithSalt` syncState_currentTime record   `H.hashWithSalt` syncState_fullSyncBefore record   `H.hashWithSalt` syncState_updateCount record   `H.hashWithSalt` syncState_uploaded record   `H.hashWithSalt` syncState_userLastUpdated record   `H.hashWithSalt` syncState_userMaxMessageEventId record  
instance QC.Arbitrary SyncState where 
  arbitrary = M.liftM SyncState (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_SyncState = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SyncState{syncState_currentTime = syncState_currentTime obj} then P.Nothing else P.Just $ default_SyncState{syncState_currentTime = syncState_currentTime obj}
    , if obj == default_SyncState{syncState_fullSyncBefore = syncState_fullSyncBefore obj} then P.Nothing else P.Just $ default_SyncState{syncState_fullSyncBefore = syncState_fullSyncBefore obj}
    , if obj == default_SyncState{syncState_updateCount = syncState_updateCount obj} then P.Nothing else P.Just $ default_SyncState{syncState_updateCount = syncState_updateCount obj}
    , if obj == default_SyncState{syncState_uploaded = syncState_uploaded obj} then P.Nothing else P.Just $ default_SyncState{syncState_uploaded = syncState_uploaded obj}
    , if obj == default_SyncState{syncState_userLastUpdated = syncState_userLastUpdated obj} then P.Nothing else P.Just $ default_SyncState{syncState_userLastUpdated = syncState_userLastUpdated obj}
    , if obj == default_SyncState{syncState_userMaxMessageEventId = syncState_userMaxMessageEventId obj} then P.Nothing else P.Just $ default_SyncState{syncState_userMaxMessageEventId = syncState_userMaxMessageEventId obj}
    ]
from_SyncState :: SyncState -> T.ThriftVal
from_SyncState record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2 -> P.Just (1, ("currentTime",T.TI64 _v2))) $ syncState_currentTime record
  , (\_v2 -> P.Just (2, ("fullSyncBefore",T.TI64 _v2))) $ syncState_fullSyncBefore record
  , (\_v2 -> P.Just (3, ("updateCount",T.TI32 _v2))) $ syncState_updateCount record
  , (\_v2 -> (4, ("uploaded",T.TI64 _v2))) <$> syncState_uploaded record
  , (\_v2 -> (5, ("userLastUpdated",T.TI64 _v2))) <$> syncState_userLastUpdated record
  , (\_v2 -> (6, ("userMaxMessageEventId",T.TI64 _v2))) <$> syncState_userMaxMessageEventId record
  ]
write_SyncState :: T.Protocol p => p -> SyncState -> P.IO ()
write_SyncState oprot record = T.writeVal oprot $ from_SyncState record
encode_SyncState :: T.StatelessProtocol p => p -> SyncState -> LBS.ByteString
encode_SyncState oprot record = T.serializeVal oprot $ from_SyncState record
to_SyncState :: T.ThriftVal -> SyncState
to_SyncState (T.TStruct fields) = SyncState{
  syncState_currentTime = P.maybe (P.error "Missing required field: currentTime") (\(_,_val4) -> (case _val4 of {T.TI64 _val5 -> _val5; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  syncState_fullSyncBefore = P.maybe (P.error "Missing required field: fullSyncBefore") (\(_,_val4) -> (case _val4 of {T.TI64 _val6 -> _val6; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  syncState_updateCount = P.maybe (P.error "Missing required field: updateCount") (\(_,_val4) -> (case _val4 of {T.TI32 _val7 -> _val7; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  syncState_uploaded = P.maybe (P.Nothing) (\(_,_val4) -> P.Just (case _val4 of {T.TI64 _val8 -> _val8; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  syncState_userLastUpdated = P.maybe (P.Nothing) (\(_,_val4) -> P.Just (case _val4 of {T.TI64 _val9 -> _val9; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  syncState_userMaxMessageEventId = P.maybe (P.Nothing) (\(_,_val4) -> P.Just (case _val4 of {T.TI64 _val10 -> _val10; _ -> P.error "wrong type"})) (Map.lookup (6) fields)
  }
to_SyncState _ = P.error "not a struct"
read_SyncState :: T.Protocol p => p -> P.IO SyncState
read_SyncState iprot = to_SyncState <$> T.readVal iprot (T.T_STRUCT typemap_SyncState)
decode_SyncState :: T.StatelessProtocol p => p -> LBS.ByteString -> SyncState
decode_SyncState iprot bs = to_SyncState $ T.deserializeVal iprot (T.T_STRUCT typemap_SyncState) bs
typemap_SyncState :: T.TypeMap
typemap_SyncState = Map.fromList [(1,("currentTime",T.T_I64)),(2,("fullSyncBefore",T.T_I64)),(3,("updateCount",T.T_I32)),(4,("uploaded",T.T_I64)),(5,("userLastUpdated",T.T_I64)),(6,("userMaxMessageEventId",T.T_I64))]
default_SyncState :: SyncState
default_SyncState = SyncState{
  syncState_currentTime = 0,
  syncState_fullSyncBefore = 0,
  syncState_updateCount = 0,
  syncState_uploaded = P.Nothing,
  syncState_userLastUpdated = P.Nothing,
  syncState_userMaxMessageEventId = P.Nothing}
data SyncChunk = SyncChunk  { syncChunk_currentTime :: I.Int64
  , syncChunk_chunkHighUSN :: P.Maybe I.Int32
  , syncChunk_updateCount :: I.Int32
  , syncChunk_notes :: P.Maybe (Vector.Vector Types_Types.Note)
  , syncChunk_notebooks :: P.Maybe (Vector.Vector Types_Types.Notebook)
  , syncChunk_tags :: P.Maybe (Vector.Vector Types_Types.Tag)
  , syncChunk_searches :: P.Maybe (Vector.Vector Types_Types.SavedSearch)
  , syncChunk_resources :: P.Maybe (Vector.Vector Types_Types.Resource)
  , syncChunk_expungedNotes :: P.Maybe (Vector.Vector LT.Text)
  , syncChunk_expungedNotebooks :: P.Maybe (Vector.Vector LT.Text)
  , syncChunk_expungedTags :: P.Maybe (Vector.Vector LT.Text)
  , syncChunk_expungedSearches :: P.Maybe (Vector.Vector LT.Text)
  , syncChunk_linkedNotebooks :: P.Maybe (Vector.Vector Types_Types.LinkedNotebook)
  , syncChunk_expungedLinkedNotebooks :: P.Maybe (Vector.Vector LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SyncChunk where
  hashWithSalt salt record = salt   `H.hashWithSalt` syncChunk_currentTime record   `H.hashWithSalt` syncChunk_chunkHighUSN record   `H.hashWithSalt` syncChunk_updateCount record   `H.hashWithSalt` syncChunk_notes record   `H.hashWithSalt` syncChunk_notebooks record   `H.hashWithSalt` syncChunk_tags record   `H.hashWithSalt` syncChunk_searches record   `H.hashWithSalt` syncChunk_resources record   `H.hashWithSalt` syncChunk_expungedNotes record   `H.hashWithSalt` syncChunk_expungedNotebooks record   `H.hashWithSalt` syncChunk_expungedTags record   `H.hashWithSalt` syncChunk_expungedSearches record   `H.hashWithSalt` syncChunk_linkedNotebooks record   `H.hashWithSalt` syncChunk_expungedLinkedNotebooks record  
instance QC.Arbitrary SyncChunk where 
  arbitrary = M.liftM SyncChunk (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_SyncChunk = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SyncChunk{syncChunk_currentTime = syncChunk_currentTime obj} then P.Nothing else P.Just $ default_SyncChunk{syncChunk_currentTime = syncChunk_currentTime obj}
    , if obj == default_SyncChunk{syncChunk_chunkHighUSN = syncChunk_chunkHighUSN obj} then P.Nothing else P.Just $ default_SyncChunk{syncChunk_chunkHighUSN = syncChunk_chunkHighUSN obj}
    , if obj == default_SyncChunk{syncChunk_updateCount = syncChunk_updateCount obj} then P.Nothing else P.Just $ default_SyncChunk{syncChunk_updateCount = syncChunk_updateCount obj}
    , if obj == default_SyncChunk{syncChunk_notes = syncChunk_notes obj} then P.Nothing else P.Just $ default_SyncChunk{syncChunk_notes = syncChunk_notes obj}
    , if obj == default_SyncChunk{syncChunk_notebooks = syncChunk_notebooks obj} then P.Nothing else P.Just $ default_SyncChunk{syncChunk_notebooks = syncChunk_notebooks obj}
    , if obj == default_SyncChunk{syncChunk_tags = syncChunk_tags obj} then P.Nothing else P.Just $ default_SyncChunk{syncChunk_tags = syncChunk_tags obj}
    , if obj == default_SyncChunk{syncChunk_searches = syncChunk_searches obj} then P.Nothing else P.Just $ default_SyncChunk{syncChunk_searches = syncChunk_searches obj}
    , if obj == default_SyncChunk{syncChunk_resources = syncChunk_resources obj} then P.Nothing else P.Just $ default_SyncChunk{syncChunk_resources = syncChunk_resources obj}
    , if obj == default_SyncChunk{syncChunk_expungedNotes = syncChunk_expungedNotes obj} then P.Nothing else P.Just $ default_SyncChunk{syncChunk_expungedNotes = syncChunk_expungedNotes obj}
    , if obj == default_SyncChunk{syncChunk_expungedNotebooks = syncChunk_expungedNotebooks obj} then P.Nothing else P.Just $ default_SyncChunk{syncChunk_expungedNotebooks = syncChunk_expungedNotebooks obj}
    , if obj == default_SyncChunk{syncChunk_expungedTags = syncChunk_expungedTags obj} then P.Nothing else P.Just $ default_SyncChunk{syncChunk_expungedTags = syncChunk_expungedTags obj}
    , if obj == default_SyncChunk{syncChunk_expungedSearches = syncChunk_expungedSearches obj} then P.Nothing else P.Just $ default_SyncChunk{syncChunk_expungedSearches = syncChunk_expungedSearches obj}
    , if obj == default_SyncChunk{syncChunk_linkedNotebooks = syncChunk_linkedNotebooks obj} then P.Nothing else P.Just $ default_SyncChunk{syncChunk_linkedNotebooks = syncChunk_linkedNotebooks obj}
    , if obj == default_SyncChunk{syncChunk_expungedLinkedNotebooks = syncChunk_expungedLinkedNotebooks obj} then P.Nothing else P.Just $ default_SyncChunk{syncChunk_expungedLinkedNotebooks = syncChunk_expungedLinkedNotebooks obj}
    ]
from_SyncChunk :: SyncChunk -> T.ThriftVal
from_SyncChunk record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v13 -> P.Just (1, ("currentTime",T.TI64 _v13))) $ syncChunk_currentTime record
  , (\_v13 -> (2, ("chunkHighUSN",T.TI32 _v13))) <$> syncChunk_chunkHighUSN record
  , (\_v13 -> P.Just (3, ("updateCount",T.TI32 _v13))) $ syncChunk_updateCount record
  , (\_v13 -> (4, ("notes",T.TList (T.T_STRUCT Types_Types.typemap_Note) $ P.map (\_v15 -> Types_Types.from_Note _v15) $ Vector.toList _v13))) <$> syncChunk_notes record
  , (\_v13 -> (5, ("notebooks",T.TList (T.T_STRUCT Types_Types.typemap_Notebook) $ P.map (\_v17 -> Types_Types.from_Notebook _v17) $ Vector.toList _v13))) <$> syncChunk_notebooks record
  , (\_v13 -> (6, ("tags",T.TList (T.T_STRUCT Types_Types.typemap_Tag) $ P.map (\_v19 -> Types_Types.from_Tag _v19) $ Vector.toList _v13))) <$> syncChunk_tags record
  , (\_v13 -> (7, ("searches",T.TList (T.T_STRUCT Types_Types.typemap_SavedSearch) $ P.map (\_v21 -> Types_Types.from_SavedSearch _v21) $ Vector.toList _v13))) <$> syncChunk_searches record
  , (\_v13 -> (8, ("resources",T.TList (T.T_STRUCT Types_Types.typemap_Resource) $ P.map (\_v23 -> Types_Types.from_Resource _v23) $ Vector.toList _v13))) <$> syncChunk_resources record
  , (\_v13 -> (9, ("expungedNotes",T.TList T.T_STRING $ P.map (\_v25 -> T.TString $ E.encodeUtf8 _v25) $ Vector.toList _v13))) <$> syncChunk_expungedNotes record
  , (\_v13 -> (10, ("expungedNotebooks",T.TList T.T_STRING $ P.map (\_v27 -> T.TString $ E.encodeUtf8 _v27) $ Vector.toList _v13))) <$> syncChunk_expungedNotebooks record
  , (\_v13 -> (11, ("expungedTags",T.TList T.T_STRING $ P.map (\_v29 -> T.TString $ E.encodeUtf8 _v29) $ Vector.toList _v13))) <$> syncChunk_expungedTags record
  , (\_v13 -> (12, ("expungedSearches",T.TList T.T_STRING $ P.map (\_v31 -> T.TString $ E.encodeUtf8 _v31) $ Vector.toList _v13))) <$> syncChunk_expungedSearches record
  , (\_v13 -> (13, ("linkedNotebooks",T.TList (T.T_STRUCT Types_Types.typemap_LinkedNotebook) $ P.map (\_v33 -> Types_Types.from_LinkedNotebook _v33) $ Vector.toList _v13))) <$> syncChunk_linkedNotebooks record
  , (\_v13 -> (14, ("expungedLinkedNotebooks",T.TList T.T_STRING $ P.map (\_v35 -> T.TString $ E.encodeUtf8 _v35) $ Vector.toList _v13))) <$> syncChunk_expungedLinkedNotebooks record
  ]
write_SyncChunk :: T.Protocol p => p -> SyncChunk -> P.IO ()
write_SyncChunk oprot record = T.writeVal oprot $ from_SyncChunk record
encode_SyncChunk :: T.StatelessProtocol p => p -> SyncChunk -> LBS.ByteString
encode_SyncChunk oprot record = T.serializeVal oprot $ from_SyncChunk record
to_SyncChunk :: T.ThriftVal -> SyncChunk
to_SyncChunk (T.TStruct fields) = SyncChunk{
  syncChunk_currentTime = P.maybe (P.error "Missing required field: currentTime") (\(_,_val37) -> (case _val37 of {T.TI64 _val38 -> _val38; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  syncChunk_chunkHighUSN = P.maybe (P.Nothing) (\(_,_val37) -> P.Just (case _val37 of {T.TI32 _val39 -> _val39; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  syncChunk_updateCount = P.maybe (P.error "Missing required field: updateCount") (\(_,_val37) -> (case _val37 of {T.TI32 _val40 -> _val40; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  syncChunk_notes = P.maybe (P.Nothing) (\(_,_val37) -> P.Just (case _val37 of {T.TList _ _val41 -> (Vector.fromList $ P.map (\_v42 -> (case _v42 of {T.TStruct _val43 -> (Types_Types.to_Note (T.TStruct _val43)); _ -> P.error "wrong type"})) _val41); _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  syncChunk_notebooks = P.maybe (P.Nothing) (\(_,_val37) -> P.Just (case _val37 of {T.TList _ _val44 -> (Vector.fromList $ P.map (\_v45 -> (case _v45 of {T.TStruct _val46 -> (Types_Types.to_Notebook (T.TStruct _val46)); _ -> P.error "wrong type"})) _val44); _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  syncChunk_tags = P.maybe (P.Nothing) (\(_,_val37) -> P.Just (case _val37 of {T.TList _ _val47 -> (Vector.fromList $ P.map (\_v48 -> (case _v48 of {T.TStruct _val49 -> (Types_Types.to_Tag (T.TStruct _val49)); _ -> P.error "wrong type"})) _val47); _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  syncChunk_searches = P.maybe (P.Nothing) (\(_,_val37) -> P.Just (case _val37 of {T.TList _ _val50 -> (Vector.fromList $ P.map (\_v51 -> (case _v51 of {T.TStruct _val52 -> (Types_Types.to_SavedSearch (T.TStruct _val52)); _ -> P.error "wrong type"})) _val50); _ -> P.error "wrong type"})) (Map.lookup (7) fields),
  syncChunk_resources = P.maybe (P.Nothing) (\(_,_val37) -> P.Just (case _val37 of {T.TList _ _val53 -> (Vector.fromList $ P.map (\_v54 -> (case _v54 of {T.TStruct _val55 -> (Types_Types.to_Resource (T.TStruct _val55)); _ -> P.error "wrong type"})) _val53); _ -> P.error "wrong type"})) (Map.lookup (8) fields),
  syncChunk_expungedNotes = P.maybe (P.Nothing) (\(_,_val37) -> P.Just (case _val37 of {T.TList _ _val56 -> (Vector.fromList $ P.map (\_v57 -> (case _v57 of {T.TString _val58 -> E.decodeUtf8 _val58; _ -> P.error "wrong type"})) _val56); _ -> P.error "wrong type"})) (Map.lookup (9) fields),
  syncChunk_expungedNotebooks = P.maybe (P.Nothing) (\(_,_val37) -> P.Just (case _val37 of {T.TList _ _val59 -> (Vector.fromList $ P.map (\_v60 -> (case _v60 of {T.TString _val61 -> E.decodeUtf8 _val61; _ -> P.error "wrong type"})) _val59); _ -> P.error "wrong type"})) (Map.lookup (10) fields),
  syncChunk_expungedTags = P.maybe (P.Nothing) (\(_,_val37) -> P.Just (case _val37 of {T.TList _ _val62 -> (Vector.fromList $ P.map (\_v63 -> (case _v63 of {T.TString _val64 -> E.decodeUtf8 _val64; _ -> P.error "wrong type"})) _val62); _ -> P.error "wrong type"})) (Map.lookup (11) fields),
  syncChunk_expungedSearches = P.maybe (P.Nothing) (\(_,_val37) -> P.Just (case _val37 of {T.TList _ _val65 -> (Vector.fromList $ P.map (\_v66 -> (case _v66 of {T.TString _val67 -> E.decodeUtf8 _val67; _ -> P.error "wrong type"})) _val65); _ -> P.error "wrong type"})) (Map.lookup (12) fields),
  syncChunk_linkedNotebooks = P.maybe (P.Nothing) (\(_,_val37) -> P.Just (case _val37 of {T.TList _ _val68 -> (Vector.fromList $ P.map (\_v69 -> (case _v69 of {T.TStruct _val70 -> (Types_Types.to_LinkedNotebook (T.TStruct _val70)); _ -> P.error "wrong type"})) _val68); _ -> P.error "wrong type"})) (Map.lookup (13) fields),
  syncChunk_expungedLinkedNotebooks = P.maybe (P.Nothing) (\(_,_val37) -> P.Just (case _val37 of {T.TList _ _val71 -> (Vector.fromList $ P.map (\_v72 -> (case _v72 of {T.TString _val73 -> E.decodeUtf8 _val73; _ -> P.error "wrong type"})) _val71); _ -> P.error "wrong type"})) (Map.lookup (14) fields)
  }
to_SyncChunk _ = P.error "not a struct"
read_SyncChunk :: T.Protocol p => p -> P.IO SyncChunk
read_SyncChunk iprot = to_SyncChunk <$> T.readVal iprot (T.T_STRUCT typemap_SyncChunk)
decode_SyncChunk :: T.StatelessProtocol p => p -> LBS.ByteString -> SyncChunk
decode_SyncChunk iprot bs = to_SyncChunk $ T.deserializeVal iprot (T.T_STRUCT typemap_SyncChunk) bs
typemap_SyncChunk :: T.TypeMap
typemap_SyncChunk = Map.fromList [(1,("currentTime",T.T_I64)),(2,("chunkHighUSN",T.T_I32)),(3,("updateCount",T.T_I32)),(4,("notes",(T.T_LIST (T.T_STRUCT Types_Types.typemap_Note)))),(5,("notebooks",(T.T_LIST (T.T_STRUCT Types_Types.typemap_Notebook)))),(6,("tags",(T.T_LIST (T.T_STRUCT Types_Types.typemap_Tag)))),(7,("searches",(T.T_LIST (T.T_STRUCT Types_Types.typemap_SavedSearch)))),(8,("resources",(T.T_LIST (T.T_STRUCT Types_Types.typemap_Resource)))),(9,("expungedNotes",(T.T_LIST T.T_STRING))),(10,("expungedNotebooks",(T.T_LIST T.T_STRING))),(11,("expungedTags",(T.T_LIST T.T_STRING))),(12,("expungedSearches",(T.T_LIST T.T_STRING))),(13,("linkedNotebooks",(T.T_LIST (T.T_STRUCT Types_Types.typemap_LinkedNotebook)))),(14,("expungedLinkedNotebooks",(T.T_LIST T.T_STRING)))]
default_SyncChunk :: SyncChunk
default_SyncChunk = SyncChunk{
  syncChunk_currentTime = 0,
  syncChunk_chunkHighUSN = P.Nothing,
  syncChunk_updateCount = 0,
  syncChunk_notes = P.Nothing,
  syncChunk_notebooks = P.Nothing,
  syncChunk_tags = P.Nothing,
  syncChunk_searches = P.Nothing,
  syncChunk_resources = P.Nothing,
  syncChunk_expungedNotes = P.Nothing,
  syncChunk_expungedNotebooks = P.Nothing,
  syncChunk_expungedTags = P.Nothing,
  syncChunk_expungedSearches = P.Nothing,
  syncChunk_linkedNotebooks = P.Nothing,
  syncChunk_expungedLinkedNotebooks = P.Nothing}
data SyncChunkFilter = SyncChunkFilter  { syncChunkFilter_includeNotes :: P.Maybe P.Bool
  , syncChunkFilter_includeNoteResources :: P.Maybe P.Bool
  , syncChunkFilter_includeNoteAttributes :: P.Maybe P.Bool
  , syncChunkFilter_includeNotebooks :: P.Maybe P.Bool
  , syncChunkFilter_includeTags :: P.Maybe P.Bool
  , syncChunkFilter_includeSearches :: P.Maybe P.Bool
  , syncChunkFilter_includeResources :: P.Maybe P.Bool
  , syncChunkFilter_includeLinkedNotebooks :: P.Maybe P.Bool
  , syncChunkFilter_includeExpunged :: P.Maybe P.Bool
  , syncChunkFilter_includeNoteApplicationDataFullMap :: P.Maybe P.Bool
  , syncChunkFilter_includeResourceApplicationDataFullMap :: P.Maybe P.Bool
  , syncChunkFilter_includeNoteResourceApplicationDataFullMap :: P.Maybe P.Bool
  , syncChunkFilter_includeSharedNotes :: P.Maybe P.Bool
  , syncChunkFilter_omitSharedNotebooks :: P.Maybe P.Bool
  , syncChunkFilter_requireNoteContentClass :: P.Maybe LT.Text
  , syncChunkFilter_notebookGuids :: P.Maybe (Set.HashSet LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SyncChunkFilter where
  hashWithSalt salt record = salt   `H.hashWithSalt` syncChunkFilter_includeNotes record   `H.hashWithSalt` syncChunkFilter_includeNoteResources record   `H.hashWithSalt` syncChunkFilter_includeNoteAttributes record   `H.hashWithSalt` syncChunkFilter_includeNotebooks record   `H.hashWithSalt` syncChunkFilter_includeTags record   `H.hashWithSalt` syncChunkFilter_includeSearches record   `H.hashWithSalt` syncChunkFilter_includeResources record   `H.hashWithSalt` syncChunkFilter_includeLinkedNotebooks record   `H.hashWithSalt` syncChunkFilter_includeExpunged record   `H.hashWithSalt` syncChunkFilter_includeNoteApplicationDataFullMap record   `H.hashWithSalt` syncChunkFilter_includeResourceApplicationDataFullMap record   `H.hashWithSalt` syncChunkFilter_includeNoteResourceApplicationDataFullMap record   `H.hashWithSalt` syncChunkFilter_includeSharedNotes record   `H.hashWithSalt` syncChunkFilter_omitSharedNotebooks record   `H.hashWithSalt` syncChunkFilter_requireNoteContentClass record   `H.hashWithSalt` syncChunkFilter_notebookGuids record  
instance QC.Arbitrary SyncChunkFilter where 
  arbitrary = M.liftM SyncChunkFilter (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_SyncChunkFilter = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SyncChunkFilter{syncChunkFilter_includeNotes = syncChunkFilter_includeNotes obj} then P.Nothing else P.Just $ default_SyncChunkFilter{syncChunkFilter_includeNotes = syncChunkFilter_includeNotes obj}
    , if obj == default_SyncChunkFilter{syncChunkFilter_includeNoteResources = syncChunkFilter_includeNoteResources obj} then P.Nothing else P.Just $ default_SyncChunkFilter{syncChunkFilter_includeNoteResources = syncChunkFilter_includeNoteResources obj}
    , if obj == default_SyncChunkFilter{syncChunkFilter_includeNoteAttributes = syncChunkFilter_includeNoteAttributes obj} then P.Nothing else P.Just $ default_SyncChunkFilter{syncChunkFilter_includeNoteAttributes = syncChunkFilter_includeNoteAttributes obj}
    , if obj == default_SyncChunkFilter{syncChunkFilter_includeNotebooks = syncChunkFilter_includeNotebooks obj} then P.Nothing else P.Just $ default_SyncChunkFilter{syncChunkFilter_includeNotebooks = syncChunkFilter_includeNotebooks obj}
    , if obj == default_SyncChunkFilter{syncChunkFilter_includeTags = syncChunkFilter_includeTags obj} then P.Nothing else P.Just $ default_SyncChunkFilter{syncChunkFilter_includeTags = syncChunkFilter_includeTags obj}
    , if obj == default_SyncChunkFilter{syncChunkFilter_includeSearches = syncChunkFilter_includeSearches obj} then P.Nothing else P.Just $ default_SyncChunkFilter{syncChunkFilter_includeSearches = syncChunkFilter_includeSearches obj}
    , if obj == default_SyncChunkFilter{syncChunkFilter_includeResources = syncChunkFilter_includeResources obj} then P.Nothing else P.Just $ default_SyncChunkFilter{syncChunkFilter_includeResources = syncChunkFilter_includeResources obj}
    , if obj == default_SyncChunkFilter{syncChunkFilter_includeLinkedNotebooks = syncChunkFilter_includeLinkedNotebooks obj} then P.Nothing else P.Just $ default_SyncChunkFilter{syncChunkFilter_includeLinkedNotebooks = syncChunkFilter_includeLinkedNotebooks obj}
    , if obj == default_SyncChunkFilter{syncChunkFilter_includeExpunged = syncChunkFilter_includeExpunged obj} then P.Nothing else P.Just $ default_SyncChunkFilter{syncChunkFilter_includeExpunged = syncChunkFilter_includeExpunged obj}
    , if obj == default_SyncChunkFilter{syncChunkFilter_includeNoteApplicationDataFullMap = syncChunkFilter_includeNoteApplicationDataFullMap obj} then P.Nothing else P.Just $ default_SyncChunkFilter{syncChunkFilter_includeNoteApplicationDataFullMap = syncChunkFilter_includeNoteApplicationDataFullMap obj}
    , if obj == default_SyncChunkFilter{syncChunkFilter_includeResourceApplicationDataFullMap = syncChunkFilter_includeResourceApplicationDataFullMap obj} then P.Nothing else P.Just $ default_SyncChunkFilter{syncChunkFilter_includeResourceApplicationDataFullMap = syncChunkFilter_includeResourceApplicationDataFullMap obj}
    , if obj == default_SyncChunkFilter{syncChunkFilter_includeNoteResourceApplicationDataFullMap = syncChunkFilter_includeNoteResourceApplicationDataFullMap obj} then P.Nothing else P.Just $ default_SyncChunkFilter{syncChunkFilter_includeNoteResourceApplicationDataFullMap = syncChunkFilter_includeNoteResourceApplicationDataFullMap obj}
    , if obj == default_SyncChunkFilter{syncChunkFilter_includeSharedNotes = syncChunkFilter_includeSharedNotes obj} then P.Nothing else P.Just $ default_SyncChunkFilter{syncChunkFilter_includeSharedNotes = syncChunkFilter_includeSharedNotes obj}
    , if obj == default_SyncChunkFilter{syncChunkFilter_omitSharedNotebooks = syncChunkFilter_omitSharedNotebooks obj} then P.Nothing else P.Just $ default_SyncChunkFilter{syncChunkFilter_omitSharedNotebooks = syncChunkFilter_omitSharedNotebooks obj}
    , if obj == default_SyncChunkFilter{syncChunkFilter_requireNoteContentClass = syncChunkFilter_requireNoteContentClass obj} then P.Nothing else P.Just $ default_SyncChunkFilter{syncChunkFilter_requireNoteContentClass = syncChunkFilter_requireNoteContentClass obj}
    , if obj == default_SyncChunkFilter{syncChunkFilter_notebookGuids = syncChunkFilter_notebookGuids obj} then P.Nothing else P.Just $ default_SyncChunkFilter{syncChunkFilter_notebookGuids = syncChunkFilter_notebookGuids obj}
    ]
from_SyncChunkFilter :: SyncChunkFilter -> T.ThriftVal
from_SyncChunkFilter record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v76 -> (1, ("includeNotes",T.TBool _v76))) <$> syncChunkFilter_includeNotes record
  , (\_v76 -> (2, ("includeNoteResources",T.TBool _v76))) <$> syncChunkFilter_includeNoteResources record
  , (\_v76 -> (3, ("includeNoteAttributes",T.TBool _v76))) <$> syncChunkFilter_includeNoteAttributes record
  , (\_v76 -> (4, ("includeNotebooks",T.TBool _v76))) <$> syncChunkFilter_includeNotebooks record
  , (\_v76 -> (5, ("includeTags",T.TBool _v76))) <$> syncChunkFilter_includeTags record
  , (\_v76 -> (6, ("includeSearches",T.TBool _v76))) <$> syncChunkFilter_includeSearches record
  , (\_v76 -> (7, ("includeResources",T.TBool _v76))) <$> syncChunkFilter_includeResources record
  , (\_v76 -> (8, ("includeLinkedNotebooks",T.TBool _v76))) <$> syncChunkFilter_includeLinkedNotebooks record
  , (\_v76 -> (9, ("includeExpunged",T.TBool _v76))) <$> syncChunkFilter_includeExpunged record
  , (\_v76 -> (10, ("includeNoteApplicationDataFullMap",T.TBool _v76))) <$> syncChunkFilter_includeNoteApplicationDataFullMap record
  , (\_v76 -> (11, ("requireNoteContentClass",T.TString $ E.encodeUtf8 _v76))) <$> syncChunkFilter_requireNoteContentClass record
  , (\_v76 -> (12, ("includeResourceApplicationDataFullMap",T.TBool _v76))) <$> syncChunkFilter_includeResourceApplicationDataFullMap record
  , (\_v76 -> (13, ("includeNoteResourceApplicationDataFullMap",T.TBool _v76))) <$> syncChunkFilter_includeNoteResourceApplicationDataFullMap record
  , (\_v76 -> (15, ("notebookGuids",T.TSet T.T_STRING $ P.map (\_v78 -> T.TString $ E.encodeUtf8 _v78) $ Set.toList _v76))) <$> syncChunkFilter_notebookGuids record
  , (\_v76 -> (16, ("omitSharedNotebooks",T.TBool _v76))) <$> syncChunkFilter_omitSharedNotebooks record
  , (\_v76 -> (17, ("includeSharedNotes",T.TBool _v76))) <$> syncChunkFilter_includeSharedNotes record
  ]
write_SyncChunkFilter :: T.Protocol p => p -> SyncChunkFilter -> P.IO ()
write_SyncChunkFilter oprot record = T.writeVal oprot $ from_SyncChunkFilter record
encode_SyncChunkFilter :: T.StatelessProtocol p => p -> SyncChunkFilter -> LBS.ByteString
encode_SyncChunkFilter oprot record = T.serializeVal oprot $ from_SyncChunkFilter record
to_SyncChunkFilter :: T.ThriftVal -> SyncChunkFilter
to_SyncChunkFilter (T.TStruct fields) = SyncChunkFilter{
  syncChunkFilter_includeNotes = P.maybe (P.Nothing) (\(_,_val80) -> P.Just (case _val80 of {T.TBool _val81 -> _val81; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  syncChunkFilter_includeNoteResources = P.maybe (P.Nothing) (\(_,_val80) -> P.Just (case _val80 of {T.TBool _val82 -> _val82; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  syncChunkFilter_includeNoteAttributes = P.maybe (P.Nothing) (\(_,_val80) -> P.Just (case _val80 of {T.TBool _val83 -> _val83; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  syncChunkFilter_includeNotebooks = P.maybe (P.Nothing) (\(_,_val80) -> P.Just (case _val80 of {T.TBool _val84 -> _val84; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  syncChunkFilter_includeTags = P.maybe (P.Nothing) (\(_,_val80) -> P.Just (case _val80 of {T.TBool _val85 -> _val85; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  syncChunkFilter_includeSearches = P.maybe (P.Nothing) (\(_,_val80) -> P.Just (case _val80 of {T.TBool _val86 -> _val86; _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  syncChunkFilter_includeResources = P.maybe (P.Nothing) (\(_,_val80) -> P.Just (case _val80 of {T.TBool _val87 -> _val87; _ -> P.error "wrong type"})) (Map.lookup (7) fields),
  syncChunkFilter_includeLinkedNotebooks = P.maybe (P.Nothing) (\(_,_val80) -> P.Just (case _val80 of {T.TBool _val88 -> _val88; _ -> P.error "wrong type"})) (Map.lookup (8) fields),
  syncChunkFilter_includeExpunged = P.maybe (P.Nothing) (\(_,_val80) -> P.Just (case _val80 of {T.TBool _val89 -> _val89; _ -> P.error "wrong type"})) (Map.lookup (9) fields),
  syncChunkFilter_includeNoteApplicationDataFullMap = P.maybe (P.Nothing) (\(_,_val80) -> P.Just (case _val80 of {T.TBool _val90 -> _val90; _ -> P.error "wrong type"})) (Map.lookup (10) fields),
  syncChunkFilter_includeResourceApplicationDataFullMap = P.maybe (P.Nothing) (\(_,_val80) -> P.Just (case _val80 of {T.TBool _val91 -> _val91; _ -> P.error "wrong type"})) (Map.lookup (12) fields),
  syncChunkFilter_includeNoteResourceApplicationDataFullMap = P.maybe (P.Nothing) (\(_,_val80) -> P.Just (case _val80 of {T.TBool _val92 -> _val92; _ -> P.error "wrong type"})) (Map.lookup (13) fields),
  syncChunkFilter_includeSharedNotes = P.maybe (P.Nothing) (\(_,_val80) -> P.Just (case _val80 of {T.TBool _val93 -> _val93; _ -> P.error "wrong type"})) (Map.lookup (17) fields),
  syncChunkFilter_omitSharedNotebooks = P.maybe (P.Nothing) (\(_,_val80) -> P.Just (case _val80 of {T.TBool _val94 -> _val94; _ -> P.error "wrong type"})) (Map.lookup (16) fields),
  syncChunkFilter_requireNoteContentClass = P.maybe (P.Nothing) (\(_,_val80) -> P.Just (case _val80 of {T.TString _val95 -> E.decodeUtf8 _val95; _ -> P.error "wrong type"})) (Map.lookup (11) fields),
  syncChunkFilter_notebookGuids = P.maybe (P.Nothing) (\(_,_val80) -> P.Just (case _val80 of {T.TSet _ _val96 -> (Set.fromList $ P.map (\_v97 -> (case _v97 of {T.TString _val98 -> E.decodeUtf8 _val98; _ -> P.error "wrong type"})) _val96); _ -> P.error "wrong type"})) (Map.lookup (15) fields)
  }
to_SyncChunkFilter _ = P.error "not a struct"
read_SyncChunkFilter :: T.Protocol p => p -> P.IO SyncChunkFilter
read_SyncChunkFilter iprot = to_SyncChunkFilter <$> T.readVal iprot (T.T_STRUCT typemap_SyncChunkFilter)
decode_SyncChunkFilter :: T.StatelessProtocol p => p -> LBS.ByteString -> SyncChunkFilter
decode_SyncChunkFilter iprot bs = to_SyncChunkFilter $ T.deserializeVal iprot (T.T_STRUCT typemap_SyncChunkFilter) bs
typemap_SyncChunkFilter :: T.TypeMap
typemap_SyncChunkFilter = Map.fromList [(1,("includeNotes",T.T_BOOL)),(2,("includeNoteResources",T.T_BOOL)),(3,("includeNoteAttributes",T.T_BOOL)),(4,("includeNotebooks",T.T_BOOL)),(5,("includeTags",T.T_BOOL)),(6,("includeSearches",T.T_BOOL)),(7,("includeResources",T.T_BOOL)),(8,("includeLinkedNotebooks",T.T_BOOL)),(9,("includeExpunged",T.T_BOOL)),(10,("includeNoteApplicationDataFullMap",T.T_BOOL)),(11,("requireNoteContentClass",T.T_STRING)),(12,("includeResourceApplicationDataFullMap",T.T_BOOL)),(13,("includeNoteResourceApplicationDataFullMap",T.T_BOOL)),(15,("notebookGuids",(T.T_SET T.T_STRING))),(16,("omitSharedNotebooks",T.T_BOOL)),(17,("includeSharedNotes",T.T_BOOL))]
default_SyncChunkFilter :: SyncChunkFilter
default_SyncChunkFilter = SyncChunkFilter{
  syncChunkFilter_includeNotes = P.Nothing,
  syncChunkFilter_includeNoteResources = P.Nothing,
  syncChunkFilter_includeNoteAttributes = P.Nothing,
  syncChunkFilter_includeNotebooks = P.Nothing,
  syncChunkFilter_includeTags = P.Nothing,
  syncChunkFilter_includeSearches = P.Nothing,
  syncChunkFilter_includeResources = P.Nothing,
  syncChunkFilter_includeLinkedNotebooks = P.Nothing,
  syncChunkFilter_includeExpunged = P.Nothing,
  syncChunkFilter_includeNoteApplicationDataFullMap = P.Nothing,
  syncChunkFilter_requireNoteContentClass = P.Nothing,
  syncChunkFilter_includeResourceApplicationDataFullMap = P.Nothing,
  syncChunkFilter_includeNoteResourceApplicationDataFullMap = P.Nothing,
  syncChunkFilter_notebookGuids = P.Nothing,
  syncChunkFilter_omitSharedNotebooks = P.Nothing,
  syncChunkFilter_includeSharedNotes = P.Nothing}
data NoteFilter = NoteFilter  { noteFilter_order :: P.Maybe I.Int32
  , noteFilter_ascending :: P.Maybe P.Bool
  , noteFilter_words :: P.Maybe LT.Text
  , noteFilter_notebookGuid :: P.Maybe LT.Text
  , noteFilter_tagGuids :: P.Maybe (Vector.Vector LT.Text)
  , noteFilter_timeZone :: P.Maybe LT.Text
  , noteFilter_inactive :: P.Maybe P.Bool
  , noteFilter_emphasized :: P.Maybe LT.Text
  , noteFilter_includeAllReadableNotebooks :: P.Maybe P.Bool
  , noteFilter_context :: P.Maybe LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable NoteFilter where
  hashWithSalt salt record = salt   `H.hashWithSalt` noteFilter_order record   `H.hashWithSalt` noteFilter_ascending record   `H.hashWithSalt` noteFilter_words record   `H.hashWithSalt` noteFilter_notebookGuid record   `H.hashWithSalt` noteFilter_tagGuids record   `H.hashWithSalt` noteFilter_timeZone record   `H.hashWithSalt` noteFilter_inactive record   `H.hashWithSalt` noteFilter_emphasized record   `H.hashWithSalt` noteFilter_includeAllReadableNotebooks record   `H.hashWithSalt` noteFilter_context record  
instance QC.Arbitrary NoteFilter where 
  arbitrary = M.liftM NoteFilter (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_NoteFilter = []
             | P.otherwise = M.catMaybes
    [ if obj == default_NoteFilter{noteFilter_order = noteFilter_order obj} then P.Nothing else P.Just $ default_NoteFilter{noteFilter_order = noteFilter_order obj}
    , if obj == default_NoteFilter{noteFilter_ascending = noteFilter_ascending obj} then P.Nothing else P.Just $ default_NoteFilter{noteFilter_ascending = noteFilter_ascending obj}
    , if obj == default_NoteFilter{noteFilter_words = noteFilter_words obj} then P.Nothing else P.Just $ default_NoteFilter{noteFilter_words = noteFilter_words obj}
    , if obj == default_NoteFilter{noteFilter_notebookGuid = noteFilter_notebookGuid obj} then P.Nothing else P.Just $ default_NoteFilter{noteFilter_notebookGuid = noteFilter_notebookGuid obj}
    , if obj == default_NoteFilter{noteFilter_tagGuids = noteFilter_tagGuids obj} then P.Nothing else P.Just $ default_NoteFilter{noteFilter_tagGuids = noteFilter_tagGuids obj}
    , if obj == default_NoteFilter{noteFilter_timeZone = noteFilter_timeZone obj} then P.Nothing else P.Just $ default_NoteFilter{noteFilter_timeZone = noteFilter_timeZone obj}
    , if obj == default_NoteFilter{noteFilter_inactive = noteFilter_inactive obj} then P.Nothing else P.Just $ default_NoteFilter{noteFilter_inactive = noteFilter_inactive obj}
    , if obj == default_NoteFilter{noteFilter_emphasized = noteFilter_emphasized obj} then P.Nothing else P.Just $ default_NoteFilter{noteFilter_emphasized = noteFilter_emphasized obj}
    , if obj == default_NoteFilter{noteFilter_includeAllReadableNotebooks = noteFilter_includeAllReadableNotebooks obj} then P.Nothing else P.Just $ default_NoteFilter{noteFilter_includeAllReadableNotebooks = noteFilter_includeAllReadableNotebooks obj}
    , if obj == default_NoteFilter{noteFilter_context = noteFilter_context obj} then P.Nothing else P.Just $ default_NoteFilter{noteFilter_context = noteFilter_context obj}
    ]
from_NoteFilter :: NoteFilter -> T.ThriftVal
from_NoteFilter record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v101 -> (1, ("order",T.TI32 _v101))) <$> noteFilter_order record
  , (\_v101 -> (2, ("ascending",T.TBool _v101))) <$> noteFilter_ascending record
  , (\_v101 -> (3, ("words",T.TString $ E.encodeUtf8 _v101))) <$> noteFilter_words record
  , (\_v101 -> (4, ("notebookGuid",T.TString $ E.encodeUtf8 _v101))) <$> noteFilter_notebookGuid record
  , (\_v101 -> (5, ("tagGuids",T.TList T.T_STRING $ P.map (\_v103 -> T.TString $ E.encodeUtf8 _v103) $ Vector.toList _v101))) <$> noteFilter_tagGuids record
  , (\_v101 -> (6, ("timeZone",T.TString $ E.encodeUtf8 _v101))) <$> noteFilter_timeZone record
  , (\_v101 -> (7, ("inactive",T.TBool _v101))) <$> noteFilter_inactive record
  , (\_v101 -> (8, ("emphasized",T.TString $ E.encodeUtf8 _v101))) <$> noteFilter_emphasized record
  , (\_v101 -> (9, ("includeAllReadableNotebooks",T.TBool _v101))) <$> noteFilter_includeAllReadableNotebooks record
  , (\_v101 -> (10, ("context",T.TString $ E.encodeUtf8 _v101))) <$> noteFilter_context record
  ]
write_NoteFilter :: T.Protocol p => p -> NoteFilter -> P.IO ()
write_NoteFilter oprot record = T.writeVal oprot $ from_NoteFilter record
encode_NoteFilter :: T.StatelessProtocol p => p -> NoteFilter -> LBS.ByteString
encode_NoteFilter oprot record = T.serializeVal oprot $ from_NoteFilter record
to_NoteFilter :: T.ThriftVal -> NoteFilter
to_NoteFilter (T.TStruct fields) = NoteFilter{
  noteFilter_order = P.maybe (P.Nothing) (\(_,_val105) -> P.Just (case _val105 of {T.TI32 _val106 -> _val106; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  noteFilter_ascending = P.maybe (P.Nothing) (\(_,_val105) -> P.Just (case _val105 of {T.TBool _val107 -> _val107; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  noteFilter_words = P.maybe (P.Nothing) (\(_,_val105) -> P.Just (case _val105 of {T.TString _val108 -> E.decodeUtf8 _val108; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  noteFilter_notebookGuid = P.maybe (P.Nothing) (\(_,_val105) -> P.Just (case _val105 of {T.TString _val109 -> E.decodeUtf8 _val109; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  noteFilter_tagGuids = P.maybe (P.Nothing) (\(_,_val105) -> P.Just (case _val105 of {T.TList _ _val110 -> (Vector.fromList $ P.map (\_v111 -> (case _v111 of {T.TString _val112 -> E.decodeUtf8 _val112; _ -> P.error "wrong type"})) _val110); _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  noteFilter_timeZone = P.maybe (P.Nothing) (\(_,_val105) -> P.Just (case _val105 of {T.TString _val113 -> E.decodeUtf8 _val113; _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  noteFilter_inactive = P.maybe (P.Nothing) (\(_,_val105) -> P.Just (case _val105 of {T.TBool _val114 -> _val114; _ -> P.error "wrong type"})) (Map.lookup (7) fields),
  noteFilter_emphasized = P.maybe (P.Nothing) (\(_,_val105) -> P.Just (case _val105 of {T.TString _val115 -> E.decodeUtf8 _val115; _ -> P.error "wrong type"})) (Map.lookup (8) fields),
  noteFilter_includeAllReadableNotebooks = P.maybe (P.Nothing) (\(_,_val105) -> P.Just (case _val105 of {T.TBool _val116 -> _val116; _ -> P.error "wrong type"})) (Map.lookup (9) fields),
  noteFilter_context = P.maybe (P.Nothing) (\(_,_val105) -> P.Just (case _val105 of {T.TString _val117 -> E.decodeUtf8 _val117; _ -> P.error "wrong type"})) (Map.lookup (10) fields)
  }
to_NoteFilter _ = P.error "not a struct"
read_NoteFilter :: T.Protocol p => p -> P.IO NoteFilter
read_NoteFilter iprot = to_NoteFilter <$> T.readVal iprot (T.T_STRUCT typemap_NoteFilter)
decode_NoteFilter :: T.StatelessProtocol p => p -> LBS.ByteString -> NoteFilter
decode_NoteFilter iprot bs = to_NoteFilter $ T.deserializeVal iprot (T.T_STRUCT typemap_NoteFilter) bs
typemap_NoteFilter :: T.TypeMap
typemap_NoteFilter = Map.fromList [(1,("order",T.T_I32)),(2,("ascending",T.T_BOOL)),(3,("words",T.T_STRING)),(4,("notebookGuid",T.T_STRING)),(5,("tagGuids",(T.T_LIST T.T_STRING))),(6,("timeZone",T.T_STRING)),(7,("inactive",T.T_BOOL)),(8,("emphasized",T.T_STRING)),(9,("includeAllReadableNotebooks",T.T_BOOL)),(10,("context",T.T_STRING))]
default_NoteFilter :: NoteFilter
default_NoteFilter = NoteFilter{
  noteFilter_order = P.Nothing,
  noteFilter_ascending = P.Nothing,
  noteFilter_words = P.Nothing,
  noteFilter_notebookGuid = P.Nothing,
  noteFilter_tagGuids = P.Nothing,
  noteFilter_timeZone = P.Nothing,
  noteFilter_inactive = P.Nothing,
  noteFilter_emphasized = P.Nothing,
  noteFilter_includeAllReadableNotebooks = P.Nothing,
  noteFilter_context = P.Nothing}
data NoteList = NoteList  { noteList_startIndex :: I.Int32
  , noteList_totalNotes :: I.Int32
  , noteList_notes :: (Vector.Vector Types_Types.Note)
  , noteList_stoppedWords :: P.Maybe (Vector.Vector LT.Text)
  , noteList_searchedWords :: P.Maybe (Vector.Vector LT.Text)
  , noteList_updateCount :: P.Maybe I.Int32
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable NoteList where
  hashWithSalt salt record = salt   `H.hashWithSalt` noteList_startIndex record   `H.hashWithSalt` noteList_totalNotes record   `H.hashWithSalt` noteList_notes record   `H.hashWithSalt` noteList_stoppedWords record   `H.hashWithSalt` noteList_searchedWords record   `H.hashWithSalt` noteList_updateCount record  
instance QC.Arbitrary NoteList where 
  arbitrary = M.liftM NoteList (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_NoteList = []
             | P.otherwise = M.catMaybes
    [ if obj == default_NoteList{noteList_startIndex = noteList_startIndex obj} then P.Nothing else P.Just $ default_NoteList{noteList_startIndex = noteList_startIndex obj}
    , if obj == default_NoteList{noteList_totalNotes = noteList_totalNotes obj} then P.Nothing else P.Just $ default_NoteList{noteList_totalNotes = noteList_totalNotes obj}
    , if obj == default_NoteList{noteList_notes = noteList_notes obj} then P.Nothing else P.Just $ default_NoteList{noteList_notes = noteList_notes obj}
    , if obj == default_NoteList{noteList_stoppedWords = noteList_stoppedWords obj} then P.Nothing else P.Just $ default_NoteList{noteList_stoppedWords = noteList_stoppedWords obj}
    , if obj == default_NoteList{noteList_searchedWords = noteList_searchedWords obj} then P.Nothing else P.Just $ default_NoteList{noteList_searchedWords = noteList_searchedWords obj}
    , if obj == default_NoteList{noteList_updateCount = noteList_updateCount obj} then P.Nothing else P.Just $ default_NoteList{noteList_updateCount = noteList_updateCount obj}
    ]
from_NoteList :: NoteList -> T.ThriftVal
from_NoteList record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v120 -> P.Just (1, ("startIndex",T.TI32 _v120))) $ noteList_startIndex record
  , (\_v120 -> P.Just (2, ("totalNotes",T.TI32 _v120))) $ noteList_totalNotes record
  , (\_v120 -> P.Just (3, ("notes",T.TList (T.T_STRUCT Types_Types.typemap_Note) $ P.map (\_v122 -> Types_Types.from_Note _v122) $ Vector.toList _v120))) $ noteList_notes record
  , (\_v120 -> (4, ("stoppedWords",T.TList T.T_STRING $ P.map (\_v124 -> T.TString $ E.encodeUtf8 _v124) $ Vector.toList _v120))) <$> noteList_stoppedWords record
  , (\_v120 -> (5, ("searchedWords",T.TList T.T_STRING $ P.map (\_v126 -> T.TString $ E.encodeUtf8 _v126) $ Vector.toList _v120))) <$> noteList_searchedWords record
  , (\_v120 -> (6, ("updateCount",T.TI32 _v120))) <$> noteList_updateCount record
  ]
write_NoteList :: T.Protocol p => p -> NoteList -> P.IO ()
write_NoteList oprot record = T.writeVal oprot $ from_NoteList record
encode_NoteList :: T.StatelessProtocol p => p -> NoteList -> LBS.ByteString
encode_NoteList oprot record = T.serializeVal oprot $ from_NoteList record
to_NoteList :: T.ThriftVal -> NoteList
to_NoteList (T.TStruct fields) = NoteList{
  noteList_startIndex = P.maybe (P.error "Missing required field: startIndex") (\(_,_val128) -> (case _val128 of {T.TI32 _val129 -> _val129; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  noteList_totalNotes = P.maybe (P.error "Missing required field: totalNotes") (\(_,_val128) -> (case _val128 of {T.TI32 _val130 -> _val130; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  noteList_notes = P.maybe (P.error "Missing required field: notes") (\(_,_val128) -> (case _val128 of {T.TList _ _val131 -> (Vector.fromList $ P.map (\_v132 -> (case _v132 of {T.TStruct _val133 -> (Types_Types.to_Note (T.TStruct _val133)); _ -> P.error "wrong type"})) _val131); _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  noteList_stoppedWords = P.maybe (P.Nothing) (\(_,_val128) -> P.Just (case _val128 of {T.TList _ _val134 -> (Vector.fromList $ P.map (\_v135 -> (case _v135 of {T.TString _val136 -> E.decodeUtf8 _val136; _ -> P.error "wrong type"})) _val134); _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  noteList_searchedWords = P.maybe (P.Nothing) (\(_,_val128) -> P.Just (case _val128 of {T.TList _ _val137 -> (Vector.fromList $ P.map (\_v138 -> (case _v138 of {T.TString _val139 -> E.decodeUtf8 _val139; _ -> P.error "wrong type"})) _val137); _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  noteList_updateCount = P.maybe (P.Nothing) (\(_,_val128) -> P.Just (case _val128 of {T.TI32 _val140 -> _val140; _ -> P.error "wrong type"})) (Map.lookup (6) fields)
  }
to_NoteList _ = P.error "not a struct"
read_NoteList :: T.Protocol p => p -> P.IO NoteList
read_NoteList iprot = to_NoteList <$> T.readVal iprot (T.T_STRUCT typemap_NoteList)
decode_NoteList :: T.StatelessProtocol p => p -> LBS.ByteString -> NoteList
decode_NoteList iprot bs = to_NoteList $ T.deserializeVal iprot (T.T_STRUCT typemap_NoteList) bs
typemap_NoteList :: T.TypeMap
typemap_NoteList = Map.fromList [(1,("startIndex",T.T_I32)),(2,("totalNotes",T.T_I32)),(3,("notes",(T.T_LIST (T.T_STRUCT Types_Types.typemap_Note)))),(4,("stoppedWords",(T.T_LIST T.T_STRING))),(5,("searchedWords",(T.T_LIST T.T_STRING))),(6,("updateCount",T.T_I32))]
default_NoteList :: NoteList
default_NoteList = NoteList{
  noteList_startIndex = 0,
  noteList_totalNotes = 0,
  noteList_notes = Vector.empty,
  noteList_stoppedWords = P.Nothing,
  noteList_searchedWords = P.Nothing,
  noteList_updateCount = P.Nothing}
data NoteMetadata = NoteMetadata  { noteMetadata_guid :: LT.Text
  , noteMetadata_title :: P.Maybe LT.Text
  , noteMetadata_contentLength :: P.Maybe I.Int32
  , noteMetadata_created :: P.Maybe I.Int64
  , noteMetadata_updated :: P.Maybe I.Int64
  , noteMetadata_deleted :: P.Maybe I.Int64
  , noteMetadata_updateSequenceNum :: P.Maybe I.Int32
  , noteMetadata_notebookGuid :: P.Maybe LT.Text
  , noteMetadata_tagGuids :: P.Maybe (Vector.Vector LT.Text)
  , noteMetadata_attributes :: P.Maybe Types_Types.NoteAttributes
  , noteMetadata_largestResourceMime :: P.Maybe LT.Text
  , noteMetadata_largestResourceSize :: P.Maybe I.Int32
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable NoteMetadata where
  hashWithSalt salt record = salt   `H.hashWithSalt` noteMetadata_guid record   `H.hashWithSalt` noteMetadata_title record   `H.hashWithSalt` noteMetadata_contentLength record   `H.hashWithSalt` noteMetadata_created record   `H.hashWithSalt` noteMetadata_updated record   `H.hashWithSalt` noteMetadata_deleted record   `H.hashWithSalt` noteMetadata_updateSequenceNum record   `H.hashWithSalt` noteMetadata_notebookGuid record   `H.hashWithSalt` noteMetadata_tagGuids record   `H.hashWithSalt` noteMetadata_attributes record   `H.hashWithSalt` noteMetadata_largestResourceMime record   `H.hashWithSalt` noteMetadata_largestResourceSize record  
instance QC.Arbitrary NoteMetadata where 
  arbitrary = M.liftM NoteMetadata (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_NoteMetadata = []
             | P.otherwise = M.catMaybes
    [ if obj == default_NoteMetadata{noteMetadata_guid = noteMetadata_guid obj} then P.Nothing else P.Just $ default_NoteMetadata{noteMetadata_guid = noteMetadata_guid obj}
    , if obj == default_NoteMetadata{noteMetadata_title = noteMetadata_title obj} then P.Nothing else P.Just $ default_NoteMetadata{noteMetadata_title = noteMetadata_title obj}
    , if obj == default_NoteMetadata{noteMetadata_contentLength = noteMetadata_contentLength obj} then P.Nothing else P.Just $ default_NoteMetadata{noteMetadata_contentLength = noteMetadata_contentLength obj}
    , if obj == default_NoteMetadata{noteMetadata_created = noteMetadata_created obj} then P.Nothing else P.Just $ default_NoteMetadata{noteMetadata_created = noteMetadata_created obj}
    , if obj == default_NoteMetadata{noteMetadata_updated = noteMetadata_updated obj} then P.Nothing else P.Just $ default_NoteMetadata{noteMetadata_updated = noteMetadata_updated obj}
    , if obj == default_NoteMetadata{noteMetadata_deleted = noteMetadata_deleted obj} then P.Nothing else P.Just $ default_NoteMetadata{noteMetadata_deleted = noteMetadata_deleted obj}
    , if obj == default_NoteMetadata{noteMetadata_updateSequenceNum = noteMetadata_updateSequenceNum obj} then P.Nothing else P.Just $ default_NoteMetadata{noteMetadata_updateSequenceNum = noteMetadata_updateSequenceNum obj}
    , if obj == default_NoteMetadata{noteMetadata_notebookGuid = noteMetadata_notebookGuid obj} then P.Nothing else P.Just $ default_NoteMetadata{noteMetadata_notebookGuid = noteMetadata_notebookGuid obj}
    , if obj == default_NoteMetadata{noteMetadata_tagGuids = noteMetadata_tagGuids obj} then P.Nothing else P.Just $ default_NoteMetadata{noteMetadata_tagGuids = noteMetadata_tagGuids obj}
    , if obj == default_NoteMetadata{noteMetadata_attributes = noteMetadata_attributes obj} then P.Nothing else P.Just $ default_NoteMetadata{noteMetadata_attributes = noteMetadata_attributes obj}
    , if obj == default_NoteMetadata{noteMetadata_largestResourceMime = noteMetadata_largestResourceMime obj} then P.Nothing else P.Just $ default_NoteMetadata{noteMetadata_largestResourceMime = noteMetadata_largestResourceMime obj}
    , if obj == default_NoteMetadata{noteMetadata_largestResourceSize = noteMetadata_largestResourceSize obj} then P.Nothing else P.Just $ default_NoteMetadata{noteMetadata_largestResourceSize = noteMetadata_largestResourceSize obj}
    ]
from_NoteMetadata :: NoteMetadata -> T.ThriftVal
from_NoteMetadata record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v143 -> P.Just (1, ("guid",T.TString $ E.encodeUtf8 _v143))) $ noteMetadata_guid record
  , (\_v143 -> (2, ("title",T.TString $ E.encodeUtf8 _v143))) <$> noteMetadata_title record
  , (\_v143 -> (5, ("contentLength",T.TI32 _v143))) <$> noteMetadata_contentLength record
  , (\_v143 -> (6, ("created",T.TI64 _v143))) <$> noteMetadata_created record
  , (\_v143 -> (7, ("updated",T.TI64 _v143))) <$> noteMetadata_updated record
  , (\_v143 -> (8, ("deleted",T.TI64 _v143))) <$> noteMetadata_deleted record
  , (\_v143 -> (10, ("updateSequenceNum",T.TI32 _v143))) <$> noteMetadata_updateSequenceNum record
  , (\_v143 -> (11, ("notebookGuid",T.TString $ E.encodeUtf8 _v143))) <$> noteMetadata_notebookGuid record
  , (\_v143 -> (12, ("tagGuids",T.TList T.T_STRING $ P.map (\_v145 -> T.TString $ E.encodeUtf8 _v145) $ Vector.toList _v143))) <$> noteMetadata_tagGuids record
  , (\_v143 -> (14, ("attributes",Types_Types.from_NoteAttributes _v143))) <$> noteMetadata_attributes record
  , (\_v143 -> (20, ("largestResourceMime",T.TString $ E.encodeUtf8 _v143))) <$> noteMetadata_largestResourceMime record
  , (\_v143 -> (21, ("largestResourceSize",T.TI32 _v143))) <$> noteMetadata_largestResourceSize record
  ]
write_NoteMetadata :: T.Protocol p => p -> NoteMetadata -> P.IO ()
write_NoteMetadata oprot record = T.writeVal oprot $ from_NoteMetadata record
encode_NoteMetadata :: T.StatelessProtocol p => p -> NoteMetadata -> LBS.ByteString
encode_NoteMetadata oprot record = T.serializeVal oprot $ from_NoteMetadata record
to_NoteMetadata :: T.ThriftVal -> NoteMetadata
to_NoteMetadata (T.TStruct fields) = NoteMetadata{
  noteMetadata_guid = P.maybe (P.error "Missing required field: guid") (\(_,_val147) -> (case _val147 of {T.TString _val148 -> E.decodeUtf8 _val148; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  noteMetadata_title = P.maybe (P.Nothing) (\(_,_val147) -> P.Just (case _val147 of {T.TString _val149 -> E.decodeUtf8 _val149; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  noteMetadata_contentLength = P.maybe (P.Nothing) (\(_,_val147) -> P.Just (case _val147 of {T.TI32 _val150 -> _val150; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  noteMetadata_created = P.maybe (P.Nothing) (\(_,_val147) -> P.Just (case _val147 of {T.TI64 _val151 -> _val151; _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  noteMetadata_updated = P.maybe (P.Nothing) (\(_,_val147) -> P.Just (case _val147 of {T.TI64 _val152 -> _val152; _ -> P.error "wrong type"})) (Map.lookup (7) fields),
  noteMetadata_deleted = P.maybe (P.Nothing) (\(_,_val147) -> P.Just (case _val147 of {T.TI64 _val153 -> _val153; _ -> P.error "wrong type"})) (Map.lookup (8) fields),
  noteMetadata_updateSequenceNum = P.maybe (P.Nothing) (\(_,_val147) -> P.Just (case _val147 of {T.TI32 _val154 -> _val154; _ -> P.error "wrong type"})) (Map.lookup (10) fields),
  noteMetadata_notebookGuid = P.maybe (P.Nothing) (\(_,_val147) -> P.Just (case _val147 of {T.TString _val155 -> E.decodeUtf8 _val155; _ -> P.error "wrong type"})) (Map.lookup (11) fields),
  noteMetadata_tagGuids = P.maybe (P.Nothing) (\(_,_val147) -> P.Just (case _val147 of {T.TList _ _val156 -> (Vector.fromList $ P.map (\_v157 -> (case _v157 of {T.TString _val158 -> E.decodeUtf8 _val158; _ -> P.error "wrong type"})) _val156); _ -> P.error "wrong type"})) (Map.lookup (12) fields),
  noteMetadata_attributes = P.maybe (P.Nothing) (\(_,_val147) -> P.Just (case _val147 of {T.TStruct _val159 -> (Types_Types.to_NoteAttributes (T.TStruct _val159)); _ -> P.error "wrong type"})) (Map.lookup (14) fields),
  noteMetadata_largestResourceMime = P.maybe (P.Nothing) (\(_,_val147) -> P.Just (case _val147 of {T.TString _val160 -> E.decodeUtf8 _val160; _ -> P.error "wrong type"})) (Map.lookup (20) fields),
  noteMetadata_largestResourceSize = P.maybe (P.Nothing) (\(_,_val147) -> P.Just (case _val147 of {T.TI32 _val161 -> _val161; _ -> P.error "wrong type"})) (Map.lookup (21) fields)
  }
to_NoteMetadata _ = P.error "not a struct"
read_NoteMetadata :: T.Protocol p => p -> P.IO NoteMetadata
read_NoteMetadata iprot = to_NoteMetadata <$> T.readVal iprot (T.T_STRUCT typemap_NoteMetadata)
decode_NoteMetadata :: T.StatelessProtocol p => p -> LBS.ByteString -> NoteMetadata
decode_NoteMetadata iprot bs = to_NoteMetadata $ T.deserializeVal iprot (T.T_STRUCT typemap_NoteMetadata) bs
typemap_NoteMetadata :: T.TypeMap
typemap_NoteMetadata = Map.fromList [(1,("guid",T.T_STRING)),(2,("title",T.T_STRING)),(5,("contentLength",T.T_I32)),(6,("created",T.T_I64)),(7,("updated",T.T_I64)),(8,("deleted",T.T_I64)),(10,("updateSequenceNum",T.T_I32)),(11,("notebookGuid",T.T_STRING)),(12,("tagGuids",(T.T_LIST T.T_STRING))),(14,("attributes",(T.T_STRUCT Types_Types.typemap_NoteAttributes))),(20,("largestResourceMime",T.T_STRING)),(21,("largestResourceSize",T.T_I32))]
default_NoteMetadata :: NoteMetadata
default_NoteMetadata = NoteMetadata{
  noteMetadata_guid = "",
  noteMetadata_title = P.Nothing,
  noteMetadata_contentLength = P.Nothing,
  noteMetadata_created = P.Nothing,
  noteMetadata_updated = P.Nothing,
  noteMetadata_deleted = P.Nothing,
  noteMetadata_updateSequenceNum = P.Nothing,
  noteMetadata_notebookGuid = P.Nothing,
  noteMetadata_tagGuids = P.Nothing,
  noteMetadata_attributes = P.Nothing,
  noteMetadata_largestResourceMime = P.Nothing,
  noteMetadata_largestResourceSize = P.Nothing}
data NotesMetadataList = NotesMetadataList  { notesMetadataList_startIndex :: I.Int32
  , notesMetadataList_totalNotes :: I.Int32
  , notesMetadataList_notes :: (Vector.Vector NoteMetadata)
  , notesMetadataList_stoppedWords :: P.Maybe (Vector.Vector LT.Text)
  , notesMetadataList_searchedWords :: P.Maybe (Vector.Vector LT.Text)
  , notesMetadataList_updateCount :: P.Maybe I.Int32
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable NotesMetadataList where
  hashWithSalt salt record = salt   `H.hashWithSalt` notesMetadataList_startIndex record   `H.hashWithSalt` notesMetadataList_totalNotes record   `H.hashWithSalt` notesMetadataList_notes record   `H.hashWithSalt` notesMetadataList_stoppedWords record   `H.hashWithSalt` notesMetadataList_searchedWords record   `H.hashWithSalt` notesMetadataList_updateCount record  
instance QC.Arbitrary NotesMetadataList where 
  arbitrary = M.liftM NotesMetadataList (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_NotesMetadataList = []
             | P.otherwise = M.catMaybes
    [ if obj == default_NotesMetadataList{notesMetadataList_startIndex = notesMetadataList_startIndex obj} then P.Nothing else P.Just $ default_NotesMetadataList{notesMetadataList_startIndex = notesMetadataList_startIndex obj}
    , if obj == default_NotesMetadataList{notesMetadataList_totalNotes = notesMetadataList_totalNotes obj} then P.Nothing else P.Just $ default_NotesMetadataList{notesMetadataList_totalNotes = notesMetadataList_totalNotes obj}
    , if obj == default_NotesMetadataList{notesMetadataList_notes = notesMetadataList_notes obj} then P.Nothing else P.Just $ default_NotesMetadataList{notesMetadataList_notes = notesMetadataList_notes obj}
    , if obj == default_NotesMetadataList{notesMetadataList_stoppedWords = notesMetadataList_stoppedWords obj} then P.Nothing else P.Just $ default_NotesMetadataList{notesMetadataList_stoppedWords = notesMetadataList_stoppedWords obj}
    , if obj == default_NotesMetadataList{notesMetadataList_searchedWords = notesMetadataList_searchedWords obj} then P.Nothing else P.Just $ default_NotesMetadataList{notesMetadataList_searchedWords = notesMetadataList_searchedWords obj}
    , if obj == default_NotesMetadataList{notesMetadataList_updateCount = notesMetadataList_updateCount obj} then P.Nothing else P.Just $ default_NotesMetadataList{notesMetadataList_updateCount = notesMetadataList_updateCount obj}
    ]
from_NotesMetadataList :: NotesMetadataList -> T.ThriftVal
from_NotesMetadataList record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v164 -> P.Just (1, ("startIndex",T.TI32 _v164))) $ notesMetadataList_startIndex record
  , (\_v164 -> P.Just (2, ("totalNotes",T.TI32 _v164))) $ notesMetadataList_totalNotes record
  , (\_v164 -> P.Just (3, ("notes",T.TList (T.T_STRUCT typemap_NoteMetadata) $ P.map (\_v166 -> from_NoteMetadata _v166) $ Vector.toList _v164))) $ notesMetadataList_notes record
  , (\_v164 -> (4, ("stoppedWords",T.TList T.T_STRING $ P.map (\_v168 -> T.TString $ E.encodeUtf8 _v168) $ Vector.toList _v164))) <$> notesMetadataList_stoppedWords record
  , (\_v164 -> (5, ("searchedWords",T.TList T.T_STRING $ P.map (\_v170 -> T.TString $ E.encodeUtf8 _v170) $ Vector.toList _v164))) <$> notesMetadataList_searchedWords record
  , (\_v164 -> (6, ("updateCount",T.TI32 _v164))) <$> notesMetadataList_updateCount record
  ]
write_NotesMetadataList :: T.Protocol p => p -> NotesMetadataList -> P.IO ()
write_NotesMetadataList oprot record = T.writeVal oprot $ from_NotesMetadataList record
encode_NotesMetadataList :: T.StatelessProtocol p => p -> NotesMetadataList -> LBS.ByteString
encode_NotesMetadataList oprot record = T.serializeVal oprot $ from_NotesMetadataList record
to_NotesMetadataList :: T.ThriftVal -> NotesMetadataList
to_NotesMetadataList (T.TStruct fields) = NotesMetadataList{
  notesMetadataList_startIndex = P.maybe (P.error "Missing required field: startIndex") (\(_,_val172) -> (case _val172 of {T.TI32 _val173 -> _val173; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  notesMetadataList_totalNotes = P.maybe (P.error "Missing required field: totalNotes") (\(_,_val172) -> (case _val172 of {T.TI32 _val174 -> _val174; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  notesMetadataList_notes = P.maybe (P.error "Missing required field: notes") (\(_,_val172) -> (case _val172 of {T.TList _ _val175 -> (Vector.fromList $ P.map (\_v176 -> (case _v176 of {T.TStruct _val177 -> (to_NoteMetadata (T.TStruct _val177)); _ -> P.error "wrong type"})) _val175); _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  notesMetadataList_stoppedWords = P.maybe (P.Nothing) (\(_,_val172) -> P.Just (case _val172 of {T.TList _ _val178 -> (Vector.fromList $ P.map (\_v179 -> (case _v179 of {T.TString _val180 -> E.decodeUtf8 _val180; _ -> P.error "wrong type"})) _val178); _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  notesMetadataList_searchedWords = P.maybe (P.Nothing) (\(_,_val172) -> P.Just (case _val172 of {T.TList _ _val181 -> (Vector.fromList $ P.map (\_v182 -> (case _v182 of {T.TString _val183 -> E.decodeUtf8 _val183; _ -> P.error "wrong type"})) _val181); _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  notesMetadataList_updateCount = P.maybe (P.Nothing) (\(_,_val172) -> P.Just (case _val172 of {T.TI32 _val184 -> _val184; _ -> P.error "wrong type"})) (Map.lookup (6) fields)
  }
to_NotesMetadataList _ = P.error "not a struct"
read_NotesMetadataList :: T.Protocol p => p -> P.IO NotesMetadataList
read_NotesMetadataList iprot = to_NotesMetadataList <$> T.readVal iprot (T.T_STRUCT typemap_NotesMetadataList)
decode_NotesMetadataList :: T.StatelessProtocol p => p -> LBS.ByteString -> NotesMetadataList
decode_NotesMetadataList iprot bs = to_NotesMetadataList $ T.deserializeVal iprot (T.T_STRUCT typemap_NotesMetadataList) bs
typemap_NotesMetadataList :: T.TypeMap
typemap_NotesMetadataList = Map.fromList [(1,("startIndex",T.T_I32)),(2,("totalNotes",T.T_I32)),(3,("notes",(T.T_LIST (T.T_STRUCT typemap_NoteMetadata)))),(4,("stoppedWords",(T.T_LIST T.T_STRING))),(5,("searchedWords",(T.T_LIST T.T_STRING))),(6,("updateCount",T.T_I32))]
default_NotesMetadataList :: NotesMetadataList
default_NotesMetadataList = NotesMetadataList{
  notesMetadataList_startIndex = 0,
  notesMetadataList_totalNotes = 0,
  notesMetadataList_notes = Vector.empty,
  notesMetadataList_stoppedWords = P.Nothing,
  notesMetadataList_searchedWords = P.Nothing,
  notesMetadataList_updateCount = P.Nothing}
data NotesMetadataResultSpec = NotesMetadataResultSpec  { notesMetadataResultSpec_includeTitle :: P.Maybe P.Bool
  , notesMetadataResultSpec_includeContentLength :: P.Maybe P.Bool
  , notesMetadataResultSpec_includeCreated :: P.Maybe P.Bool
  , notesMetadataResultSpec_includeUpdated :: P.Maybe P.Bool
  , notesMetadataResultSpec_includeDeleted :: P.Maybe P.Bool
  , notesMetadataResultSpec_includeUpdateSequenceNum :: P.Maybe P.Bool
  , notesMetadataResultSpec_includeNotebookGuid :: P.Maybe P.Bool
  , notesMetadataResultSpec_includeTagGuids :: P.Maybe P.Bool
  , notesMetadataResultSpec_includeAttributes :: P.Maybe P.Bool
  , notesMetadataResultSpec_includeLargestResourceMime :: P.Maybe P.Bool
  , notesMetadataResultSpec_includeLargestResourceSize :: P.Maybe P.Bool
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable NotesMetadataResultSpec where
  hashWithSalt salt record = salt   `H.hashWithSalt` notesMetadataResultSpec_includeTitle record   `H.hashWithSalt` notesMetadataResultSpec_includeContentLength record   `H.hashWithSalt` notesMetadataResultSpec_includeCreated record   `H.hashWithSalt` notesMetadataResultSpec_includeUpdated record   `H.hashWithSalt` notesMetadataResultSpec_includeDeleted record   `H.hashWithSalt` notesMetadataResultSpec_includeUpdateSequenceNum record   `H.hashWithSalt` notesMetadataResultSpec_includeNotebookGuid record   `H.hashWithSalt` notesMetadataResultSpec_includeTagGuids record   `H.hashWithSalt` notesMetadataResultSpec_includeAttributes record   `H.hashWithSalt` notesMetadataResultSpec_includeLargestResourceMime record   `H.hashWithSalt` notesMetadataResultSpec_includeLargestResourceSize record  
instance QC.Arbitrary NotesMetadataResultSpec where 
  arbitrary = M.liftM NotesMetadataResultSpec (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_NotesMetadataResultSpec = []
             | P.otherwise = M.catMaybes
    [ if obj == default_NotesMetadataResultSpec{notesMetadataResultSpec_includeTitle = notesMetadataResultSpec_includeTitle obj} then P.Nothing else P.Just $ default_NotesMetadataResultSpec{notesMetadataResultSpec_includeTitle = notesMetadataResultSpec_includeTitle obj}
    , if obj == default_NotesMetadataResultSpec{notesMetadataResultSpec_includeContentLength = notesMetadataResultSpec_includeContentLength obj} then P.Nothing else P.Just $ default_NotesMetadataResultSpec{notesMetadataResultSpec_includeContentLength = notesMetadataResultSpec_includeContentLength obj}
    , if obj == default_NotesMetadataResultSpec{notesMetadataResultSpec_includeCreated = notesMetadataResultSpec_includeCreated obj} then P.Nothing else P.Just $ default_NotesMetadataResultSpec{notesMetadataResultSpec_includeCreated = notesMetadataResultSpec_includeCreated obj}
    , if obj == default_NotesMetadataResultSpec{notesMetadataResultSpec_includeUpdated = notesMetadataResultSpec_includeUpdated obj} then P.Nothing else P.Just $ default_NotesMetadataResultSpec{notesMetadataResultSpec_includeUpdated = notesMetadataResultSpec_includeUpdated obj}
    , if obj == default_NotesMetadataResultSpec{notesMetadataResultSpec_includeDeleted = notesMetadataResultSpec_includeDeleted obj} then P.Nothing else P.Just $ default_NotesMetadataResultSpec{notesMetadataResultSpec_includeDeleted = notesMetadataResultSpec_includeDeleted obj}
    , if obj == default_NotesMetadataResultSpec{notesMetadataResultSpec_includeUpdateSequenceNum = notesMetadataResultSpec_includeUpdateSequenceNum obj} then P.Nothing else P.Just $ default_NotesMetadataResultSpec{notesMetadataResultSpec_includeUpdateSequenceNum = notesMetadataResultSpec_includeUpdateSequenceNum obj}
    , if obj == default_NotesMetadataResultSpec{notesMetadataResultSpec_includeNotebookGuid = notesMetadataResultSpec_includeNotebookGuid obj} then P.Nothing else P.Just $ default_NotesMetadataResultSpec{notesMetadataResultSpec_includeNotebookGuid = notesMetadataResultSpec_includeNotebookGuid obj}
    , if obj == default_NotesMetadataResultSpec{notesMetadataResultSpec_includeTagGuids = notesMetadataResultSpec_includeTagGuids obj} then P.Nothing else P.Just $ default_NotesMetadataResultSpec{notesMetadataResultSpec_includeTagGuids = notesMetadataResultSpec_includeTagGuids obj}
    , if obj == default_NotesMetadataResultSpec{notesMetadataResultSpec_includeAttributes = notesMetadataResultSpec_includeAttributes obj} then P.Nothing else P.Just $ default_NotesMetadataResultSpec{notesMetadataResultSpec_includeAttributes = notesMetadataResultSpec_includeAttributes obj}
    , if obj == default_NotesMetadataResultSpec{notesMetadataResultSpec_includeLargestResourceMime = notesMetadataResultSpec_includeLargestResourceMime obj} then P.Nothing else P.Just $ default_NotesMetadataResultSpec{notesMetadataResultSpec_includeLargestResourceMime = notesMetadataResultSpec_includeLargestResourceMime obj}
    , if obj == default_NotesMetadataResultSpec{notesMetadataResultSpec_includeLargestResourceSize = notesMetadataResultSpec_includeLargestResourceSize obj} then P.Nothing else P.Just $ default_NotesMetadataResultSpec{notesMetadataResultSpec_includeLargestResourceSize = notesMetadataResultSpec_includeLargestResourceSize obj}
    ]
from_NotesMetadataResultSpec :: NotesMetadataResultSpec -> T.ThriftVal
from_NotesMetadataResultSpec record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v187 -> (2, ("includeTitle",T.TBool _v187))) <$> notesMetadataResultSpec_includeTitle record
  , (\_v187 -> (5, ("includeContentLength",T.TBool _v187))) <$> notesMetadataResultSpec_includeContentLength record
  , (\_v187 -> (6, ("includeCreated",T.TBool _v187))) <$> notesMetadataResultSpec_includeCreated record
  , (\_v187 -> (7, ("includeUpdated",T.TBool _v187))) <$> notesMetadataResultSpec_includeUpdated record
  , (\_v187 -> (8, ("includeDeleted",T.TBool _v187))) <$> notesMetadataResultSpec_includeDeleted record
  , (\_v187 -> (10, ("includeUpdateSequenceNum",T.TBool _v187))) <$> notesMetadataResultSpec_includeUpdateSequenceNum record
  , (\_v187 -> (11, ("includeNotebookGuid",T.TBool _v187))) <$> notesMetadataResultSpec_includeNotebookGuid record
  , (\_v187 -> (12, ("includeTagGuids",T.TBool _v187))) <$> notesMetadataResultSpec_includeTagGuids record
  , (\_v187 -> (14, ("includeAttributes",T.TBool _v187))) <$> notesMetadataResultSpec_includeAttributes record
  , (\_v187 -> (20, ("includeLargestResourceMime",T.TBool _v187))) <$> notesMetadataResultSpec_includeLargestResourceMime record
  , (\_v187 -> (21, ("includeLargestResourceSize",T.TBool _v187))) <$> notesMetadataResultSpec_includeLargestResourceSize record
  ]
write_NotesMetadataResultSpec :: T.Protocol p => p -> NotesMetadataResultSpec -> P.IO ()
write_NotesMetadataResultSpec oprot record = T.writeVal oprot $ from_NotesMetadataResultSpec record
encode_NotesMetadataResultSpec :: T.StatelessProtocol p => p -> NotesMetadataResultSpec -> LBS.ByteString
encode_NotesMetadataResultSpec oprot record = T.serializeVal oprot $ from_NotesMetadataResultSpec record
to_NotesMetadataResultSpec :: T.ThriftVal -> NotesMetadataResultSpec
to_NotesMetadataResultSpec (T.TStruct fields) = NotesMetadataResultSpec{
  notesMetadataResultSpec_includeTitle = P.maybe (P.Nothing) (\(_,_val189) -> P.Just (case _val189 of {T.TBool _val190 -> _val190; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  notesMetadataResultSpec_includeContentLength = P.maybe (P.Nothing) (\(_,_val189) -> P.Just (case _val189 of {T.TBool _val191 -> _val191; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  notesMetadataResultSpec_includeCreated = P.maybe (P.Nothing) (\(_,_val189) -> P.Just (case _val189 of {T.TBool _val192 -> _val192; _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  notesMetadataResultSpec_includeUpdated = P.maybe (P.Nothing) (\(_,_val189) -> P.Just (case _val189 of {T.TBool _val193 -> _val193; _ -> P.error "wrong type"})) (Map.lookup (7) fields),
  notesMetadataResultSpec_includeDeleted = P.maybe (P.Nothing) (\(_,_val189) -> P.Just (case _val189 of {T.TBool _val194 -> _val194; _ -> P.error "wrong type"})) (Map.lookup (8) fields),
  notesMetadataResultSpec_includeUpdateSequenceNum = P.maybe (P.Nothing) (\(_,_val189) -> P.Just (case _val189 of {T.TBool _val195 -> _val195; _ -> P.error "wrong type"})) (Map.lookup (10) fields),
  notesMetadataResultSpec_includeNotebookGuid = P.maybe (P.Nothing) (\(_,_val189) -> P.Just (case _val189 of {T.TBool _val196 -> _val196; _ -> P.error "wrong type"})) (Map.lookup (11) fields),
  notesMetadataResultSpec_includeTagGuids = P.maybe (P.Nothing) (\(_,_val189) -> P.Just (case _val189 of {T.TBool _val197 -> _val197; _ -> P.error "wrong type"})) (Map.lookup (12) fields),
  notesMetadataResultSpec_includeAttributes = P.maybe (P.Nothing) (\(_,_val189) -> P.Just (case _val189 of {T.TBool _val198 -> _val198; _ -> P.error "wrong type"})) (Map.lookup (14) fields),
  notesMetadataResultSpec_includeLargestResourceMime = P.maybe (P.Nothing) (\(_,_val189) -> P.Just (case _val189 of {T.TBool _val199 -> _val199; _ -> P.error "wrong type"})) (Map.lookup (20) fields),
  notesMetadataResultSpec_includeLargestResourceSize = P.maybe (P.Nothing) (\(_,_val189) -> P.Just (case _val189 of {T.TBool _val200 -> _val200; _ -> P.error "wrong type"})) (Map.lookup (21) fields)
  }
to_NotesMetadataResultSpec _ = P.error "not a struct"
read_NotesMetadataResultSpec :: T.Protocol p => p -> P.IO NotesMetadataResultSpec
read_NotesMetadataResultSpec iprot = to_NotesMetadataResultSpec <$> T.readVal iprot (T.T_STRUCT typemap_NotesMetadataResultSpec)
decode_NotesMetadataResultSpec :: T.StatelessProtocol p => p -> LBS.ByteString -> NotesMetadataResultSpec
decode_NotesMetadataResultSpec iprot bs = to_NotesMetadataResultSpec $ T.deserializeVal iprot (T.T_STRUCT typemap_NotesMetadataResultSpec) bs
typemap_NotesMetadataResultSpec :: T.TypeMap
typemap_NotesMetadataResultSpec = Map.fromList [(2,("includeTitle",T.T_BOOL)),(5,("includeContentLength",T.T_BOOL)),(6,("includeCreated",T.T_BOOL)),(7,("includeUpdated",T.T_BOOL)),(8,("includeDeleted",T.T_BOOL)),(10,("includeUpdateSequenceNum",T.T_BOOL)),(11,("includeNotebookGuid",T.T_BOOL)),(12,("includeTagGuids",T.T_BOOL)),(14,("includeAttributes",T.T_BOOL)),(20,("includeLargestResourceMime",T.T_BOOL)),(21,("includeLargestResourceSize",T.T_BOOL))]
default_NotesMetadataResultSpec :: NotesMetadataResultSpec
default_NotesMetadataResultSpec = NotesMetadataResultSpec{
  notesMetadataResultSpec_includeTitle = P.Nothing,
  notesMetadataResultSpec_includeContentLength = P.Nothing,
  notesMetadataResultSpec_includeCreated = P.Nothing,
  notesMetadataResultSpec_includeUpdated = P.Nothing,
  notesMetadataResultSpec_includeDeleted = P.Nothing,
  notesMetadataResultSpec_includeUpdateSequenceNum = P.Nothing,
  notesMetadataResultSpec_includeNotebookGuid = P.Nothing,
  notesMetadataResultSpec_includeTagGuids = P.Nothing,
  notesMetadataResultSpec_includeAttributes = P.Nothing,
  notesMetadataResultSpec_includeLargestResourceMime = P.Nothing,
  notesMetadataResultSpec_includeLargestResourceSize = P.Nothing}
data NoteCollectionCounts = NoteCollectionCounts  { noteCollectionCounts_notebookCounts :: P.Maybe (Map.HashMap LT.Text I.Int32)
  , noteCollectionCounts_tagCounts :: P.Maybe (Map.HashMap LT.Text I.Int32)
  , noteCollectionCounts_trashCount :: P.Maybe I.Int32
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable NoteCollectionCounts where
  hashWithSalt salt record = salt   `H.hashWithSalt` noteCollectionCounts_notebookCounts record   `H.hashWithSalt` noteCollectionCounts_tagCounts record   `H.hashWithSalt` noteCollectionCounts_trashCount record  
instance QC.Arbitrary NoteCollectionCounts where 
  arbitrary = M.liftM NoteCollectionCounts (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_NoteCollectionCounts = []
             | P.otherwise = M.catMaybes
    [ if obj == default_NoteCollectionCounts{noteCollectionCounts_notebookCounts = noteCollectionCounts_notebookCounts obj} then P.Nothing else P.Just $ default_NoteCollectionCounts{noteCollectionCounts_notebookCounts = noteCollectionCounts_notebookCounts obj}
    , if obj == default_NoteCollectionCounts{noteCollectionCounts_tagCounts = noteCollectionCounts_tagCounts obj} then P.Nothing else P.Just $ default_NoteCollectionCounts{noteCollectionCounts_tagCounts = noteCollectionCounts_tagCounts obj}
    , if obj == default_NoteCollectionCounts{noteCollectionCounts_trashCount = noteCollectionCounts_trashCount obj} then P.Nothing else P.Just $ default_NoteCollectionCounts{noteCollectionCounts_trashCount = noteCollectionCounts_trashCount obj}
    ]
from_NoteCollectionCounts :: NoteCollectionCounts -> T.ThriftVal
from_NoteCollectionCounts record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v203 -> (1, ("notebookCounts",T.TMap T.T_STRING T.T_I32 $ P.map (\(_k204,_v205) -> (T.TString $ E.encodeUtf8 _k204, T.TI32 _v205)) $ Map.toList _v203))) <$> noteCollectionCounts_notebookCounts record
  , (\_v203 -> (2, ("tagCounts",T.TMap T.T_STRING T.T_I32 $ P.map (\(_k206,_v207) -> (T.TString $ E.encodeUtf8 _k206, T.TI32 _v207)) $ Map.toList _v203))) <$> noteCollectionCounts_tagCounts record
  , (\_v203 -> (3, ("trashCount",T.TI32 _v203))) <$> noteCollectionCounts_trashCount record
  ]
write_NoteCollectionCounts :: T.Protocol p => p -> NoteCollectionCounts -> P.IO ()
write_NoteCollectionCounts oprot record = T.writeVal oprot $ from_NoteCollectionCounts record
encode_NoteCollectionCounts :: T.StatelessProtocol p => p -> NoteCollectionCounts -> LBS.ByteString
encode_NoteCollectionCounts oprot record = T.serializeVal oprot $ from_NoteCollectionCounts record
to_NoteCollectionCounts :: T.ThriftVal -> NoteCollectionCounts
to_NoteCollectionCounts (T.TStruct fields) = NoteCollectionCounts{
  noteCollectionCounts_notebookCounts = P.maybe (P.Nothing) (\(_,_val209) -> P.Just (case _val209 of {T.TMap _ _ _val210 -> (Map.fromList $ P.map (\(_k212,_v211) -> ((case _k212 of {T.TString _val213 -> E.decodeUtf8 _val213; _ -> P.error "wrong type"}),(case _v211 of {T.TI32 _val214 -> _val214; _ -> P.error "wrong type"}))) _val210); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  noteCollectionCounts_tagCounts = P.maybe (P.Nothing) (\(_,_val209) -> P.Just (case _val209 of {T.TMap _ _ _val215 -> (Map.fromList $ P.map (\(_k217,_v216) -> ((case _k217 of {T.TString _val218 -> E.decodeUtf8 _val218; _ -> P.error "wrong type"}),(case _v216 of {T.TI32 _val219 -> _val219; _ -> P.error "wrong type"}))) _val215); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  noteCollectionCounts_trashCount = P.maybe (P.Nothing) (\(_,_val209) -> P.Just (case _val209 of {T.TI32 _val220 -> _val220; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_NoteCollectionCounts _ = P.error "not a struct"
read_NoteCollectionCounts :: T.Protocol p => p -> P.IO NoteCollectionCounts
read_NoteCollectionCounts iprot = to_NoteCollectionCounts <$> T.readVal iprot (T.T_STRUCT typemap_NoteCollectionCounts)
decode_NoteCollectionCounts :: T.StatelessProtocol p => p -> LBS.ByteString -> NoteCollectionCounts
decode_NoteCollectionCounts iprot bs = to_NoteCollectionCounts $ T.deserializeVal iprot (T.T_STRUCT typemap_NoteCollectionCounts) bs
typemap_NoteCollectionCounts :: T.TypeMap
typemap_NoteCollectionCounts = Map.fromList [(1,("notebookCounts",(T.T_MAP T.T_STRING T.T_I32))),(2,("tagCounts",(T.T_MAP T.T_STRING T.T_I32))),(3,("trashCount",T.T_I32))]
default_NoteCollectionCounts :: NoteCollectionCounts
default_NoteCollectionCounts = NoteCollectionCounts{
  noteCollectionCounts_notebookCounts = P.Nothing,
  noteCollectionCounts_tagCounts = P.Nothing,
  noteCollectionCounts_trashCount = P.Nothing}
data NoteResultSpec = NoteResultSpec  { noteResultSpec_includeContent :: P.Maybe P.Bool
  , noteResultSpec_includeResourcesData :: P.Maybe P.Bool
  , noteResultSpec_includeResourcesRecognition :: P.Maybe P.Bool
  , noteResultSpec_includeResourcesAlternateData :: P.Maybe P.Bool
  , noteResultSpec_includeSharedNotes :: P.Maybe P.Bool
  , noteResultSpec_includeNoteAppDataValues :: P.Maybe P.Bool
  , noteResultSpec_includeResourceAppDataValues :: P.Maybe P.Bool
  , noteResultSpec_includeAccountLimits :: P.Maybe P.Bool
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable NoteResultSpec where
  hashWithSalt salt record = salt   `H.hashWithSalt` noteResultSpec_includeContent record   `H.hashWithSalt` noteResultSpec_includeResourcesData record   `H.hashWithSalt` noteResultSpec_includeResourcesRecognition record   `H.hashWithSalt` noteResultSpec_includeResourcesAlternateData record   `H.hashWithSalt` noteResultSpec_includeSharedNotes record   `H.hashWithSalt` noteResultSpec_includeNoteAppDataValues record   `H.hashWithSalt` noteResultSpec_includeResourceAppDataValues record   `H.hashWithSalt` noteResultSpec_includeAccountLimits record  
instance QC.Arbitrary NoteResultSpec where 
  arbitrary = M.liftM NoteResultSpec (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_NoteResultSpec = []
             | P.otherwise = M.catMaybes
    [ if obj == default_NoteResultSpec{noteResultSpec_includeContent = noteResultSpec_includeContent obj} then P.Nothing else P.Just $ default_NoteResultSpec{noteResultSpec_includeContent = noteResultSpec_includeContent obj}
    , if obj == default_NoteResultSpec{noteResultSpec_includeResourcesData = noteResultSpec_includeResourcesData obj} then P.Nothing else P.Just $ default_NoteResultSpec{noteResultSpec_includeResourcesData = noteResultSpec_includeResourcesData obj}
    , if obj == default_NoteResultSpec{noteResultSpec_includeResourcesRecognition = noteResultSpec_includeResourcesRecognition obj} then P.Nothing else P.Just $ default_NoteResultSpec{noteResultSpec_includeResourcesRecognition = noteResultSpec_includeResourcesRecognition obj}
    , if obj == default_NoteResultSpec{noteResultSpec_includeResourcesAlternateData = noteResultSpec_includeResourcesAlternateData obj} then P.Nothing else P.Just $ default_NoteResultSpec{noteResultSpec_includeResourcesAlternateData = noteResultSpec_includeResourcesAlternateData obj}
    , if obj == default_NoteResultSpec{noteResultSpec_includeSharedNotes = noteResultSpec_includeSharedNotes obj} then P.Nothing else P.Just $ default_NoteResultSpec{noteResultSpec_includeSharedNotes = noteResultSpec_includeSharedNotes obj}
    , if obj == default_NoteResultSpec{noteResultSpec_includeNoteAppDataValues = noteResultSpec_includeNoteAppDataValues obj} then P.Nothing else P.Just $ default_NoteResultSpec{noteResultSpec_includeNoteAppDataValues = noteResultSpec_includeNoteAppDataValues obj}
    , if obj == default_NoteResultSpec{noteResultSpec_includeResourceAppDataValues = noteResultSpec_includeResourceAppDataValues obj} then P.Nothing else P.Just $ default_NoteResultSpec{noteResultSpec_includeResourceAppDataValues = noteResultSpec_includeResourceAppDataValues obj}
    , if obj == default_NoteResultSpec{noteResultSpec_includeAccountLimits = noteResultSpec_includeAccountLimits obj} then P.Nothing else P.Just $ default_NoteResultSpec{noteResultSpec_includeAccountLimits = noteResultSpec_includeAccountLimits obj}
    ]
from_NoteResultSpec :: NoteResultSpec -> T.ThriftVal
from_NoteResultSpec record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v223 -> (1, ("includeContent",T.TBool _v223))) <$> noteResultSpec_includeContent record
  , (\_v223 -> (2, ("includeResourcesData",T.TBool _v223))) <$> noteResultSpec_includeResourcesData record
  , (\_v223 -> (3, ("includeResourcesRecognition",T.TBool _v223))) <$> noteResultSpec_includeResourcesRecognition record
  , (\_v223 -> (4, ("includeResourcesAlternateData",T.TBool _v223))) <$> noteResultSpec_includeResourcesAlternateData record
  , (\_v223 -> (5, ("includeSharedNotes",T.TBool _v223))) <$> noteResultSpec_includeSharedNotes record
  , (\_v223 -> (6, ("includeNoteAppDataValues",T.TBool _v223))) <$> noteResultSpec_includeNoteAppDataValues record
  , (\_v223 -> (7, ("includeResourceAppDataValues",T.TBool _v223))) <$> noteResultSpec_includeResourceAppDataValues record
  , (\_v223 -> (8, ("includeAccountLimits",T.TBool _v223))) <$> noteResultSpec_includeAccountLimits record
  ]
write_NoteResultSpec :: T.Protocol p => p -> NoteResultSpec -> P.IO ()
write_NoteResultSpec oprot record = T.writeVal oprot $ from_NoteResultSpec record
encode_NoteResultSpec :: T.StatelessProtocol p => p -> NoteResultSpec -> LBS.ByteString
encode_NoteResultSpec oprot record = T.serializeVal oprot $ from_NoteResultSpec record
to_NoteResultSpec :: T.ThriftVal -> NoteResultSpec
to_NoteResultSpec (T.TStruct fields) = NoteResultSpec{
  noteResultSpec_includeContent = P.maybe (P.Nothing) (\(_,_val225) -> P.Just (case _val225 of {T.TBool _val226 -> _val226; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  noteResultSpec_includeResourcesData = P.maybe (P.Nothing) (\(_,_val225) -> P.Just (case _val225 of {T.TBool _val227 -> _val227; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  noteResultSpec_includeResourcesRecognition = P.maybe (P.Nothing) (\(_,_val225) -> P.Just (case _val225 of {T.TBool _val228 -> _val228; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  noteResultSpec_includeResourcesAlternateData = P.maybe (P.Nothing) (\(_,_val225) -> P.Just (case _val225 of {T.TBool _val229 -> _val229; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  noteResultSpec_includeSharedNotes = P.maybe (P.Nothing) (\(_,_val225) -> P.Just (case _val225 of {T.TBool _val230 -> _val230; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  noteResultSpec_includeNoteAppDataValues = P.maybe (P.Nothing) (\(_,_val225) -> P.Just (case _val225 of {T.TBool _val231 -> _val231; _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  noteResultSpec_includeResourceAppDataValues = P.maybe (P.Nothing) (\(_,_val225) -> P.Just (case _val225 of {T.TBool _val232 -> _val232; _ -> P.error "wrong type"})) (Map.lookup (7) fields),
  noteResultSpec_includeAccountLimits = P.maybe (P.Nothing) (\(_,_val225) -> P.Just (case _val225 of {T.TBool _val233 -> _val233; _ -> P.error "wrong type"})) (Map.lookup (8) fields)
  }
to_NoteResultSpec _ = P.error "not a struct"
read_NoteResultSpec :: T.Protocol p => p -> P.IO NoteResultSpec
read_NoteResultSpec iprot = to_NoteResultSpec <$> T.readVal iprot (T.T_STRUCT typemap_NoteResultSpec)
decode_NoteResultSpec :: T.StatelessProtocol p => p -> LBS.ByteString -> NoteResultSpec
decode_NoteResultSpec iprot bs = to_NoteResultSpec $ T.deserializeVal iprot (T.T_STRUCT typemap_NoteResultSpec) bs
typemap_NoteResultSpec :: T.TypeMap
typemap_NoteResultSpec = Map.fromList [(1,("includeContent",T.T_BOOL)),(2,("includeResourcesData",T.T_BOOL)),(3,("includeResourcesRecognition",T.T_BOOL)),(4,("includeResourcesAlternateData",T.T_BOOL)),(5,("includeSharedNotes",T.T_BOOL)),(6,("includeNoteAppDataValues",T.T_BOOL)),(7,("includeResourceAppDataValues",T.T_BOOL)),(8,("includeAccountLimits",T.T_BOOL))]
default_NoteResultSpec :: NoteResultSpec
default_NoteResultSpec = NoteResultSpec{
  noteResultSpec_includeContent = P.Nothing,
  noteResultSpec_includeResourcesData = P.Nothing,
  noteResultSpec_includeResourcesRecognition = P.Nothing,
  noteResultSpec_includeResourcesAlternateData = P.Nothing,
  noteResultSpec_includeSharedNotes = P.Nothing,
  noteResultSpec_includeNoteAppDataValues = P.Nothing,
  noteResultSpec_includeResourceAppDataValues = P.Nothing,
  noteResultSpec_includeAccountLimits = P.Nothing}
data NoteEmailParameters = NoteEmailParameters  { noteEmailParameters_guid :: P.Maybe LT.Text
  , noteEmailParameters_note :: P.Maybe Types_Types.Note
  , noteEmailParameters_toAddresses :: P.Maybe (Vector.Vector LT.Text)
  , noteEmailParameters_ccAddresses :: P.Maybe (Vector.Vector LT.Text)
  , noteEmailParameters_subject :: P.Maybe LT.Text
  , noteEmailParameters_message :: P.Maybe LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable NoteEmailParameters where
  hashWithSalt salt record = salt   `H.hashWithSalt` noteEmailParameters_guid record   `H.hashWithSalt` noteEmailParameters_note record   `H.hashWithSalt` noteEmailParameters_toAddresses record   `H.hashWithSalt` noteEmailParameters_ccAddresses record   `H.hashWithSalt` noteEmailParameters_subject record   `H.hashWithSalt` noteEmailParameters_message record  
instance QC.Arbitrary NoteEmailParameters where 
  arbitrary = M.liftM NoteEmailParameters (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_NoteEmailParameters = []
             | P.otherwise = M.catMaybes
    [ if obj == default_NoteEmailParameters{noteEmailParameters_guid = noteEmailParameters_guid obj} then P.Nothing else P.Just $ default_NoteEmailParameters{noteEmailParameters_guid = noteEmailParameters_guid obj}
    , if obj == default_NoteEmailParameters{noteEmailParameters_note = noteEmailParameters_note obj} then P.Nothing else P.Just $ default_NoteEmailParameters{noteEmailParameters_note = noteEmailParameters_note obj}
    , if obj == default_NoteEmailParameters{noteEmailParameters_toAddresses = noteEmailParameters_toAddresses obj} then P.Nothing else P.Just $ default_NoteEmailParameters{noteEmailParameters_toAddresses = noteEmailParameters_toAddresses obj}
    , if obj == default_NoteEmailParameters{noteEmailParameters_ccAddresses = noteEmailParameters_ccAddresses obj} then P.Nothing else P.Just $ default_NoteEmailParameters{noteEmailParameters_ccAddresses = noteEmailParameters_ccAddresses obj}
    , if obj == default_NoteEmailParameters{noteEmailParameters_subject = noteEmailParameters_subject obj} then P.Nothing else P.Just $ default_NoteEmailParameters{noteEmailParameters_subject = noteEmailParameters_subject obj}
    , if obj == default_NoteEmailParameters{noteEmailParameters_message = noteEmailParameters_message obj} then P.Nothing else P.Just $ default_NoteEmailParameters{noteEmailParameters_message = noteEmailParameters_message obj}
    ]
from_NoteEmailParameters :: NoteEmailParameters -> T.ThriftVal
from_NoteEmailParameters record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v236 -> (1, ("guid",T.TString $ E.encodeUtf8 _v236))) <$> noteEmailParameters_guid record
  , (\_v236 -> (2, ("note",Types_Types.from_Note _v236))) <$> noteEmailParameters_note record
  , (\_v236 -> (3, ("toAddresses",T.TList T.T_STRING $ P.map (\_v238 -> T.TString $ E.encodeUtf8 _v238) $ Vector.toList _v236))) <$> noteEmailParameters_toAddresses record
  , (\_v236 -> (4, ("ccAddresses",T.TList T.T_STRING $ P.map (\_v240 -> T.TString $ E.encodeUtf8 _v240) $ Vector.toList _v236))) <$> noteEmailParameters_ccAddresses record
  , (\_v236 -> (5, ("subject",T.TString $ E.encodeUtf8 _v236))) <$> noteEmailParameters_subject record
  , (\_v236 -> (6, ("message",T.TString $ E.encodeUtf8 _v236))) <$> noteEmailParameters_message record
  ]
write_NoteEmailParameters :: T.Protocol p => p -> NoteEmailParameters -> P.IO ()
write_NoteEmailParameters oprot record = T.writeVal oprot $ from_NoteEmailParameters record
encode_NoteEmailParameters :: T.StatelessProtocol p => p -> NoteEmailParameters -> LBS.ByteString
encode_NoteEmailParameters oprot record = T.serializeVal oprot $ from_NoteEmailParameters record
to_NoteEmailParameters :: T.ThriftVal -> NoteEmailParameters
to_NoteEmailParameters (T.TStruct fields) = NoteEmailParameters{
  noteEmailParameters_guid = P.maybe (P.Nothing) (\(_,_val242) -> P.Just (case _val242 of {T.TString _val243 -> E.decodeUtf8 _val243; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  noteEmailParameters_note = P.maybe (P.Nothing) (\(_,_val242) -> P.Just (case _val242 of {T.TStruct _val244 -> (Types_Types.to_Note (T.TStruct _val244)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  noteEmailParameters_toAddresses = P.maybe (P.Nothing) (\(_,_val242) -> P.Just (case _val242 of {T.TList _ _val245 -> (Vector.fromList $ P.map (\_v246 -> (case _v246 of {T.TString _val247 -> E.decodeUtf8 _val247; _ -> P.error "wrong type"})) _val245); _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  noteEmailParameters_ccAddresses = P.maybe (P.Nothing) (\(_,_val242) -> P.Just (case _val242 of {T.TList _ _val248 -> (Vector.fromList $ P.map (\_v249 -> (case _v249 of {T.TString _val250 -> E.decodeUtf8 _val250; _ -> P.error "wrong type"})) _val248); _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  noteEmailParameters_subject = P.maybe (P.Nothing) (\(_,_val242) -> P.Just (case _val242 of {T.TString _val251 -> E.decodeUtf8 _val251; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  noteEmailParameters_message = P.maybe (P.Nothing) (\(_,_val242) -> P.Just (case _val242 of {T.TString _val252 -> E.decodeUtf8 _val252; _ -> P.error "wrong type"})) (Map.lookup (6) fields)
  }
to_NoteEmailParameters _ = P.error "not a struct"
read_NoteEmailParameters :: T.Protocol p => p -> P.IO NoteEmailParameters
read_NoteEmailParameters iprot = to_NoteEmailParameters <$> T.readVal iprot (T.T_STRUCT typemap_NoteEmailParameters)
decode_NoteEmailParameters :: T.StatelessProtocol p => p -> LBS.ByteString -> NoteEmailParameters
decode_NoteEmailParameters iprot bs = to_NoteEmailParameters $ T.deserializeVal iprot (T.T_STRUCT typemap_NoteEmailParameters) bs
typemap_NoteEmailParameters :: T.TypeMap
typemap_NoteEmailParameters = Map.fromList [(1,("guid",T.T_STRING)),(2,("note",(T.T_STRUCT Types_Types.typemap_Note))),(3,("toAddresses",(T.T_LIST T.T_STRING))),(4,("ccAddresses",(T.T_LIST T.T_STRING))),(5,("subject",T.T_STRING)),(6,("message",T.T_STRING))]
default_NoteEmailParameters :: NoteEmailParameters
default_NoteEmailParameters = NoteEmailParameters{
  noteEmailParameters_guid = P.Nothing,
  noteEmailParameters_note = P.Nothing,
  noteEmailParameters_toAddresses = P.Nothing,
  noteEmailParameters_ccAddresses = P.Nothing,
  noteEmailParameters_subject = P.Nothing,
  noteEmailParameters_message = P.Nothing}
data NoteVersionId = NoteVersionId  { noteVersionId_updateSequenceNum :: I.Int32
  , noteVersionId_updated :: I.Int64
  , noteVersionId_saved :: I.Int64
  , noteVersionId_title :: LT.Text
  , noteVersionId_lastEditorId :: P.Maybe I.Int32
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable NoteVersionId where
  hashWithSalt salt record = salt   `H.hashWithSalt` noteVersionId_updateSequenceNum record   `H.hashWithSalt` noteVersionId_updated record   `H.hashWithSalt` noteVersionId_saved record   `H.hashWithSalt` noteVersionId_title record   `H.hashWithSalt` noteVersionId_lastEditorId record  
instance QC.Arbitrary NoteVersionId where 
  arbitrary = M.liftM NoteVersionId (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_NoteVersionId = []
             | P.otherwise = M.catMaybes
    [ if obj == default_NoteVersionId{noteVersionId_updateSequenceNum = noteVersionId_updateSequenceNum obj} then P.Nothing else P.Just $ default_NoteVersionId{noteVersionId_updateSequenceNum = noteVersionId_updateSequenceNum obj}
    , if obj == default_NoteVersionId{noteVersionId_updated = noteVersionId_updated obj} then P.Nothing else P.Just $ default_NoteVersionId{noteVersionId_updated = noteVersionId_updated obj}
    , if obj == default_NoteVersionId{noteVersionId_saved = noteVersionId_saved obj} then P.Nothing else P.Just $ default_NoteVersionId{noteVersionId_saved = noteVersionId_saved obj}
    , if obj == default_NoteVersionId{noteVersionId_title = noteVersionId_title obj} then P.Nothing else P.Just $ default_NoteVersionId{noteVersionId_title = noteVersionId_title obj}
    , if obj == default_NoteVersionId{noteVersionId_lastEditorId = noteVersionId_lastEditorId obj} then P.Nothing else P.Just $ default_NoteVersionId{noteVersionId_lastEditorId = noteVersionId_lastEditorId obj}
    ]
from_NoteVersionId :: NoteVersionId -> T.ThriftVal
from_NoteVersionId record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v255 -> P.Just (1, ("updateSequenceNum",T.TI32 _v255))) $ noteVersionId_updateSequenceNum record
  , (\_v255 -> P.Just (2, ("updated",T.TI64 _v255))) $ noteVersionId_updated record
  , (\_v255 -> P.Just (3, ("saved",T.TI64 _v255))) $ noteVersionId_saved record
  , (\_v255 -> P.Just (4, ("title",T.TString $ E.encodeUtf8 _v255))) $ noteVersionId_title record
  , (\_v255 -> (5, ("lastEditorId",T.TI32 _v255))) <$> noteVersionId_lastEditorId record
  ]
write_NoteVersionId :: T.Protocol p => p -> NoteVersionId -> P.IO ()
write_NoteVersionId oprot record = T.writeVal oprot $ from_NoteVersionId record
encode_NoteVersionId :: T.StatelessProtocol p => p -> NoteVersionId -> LBS.ByteString
encode_NoteVersionId oprot record = T.serializeVal oprot $ from_NoteVersionId record
to_NoteVersionId :: T.ThriftVal -> NoteVersionId
to_NoteVersionId (T.TStruct fields) = NoteVersionId{
  noteVersionId_updateSequenceNum = P.maybe (P.error "Missing required field: updateSequenceNum") (\(_,_val257) -> (case _val257 of {T.TI32 _val258 -> _val258; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  noteVersionId_updated = P.maybe (P.error "Missing required field: updated") (\(_,_val257) -> (case _val257 of {T.TI64 _val259 -> _val259; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  noteVersionId_saved = P.maybe (P.error "Missing required field: saved") (\(_,_val257) -> (case _val257 of {T.TI64 _val260 -> _val260; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  noteVersionId_title = P.maybe (P.error "Missing required field: title") (\(_,_val257) -> (case _val257 of {T.TString _val261 -> E.decodeUtf8 _val261; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  noteVersionId_lastEditorId = P.maybe (P.Nothing) (\(_,_val257) -> P.Just (case _val257 of {T.TI32 _val262 -> _val262; _ -> P.error "wrong type"})) (Map.lookup (5) fields)
  }
to_NoteVersionId _ = P.error "not a struct"
read_NoteVersionId :: T.Protocol p => p -> P.IO NoteVersionId
read_NoteVersionId iprot = to_NoteVersionId <$> T.readVal iprot (T.T_STRUCT typemap_NoteVersionId)
decode_NoteVersionId :: T.StatelessProtocol p => p -> LBS.ByteString -> NoteVersionId
decode_NoteVersionId iprot bs = to_NoteVersionId $ T.deserializeVal iprot (T.T_STRUCT typemap_NoteVersionId) bs
typemap_NoteVersionId :: T.TypeMap
typemap_NoteVersionId = Map.fromList [(1,("updateSequenceNum",T.T_I32)),(2,("updated",T.T_I64)),(3,("saved",T.T_I64)),(4,("title",T.T_STRING)),(5,("lastEditorId",T.T_I32))]
default_NoteVersionId :: NoteVersionId
default_NoteVersionId = NoteVersionId{
  noteVersionId_updateSequenceNum = 0,
  noteVersionId_updated = 0,
  noteVersionId_saved = 0,
  noteVersionId_title = "",
  noteVersionId_lastEditorId = P.Nothing}
data RelatedQuery = RelatedQuery  { relatedQuery_noteGuid :: P.Maybe LT.Text
  , relatedQuery_plainText :: P.Maybe LT.Text
  , relatedQuery_filter :: P.Maybe NoteFilter
  , relatedQuery_referenceUri :: P.Maybe LT.Text
  , relatedQuery_context :: P.Maybe LT.Text
  , relatedQuery_cacheKey :: P.Maybe LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RelatedQuery where
  hashWithSalt salt record = salt   `H.hashWithSalt` relatedQuery_noteGuid record   `H.hashWithSalt` relatedQuery_plainText record   `H.hashWithSalt` relatedQuery_filter record   `H.hashWithSalt` relatedQuery_referenceUri record   `H.hashWithSalt` relatedQuery_context record   `H.hashWithSalt` relatedQuery_cacheKey record  
instance QC.Arbitrary RelatedQuery where 
  arbitrary = M.liftM RelatedQuery (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_RelatedQuery = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RelatedQuery{relatedQuery_noteGuid = relatedQuery_noteGuid obj} then P.Nothing else P.Just $ default_RelatedQuery{relatedQuery_noteGuid = relatedQuery_noteGuid obj}
    , if obj == default_RelatedQuery{relatedQuery_plainText = relatedQuery_plainText obj} then P.Nothing else P.Just $ default_RelatedQuery{relatedQuery_plainText = relatedQuery_plainText obj}
    , if obj == default_RelatedQuery{relatedQuery_filter = relatedQuery_filter obj} then P.Nothing else P.Just $ default_RelatedQuery{relatedQuery_filter = relatedQuery_filter obj}
    , if obj == default_RelatedQuery{relatedQuery_referenceUri = relatedQuery_referenceUri obj} then P.Nothing else P.Just $ default_RelatedQuery{relatedQuery_referenceUri = relatedQuery_referenceUri obj}
    , if obj == default_RelatedQuery{relatedQuery_context = relatedQuery_context obj} then P.Nothing else P.Just $ default_RelatedQuery{relatedQuery_context = relatedQuery_context obj}
    , if obj == default_RelatedQuery{relatedQuery_cacheKey = relatedQuery_cacheKey obj} then P.Nothing else P.Just $ default_RelatedQuery{relatedQuery_cacheKey = relatedQuery_cacheKey obj}
    ]
from_RelatedQuery :: RelatedQuery -> T.ThriftVal
from_RelatedQuery record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v265 -> (1, ("noteGuid",T.TString $ E.encodeUtf8 _v265))) <$> relatedQuery_noteGuid record
  , (\_v265 -> (2, ("plainText",T.TString $ E.encodeUtf8 _v265))) <$> relatedQuery_plainText record
  , (\_v265 -> (3, ("filter",from_NoteFilter _v265))) <$> relatedQuery_filter record
  , (\_v265 -> (4, ("referenceUri",T.TString $ E.encodeUtf8 _v265))) <$> relatedQuery_referenceUri record
  , (\_v265 -> (5, ("context",T.TString $ E.encodeUtf8 _v265))) <$> relatedQuery_context record
  , (\_v265 -> (6, ("cacheKey",T.TString $ E.encodeUtf8 _v265))) <$> relatedQuery_cacheKey record
  ]
write_RelatedQuery :: T.Protocol p => p -> RelatedQuery -> P.IO ()
write_RelatedQuery oprot record = T.writeVal oprot $ from_RelatedQuery record
encode_RelatedQuery :: T.StatelessProtocol p => p -> RelatedQuery -> LBS.ByteString
encode_RelatedQuery oprot record = T.serializeVal oprot $ from_RelatedQuery record
to_RelatedQuery :: T.ThriftVal -> RelatedQuery
to_RelatedQuery (T.TStruct fields) = RelatedQuery{
  relatedQuery_noteGuid = P.maybe (P.Nothing) (\(_,_val267) -> P.Just (case _val267 of {T.TString _val268 -> E.decodeUtf8 _val268; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  relatedQuery_plainText = P.maybe (P.Nothing) (\(_,_val267) -> P.Just (case _val267 of {T.TString _val269 -> E.decodeUtf8 _val269; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  relatedQuery_filter = P.maybe (P.Nothing) (\(_,_val267) -> P.Just (case _val267 of {T.TStruct _val270 -> (to_NoteFilter (T.TStruct _val270)); _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  relatedQuery_referenceUri = P.maybe (P.Nothing) (\(_,_val267) -> P.Just (case _val267 of {T.TString _val271 -> E.decodeUtf8 _val271; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  relatedQuery_context = P.maybe (P.Nothing) (\(_,_val267) -> P.Just (case _val267 of {T.TString _val272 -> E.decodeUtf8 _val272; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  relatedQuery_cacheKey = P.maybe (P.Nothing) (\(_,_val267) -> P.Just (case _val267 of {T.TString _val273 -> E.decodeUtf8 _val273; _ -> P.error "wrong type"})) (Map.lookup (6) fields)
  }
to_RelatedQuery _ = P.error "not a struct"
read_RelatedQuery :: T.Protocol p => p -> P.IO RelatedQuery
read_RelatedQuery iprot = to_RelatedQuery <$> T.readVal iprot (T.T_STRUCT typemap_RelatedQuery)
decode_RelatedQuery :: T.StatelessProtocol p => p -> LBS.ByteString -> RelatedQuery
decode_RelatedQuery iprot bs = to_RelatedQuery $ T.deserializeVal iprot (T.T_STRUCT typemap_RelatedQuery) bs
typemap_RelatedQuery :: T.TypeMap
typemap_RelatedQuery = Map.fromList [(1,("noteGuid",T.T_STRING)),(2,("plainText",T.T_STRING)),(3,("filter",(T.T_STRUCT typemap_NoteFilter))),(4,("referenceUri",T.T_STRING)),(5,("context",T.T_STRING)),(6,("cacheKey",T.T_STRING))]
default_RelatedQuery :: RelatedQuery
default_RelatedQuery = RelatedQuery{
  relatedQuery_noteGuid = P.Nothing,
  relatedQuery_plainText = P.Nothing,
  relatedQuery_filter = P.Nothing,
  relatedQuery_referenceUri = P.Nothing,
  relatedQuery_context = P.Nothing,
  relatedQuery_cacheKey = P.Nothing}
data RelatedResult = RelatedResult  { relatedResult_notes :: P.Maybe (Vector.Vector Types_Types.Note)
  , relatedResult_notebooks :: P.Maybe (Vector.Vector Types_Types.Notebook)
  , relatedResult_tags :: P.Maybe (Vector.Vector Types_Types.Tag)
  , relatedResult_containingNotebooks :: P.Maybe (Vector.Vector Types_Types.NotebookDescriptor)
  , relatedResult_experts :: P.Maybe (Vector.Vector Types_Types.UserProfile)
  , relatedResult_relatedContent :: P.Maybe (Vector.Vector Types_Types.RelatedContent)
  , relatedResult_cacheKey :: P.Maybe LT.Text
  , relatedResult_cacheExpires :: P.Maybe I.Int32
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RelatedResult where
  hashWithSalt salt record = salt   `H.hashWithSalt` relatedResult_notes record   `H.hashWithSalt` relatedResult_notebooks record   `H.hashWithSalt` relatedResult_tags record   `H.hashWithSalt` relatedResult_containingNotebooks record   `H.hashWithSalt` relatedResult_experts record   `H.hashWithSalt` relatedResult_relatedContent record   `H.hashWithSalt` relatedResult_cacheKey record   `H.hashWithSalt` relatedResult_cacheExpires record  
instance QC.Arbitrary RelatedResult where 
  arbitrary = M.liftM RelatedResult (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_RelatedResult = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RelatedResult{relatedResult_notes = relatedResult_notes obj} then P.Nothing else P.Just $ default_RelatedResult{relatedResult_notes = relatedResult_notes obj}
    , if obj == default_RelatedResult{relatedResult_notebooks = relatedResult_notebooks obj} then P.Nothing else P.Just $ default_RelatedResult{relatedResult_notebooks = relatedResult_notebooks obj}
    , if obj == default_RelatedResult{relatedResult_tags = relatedResult_tags obj} then P.Nothing else P.Just $ default_RelatedResult{relatedResult_tags = relatedResult_tags obj}
    , if obj == default_RelatedResult{relatedResult_containingNotebooks = relatedResult_containingNotebooks obj} then P.Nothing else P.Just $ default_RelatedResult{relatedResult_containingNotebooks = relatedResult_containingNotebooks obj}
    , if obj == default_RelatedResult{relatedResult_experts = relatedResult_experts obj} then P.Nothing else P.Just $ default_RelatedResult{relatedResult_experts = relatedResult_experts obj}
    , if obj == default_RelatedResult{relatedResult_relatedContent = relatedResult_relatedContent obj} then P.Nothing else P.Just $ default_RelatedResult{relatedResult_relatedContent = relatedResult_relatedContent obj}
    , if obj == default_RelatedResult{relatedResult_cacheKey = relatedResult_cacheKey obj} then P.Nothing else P.Just $ default_RelatedResult{relatedResult_cacheKey = relatedResult_cacheKey obj}
    , if obj == default_RelatedResult{relatedResult_cacheExpires = relatedResult_cacheExpires obj} then P.Nothing else P.Just $ default_RelatedResult{relatedResult_cacheExpires = relatedResult_cacheExpires obj}
    ]
from_RelatedResult :: RelatedResult -> T.ThriftVal
from_RelatedResult record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v276 -> (1, ("notes",T.TList (T.T_STRUCT Types_Types.typemap_Note) $ P.map (\_v278 -> Types_Types.from_Note _v278) $ Vector.toList _v276))) <$> relatedResult_notes record
  , (\_v276 -> (2, ("notebooks",T.TList (T.T_STRUCT Types_Types.typemap_Notebook) $ P.map (\_v280 -> Types_Types.from_Notebook _v280) $ Vector.toList _v276))) <$> relatedResult_notebooks record
  , (\_v276 -> (3, ("tags",T.TList (T.T_STRUCT Types_Types.typemap_Tag) $ P.map (\_v282 -> Types_Types.from_Tag _v282) $ Vector.toList _v276))) <$> relatedResult_tags record
  , (\_v276 -> (4, ("containingNotebooks",T.TList (T.T_STRUCT Types_Types.typemap_NotebookDescriptor) $ P.map (\_v284 -> Types_Types.from_NotebookDescriptor _v284) $ Vector.toList _v276))) <$> relatedResult_containingNotebooks record
  , (\_v276 -> (6, ("experts",T.TList (T.T_STRUCT Types_Types.typemap_UserProfile) $ P.map (\_v286 -> Types_Types.from_UserProfile _v286) $ Vector.toList _v276))) <$> relatedResult_experts record
  , (\_v276 -> (7, ("relatedContent",T.TList (T.T_STRUCT Types_Types.typemap_RelatedContent) $ P.map (\_v288 -> Types_Types.from_RelatedContent _v288) $ Vector.toList _v276))) <$> relatedResult_relatedContent record
  , (\_v276 -> (8, ("cacheKey",T.TString $ E.encodeUtf8 _v276))) <$> relatedResult_cacheKey record
  , (\_v276 -> (9, ("cacheExpires",T.TI32 _v276))) <$> relatedResult_cacheExpires record
  ]
write_RelatedResult :: T.Protocol p => p -> RelatedResult -> P.IO ()
write_RelatedResult oprot record = T.writeVal oprot $ from_RelatedResult record
encode_RelatedResult :: T.StatelessProtocol p => p -> RelatedResult -> LBS.ByteString
encode_RelatedResult oprot record = T.serializeVal oprot $ from_RelatedResult record
to_RelatedResult :: T.ThriftVal -> RelatedResult
to_RelatedResult (T.TStruct fields) = RelatedResult{
  relatedResult_notes = P.maybe (P.Nothing) (\(_,_val290) -> P.Just (case _val290 of {T.TList _ _val291 -> (Vector.fromList $ P.map (\_v292 -> (case _v292 of {T.TStruct _val293 -> (Types_Types.to_Note (T.TStruct _val293)); _ -> P.error "wrong type"})) _val291); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  relatedResult_notebooks = P.maybe (P.Nothing) (\(_,_val290) -> P.Just (case _val290 of {T.TList _ _val294 -> (Vector.fromList $ P.map (\_v295 -> (case _v295 of {T.TStruct _val296 -> (Types_Types.to_Notebook (T.TStruct _val296)); _ -> P.error "wrong type"})) _val294); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  relatedResult_tags = P.maybe (P.Nothing) (\(_,_val290) -> P.Just (case _val290 of {T.TList _ _val297 -> (Vector.fromList $ P.map (\_v298 -> (case _v298 of {T.TStruct _val299 -> (Types_Types.to_Tag (T.TStruct _val299)); _ -> P.error "wrong type"})) _val297); _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  relatedResult_containingNotebooks = P.maybe (P.Nothing) (\(_,_val290) -> P.Just (case _val290 of {T.TList _ _val300 -> (Vector.fromList $ P.map (\_v301 -> (case _v301 of {T.TStruct _val302 -> (Types_Types.to_NotebookDescriptor (T.TStruct _val302)); _ -> P.error "wrong type"})) _val300); _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  relatedResult_experts = P.maybe (P.Nothing) (\(_,_val290) -> P.Just (case _val290 of {T.TList _ _val303 -> (Vector.fromList $ P.map (\_v304 -> (case _v304 of {T.TStruct _val305 -> (Types_Types.to_UserProfile (T.TStruct _val305)); _ -> P.error "wrong type"})) _val303); _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  relatedResult_relatedContent = P.maybe (P.Nothing) (\(_,_val290) -> P.Just (case _val290 of {T.TList _ _val306 -> (Vector.fromList $ P.map (\_v307 -> (case _v307 of {T.TStruct _val308 -> (Types_Types.to_RelatedContent (T.TStruct _val308)); _ -> P.error "wrong type"})) _val306); _ -> P.error "wrong type"})) (Map.lookup (7) fields),
  relatedResult_cacheKey = P.maybe (P.Nothing) (\(_,_val290) -> P.Just (case _val290 of {T.TString _val309 -> E.decodeUtf8 _val309; _ -> P.error "wrong type"})) (Map.lookup (8) fields),
  relatedResult_cacheExpires = P.maybe (P.Nothing) (\(_,_val290) -> P.Just (case _val290 of {T.TI32 _val310 -> _val310; _ -> P.error "wrong type"})) (Map.lookup (9) fields)
  }
to_RelatedResult _ = P.error "not a struct"
read_RelatedResult :: T.Protocol p => p -> P.IO RelatedResult
read_RelatedResult iprot = to_RelatedResult <$> T.readVal iprot (T.T_STRUCT typemap_RelatedResult)
decode_RelatedResult :: T.StatelessProtocol p => p -> LBS.ByteString -> RelatedResult
decode_RelatedResult iprot bs = to_RelatedResult $ T.deserializeVal iprot (T.T_STRUCT typemap_RelatedResult) bs
typemap_RelatedResult :: T.TypeMap
typemap_RelatedResult = Map.fromList [(1,("notes",(T.T_LIST (T.T_STRUCT Types_Types.typemap_Note)))),(2,("notebooks",(T.T_LIST (T.T_STRUCT Types_Types.typemap_Notebook)))),(3,("tags",(T.T_LIST (T.T_STRUCT Types_Types.typemap_Tag)))),(4,("containingNotebooks",(T.T_LIST (T.T_STRUCT Types_Types.typemap_NotebookDescriptor)))),(6,("experts",(T.T_LIST (T.T_STRUCT Types_Types.typemap_UserProfile)))),(7,("relatedContent",(T.T_LIST (T.T_STRUCT Types_Types.typemap_RelatedContent)))),(8,("cacheKey",T.T_STRING)),(9,("cacheExpires",T.T_I32))]
default_RelatedResult :: RelatedResult
default_RelatedResult = RelatedResult{
  relatedResult_notes = P.Nothing,
  relatedResult_notebooks = P.Nothing,
  relatedResult_tags = P.Nothing,
  relatedResult_containingNotebooks = P.Nothing,
  relatedResult_experts = P.Nothing,
  relatedResult_relatedContent = P.Nothing,
  relatedResult_cacheKey = P.Nothing,
  relatedResult_cacheExpires = P.Nothing}
data RelatedResultSpec = RelatedResultSpec  { relatedResultSpec_maxNotes :: P.Maybe I.Int32
  , relatedResultSpec_maxNotebooks :: P.Maybe I.Int32
  , relatedResultSpec_maxTags :: P.Maybe I.Int32
  , relatedResultSpec_writableNotebooksOnly :: P.Maybe P.Bool
  , relatedResultSpec_includeContainingNotebooks :: P.Maybe P.Bool
  , relatedResultSpec_maxExperts :: P.Maybe I.Int32
  , relatedResultSpec_maxRelatedContent :: P.Maybe I.Int32
  , relatedResultSpec_relatedContentTypes :: P.Maybe (Set.HashSet Types_Types.RelatedContentType)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RelatedResultSpec where
  hashWithSalt salt record = salt   `H.hashWithSalt` relatedResultSpec_maxNotes record   `H.hashWithSalt` relatedResultSpec_maxNotebooks record   `H.hashWithSalt` relatedResultSpec_maxTags record   `H.hashWithSalt` relatedResultSpec_writableNotebooksOnly record   `H.hashWithSalt` relatedResultSpec_includeContainingNotebooks record   `H.hashWithSalt` relatedResultSpec_maxExperts record   `H.hashWithSalt` relatedResultSpec_maxRelatedContent record   `H.hashWithSalt` relatedResultSpec_relatedContentTypes record  
instance QC.Arbitrary RelatedResultSpec where 
  arbitrary = M.liftM RelatedResultSpec (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_RelatedResultSpec = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RelatedResultSpec{relatedResultSpec_maxNotes = relatedResultSpec_maxNotes obj} then P.Nothing else P.Just $ default_RelatedResultSpec{relatedResultSpec_maxNotes = relatedResultSpec_maxNotes obj}
    , if obj == default_RelatedResultSpec{relatedResultSpec_maxNotebooks = relatedResultSpec_maxNotebooks obj} then P.Nothing else P.Just $ default_RelatedResultSpec{relatedResultSpec_maxNotebooks = relatedResultSpec_maxNotebooks obj}
    , if obj == default_RelatedResultSpec{relatedResultSpec_maxTags = relatedResultSpec_maxTags obj} then P.Nothing else P.Just $ default_RelatedResultSpec{relatedResultSpec_maxTags = relatedResultSpec_maxTags obj}
    , if obj == default_RelatedResultSpec{relatedResultSpec_writableNotebooksOnly = relatedResultSpec_writableNotebooksOnly obj} then P.Nothing else P.Just $ default_RelatedResultSpec{relatedResultSpec_writableNotebooksOnly = relatedResultSpec_writableNotebooksOnly obj}
    , if obj == default_RelatedResultSpec{relatedResultSpec_includeContainingNotebooks = relatedResultSpec_includeContainingNotebooks obj} then P.Nothing else P.Just $ default_RelatedResultSpec{relatedResultSpec_includeContainingNotebooks = relatedResultSpec_includeContainingNotebooks obj}
    , if obj == default_RelatedResultSpec{relatedResultSpec_maxExperts = relatedResultSpec_maxExperts obj} then P.Nothing else P.Just $ default_RelatedResultSpec{relatedResultSpec_maxExperts = relatedResultSpec_maxExperts obj}
    , if obj == default_RelatedResultSpec{relatedResultSpec_maxRelatedContent = relatedResultSpec_maxRelatedContent obj} then P.Nothing else P.Just $ default_RelatedResultSpec{relatedResultSpec_maxRelatedContent = relatedResultSpec_maxRelatedContent obj}
    , if obj == default_RelatedResultSpec{relatedResultSpec_relatedContentTypes = relatedResultSpec_relatedContentTypes obj} then P.Nothing else P.Just $ default_RelatedResultSpec{relatedResultSpec_relatedContentTypes = relatedResultSpec_relatedContentTypes obj}
    ]
from_RelatedResultSpec :: RelatedResultSpec -> T.ThriftVal
from_RelatedResultSpec record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v313 -> (1, ("maxNotes",T.TI32 _v313))) <$> relatedResultSpec_maxNotes record
  , (\_v313 -> (2, ("maxNotebooks",T.TI32 _v313))) <$> relatedResultSpec_maxNotebooks record
  , (\_v313 -> (3, ("maxTags",T.TI32 _v313))) <$> relatedResultSpec_maxTags record
  , (\_v313 -> (4, ("writableNotebooksOnly",T.TBool _v313))) <$> relatedResultSpec_writableNotebooksOnly record
  , (\_v313 -> (5, ("includeContainingNotebooks",T.TBool _v313))) <$> relatedResultSpec_includeContainingNotebooks record
  , (\_v313 -> (7, ("maxExperts",T.TI32 _v313))) <$> relatedResultSpec_maxExperts record
  , (\_v313 -> (8, ("maxRelatedContent",T.TI32 _v313))) <$> relatedResultSpec_maxRelatedContent record
  , (\_v313 -> (9, ("relatedContentTypes",T.TSet T.T_I32 $ P.map (\_v315 -> T.TI32 $ P.fromIntegral $ P.fromEnum _v315) $ Set.toList _v313))) <$> relatedResultSpec_relatedContentTypes record
  ]
write_RelatedResultSpec :: T.Protocol p => p -> RelatedResultSpec -> P.IO ()
write_RelatedResultSpec oprot record = T.writeVal oprot $ from_RelatedResultSpec record
encode_RelatedResultSpec :: T.StatelessProtocol p => p -> RelatedResultSpec -> LBS.ByteString
encode_RelatedResultSpec oprot record = T.serializeVal oprot $ from_RelatedResultSpec record
to_RelatedResultSpec :: T.ThriftVal -> RelatedResultSpec
to_RelatedResultSpec (T.TStruct fields) = RelatedResultSpec{
  relatedResultSpec_maxNotes = P.maybe (P.Nothing) (\(_,_val317) -> P.Just (case _val317 of {T.TI32 _val318 -> _val318; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  relatedResultSpec_maxNotebooks = P.maybe (P.Nothing) (\(_,_val317) -> P.Just (case _val317 of {T.TI32 _val319 -> _val319; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  relatedResultSpec_maxTags = P.maybe (P.Nothing) (\(_,_val317) -> P.Just (case _val317 of {T.TI32 _val320 -> _val320; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  relatedResultSpec_writableNotebooksOnly = P.maybe (P.Nothing) (\(_,_val317) -> P.Just (case _val317 of {T.TBool _val321 -> _val321; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  relatedResultSpec_includeContainingNotebooks = P.maybe (P.Nothing) (\(_,_val317) -> P.Just (case _val317 of {T.TBool _val322 -> _val322; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  relatedResultSpec_maxExperts = P.maybe (P.Nothing) (\(_,_val317) -> P.Just (case _val317 of {T.TI32 _val323 -> _val323; _ -> P.error "wrong type"})) (Map.lookup (7) fields),
  relatedResultSpec_maxRelatedContent = P.maybe (P.Nothing) (\(_,_val317) -> P.Just (case _val317 of {T.TI32 _val324 -> _val324; _ -> P.error "wrong type"})) (Map.lookup (8) fields),
  relatedResultSpec_relatedContentTypes = P.maybe (P.Nothing) (\(_,_val317) -> P.Just (case _val317 of {T.TSet _ _val325 -> (Set.fromList $ P.map (\_v326 -> (case _v326 of {T.TI32 _val327 -> P.toEnum $ P.fromIntegral _val327; _ -> P.error "wrong type"})) _val325); _ -> P.error "wrong type"})) (Map.lookup (9) fields)
  }
to_RelatedResultSpec _ = P.error "not a struct"
read_RelatedResultSpec :: T.Protocol p => p -> P.IO RelatedResultSpec
read_RelatedResultSpec iprot = to_RelatedResultSpec <$> T.readVal iprot (T.T_STRUCT typemap_RelatedResultSpec)
decode_RelatedResultSpec :: T.StatelessProtocol p => p -> LBS.ByteString -> RelatedResultSpec
decode_RelatedResultSpec iprot bs = to_RelatedResultSpec $ T.deserializeVal iprot (T.T_STRUCT typemap_RelatedResultSpec) bs
typemap_RelatedResultSpec :: T.TypeMap
typemap_RelatedResultSpec = Map.fromList [(1,("maxNotes",T.T_I32)),(2,("maxNotebooks",T.T_I32)),(3,("maxTags",T.T_I32)),(4,("writableNotebooksOnly",T.T_BOOL)),(5,("includeContainingNotebooks",T.T_BOOL)),(7,("maxExperts",T.T_I32)),(8,("maxRelatedContent",T.T_I32)),(9,("relatedContentTypes",(T.T_SET T.T_I32)))]
default_RelatedResultSpec :: RelatedResultSpec
default_RelatedResultSpec = RelatedResultSpec{
  relatedResultSpec_maxNotes = P.Nothing,
  relatedResultSpec_maxNotebooks = P.Nothing,
  relatedResultSpec_maxTags = P.Nothing,
  relatedResultSpec_writableNotebooksOnly = P.Nothing,
  relatedResultSpec_includeContainingNotebooks = P.Nothing,
  relatedResultSpec_maxExperts = P.Nothing,
  relatedResultSpec_maxRelatedContent = P.Nothing,
  relatedResultSpec_relatedContentTypes = P.Nothing}
data UpdateNoteIfUsnMatchesResult = UpdateNoteIfUsnMatchesResult  { updateNoteIfUsnMatchesResult_note :: P.Maybe Types_Types.Note
  , updateNoteIfUsnMatchesResult_updated :: P.Maybe P.Bool
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateNoteIfUsnMatchesResult where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateNoteIfUsnMatchesResult_note record   `H.hashWithSalt` updateNoteIfUsnMatchesResult_updated record  
instance QC.Arbitrary UpdateNoteIfUsnMatchesResult where 
  arbitrary = M.liftM UpdateNoteIfUsnMatchesResult (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_UpdateNoteIfUsnMatchesResult = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateNoteIfUsnMatchesResult{updateNoteIfUsnMatchesResult_note = updateNoteIfUsnMatchesResult_note obj} then P.Nothing else P.Just $ default_UpdateNoteIfUsnMatchesResult{updateNoteIfUsnMatchesResult_note = updateNoteIfUsnMatchesResult_note obj}
    , if obj == default_UpdateNoteIfUsnMatchesResult{updateNoteIfUsnMatchesResult_updated = updateNoteIfUsnMatchesResult_updated obj} then P.Nothing else P.Just $ default_UpdateNoteIfUsnMatchesResult{updateNoteIfUsnMatchesResult_updated = updateNoteIfUsnMatchesResult_updated obj}
    ]
from_UpdateNoteIfUsnMatchesResult :: UpdateNoteIfUsnMatchesResult -> T.ThriftVal
from_UpdateNoteIfUsnMatchesResult record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v330 -> (1, ("note",Types_Types.from_Note _v330))) <$> updateNoteIfUsnMatchesResult_note record
  , (\_v330 -> (2, ("updated",T.TBool _v330))) <$> updateNoteIfUsnMatchesResult_updated record
  ]
write_UpdateNoteIfUsnMatchesResult :: T.Protocol p => p -> UpdateNoteIfUsnMatchesResult -> P.IO ()
write_UpdateNoteIfUsnMatchesResult oprot record = T.writeVal oprot $ from_UpdateNoteIfUsnMatchesResult record
encode_UpdateNoteIfUsnMatchesResult :: T.StatelessProtocol p => p -> UpdateNoteIfUsnMatchesResult -> LBS.ByteString
encode_UpdateNoteIfUsnMatchesResult oprot record = T.serializeVal oprot $ from_UpdateNoteIfUsnMatchesResult record
to_UpdateNoteIfUsnMatchesResult :: T.ThriftVal -> UpdateNoteIfUsnMatchesResult
to_UpdateNoteIfUsnMatchesResult (T.TStruct fields) = UpdateNoteIfUsnMatchesResult{
  updateNoteIfUsnMatchesResult_note = P.maybe (P.Nothing) (\(_,_val332) -> P.Just (case _val332 of {T.TStruct _val333 -> (Types_Types.to_Note (T.TStruct _val333)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  updateNoteIfUsnMatchesResult_updated = P.maybe (P.Nothing) (\(_,_val332) -> P.Just (case _val332 of {T.TBool _val334 -> _val334; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_UpdateNoteIfUsnMatchesResult _ = P.error "not a struct"
read_UpdateNoteIfUsnMatchesResult :: T.Protocol p => p -> P.IO UpdateNoteIfUsnMatchesResult
read_UpdateNoteIfUsnMatchesResult iprot = to_UpdateNoteIfUsnMatchesResult <$> T.readVal iprot (T.T_STRUCT typemap_UpdateNoteIfUsnMatchesResult)
decode_UpdateNoteIfUsnMatchesResult :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateNoteIfUsnMatchesResult
decode_UpdateNoteIfUsnMatchesResult iprot bs = to_UpdateNoteIfUsnMatchesResult $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateNoteIfUsnMatchesResult) bs
typemap_UpdateNoteIfUsnMatchesResult :: T.TypeMap
typemap_UpdateNoteIfUsnMatchesResult = Map.fromList [(1,("note",(T.T_STRUCT Types_Types.typemap_Note))),(2,("updated",T.T_BOOL))]
default_UpdateNoteIfUsnMatchesResult :: UpdateNoteIfUsnMatchesResult
default_UpdateNoteIfUsnMatchesResult = UpdateNoteIfUsnMatchesResult{
  updateNoteIfUsnMatchesResult_note = P.Nothing,
  updateNoteIfUsnMatchesResult_updated = P.Nothing}
data ShareRelationshipRestrictions = ShareRelationshipRestrictions  { shareRelationshipRestrictions_noSetReadOnly :: P.Maybe P.Bool
  , shareRelationshipRestrictions_noSetReadPlusActivity :: P.Maybe P.Bool
  , shareRelationshipRestrictions_noSetModify :: P.Maybe P.Bool
  , shareRelationshipRestrictions_noSetFullAccess :: P.Maybe P.Bool
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ShareRelationshipRestrictions where
  hashWithSalt salt record = salt   `H.hashWithSalt` shareRelationshipRestrictions_noSetReadOnly record   `H.hashWithSalt` shareRelationshipRestrictions_noSetReadPlusActivity record   `H.hashWithSalt` shareRelationshipRestrictions_noSetModify record   `H.hashWithSalt` shareRelationshipRestrictions_noSetFullAccess record  
instance QC.Arbitrary ShareRelationshipRestrictions where 
  arbitrary = M.liftM ShareRelationshipRestrictions (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_ShareRelationshipRestrictions = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ShareRelationshipRestrictions{shareRelationshipRestrictions_noSetReadOnly = shareRelationshipRestrictions_noSetReadOnly obj} then P.Nothing else P.Just $ default_ShareRelationshipRestrictions{shareRelationshipRestrictions_noSetReadOnly = shareRelationshipRestrictions_noSetReadOnly obj}
    , if obj == default_ShareRelationshipRestrictions{shareRelationshipRestrictions_noSetReadPlusActivity = shareRelationshipRestrictions_noSetReadPlusActivity obj} then P.Nothing else P.Just $ default_ShareRelationshipRestrictions{shareRelationshipRestrictions_noSetReadPlusActivity = shareRelationshipRestrictions_noSetReadPlusActivity obj}
    , if obj == default_ShareRelationshipRestrictions{shareRelationshipRestrictions_noSetModify = shareRelationshipRestrictions_noSetModify obj} then P.Nothing else P.Just $ default_ShareRelationshipRestrictions{shareRelationshipRestrictions_noSetModify = shareRelationshipRestrictions_noSetModify obj}
    , if obj == default_ShareRelationshipRestrictions{shareRelationshipRestrictions_noSetFullAccess = shareRelationshipRestrictions_noSetFullAccess obj} then P.Nothing else P.Just $ default_ShareRelationshipRestrictions{shareRelationshipRestrictions_noSetFullAccess = shareRelationshipRestrictions_noSetFullAccess obj}
    ]
from_ShareRelationshipRestrictions :: ShareRelationshipRestrictions -> T.ThriftVal
from_ShareRelationshipRestrictions record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v337 -> (1, ("noSetReadOnly",T.TBool _v337))) <$> shareRelationshipRestrictions_noSetReadOnly record
  , (\_v337 -> (2, ("noSetReadPlusActivity",T.TBool _v337))) <$> shareRelationshipRestrictions_noSetReadPlusActivity record
  , (\_v337 -> (3, ("noSetModify",T.TBool _v337))) <$> shareRelationshipRestrictions_noSetModify record
  , (\_v337 -> (4, ("noSetFullAccess",T.TBool _v337))) <$> shareRelationshipRestrictions_noSetFullAccess record
  ]
write_ShareRelationshipRestrictions :: T.Protocol p => p -> ShareRelationshipRestrictions -> P.IO ()
write_ShareRelationshipRestrictions oprot record = T.writeVal oprot $ from_ShareRelationshipRestrictions record
encode_ShareRelationshipRestrictions :: T.StatelessProtocol p => p -> ShareRelationshipRestrictions -> LBS.ByteString
encode_ShareRelationshipRestrictions oprot record = T.serializeVal oprot $ from_ShareRelationshipRestrictions record
to_ShareRelationshipRestrictions :: T.ThriftVal -> ShareRelationshipRestrictions
to_ShareRelationshipRestrictions (T.TStruct fields) = ShareRelationshipRestrictions{
  shareRelationshipRestrictions_noSetReadOnly = P.maybe (P.Nothing) (\(_,_val339) -> P.Just (case _val339 of {T.TBool _val340 -> _val340; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  shareRelationshipRestrictions_noSetReadPlusActivity = P.maybe (P.Nothing) (\(_,_val339) -> P.Just (case _val339 of {T.TBool _val341 -> _val341; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  shareRelationshipRestrictions_noSetModify = P.maybe (P.Nothing) (\(_,_val339) -> P.Just (case _val339 of {T.TBool _val342 -> _val342; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  shareRelationshipRestrictions_noSetFullAccess = P.maybe (P.Nothing) (\(_,_val339) -> P.Just (case _val339 of {T.TBool _val343 -> _val343; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_ShareRelationshipRestrictions _ = P.error "not a struct"
read_ShareRelationshipRestrictions :: T.Protocol p => p -> P.IO ShareRelationshipRestrictions
read_ShareRelationshipRestrictions iprot = to_ShareRelationshipRestrictions <$> T.readVal iprot (T.T_STRUCT typemap_ShareRelationshipRestrictions)
decode_ShareRelationshipRestrictions :: T.StatelessProtocol p => p -> LBS.ByteString -> ShareRelationshipRestrictions
decode_ShareRelationshipRestrictions iprot bs = to_ShareRelationshipRestrictions $ T.deserializeVal iprot (T.T_STRUCT typemap_ShareRelationshipRestrictions) bs
typemap_ShareRelationshipRestrictions :: T.TypeMap
typemap_ShareRelationshipRestrictions = Map.fromList [(1,("noSetReadOnly",T.T_BOOL)),(2,("noSetReadPlusActivity",T.T_BOOL)),(3,("noSetModify",T.T_BOOL)),(4,("noSetFullAccess",T.T_BOOL))]
default_ShareRelationshipRestrictions :: ShareRelationshipRestrictions
default_ShareRelationshipRestrictions = ShareRelationshipRestrictions{
  shareRelationshipRestrictions_noSetReadOnly = P.Nothing,
  shareRelationshipRestrictions_noSetReadPlusActivity = P.Nothing,
  shareRelationshipRestrictions_noSetModify = P.Nothing,
  shareRelationshipRestrictions_noSetFullAccess = P.Nothing}
data InvitationShareRelationship = InvitationShareRelationship  { invitationShareRelationship_displayName :: P.Maybe LT.Text
  , invitationShareRelationship_recipientUserIdentity :: P.Maybe Types_Types.UserIdentity
  , invitationShareRelationship_privilege :: P.Maybe ShareRelationshipPrivilegeLevel
  , invitationShareRelationship_sharerUserId :: P.Maybe I.Int32
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable InvitationShareRelationship where
  hashWithSalt salt record = salt   `H.hashWithSalt` invitationShareRelationship_displayName record   `H.hashWithSalt` invitationShareRelationship_recipientUserIdentity record   `H.hashWithSalt` invitationShareRelationship_privilege record   `H.hashWithSalt` invitationShareRelationship_sharerUserId record  
instance QC.Arbitrary InvitationShareRelationship where 
  arbitrary = M.liftM InvitationShareRelationship (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_InvitationShareRelationship = []
             | P.otherwise = M.catMaybes
    [ if obj == default_InvitationShareRelationship{invitationShareRelationship_displayName = invitationShareRelationship_displayName obj} then P.Nothing else P.Just $ default_InvitationShareRelationship{invitationShareRelationship_displayName = invitationShareRelationship_displayName obj}
    , if obj == default_InvitationShareRelationship{invitationShareRelationship_recipientUserIdentity = invitationShareRelationship_recipientUserIdentity obj} then P.Nothing else P.Just $ default_InvitationShareRelationship{invitationShareRelationship_recipientUserIdentity = invitationShareRelationship_recipientUserIdentity obj}
    , if obj == default_InvitationShareRelationship{invitationShareRelationship_privilege = invitationShareRelationship_privilege obj} then P.Nothing else P.Just $ default_InvitationShareRelationship{invitationShareRelationship_privilege = invitationShareRelationship_privilege obj}
    , if obj == default_InvitationShareRelationship{invitationShareRelationship_sharerUserId = invitationShareRelationship_sharerUserId obj} then P.Nothing else P.Just $ default_InvitationShareRelationship{invitationShareRelationship_sharerUserId = invitationShareRelationship_sharerUserId obj}
    ]
from_InvitationShareRelationship :: InvitationShareRelationship -> T.ThriftVal
from_InvitationShareRelationship record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v346 -> (1, ("displayName",T.TString $ E.encodeUtf8 _v346))) <$> invitationShareRelationship_displayName record
  , (\_v346 -> (2, ("recipientUserIdentity",Types_Types.from_UserIdentity _v346))) <$> invitationShareRelationship_recipientUserIdentity record
  , (\_v346 -> (3, ("privilege",T.TI32 $ P.fromIntegral $ P.fromEnum _v346))) <$> invitationShareRelationship_privilege record
  , (\_v346 -> (5, ("sharerUserId",T.TI32 _v346))) <$> invitationShareRelationship_sharerUserId record
  ]
write_InvitationShareRelationship :: T.Protocol p => p -> InvitationShareRelationship -> P.IO ()
write_InvitationShareRelationship oprot record = T.writeVal oprot $ from_InvitationShareRelationship record
encode_InvitationShareRelationship :: T.StatelessProtocol p => p -> InvitationShareRelationship -> LBS.ByteString
encode_InvitationShareRelationship oprot record = T.serializeVal oprot $ from_InvitationShareRelationship record
to_InvitationShareRelationship :: T.ThriftVal -> InvitationShareRelationship
to_InvitationShareRelationship (T.TStruct fields) = InvitationShareRelationship{
  invitationShareRelationship_displayName = P.maybe (P.Nothing) (\(_,_val348) -> P.Just (case _val348 of {T.TString _val349 -> E.decodeUtf8 _val349; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  invitationShareRelationship_recipientUserIdentity = P.maybe (P.Nothing) (\(_,_val348) -> P.Just (case _val348 of {T.TStruct _val350 -> (Types_Types.to_UserIdentity (T.TStruct _val350)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  invitationShareRelationship_privilege = P.maybe (P.Nothing) (\(_,_val348) -> P.Just (case _val348 of {T.TI32 _val351 -> P.toEnum $ P.fromIntegral _val351; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  invitationShareRelationship_sharerUserId = P.maybe (P.Nothing) (\(_,_val348) -> P.Just (case _val348 of {T.TI32 _val352 -> _val352; _ -> P.error "wrong type"})) (Map.lookup (5) fields)
  }
to_InvitationShareRelationship _ = P.error "not a struct"
read_InvitationShareRelationship :: T.Protocol p => p -> P.IO InvitationShareRelationship
read_InvitationShareRelationship iprot = to_InvitationShareRelationship <$> T.readVal iprot (T.T_STRUCT typemap_InvitationShareRelationship)
decode_InvitationShareRelationship :: T.StatelessProtocol p => p -> LBS.ByteString -> InvitationShareRelationship
decode_InvitationShareRelationship iprot bs = to_InvitationShareRelationship $ T.deserializeVal iprot (T.T_STRUCT typemap_InvitationShareRelationship) bs
typemap_InvitationShareRelationship :: T.TypeMap
typemap_InvitationShareRelationship = Map.fromList [(1,("displayName",T.T_STRING)),(2,("recipientUserIdentity",(T.T_STRUCT Types_Types.typemap_UserIdentity))),(3,("privilege",T.T_I32)),(5,("sharerUserId",T.T_I32))]
default_InvitationShareRelationship :: InvitationShareRelationship
default_InvitationShareRelationship = InvitationShareRelationship{
  invitationShareRelationship_displayName = P.Nothing,
  invitationShareRelationship_recipientUserIdentity = P.Nothing,
  invitationShareRelationship_privilege = P.Nothing,
  invitationShareRelationship_sharerUserId = P.Nothing}
data MemberShareRelationship = MemberShareRelationship  { memberShareRelationship_displayName :: P.Maybe LT.Text
  , memberShareRelationship_recipientUserId :: P.Maybe I.Int32
  , memberShareRelationship_bestPrivilege :: P.Maybe ShareRelationshipPrivilegeLevel
  , memberShareRelationship_individualPrivilege :: P.Maybe ShareRelationshipPrivilegeLevel
  , memberShareRelationship_restrictions :: P.Maybe ShareRelationshipRestrictions
  , memberShareRelationship_sharerUserId :: P.Maybe I.Int32
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable MemberShareRelationship where
  hashWithSalt salt record = salt   `H.hashWithSalt` memberShareRelationship_displayName record   `H.hashWithSalt` memberShareRelationship_recipientUserId record   `H.hashWithSalt` memberShareRelationship_bestPrivilege record   `H.hashWithSalt` memberShareRelationship_individualPrivilege record   `H.hashWithSalt` memberShareRelationship_restrictions record   `H.hashWithSalt` memberShareRelationship_sharerUserId record  
instance QC.Arbitrary MemberShareRelationship where 
  arbitrary = M.liftM MemberShareRelationship (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_MemberShareRelationship = []
             | P.otherwise = M.catMaybes
    [ if obj == default_MemberShareRelationship{memberShareRelationship_displayName = memberShareRelationship_displayName obj} then P.Nothing else P.Just $ default_MemberShareRelationship{memberShareRelationship_displayName = memberShareRelationship_displayName obj}
    , if obj == default_MemberShareRelationship{memberShareRelationship_recipientUserId = memberShareRelationship_recipientUserId obj} then P.Nothing else P.Just $ default_MemberShareRelationship{memberShareRelationship_recipientUserId = memberShareRelationship_recipientUserId obj}
    , if obj == default_MemberShareRelationship{memberShareRelationship_bestPrivilege = memberShareRelationship_bestPrivilege obj} then P.Nothing else P.Just $ default_MemberShareRelationship{memberShareRelationship_bestPrivilege = memberShareRelationship_bestPrivilege obj}
    , if obj == default_MemberShareRelationship{memberShareRelationship_individualPrivilege = memberShareRelationship_individualPrivilege obj} then P.Nothing else P.Just $ default_MemberShareRelationship{memberShareRelationship_individualPrivilege = memberShareRelationship_individualPrivilege obj}
    , if obj == default_MemberShareRelationship{memberShareRelationship_restrictions = memberShareRelationship_restrictions obj} then P.Nothing else P.Just $ default_MemberShareRelationship{memberShareRelationship_restrictions = memberShareRelationship_restrictions obj}
    , if obj == default_MemberShareRelationship{memberShareRelationship_sharerUserId = memberShareRelationship_sharerUserId obj} then P.Nothing else P.Just $ default_MemberShareRelationship{memberShareRelationship_sharerUserId = memberShareRelationship_sharerUserId obj}
    ]
from_MemberShareRelationship :: MemberShareRelationship -> T.ThriftVal
from_MemberShareRelationship record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v355 -> (1, ("displayName",T.TString $ E.encodeUtf8 _v355))) <$> memberShareRelationship_displayName record
  , (\_v355 -> (2, ("recipientUserId",T.TI32 _v355))) <$> memberShareRelationship_recipientUserId record
  , (\_v355 -> (3, ("bestPrivilege",T.TI32 $ P.fromIntegral $ P.fromEnum _v355))) <$> memberShareRelationship_bestPrivilege record
  , (\_v355 -> (4, ("individualPrivilege",T.TI32 $ P.fromIntegral $ P.fromEnum _v355))) <$> memberShareRelationship_individualPrivilege record
  , (\_v355 -> (5, ("restrictions",from_ShareRelationshipRestrictions _v355))) <$> memberShareRelationship_restrictions record
  , (\_v355 -> (6, ("sharerUserId",T.TI32 _v355))) <$> memberShareRelationship_sharerUserId record
  ]
write_MemberShareRelationship :: T.Protocol p => p -> MemberShareRelationship -> P.IO ()
write_MemberShareRelationship oprot record = T.writeVal oprot $ from_MemberShareRelationship record
encode_MemberShareRelationship :: T.StatelessProtocol p => p -> MemberShareRelationship -> LBS.ByteString
encode_MemberShareRelationship oprot record = T.serializeVal oprot $ from_MemberShareRelationship record
to_MemberShareRelationship :: T.ThriftVal -> MemberShareRelationship
to_MemberShareRelationship (T.TStruct fields) = MemberShareRelationship{
  memberShareRelationship_displayName = P.maybe (P.Nothing) (\(_,_val357) -> P.Just (case _val357 of {T.TString _val358 -> E.decodeUtf8 _val358; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  memberShareRelationship_recipientUserId = P.maybe (P.Nothing) (\(_,_val357) -> P.Just (case _val357 of {T.TI32 _val359 -> _val359; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  memberShareRelationship_bestPrivilege = P.maybe (P.Nothing) (\(_,_val357) -> P.Just (case _val357 of {T.TI32 _val360 -> P.toEnum $ P.fromIntegral _val360; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  memberShareRelationship_individualPrivilege = P.maybe (P.Nothing) (\(_,_val357) -> P.Just (case _val357 of {T.TI32 _val361 -> P.toEnum $ P.fromIntegral _val361; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  memberShareRelationship_restrictions = P.maybe (P.Nothing) (\(_,_val357) -> P.Just (case _val357 of {T.TStruct _val362 -> (to_ShareRelationshipRestrictions (T.TStruct _val362)); _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  memberShareRelationship_sharerUserId = P.maybe (P.Nothing) (\(_,_val357) -> P.Just (case _val357 of {T.TI32 _val363 -> _val363; _ -> P.error "wrong type"})) (Map.lookup (6) fields)
  }
to_MemberShareRelationship _ = P.error "not a struct"
read_MemberShareRelationship :: T.Protocol p => p -> P.IO MemberShareRelationship
read_MemberShareRelationship iprot = to_MemberShareRelationship <$> T.readVal iprot (T.T_STRUCT typemap_MemberShareRelationship)
decode_MemberShareRelationship :: T.StatelessProtocol p => p -> LBS.ByteString -> MemberShareRelationship
decode_MemberShareRelationship iprot bs = to_MemberShareRelationship $ T.deserializeVal iprot (T.T_STRUCT typemap_MemberShareRelationship) bs
typemap_MemberShareRelationship :: T.TypeMap
typemap_MemberShareRelationship = Map.fromList [(1,("displayName",T.T_STRING)),(2,("recipientUserId",T.T_I32)),(3,("bestPrivilege",T.T_I32)),(4,("individualPrivilege",T.T_I32)),(5,("restrictions",(T.T_STRUCT typemap_ShareRelationshipRestrictions))),(6,("sharerUserId",T.T_I32))]
default_MemberShareRelationship :: MemberShareRelationship
default_MemberShareRelationship = MemberShareRelationship{
  memberShareRelationship_displayName = P.Nothing,
  memberShareRelationship_recipientUserId = P.Nothing,
  memberShareRelationship_bestPrivilege = P.Nothing,
  memberShareRelationship_individualPrivilege = P.Nothing,
  memberShareRelationship_restrictions = P.Nothing,
  memberShareRelationship_sharerUserId = P.Nothing}
data ShareRelationships = ShareRelationships  { shareRelationships_invitations :: P.Maybe (Vector.Vector InvitationShareRelationship)
  , shareRelationships_memberships :: P.Maybe (Vector.Vector MemberShareRelationship)
  , shareRelationships_invitationRestrictions :: P.Maybe ShareRelationshipRestrictions
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ShareRelationships where
  hashWithSalt salt record = salt   `H.hashWithSalt` shareRelationships_invitations record   `H.hashWithSalt` shareRelationships_memberships record   `H.hashWithSalt` shareRelationships_invitationRestrictions record  
instance QC.Arbitrary ShareRelationships where 
  arbitrary = M.liftM ShareRelationships (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_ShareRelationships = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ShareRelationships{shareRelationships_invitations = shareRelationships_invitations obj} then P.Nothing else P.Just $ default_ShareRelationships{shareRelationships_invitations = shareRelationships_invitations obj}
    , if obj == default_ShareRelationships{shareRelationships_memberships = shareRelationships_memberships obj} then P.Nothing else P.Just $ default_ShareRelationships{shareRelationships_memberships = shareRelationships_memberships obj}
    , if obj == default_ShareRelationships{shareRelationships_invitationRestrictions = shareRelationships_invitationRestrictions obj} then P.Nothing else P.Just $ default_ShareRelationships{shareRelationships_invitationRestrictions = shareRelationships_invitationRestrictions obj}
    ]
from_ShareRelationships :: ShareRelationships -> T.ThriftVal
from_ShareRelationships record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v366 -> (1, ("invitations",T.TList (T.T_STRUCT typemap_InvitationShareRelationship) $ P.map (\_v368 -> from_InvitationShareRelationship _v368) $ Vector.toList _v366))) <$> shareRelationships_invitations record
  , (\_v366 -> (2, ("memberships",T.TList (T.T_STRUCT typemap_MemberShareRelationship) $ P.map (\_v370 -> from_MemberShareRelationship _v370) $ Vector.toList _v366))) <$> shareRelationships_memberships record
  , (\_v366 -> (3, ("invitationRestrictions",from_ShareRelationshipRestrictions _v366))) <$> shareRelationships_invitationRestrictions record
  ]
write_ShareRelationships :: T.Protocol p => p -> ShareRelationships -> P.IO ()
write_ShareRelationships oprot record = T.writeVal oprot $ from_ShareRelationships record
encode_ShareRelationships :: T.StatelessProtocol p => p -> ShareRelationships -> LBS.ByteString
encode_ShareRelationships oprot record = T.serializeVal oprot $ from_ShareRelationships record
to_ShareRelationships :: T.ThriftVal -> ShareRelationships
to_ShareRelationships (T.TStruct fields) = ShareRelationships{
  shareRelationships_invitations = P.maybe (P.Nothing) (\(_,_val372) -> P.Just (case _val372 of {T.TList _ _val373 -> (Vector.fromList $ P.map (\_v374 -> (case _v374 of {T.TStruct _val375 -> (to_InvitationShareRelationship (T.TStruct _val375)); _ -> P.error "wrong type"})) _val373); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  shareRelationships_memberships = P.maybe (P.Nothing) (\(_,_val372) -> P.Just (case _val372 of {T.TList _ _val376 -> (Vector.fromList $ P.map (\_v377 -> (case _v377 of {T.TStruct _val378 -> (to_MemberShareRelationship (T.TStruct _val378)); _ -> P.error "wrong type"})) _val376); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  shareRelationships_invitationRestrictions = P.maybe (P.Nothing) (\(_,_val372) -> P.Just (case _val372 of {T.TStruct _val379 -> (to_ShareRelationshipRestrictions (T.TStruct _val379)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_ShareRelationships _ = P.error "not a struct"
read_ShareRelationships :: T.Protocol p => p -> P.IO ShareRelationships
read_ShareRelationships iprot = to_ShareRelationships <$> T.readVal iprot (T.T_STRUCT typemap_ShareRelationships)
decode_ShareRelationships :: T.StatelessProtocol p => p -> LBS.ByteString -> ShareRelationships
decode_ShareRelationships iprot bs = to_ShareRelationships $ T.deserializeVal iprot (T.T_STRUCT typemap_ShareRelationships) bs
typemap_ShareRelationships :: T.TypeMap
typemap_ShareRelationships = Map.fromList [(1,("invitations",(T.T_LIST (T.T_STRUCT typemap_InvitationShareRelationship)))),(2,("memberships",(T.T_LIST (T.T_STRUCT typemap_MemberShareRelationship)))),(3,("invitationRestrictions",(T.T_STRUCT typemap_ShareRelationshipRestrictions)))]
default_ShareRelationships :: ShareRelationships
default_ShareRelationships = ShareRelationships{
  shareRelationships_invitations = P.Nothing,
  shareRelationships_memberships = P.Nothing,
  shareRelationships_invitationRestrictions = P.Nothing}
data ManageNotebookSharesParameters = ManageNotebookSharesParameters  { manageNotebookSharesParameters_notebookGuid :: P.Maybe LT.Text
  , manageNotebookSharesParameters_inviteMessage :: P.Maybe LT.Text
  , manageNotebookSharesParameters_membershipsToUpdate :: P.Maybe (Vector.Vector MemberShareRelationship)
  , manageNotebookSharesParameters_invitationsToCreateOrUpdate :: P.Maybe (Vector.Vector InvitationShareRelationship)
  , manageNotebookSharesParameters_unshares :: P.Maybe (Vector.Vector Types_Types.UserIdentity)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ManageNotebookSharesParameters where
  hashWithSalt salt record = salt   `H.hashWithSalt` manageNotebookSharesParameters_notebookGuid record   `H.hashWithSalt` manageNotebookSharesParameters_inviteMessage record   `H.hashWithSalt` manageNotebookSharesParameters_membershipsToUpdate record   `H.hashWithSalt` manageNotebookSharesParameters_invitationsToCreateOrUpdate record   `H.hashWithSalt` manageNotebookSharesParameters_unshares record  
instance QC.Arbitrary ManageNotebookSharesParameters where 
  arbitrary = M.liftM ManageNotebookSharesParameters (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_ManageNotebookSharesParameters = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ManageNotebookSharesParameters{manageNotebookSharesParameters_notebookGuid = manageNotebookSharesParameters_notebookGuid obj} then P.Nothing else P.Just $ default_ManageNotebookSharesParameters{manageNotebookSharesParameters_notebookGuid = manageNotebookSharesParameters_notebookGuid obj}
    , if obj == default_ManageNotebookSharesParameters{manageNotebookSharesParameters_inviteMessage = manageNotebookSharesParameters_inviteMessage obj} then P.Nothing else P.Just $ default_ManageNotebookSharesParameters{manageNotebookSharesParameters_inviteMessage = manageNotebookSharesParameters_inviteMessage obj}
    , if obj == default_ManageNotebookSharesParameters{manageNotebookSharesParameters_membershipsToUpdate = manageNotebookSharesParameters_membershipsToUpdate obj} then P.Nothing else P.Just $ default_ManageNotebookSharesParameters{manageNotebookSharesParameters_membershipsToUpdate = manageNotebookSharesParameters_membershipsToUpdate obj}
    , if obj == default_ManageNotebookSharesParameters{manageNotebookSharesParameters_invitationsToCreateOrUpdate = manageNotebookSharesParameters_invitationsToCreateOrUpdate obj} then P.Nothing else P.Just $ default_ManageNotebookSharesParameters{manageNotebookSharesParameters_invitationsToCreateOrUpdate = manageNotebookSharesParameters_invitationsToCreateOrUpdate obj}
    , if obj == default_ManageNotebookSharesParameters{manageNotebookSharesParameters_unshares = manageNotebookSharesParameters_unshares obj} then P.Nothing else P.Just $ default_ManageNotebookSharesParameters{manageNotebookSharesParameters_unshares = manageNotebookSharesParameters_unshares obj}
    ]
from_ManageNotebookSharesParameters :: ManageNotebookSharesParameters -> T.ThriftVal
from_ManageNotebookSharesParameters record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v382 -> (1, ("notebookGuid",T.TString $ E.encodeUtf8 _v382))) <$> manageNotebookSharesParameters_notebookGuid record
  , (\_v382 -> (2, ("inviteMessage",T.TString $ E.encodeUtf8 _v382))) <$> manageNotebookSharesParameters_inviteMessage record
  , (\_v382 -> (3, ("membershipsToUpdate",T.TList (T.T_STRUCT typemap_MemberShareRelationship) $ P.map (\_v384 -> from_MemberShareRelationship _v384) $ Vector.toList _v382))) <$> manageNotebookSharesParameters_membershipsToUpdate record
  , (\_v382 -> (4, ("invitationsToCreateOrUpdate",T.TList (T.T_STRUCT typemap_InvitationShareRelationship) $ P.map (\_v386 -> from_InvitationShareRelationship _v386) $ Vector.toList _v382))) <$> manageNotebookSharesParameters_invitationsToCreateOrUpdate record
  , (\_v382 -> (5, ("unshares",T.TList (T.T_STRUCT Types_Types.typemap_UserIdentity) $ P.map (\_v388 -> Types_Types.from_UserIdentity _v388) $ Vector.toList _v382))) <$> manageNotebookSharesParameters_unshares record
  ]
write_ManageNotebookSharesParameters :: T.Protocol p => p -> ManageNotebookSharesParameters -> P.IO ()
write_ManageNotebookSharesParameters oprot record = T.writeVal oprot $ from_ManageNotebookSharesParameters record
encode_ManageNotebookSharesParameters :: T.StatelessProtocol p => p -> ManageNotebookSharesParameters -> LBS.ByteString
encode_ManageNotebookSharesParameters oprot record = T.serializeVal oprot $ from_ManageNotebookSharesParameters record
to_ManageNotebookSharesParameters :: T.ThriftVal -> ManageNotebookSharesParameters
to_ManageNotebookSharesParameters (T.TStruct fields) = ManageNotebookSharesParameters{
  manageNotebookSharesParameters_notebookGuid = P.maybe (P.Nothing) (\(_,_val390) -> P.Just (case _val390 of {T.TString _val391 -> E.decodeUtf8 _val391; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  manageNotebookSharesParameters_inviteMessage = P.maybe (P.Nothing) (\(_,_val390) -> P.Just (case _val390 of {T.TString _val392 -> E.decodeUtf8 _val392; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  manageNotebookSharesParameters_membershipsToUpdate = P.maybe (P.Nothing) (\(_,_val390) -> P.Just (case _val390 of {T.TList _ _val393 -> (Vector.fromList $ P.map (\_v394 -> (case _v394 of {T.TStruct _val395 -> (to_MemberShareRelationship (T.TStruct _val395)); _ -> P.error "wrong type"})) _val393); _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  manageNotebookSharesParameters_invitationsToCreateOrUpdate = P.maybe (P.Nothing) (\(_,_val390) -> P.Just (case _val390 of {T.TList _ _val396 -> (Vector.fromList $ P.map (\_v397 -> (case _v397 of {T.TStruct _val398 -> (to_InvitationShareRelationship (T.TStruct _val398)); _ -> P.error "wrong type"})) _val396); _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  manageNotebookSharesParameters_unshares = P.maybe (P.Nothing) (\(_,_val390) -> P.Just (case _val390 of {T.TList _ _val399 -> (Vector.fromList $ P.map (\_v400 -> (case _v400 of {T.TStruct _val401 -> (Types_Types.to_UserIdentity (T.TStruct _val401)); _ -> P.error "wrong type"})) _val399); _ -> P.error "wrong type"})) (Map.lookup (5) fields)
  }
to_ManageNotebookSharesParameters _ = P.error "not a struct"
read_ManageNotebookSharesParameters :: T.Protocol p => p -> P.IO ManageNotebookSharesParameters
read_ManageNotebookSharesParameters iprot = to_ManageNotebookSharesParameters <$> T.readVal iprot (T.T_STRUCT typemap_ManageNotebookSharesParameters)
decode_ManageNotebookSharesParameters :: T.StatelessProtocol p => p -> LBS.ByteString -> ManageNotebookSharesParameters
decode_ManageNotebookSharesParameters iprot bs = to_ManageNotebookSharesParameters $ T.deserializeVal iprot (T.T_STRUCT typemap_ManageNotebookSharesParameters) bs
typemap_ManageNotebookSharesParameters :: T.TypeMap
typemap_ManageNotebookSharesParameters = Map.fromList [(1,("notebookGuid",T.T_STRING)),(2,("inviteMessage",T.T_STRING)),(3,("membershipsToUpdate",(T.T_LIST (T.T_STRUCT typemap_MemberShareRelationship)))),(4,("invitationsToCreateOrUpdate",(T.T_LIST (T.T_STRUCT typemap_InvitationShareRelationship)))),(5,("unshares",(T.T_LIST (T.T_STRUCT Types_Types.typemap_UserIdentity))))]
default_ManageNotebookSharesParameters :: ManageNotebookSharesParameters
default_ManageNotebookSharesParameters = ManageNotebookSharesParameters{
  manageNotebookSharesParameters_notebookGuid = P.Nothing,
  manageNotebookSharesParameters_inviteMessage = P.Nothing,
  manageNotebookSharesParameters_membershipsToUpdate = P.Nothing,
  manageNotebookSharesParameters_invitationsToCreateOrUpdate = P.Nothing,
  manageNotebookSharesParameters_unshares = P.Nothing}
data ManageNotebookSharesError = ManageNotebookSharesError  { manageNotebookSharesError_userIdentity :: P.Maybe Types_Types.UserIdentity
  , manageNotebookSharesError_userException :: P.Maybe Errors_Types.EDAMUserException
  , manageNotebookSharesError_notFoundException :: P.Maybe Errors_Types.EDAMNotFoundException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ManageNotebookSharesError where
  hashWithSalt salt record = salt   `H.hashWithSalt` manageNotebookSharesError_userIdentity record   `H.hashWithSalt` manageNotebookSharesError_userException record   `H.hashWithSalt` manageNotebookSharesError_notFoundException record  
instance QC.Arbitrary ManageNotebookSharesError where 
  arbitrary = M.liftM ManageNotebookSharesError (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_ManageNotebookSharesError = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ManageNotebookSharesError{manageNotebookSharesError_userIdentity = manageNotebookSharesError_userIdentity obj} then P.Nothing else P.Just $ default_ManageNotebookSharesError{manageNotebookSharesError_userIdentity = manageNotebookSharesError_userIdentity obj}
    , if obj == default_ManageNotebookSharesError{manageNotebookSharesError_userException = manageNotebookSharesError_userException obj} then P.Nothing else P.Just $ default_ManageNotebookSharesError{manageNotebookSharesError_userException = manageNotebookSharesError_userException obj}
    , if obj == default_ManageNotebookSharesError{manageNotebookSharesError_notFoundException = manageNotebookSharesError_notFoundException obj} then P.Nothing else P.Just $ default_ManageNotebookSharesError{manageNotebookSharesError_notFoundException = manageNotebookSharesError_notFoundException obj}
    ]
from_ManageNotebookSharesError :: ManageNotebookSharesError -> T.ThriftVal
from_ManageNotebookSharesError record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v404 -> (2, ("userException",Errors_Types.from_EDAMUserException _v404))) <$> manageNotebookSharesError_userException record, (\_v404 -> (3, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v404))) <$> manageNotebookSharesError_notFoundException record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v404 -> (1, ("userIdentity",Types_Types.from_UserIdentity _v404))) <$> manageNotebookSharesError_userIdentity record
    , (\_v404 -> (2, ("userException",Errors_Types.from_EDAMUserException _v404))) <$> manageNotebookSharesError_userException record
    , (\_v404 -> (3, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v404))) <$> manageNotebookSharesError_notFoundException record
    ]
    )
write_ManageNotebookSharesError :: T.Protocol p => p -> ManageNotebookSharesError -> P.IO ()
write_ManageNotebookSharesError oprot record = T.writeVal oprot $ from_ManageNotebookSharesError record
encode_ManageNotebookSharesError :: T.StatelessProtocol p => p -> ManageNotebookSharesError -> LBS.ByteString
encode_ManageNotebookSharesError oprot record = T.serializeVal oprot $ from_ManageNotebookSharesError record
to_ManageNotebookSharesError :: T.ThriftVal -> ManageNotebookSharesError
to_ManageNotebookSharesError (T.TStruct fields) = ManageNotebookSharesError{
  manageNotebookSharesError_userIdentity = P.maybe (P.Nothing) (\(_,_val406) -> P.Just (case _val406 of {T.TStruct _val407 -> (Types_Types.to_UserIdentity (T.TStruct _val407)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  manageNotebookSharesError_userException = P.maybe (P.Nothing) (\(_,_val406) -> P.Just (case _val406 of {T.TStruct _val408 -> (Errors_Types.to_EDAMUserException (T.TStruct _val408)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  manageNotebookSharesError_notFoundException = P.maybe (P.Nothing) (\(_,_val406) -> P.Just (case _val406 of {T.TStruct _val409 -> (Errors_Types.to_EDAMNotFoundException (T.TStruct _val409)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_ManageNotebookSharesError _ = P.error "not a struct"
read_ManageNotebookSharesError :: T.Protocol p => p -> P.IO ManageNotebookSharesError
read_ManageNotebookSharesError iprot = to_ManageNotebookSharesError <$> T.readVal iprot (T.T_STRUCT typemap_ManageNotebookSharesError)
decode_ManageNotebookSharesError :: T.StatelessProtocol p => p -> LBS.ByteString -> ManageNotebookSharesError
decode_ManageNotebookSharesError iprot bs = to_ManageNotebookSharesError $ T.deserializeVal iprot (T.T_STRUCT typemap_ManageNotebookSharesError) bs
typemap_ManageNotebookSharesError :: T.TypeMap
typemap_ManageNotebookSharesError = Map.fromList [(1,("userIdentity",(T.T_STRUCT Types_Types.typemap_UserIdentity))),(2,("userException",(T.T_STRUCT Errors_Types.typemap_EDAMUserException))),(3,("notFoundException",(T.T_STRUCT Errors_Types.typemap_EDAMNotFoundException)))]
default_ManageNotebookSharesError :: ManageNotebookSharesError
default_ManageNotebookSharesError = ManageNotebookSharesError{
  manageNotebookSharesError_userIdentity = P.Nothing,
  manageNotebookSharesError_userException = P.Nothing,
  manageNotebookSharesError_notFoundException = P.Nothing}
data ManageNotebookSharesResult = ManageNotebookSharesResult  { manageNotebookSharesResult_errors :: P.Maybe (Vector.Vector ManageNotebookSharesError)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ManageNotebookSharesResult where
  hashWithSalt salt record = salt   `H.hashWithSalt` manageNotebookSharesResult_errors record  
instance QC.Arbitrary ManageNotebookSharesResult where 
  arbitrary = M.liftM ManageNotebookSharesResult (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_ManageNotebookSharesResult = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ManageNotebookSharesResult{manageNotebookSharesResult_errors = manageNotebookSharesResult_errors obj} then P.Nothing else P.Just $ default_ManageNotebookSharesResult{manageNotebookSharesResult_errors = manageNotebookSharesResult_errors obj}
    ]
from_ManageNotebookSharesResult :: ManageNotebookSharesResult -> T.ThriftVal
from_ManageNotebookSharesResult record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v412 -> (1, ("errors",T.TList (T.T_STRUCT typemap_ManageNotebookSharesError) $ P.map (\_v414 -> from_ManageNotebookSharesError _v414) $ Vector.toList _v412))) <$> manageNotebookSharesResult_errors record
  ]
write_ManageNotebookSharesResult :: T.Protocol p => p -> ManageNotebookSharesResult -> P.IO ()
write_ManageNotebookSharesResult oprot record = T.writeVal oprot $ from_ManageNotebookSharesResult record
encode_ManageNotebookSharesResult :: T.StatelessProtocol p => p -> ManageNotebookSharesResult -> LBS.ByteString
encode_ManageNotebookSharesResult oprot record = T.serializeVal oprot $ from_ManageNotebookSharesResult record
to_ManageNotebookSharesResult :: T.ThriftVal -> ManageNotebookSharesResult
to_ManageNotebookSharesResult (T.TStruct fields) = ManageNotebookSharesResult{
  manageNotebookSharesResult_errors = P.maybe (P.Nothing) (\(_,_val416) -> P.Just (case _val416 of {T.TList _ _val417 -> (Vector.fromList $ P.map (\_v418 -> (case _v418 of {T.TStruct _val419 -> (to_ManageNotebookSharesError (T.TStruct _val419)); _ -> P.error "wrong type"})) _val417); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_ManageNotebookSharesResult _ = P.error "not a struct"
read_ManageNotebookSharesResult :: T.Protocol p => p -> P.IO ManageNotebookSharesResult
read_ManageNotebookSharesResult iprot = to_ManageNotebookSharesResult <$> T.readVal iprot (T.T_STRUCT typemap_ManageNotebookSharesResult)
decode_ManageNotebookSharesResult :: T.StatelessProtocol p => p -> LBS.ByteString -> ManageNotebookSharesResult
decode_ManageNotebookSharesResult iprot bs = to_ManageNotebookSharesResult $ T.deserializeVal iprot (T.T_STRUCT typemap_ManageNotebookSharesResult) bs
typemap_ManageNotebookSharesResult :: T.TypeMap
typemap_ManageNotebookSharesResult = Map.fromList [(1,("errors",(T.T_LIST (T.T_STRUCT typemap_ManageNotebookSharesError))))]
default_ManageNotebookSharesResult :: ManageNotebookSharesResult
default_ManageNotebookSharesResult = ManageNotebookSharesResult{
  manageNotebookSharesResult_errors = P.Nothing}
data SharedNoteTemplate = SharedNoteTemplate  { sharedNoteTemplate_noteGuid :: P.Maybe LT.Text
  , sharedNoteTemplate_recipientThreadId :: P.Maybe I.Int64
  , sharedNoteTemplate_recipientContacts :: P.Maybe (Vector.Vector Types_Types.Contact)
  , sharedNoteTemplate_privilege :: P.Maybe Types_Types.SharedNotePrivilegeLevel
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SharedNoteTemplate where
  hashWithSalt salt record = salt   `H.hashWithSalt` sharedNoteTemplate_noteGuid record   `H.hashWithSalt` sharedNoteTemplate_recipientThreadId record   `H.hashWithSalt` sharedNoteTemplate_recipientContacts record   `H.hashWithSalt` sharedNoteTemplate_privilege record  
instance QC.Arbitrary SharedNoteTemplate where 
  arbitrary = M.liftM SharedNoteTemplate (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_SharedNoteTemplate = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SharedNoteTemplate{sharedNoteTemplate_noteGuid = sharedNoteTemplate_noteGuid obj} then P.Nothing else P.Just $ default_SharedNoteTemplate{sharedNoteTemplate_noteGuid = sharedNoteTemplate_noteGuid obj}
    , if obj == default_SharedNoteTemplate{sharedNoteTemplate_recipientThreadId = sharedNoteTemplate_recipientThreadId obj} then P.Nothing else P.Just $ default_SharedNoteTemplate{sharedNoteTemplate_recipientThreadId = sharedNoteTemplate_recipientThreadId obj}
    , if obj == default_SharedNoteTemplate{sharedNoteTemplate_recipientContacts = sharedNoteTemplate_recipientContacts obj} then P.Nothing else P.Just $ default_SharedNoteTemplate{sharedNoteTemplate_recipientContacts = sharedNoteTemplate_recipientContacts obj}
    , if obj == default_SharedNoteTemplate{sharedNoteTemplate_privilege = sharedNoteTemplate_privilege obj} then P.Nothing else P.Just $ default_SharedNoteTemplate{sharedNoteTemplate_privilege = sharedNoteTemplate_privilege obj}
    ]
from_SharedNoteTemplate :: SharedNoteTemplate -> T.ThriftVal
from_SharedNoteTemplate record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v422 -> (1, ("noteGuid",T.TString $ E.encodeUtf8 _v422))) <$> sharedNoteTemplate_noteGuid record
  , (\_v422 -> (2, ("recipientContacts",T.TList (T.T_STRUCT Types_Types.typemap_Contact) $ P.map (\_v424 -> Types_Types.from_Contact _v424) $ Vector.toList _v422))) <$> sharedNoteTemplate_recipientContacts record
  , (\_v422 -> (3, ("privilege",T.TI32 $ P.fromIntegral $ P.fromEnum _v422))) <$> sharedNoteTemplate_privilege record
  , (\_v422 -> (4, ("recipientThreadId",T.TI64 _v422))) <$> sharedNoteTemplate_recipientThreadId record
  ]
write_SharedNoteTemplate :: T.Protocol p => p -> SharedNoteTemplate -> P.IO ()
write_SharedNoteTemplate oprot record = T.writeVal oprot $ from_SharedNoteTemplate record
encode_SharedNoteTemplate :: T.StatelessProtocol p => p -> SharedNoteTemplate -> LBS.ByteString
encode_SharedNoteTemplate oprot record = T.serializeVal oprot $ from_SharedNoteTemplate record
to_SharedNoteTemplate :: T.ThriftVal -> SharedNoteTemplate
to_SharedNoteTemplate (T.TStruct fields) = SharedNoteTemplate{
  sharedNoteTemplate_noteGuid = P.maybe (P.Nothing) (\(_,_val426) -> P.Just (case _val426 of {T.TString _val427 -> E.decodeUtf8 _val427; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  sharedNoteTemplate_recipientThreadId = P.maybe (P.Nothing) (\(_,_val426) -> P.Just (case _val426 of {T.TI64 _val428 -> _val428; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  sharedNoteTemplate_recipientContacts = P.maybe (P.Nothing) (\(_,_val426) -> P.Just (case _val426 of {T.TList _ _val429 -> (Vector.fromList $ P.map (\_v430 -> (case _v430 of {T.TStruct _val431 -> (Types_Types.to_Contact (T.TStruct _val431)); _ -> P.error "wrong type"})) _val429); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  sharedNoteTemplate_privilege = P.maybe (P.Nothing) (\(_,_val426) -> P.Just (case _val426 of {T.TI32 _val432 -> P.toEnum $ P.fromIntegral _val432; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_SharedNoteTemplate _ = P.error "not a struct"
read_SharedNoteTemplate :: T.Protocol p => p -> P.IO SharedNoteTemplate
read_SharedNoteTemplate iprot = to_SharedNoteTemplate <$> T.readVal iprot (T.T_STRUCT typemap_SharedNoteTemplate)
decode_SharedNoteTemplate :: T.StatelessProtocol p => p -> LBS.ByteString -> SharedNoteTemplate
decode_SharedNoteTemplate iprot bs = to_SharedNoteTemplate $ T.deserializeVal iprot (T.T_STRUCT typemap_SharedNoteTemplate) bs
typemap_SharedNoteTemplate :: T.TypeMap
typemap_SharedNoteTemplate = Map.fromList [(1,("noteGuid",T.T_STRING)),(2,("recipientContacts",(T.T_LIST (T.T_STRUCT Types_Types.typemap_Contact)))),(3,("privilege",T.T_I32)),(4,("recipientThreadId",T.T_I64))]
default_SharedNoteTemplate :: SharedNoteTemplate
default_SharedNoteTemplate = SharedNoteTemplate{
  sharedNoteTemplate_noteGuid = P.Nothing,
  sharedNoteTemplate_recipientContacts = P.Nothing,
  sharedNoteTemplate_privilege = P.Nothing,
  sharedNoteTemplate_recipientThreadId = P.Nothing}
data NotebookShareTemplate = NotebookShareTemplate  { notebookShareTemplate_notebookGuid :: P.Maybe LT.Text
  , notebookShareTemplate_recipientThreadId :: P.Maybe I.Int64
  , notebookShareTemplate_recipientContacts :: P.Maybe (Vector.Vector Types_Types.Contact)
  , notebookShareTemplate_privilege :: P.Maybe Types_Types.SharedNotebookPrivilegeLevel
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable NotebookShareTemplate where
  hashWithSalt salt record = salt   `H.hashWithSalt` notebookShareTemplate_notebookGuid record   `H.hashWithSalt` notebookShareTemplate_recipientThreadId record   `H.hashWithSalt` notebookShareTemplate_recipientContacts record   `H.hashWithSalt` notebookShareTemplate_privilege record  
instance QC.Arbitrary NotebookShareTemplate where 
  arbitrary = M.liftM NotebookShareTemplate (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_NotebookShareTemplate = []
             | P.otherwise = M.catMaybes
    [ if obj == default_NotebookShareTemplate{notebookShareTemplate_notebookGuid = notebookShareTemplate_notebookGuid obj} then P.Nothing else P.Just $ default_NotebookShareTemplate{notebookShareTemplate_notebookGuid = notebookShareTemplate_notebookGuid obj}
    , if obj == default_NotebookShareTemplate{notebookShareTemplate_recipientThreadId = notebookShareTemplate_recipientThreadId obj} then P.Nothing else P.Just $ default_NotebookShareTemplate{notebookShareTemplate_recipientThreadId = notebookShareTemplate_recipientThreadId obj}
    , if obj == default_NotebookShareTemplate{notebookShareTemplate_recipientContacts = notebookShareTemplate_recipientContacts obj} then P.Nothing else P.Just $ default_NotebookShareTemplate{notebookShareTemplate_recipientContacts = notebookShareTemplate_recipientContacts obj}
    , if obj == default_NotebookShareTemplate{notebookShareTemplate_privilege = notebookShareTemplate_privilege obj} then P.Nothing else P.Just $ default_NotebookShareTemplate{notebookShareTemplate_privilege = notebookShareTemplate_privilege obj}
    ]
from_NotebookShareTemplate :: NotebookShareTemplate -> T.ThriftVal
from_NotebookShareTemplate record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v435 -> (1, ("notebookGuid",T.TString $ E.encodeUtf8 _v435))) <$> notebookShareTemplate_notebookGuid record
  , (\_v435 -> (2, ("recipientContacts",T.TList (T.T_STRUCT Types_Types.typemap_Contact) $ P.map (\_v437 -> Types_Types.from_Contact _v437) $ Vector.toList _v435))) <$> notebookShareTemplate_recipientContacts record
  , (\_v435 -> (3, ("privilege",T.TI32 $ P.fromIntegral $ P.fromEnum _v435))) <$> notebookShareTemplate_privilege record
  , (\_v435 -> (4, ("recipientThreadId",T.TI64 _v435))) <$> notebookShareTemplate_recipientThreadId record
  ]
write_NotebookShareTemplate :: T.Protocol p => p -> NotebookShareTemplate -> P.IO ()
write_NotebookShareTemplate oprot record = T.writeVal oprot $ from_NotebookShareTemplate record
encode_NotebookShareTemplate :: T.StatelessProtocol p => p -> NotebookShareTemplate -> LBS.ByteString
encode_NotebookShareTemplate oprot record = T.serializeVal oprot $ from_NotebookShareTemplate record
to_NotebookShareTemplate :: T.ThriftVal -> NotebookShareTemplate
to_NotebookShareTemplate (T.TStruct fields) = NotebookShareTemplate{
  notebookShareTemplate_notebookGuid = P.maybe (P.Nothing) (\(_,_val439) -> P.Just (case _val439 of {T.TString _val440 -> E.decodeUtf8 _val440; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  notebookShareTemplate_recipientThreadId = P.maybe (P.Nothing) (\(_,_val439) -> P.Just (case _val439 of {T.TI64 _val441 -> _val441; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  notebookShareTemplate_recipientContacts = P.maybe (P.Nothing) (\(_,_val439) -> P.Just (case _val439 of {T.TList _ _val442 -> (Vector.fromList $ P.map (\_v443 -> (case _v443 of {T.TStruct _val444 -> (Types_Types.to_Contact (T.TStruct _val444)); _ -> P.error "wrong type"})) _val442); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  notebookShareTemplate_privilege = P.maybe (P.Nothing) (\(_,_val439) -> P.Just (case _val439 of {T.TI32 _val445 -> P.toEnum $ P.fromIntegral _val445; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_NotebookShareTemplate _ = P.error "not a struct"
read_NotebookShareTemplate :: T.Protocol p => p -> P.IO NotebookShareTemplate
read_NotebookShareTemplate iprot = to_NotebookShareTemplate <$> T.readVal iprot (T.T_STRUCT typemap_NotebookShareTemplate)
decode_NotebookShareTemplate :: T.StatelessProtocol p => p -> LBS.ByteString -> NotebookShareTemplate
decode_NotebookShareTemplate iprot bs = to_NotebookShareTemplate $ T.deserializeVal iprot (T.T_STRUCT typemap_NotebookShareTemplate) bs
typemap_NotebookShareTemplate :: T.TypeMap
typemap_NotebookShareTemplate = Map.fromList [(1,("notebookGuid",T.T_STRING)),(2,("recipientContacts",(T.T_LIST (T.T_STRUCT Types_Types.typemap_Contact)))),(3,("privilege",T.T_I32)),(4,("recipientThreadId",T.T_I64))]
default_NotebookShareTemplate :: NotebookShareTemplate
default_NotebookShareTemplate = NotebookShareTemplate{
  notebookShareTemplate_notebookGuid = P.Nothing,
  notebookShareTemplate_recipientContacts = P.Nothing,
  notebookShareTemplate_privilege = P.Nothing,
  notebookShareTemplate_recipientThreadId = P.Nothing}
data CreateOrUpdateNotebookSharesResult = CreateOrUpdateNotebookSharesResult  { createOrUpdateNotebookSharesResult_updateSequenceNum :: P.Maybe I.Int32
  , createOrUpdateNotebookSharesResult_matchingShares :: P.Maybe (Vector.Vector Types_Types.SharedNotebook)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable CreateOrUpdateNotebookSharesResult where
  hashWithSalt salt record = salt   `H.hashWithSalt` createOrUpdateNotebookSharesResult_updateSequenceNum record   `H.hashWithSalt` createOrUpdateNotebookSharesResult_matchingShares record  
instance QC.Arbitrary CreateOrUpdateNotebookSharesResult where 
  arbitrary = M.liftM CreateOrUpdateNotebookSharesResult (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_CreateOrUpdateNotebookSharesResult = []
             | P.otherwise = M.catMaybes
    [ if obj == default_CreateOrUpdateNotebookSharesResult{createOrUpdateNotebookSharesResult_updateSequenceNum = createOrUpdateNotebookSharesResult_updateSequenceNum obj} then P.Nothing else P.Just $ default_CreateOrUpdateNotebookSharesResult{createOrUpdateNotebookSharesResult_updateSequenceNum = createOrUpdateNotebookSharesResult_updateSequenceNum obj}
    , if obj == default_CreateOrUpdateNotebookSharesResult{createOrUpdateNotebookSharesResult_matchingShares = createOrUpdateNotebookSharesResult_matchingShares obj} then P.Nothing else P.Just $ default_CreateOrUpdateNotebookSharesResult{createOrUpdateNotebookSharesResult_matchingShares = createOrUpdateNotebookSharesResult_matchingShares obj}
    ]
from_CreateOrUpdateNotebookSharesResult :: CreateOrUpdateNotebookSharesResult -> T.ThriftVal
from_CreateOrUpdateNotebookSharesResult record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v448 -> (1, ("updateSequenceNum",T.TI32 _v448))) <$> createOrUpdateNotebookSharesResult_updateSequenceNum record
  , (\_v448 -> (2, ("matchingShares",T.TList (T.T_STRUCT Types_Types.typemap_SharedNotebook) $ P.map (\_v450 -> Types_Types.from_SharedNotebook _v450) $ Vector.toList _v448))) <$> createOrUpdateNotebookSharesResult_matchingShares record
  ]
write_CreateOrUpdateNotebookSharesResult :: T.Protocol p => p -> CreateOrUpdateNotebookSharesResult -> P.IO ()
write_CreateOrUpdateNotebookSharesResult oprot record = T.writeVal oprot $ from_CreateOrUpdateNotebookSharesResult record
encode_CreateOrUpdateNotebookSharesResult :: T.StatelessProtocol p => p -> CreateOrUpdateNotebookSharesResult -> LBS.ByteString
encode_CreateOrUpdateNotebookSharesResult oprot record = T.serializeVal oprot $ from_CreateOrUpdateNotebookSharesResult record
to_CreateOrUpdateNotebookSharesResult :: T.ThriftVal -> CreateOrUpdateNotebookSharesResult
to_CreateOrUpdateNotebookSharesResult (T.TStruct fields) = CreateOrUpdateNotebookSharesResult{
  createOrUpdateNotebookSharesResult_updateSequenceNum = P.maybe (P.Nothing) (\(_,_val452) -> P.Just (case _val452 of {T.TI32 _val453 -> _val453; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  createOrUpdateNotebookSharesResult_matchingShares = P.maybe (P.Nothing) (\(_,_val452) -> P.Just (case _val452 of {T.TList _ _val454 -> (Vector.fromList $ P.map (\_v455 -> (case _v455 of {T.TStruct _val456 -> (Types_Types.to_SharedNotebook (T.TStruct _val456)); _ -> P.error "wrong type"})) _val454); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_CreateOrUpdateNotebookSharesResult _ = P.error "not a struct"
read_CreateOrUpdateNotebookSharesResult :: T.Protocol p => p -> P.IO CreateOrUpdateNotebookSharesResult
read_CreateOrUpdateNotebookSharesResult iprot = to_CreateOrUpdateNotebookSharesResult <$> T.readVal iprot (T.T_STRUCT typemap_CreateOrUpdateNotebookSharesResult)
decode_CreateOrUpdateNotebookSharesResult :: T.StatelessProtocol p => p -> LBS.ByteString -> CreateOrUpdateNotebookSharesResult
decode_CreateOrUpdateNotebookSharesResult iprot bs = to_CreateOrUpdateNotebookSharesResult $ T.deserializeVal iprot (T.T_STRUCT typemap_CreateOrUpdateNotebookSharesResult) bs
typemap_CreateOrUpdateNotebookSharesResult :: T.TypeMap
typemap_CreateOrUpdateNotebookSharesResult = Map.fromList [(1,("updateSequenceNum",T.T_I32)),(2,("matchingShares",(T.T_LIST (T.T_STRUCT Types_Types.typemap_SharedNotebook))))]
default_CreateOrUpdateNotebookSharesResult :: CreateOrUpdateNotebookSharesResult
default_CreateOrUpdateNotebookSharesResult = CreateOrUpdateNotebookSharesResult{
  createOrUpdateNotebookSharesResult_updateSequenceNum = P.Nothing,
  createOrUpdateNotebookSharesResult_matchingShares = P.Nothing}
data NoteShareRelationshipRestrictions = NoteShareRelationshipRestrictions  { noteShareRelationshipRestrictions_noSetReadNote :: P.Maybe P.Bool
  , noteShareRelationshipRestrictions_noSetModifyNote :: P.Maybe P.Bool
  , noteShareRelationshipRestrictions_noSetFullAccess :: P.Maybe P.Bool
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable NoteShareRelationshipRestrictions where
  hashWithSalt salt record = salt   `H.hashWithSalt` noteShareRelationshipRestrictions_noSetReadNote record   `H.hashWithSalt` noteShareRelationshipRestrictions_noSetModifyNote record   `H.hashWithSalt` noteShareRelationshipRestrictions_noSetFullAccess record  
instance QC.Arbitrary NoteShareRelationshipRestrictions where 
  arbitrary = M.liftM NoteShareRelationshipRestrictions (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_NoteShareRelationshipRestrictions = []
             | P.otherwise = M.catMaybes
    [ if obj == default_NoteShareRelationshipRestrictions{noteShareRelationshipRestrictions_noSetReadNote = noteShareRelationshipRestrictions_noSetReadNote obj} then P.Nothing else P.Just $ default_NoteShareRelationshipRestrictions{noteShareRelationshipRestrictions_noSetReadNote = noteShareRelationshipRestrictions_noSetReadNote obj}
    , if obj == default_NoteShareRelationshipRestrictions{noteShareRelationshipRestrictions_noSetModifyNote = noteShareRelationshipRestrictions_noSetModifyNote obj} then P.Nothing else P.Just $ default_NoteShareRelationshipRestrictions{noteShareRelationshipRestrictions_noSetModifyNote = noteShareRelationshipRestrictions_noSetModifyNote obj}
    , if obj == default_NoteShareRelationshipRestrictions{noteShareRelationshipRestrictions_noSetFullAccess = noteShareRelationshipRestrictions_noSetFullAccess obj} then P.Nothing else P.Just $ default_NoteShareRelationshipRestrictions{noteShareRelationshipRestrictions_noSetFullAccess = noteShareRelationshipRestrictions_noSetFullAccess obj}
    ]
from_NoteShareRelationshipRestrictions :: NoteShareRelationshipRestrictions -> T.ThriftVal
from_NoteShareRelationshipRestrictions record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v459 -> (1, ("noSetReadNote",T.TBool _v459))) <$> noteShareRelationshipRestrictions_noSetReadNote record
  , (\_v459 -> (2, ("noSetModifyNote",T.TBool _v459))) <$> noteShareRelationshipRestrictions_noSetModifyNote record
  , (\_v459 -> (3, ("noSetFullAccess",T.TBool _v459))) <$> noteShareRelationshipRestrictions_noSetFullAccess record
  ]
write_NoteShareRelationshipRestrictions :: T.Protocol p => p -> NoteShareRelationshipRestrictions -> P.IO ()
write_NoteShareRelationshipRestrictions oprot record = T.writeVal oprot $ from_NoteShareRelationshipRestrictions record
encode_NoteShareRelationshipRestrictions :: T.StatelessProtocol p => p -> NoteShareRelationshipRestrictions -> LBS.ByteString
encode_NoteShareRelationshipRestrictions oprot record = T.serializeVal oprot $ from_NoteShareRelationshipRestrictions record
to_NoteShareRelationshipRestrictions :: T.ThriftVal -> NoteShareRelationshipRestrictions
to_NoteShareRelationshipRestrictions (T.TStruct fields) = NoteShareRelationshipRestrictions{
  noteShareRelationshipRestrictions_noSetReadNote = P.maybe (P.Nothing) (\(_,_val461) -> P.Just (case _val461 of {T.TBool _val462 -> _val462; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  noteShareRelationshipRestrictions_noSetModifyNote = P.maybe (P.Nothing) (\(_,_val461) -> P.Just (case _val461 of {T.TBool _val463 -> _val463; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  noteShareRelationshipRestrictions_noSetFullAccess = P.maybe (P.Nothing) (\(_,_val461) -> P.Just (case _val461 of {T.TBool _val464 -> _val464; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_NoteShareRelationshipRestrictions _ = P.error "not a struct"
read_NoteShareRelationshipRestrictions :: T.Protocol p => p -> P.IO NoteShareRelationshipRestrictions
read_NoteShareRelationshipRestrictions iprot = to_NoteShareRelationshipRestrictions <$> T.readVal iprot (T.T_STRUCT typemap_NoteShareRelationshipRestrictions)
decode_NoteShareRelationshipRestrictions :: T.StatelessProtocol p => p -> LBS.ByteString -> NoteShareRelationshipRestrictions
decode_NoteShareRelationshipRestrictions iprot bs = to_NoteShareRelationshipRestrictions $ T.deserializeVal iprot (T.T_STRUCT typemap_NoteShareRelationshipRestrictions) bs
typemap_NoteShareRelationshipRestrictions :: T.TypeMap
typemap_NoteShareRelationshipRestrictions = Map.fromList [(1,("noSetReadNote",T.T_BOOL)),(2,("noSetModifyNote",T.T_BOOL)),(3,("noSetFullAccess",T.T_BOOL))]
default_NoteShareRelationshipRestrictions :: NoteShareRelationshipRestrictions
default_NoteShareRelationshipRestrictions = NoteShareRelationshipRestrictions{
  noteShareRelationshipRestrictions_noSetReadNote = P.Nothing,
  noteShareRelationshipRestrictions_noSetModifyNote = P.Nothing,
  noteShareRelationshipRestrictions_noSetFullAccess = P.Nothing}
data NoteMemberShareRelationship = NoteMemberShareRelationship  { noteMemberShareRelationship_displayName :: P.Maybe LT.Text
  , noteMemberShareRelationship_recipientUserId :: P.Maybe I.Int32
  , noteMemberShareRelationship_privilege :: P.Maybe Types_Types.SharedNotePrivilegeLevel
  , noteMemberShareRelationship_restrictions :: P.Maybe NoteShareRelationshipRestrictions
  , noteMemberShareRelationship_sharerUserId :: P.Maybe I.Int32
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable NoteMemberShareRelationship where
  hashWithSalt salt record = salt   `H.hashWithSalt` noteMemberShareRelationship_displayName record   `H.hashWithSalt` noteMemberShareRelationship_recipientUserId record   `H.hashWithSalt` noteMemberShareRelationship_privilege record   `H.hashWithSalt` noteMemberShareRelationship_restrictions record   `H.hashWithSalt` noteMemberShareRelationship_sharerUserId record  
instance QC.Arbitrary NoteMemberShareRelationship where 
  arbitrary = M.liftM NoteMemberShareRelationship (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_NoteMemberShareRelationship = []
             | P.otherwise = M.catMaybes
    [ if obj == default_NoteMemberShareRelationship{noteMemberShareRelationship_displayName = noteMemberShareRelationship_displayName obj} then P.Nothing else P.Just $ default_NoteMemberShareRelationship{noteMemberShareRelationship_displayName = noteMemberShareRelationship_displayName obj}
    , if obj == default_NoteMemberShareRelationship{noteMemberShareRelationship_recipientUserId = noteMemberShareRelationship_recipientUserId obj} then P.Nothing else P.Just $ default_NoteMemberShareRelationship{noteMemberShareRelationship_recipientUserId = noteMemberShareRelationship_recipientUserId obj}
    , if obj == default_NoteMemberShareRelationship{noteMemberShareRelationship_privilege = noteMemberShareRelationship_privilege obj} then P.Nothing else P.Just $ default_NoteMemberShareRelationship{noteMemberShareRelationship_privilege = noteMemberShareRelationship_privilege obj}
    , if obj == default_NoteMemberShareRelationship{noteMemberShareRelationship_restrictions = noteMemberShareRelationship_restrictions obj} then P.Nothing else P.Just $ default_NoteMemberShareRelationship{noteMemberShareRelationship_restrictions = noteMemberShareRelationship_restrictions obj}
    , if obj == default_NoteMemberShareRelationship{noteMemberShareRelationship_sharerUserId = noteMemberShareRelationship_sharerUserId obj} then P.Nothing else P.Just $ default_NoteMemberShareRelationship{noteMemberShareRelationship_sharerUserId = noteMemberShareRelationship_sharerUserId obj}
    ]
from_NoteMemberShareRelationship :: NoteMemberShareRelationship -> T.ThriftVal
from_NoteMemberShareRelationship record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v467 -> (1, ("displayName",T.TString $ E.encodeUtf8 _v467))) <$> noteMemberShareRelationship_displayName record
  , (\_v467 -> (2, ("recipientUserId",T.TI32 _v467))) <$> noteMemberShareRelationship_recipientUserId record
  , (\_v467 -> (3, ("privilege",T.TI32 $ P.fromIntegral $ P.fromEnum _v467))) <$> noteMemberShareRelationship_privilege record
  , (\_v467 -> (4, ("restrictions",from_NoteShareRelationshipRestrictions _v467))) <$> noteMemberShareRelationship_restrictions record
  , (\_v467 -> (5, ("sharerUserId",T.TI32 _v467))) <$> noteMemberShareRelationship_sharerUserId record
  ]
write_NoteMemberShareRelationship :: T.Protocol p => p -> NoteMemberShareRelationship -> P.IO ()
write_NoteMemberShareRelationship oprot record = T.writeVal oprot $ from_NoteMemberShareRelationship record
encode_NoteMemberShareRelationship :: T.StatelessProtocol p => p -> NoteMemberShareRelationship -> LBS.ByteString
encode_NoteMemberShareRelationship oprot record = T.serializeVal oprot $ from_NoteMemberShareRelationship record
to_NoteMemberShareRelationship :: T.ThriftVal -> NoteMemberShareRelationship
to_NoteMemberShareRelationship (T.TStruct fields) = NoteMemberShareRelationship{
  noteMemberShareRelationship_displayName = P.maybe (P.Nothing) (\(_,_val469) -> P.Just (case _val469 of {T.TString _val470 -> E.decodeUtf8 _val470; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  noteMemberShareRelationship_recipientUserId = P.maybe (P.Nothing) (\(_,_val469) -> P.Just (case _val469 of {T.TI32 _val471 -> _val471; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  noteMemberShareRelationship_privilege = P.maybe (P.Nothing) (\(_,_val469) -> P.Just (case _val469 of {T.TI32 _val472 -> P.toEnum $ P.fromIntegral _val472; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  noteMemberShareRelationship_restrictions = P.maybe (P.Nothing) (\(_,_val469) -> P.Just (case _val469 of {T.TStruct _val473 -> (to_NoteShareRelationshipRestrictions (T.TStruct _val473)); _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  noteMemberShareRelationship_sharerUserId = P.maybe (P.Nothing) (\(_,_val469) -> P.Just (case _val469 of {T.TI32 _val474 -> _val474; _ -> P.error "wrong type"})) (Map.lookup (5) fields)
  }
to_NoteMemberShareRelationship _ = P.error "not a struct"
read_NoteMemberShareRelationship :: T.Protocol p => p -> P.IO NoteMemberShareRelationship
read_NoteMemberShareRelationship iprot = to_NoteMemberShareRelationship <$> T.readVal iprot (T.T_STRUCT typemap_NoteMemberShareRelationship)
decode_NoteMemberShareRelationship :: T.StatelessProtocol p => p -> LBS.ByteString -> NoteMemberShareRelationship
decode_NoteMemberShareRelationship iprot bs = to_NoteMemberShareRelationship $ T.deserializeVal iprot (T.T_STRUCT typemap_NoteMemberShareRelationship) bs
typemap_NoteMemberShareRelationship :: T.TypeMap
typemap_NoteMemberShareRelationship = Map.fromList [(1,("displayName",T.T_STRING)),(2,("recipientUserId",T.T_I32)),(3,("privilege",T.T_I32)),(4,("restrictions",(T.T_STRUCT typemap_NoteShareRelationshipRestrictions))),(5,("sharerUserId",T.T_I32))]
default_NoteMemberShareRelationship :: NoteMemberShareRelationship
default_NoteMemberShareRelationship = NoteMemberShareRelationship{
  noteMemberShareRelationship_displayName = P.Nothing,
  noteMemberShareRelationship_recipientUserId = P.Nothing,
  noteMemberShareRelationship_privilege = P.Nothing,
  noteMemberShareRelationship_restrictions = P.Nothing,
  noteMemberShareRelationship_sharerUserId = P.Nothing}
data NoteInvitationShareRelationship = NoteInvitationShareRelationship  { noteInvitationShareRelationship_displayName :: P.Maybe LT.Text
  , noteInvitationShareRelationship_recipientIdentityId :: P.Maybe I.Int64
  , noteInvitationShareRelationship_privilege :: P.Maybe Types_Types.SharedNotePrivilegeLevel
  , noteInvitationShareRelationship_sharerUserId :: P.Maybe I.Int32
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable NoteInvitationShareRelationship where
  hashWithSalt salt record = salt   `H.hashWithSalt` noteInvitationShareRelationship_displayName record   `H.hashWithSalt` noteInvitationShareRelationship_recipientIdentityId record   `H.hashWithSalt` noteInvitationShareRelationship_privilege record   `H.hashWithSalt` noteInvitationShareRelationship_sharerUserId record  
instance QC.Arbitrary NoteInvitationShareRelationship where 
  arbitrary = M.liftM NoteInvitationShareRelationship (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_NoteInvitationShareRelationship = []
             | P.otherwise = M.catMaybes
    [ if obj == default_NoteInvitationShareRelationship{noteInvitationShareRelationship_displayName = noteInvitationShareRelationship_displayName obj} then P.Nothing else P.Just $ default_NoteInvitationShareRelationship{noteInvitationShareRelationship_displayName = noteInvitationShareRelationship_displayName obj}
    , if obj == default_NoteInvitationShareRelationship{noteInvitationShareRelationship_recipientIdentityId = noteInvitationShareRelationship_recipientIdentityId obj} then P.Nothing else P.Just $ default_NoteInvitationShareRelationship{noteInvitationShareRelationship_recipientIdentityId = noteInvitationShareRelationship_recipientIdentityId obj}
    , if obj == default_NoteInvitationShareRelationship{noteInvitationShareRelationship_privilege = noteInvitationShareRelationship_privilege obj} then P.Nothing else P.Just $ default_NoteInvitationShareRelationship{noteInvitationShareRelationship_privilege = noteInvitationShareRelationship_privilege obj}
    , if obj == default_NoteInvitationShareRelationship{noteInvitationShareRelationship_sharerUserId = noteInvitationShareRelationship_sharerUserId obj} then P.Nothing else P.Just $ default_NoteInvitationShareRelationship{noteInvitationShareRelationship_sharerUserId = noteInvitationShareRelationship_sharerUserId obj}
    ]
from_NoteInvitationShareRelationship :: NoteInvitationShareRelationship -> T.ThriftVal
from_NoteInvitationShareRelationship record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v477 -> (1, ("displayName",T.TString $ E.encodeUtf8 _v477))) <$> noteInvitationShareRelationship_displayName record
  , (\_v477 -> (2, ("recipientIdentityId",T.TI64 _v477))) <$> noteInvitationShareRelationship_recipientIdentityId record
  , (\_v477 -> (3, ("privilege",T.TI32 $ P.fromIntegral $ P.fromEnum _v477))) <$> noteInvitationShareRelationship_privilege record
  , (\_v477 -> (5, ("sharerUserId",T.TI32 _v477))) <$> noteInvitationShareRelationship_sharerUserId record
  ]
write_NoteInvitationShareRelationship :: T.Protocol p => p -> NoteInvitationShareRelationship -> P.IO ()
write_NoteInvitationShareRelationship oprot record = T.writeVal oprot $ from_NoteInvitationShareRelationship record
encode_NoteInvitationShareRelationship :: T.StatelessProtocol p => p -> NoteInvitationShareRelationship -> LBS.ByteString
encode_NoteInvitationShareRelationship oprot record = T.serializeVal oprot $ from_NoteInvitationShareRelationship record
to_NoteInvitationShareRelationship :: T.ThriftVal -> NoteInvitationShareRelationship
to_NoteInvitationShareRelationship (T.TStruct fields) = NoteInvitationShareRelationship{
  noteInvitationShareRelationship_displayName = P.maybe (P.Nothing) (\(_,_val479) -> P.Just (case _val479 of {T.TString _val480 -> E.decodeUtf8 _val480; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  noteInvitationShareRelationship_recipientIdentityId = P.maybe (P.Nothing) (\(_,_val479) -> P.Just (case _val479 of {T.TI64 _val481 -> _val481; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  noteInvitationShareRelationship_privilege = P.maybe (P.Nothing) (\(_,_val479) -> P.Just (case _val479 of {T.TI32 _val482 -> P.toEnum $ P.fromIntegral _val482; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  noteInvitationShareRelationship_sharerUserId = P.maybe (P.Nothing) (\(_,_val479) -> P.Just (case _val479 of {T.TI32 _val483 -> _val483; _ -> P.error "wrong type"})) (Map.lookup (5) fields)
  }
to_NoteInvitationShareRelationship _ = P.error "not a struct"
read_NoteInvitationShareRelationship :: T.Protocol p => p -> P.IO NoteInvitationShareRelationship
read_NoteInvitationShareRelationship iprot = to_NoteInvitationShareRelationship <$> T.readVal iprot (T.T_STRUCT typemap_NoteInvitationShareRelationship)
decode_NoteInvitationShareRelationship :: T.StatelessProtocol p => p -> LBS.ByteString -> NoteInvitationShareRelationship
decode_NoteInvitationShareRelationship iprot bs = to_NoteInvitationShareRelationship $ T.deserializeVal iprot (T.T_STRUCT typemap_NoteInvitationShareRelationship) bs
typemap_NoteInvitationShareRelationship :: T.TypeMap
typemap_NoteInvitationShareRelationship = Map.fromList [(1,("displayName",T.T_STRING)),(2,("recipientIdentityId",T.T_I64)),(3,("privilege",T.T_I32)),(5,("sharerUserId",T.T_I32))]
default_NoteInvitationShareRelationship :: NoteInvitationShareRelationship
default_NoteInvitationShareRelationship = NoteInvitationShareRelationship{
  noteInvitationShareRelationship_displayName = P.Nothing,
  noteInvitationShareRelationship_recipientIdentityId = P.Nothing,
  noteInvitationShareRelationship_privilege = P.Nothing,
  noteInvitationShareRelationship_sharerUserId = P.Nothing}
data NoteShareRelationships = NoteShareRelationships  { noteShareRelationships_invitations :: P.Maybe (Vector.Vector NoteInvitationShareRelationship)
  , noteShareRelationships_memberships :: P.Maybe (Vector.Vector NoteMemberShareRelationship)
  , noteShareRelationships_invitationRestrictions :: P.Maybe NoteShareRelationshipRestrictions
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable NoteShareRelationships where
  hashWithSalt salt record = salt   `H.hashWithSalt` noteShareRelationships_invitations record   `H.hashWithSalt` noteShareRelationships_memberships record   `H.hashWithSalt` noteShareRelationships_invitationRestrictions record  
instance QC.Arbitrary NoteShareRelationships where 
  arbitrary = M.liftM NoteShareRelationships (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_NoteShareRelationships = []
             | P.otherwise = M.catMaybes
    [ if obj == default_NoteShareRelationships{noteShareRelationships_invitations = noteShareRelationships_invitations obj} then P.Nothing else P.Just $ default_NoteShareRelationships{noteShareRelationships_invitations = noteShareRelationships_invitations obj}
    , if obj == default_NoteShareRelationships{noteShareRelationships_memberships = noteShareRelationships_memberships obj} then P.Nothing else P.Just $ default_NoteShareRelationships{noteShareRelationships_memberships = noteShareRelationships_memberships obj}
    , if obj == default_NoteShareRelationships{noteShareRelationships_invitationRestrictions = noteShareRelationships_invitationRestrictions obj} then P.Nothing else P.Just $ default_NoteShareRelationships{noteShareRelationships_invitationRestrictions = noteShareRelationships_invitationRestrictions obj}
    ]
from_NoteShareRelationships :: NoteShareRelationships -> T.ThriftVal
from_NoteShareRelationships record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v486 -> (1, ("invitations",T.TList (T.T_STRUCT typemap_NoteInvitationShareRelationship) $ P.map (\_v488 -> from_NoteInvitationShareRelationship _v488) $ Vector.toList _v486))) <$> noteShareRelationships_invitations record
  , (\_v486 -> (2, ("memberships",T.TList (T.T_STRUCT typemap_NoteMemberShareRelationship) $ P.map (\_v490 -> from_NoteMemberShareRelationship _v490) $ Vector.toList _v486))) <$> noteShareRelationships_memberships record
  , (\_v486 -> (3, ("invitationRestrictions",from_NoteShareRelationshipRestrictions _v486))) <$> noteShareRelationships_invitationRestrictions record
  ]
write_NoteShareRelationships :: T.Protocol p => p -> NoteShareRelationships -> P.IO ()
write_NoteShareRelationships oprot record = T.writeVal oprot $ from_NoteShareRelationships record
encode_NoteShareRelationships :: T.StatelessProtocol p => p -> NoteShareRelationships -> LBS.ByteString
encode_NoteShareRelationships oprot record = T.serializeVal oprot $ from_NoteShareRelationships record
to_NoteShareRelationships :: T.ThriftVal -> NoteShareRelationships
to_NoteShareRelationships (T.TStruct fields) = NoteShareRelationships{
  noteShareRelationships_invitations = P.maybe (P.Nothing) (\(_,_val492) -> P.Just (case _val492 of {T.TList _ _val493 -> (Vector.fromList $ P.map (\_v494 -> (case _v494 of {T.TStruct _val495 -> (to_NoteInvitationShareRelationship (T.TStruct _val495)); _ -> P.error "wrong type"})) _val493); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  noteShareRelationships_memberships = P.maybe (P.Nothing) (\(_,_val492) -> P.Just (case _val492 of {T.TList _ _val496 -> (Vector.fromList $ P.map (\_v497 -> (case _v497 of {T.TStruct _val498 -> (to_NoteMemberShareRelationship (T.TStruct _val498)); _ -> P.error "wrong type"})) _val496); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  noteShareRelationships_invitationRestrictions = P.maybe (P.Nothing) (\(_,_val492) -> P.Just (case _val492 of {T.TStruct _val499 -> (to_NoteShareRelationshipRestrictions (T.TStruct _val499)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_NoteShareRelationships _ = P.error "not a struct"
read_NoteShareRelationships :: T.Protocol p => p -> P.IO NoteShareRelationships
read_NoteShareRelationships iprot = to_NoteShareRelationships <$> T.readVal iprot (T.T_STRUCT typemap_NoteShareRelationships)
decode_NoteShareRelationships :: T.StatelessProtocol p => p -> LBS.ByteString -> NoteShareRelationships
decode_NoteShareRelationships iprot bs = to_NoteShareRelationships $ T.deserializeVal iprot (T.T_STRUCT typemap_NoteShareRelationships) bs
typemap_NoteShareRelationships :: T.TypeMap
typemap_NoteShareRelationships = Map.fromList [(1,("invitations",(T.T_LIST (T.T_STRUCT typemap_NoteInvitationShareRelationship)))),(2,("memberships",(T.T_LIST (T.T_STRUCT typemap_NoteMemberShareRelationship)))),(3,("invitationRestrictions",(T.T_STRUCT typemap_NoteShareRelationshipRestrictions)))]
default_NoteShareRelationships :: NoteShareRelationships
default_NoteShareRelationships = NoteShareRelationships{
  noteShareRelationships_invitations = P.Nothing,
  noteShareRelationships_memberships = P.Nothing,
  noteShareRelationships_invitationRestrictions = P.Nothing}
data ManageNoteSharesParameters = ManageNoteSharesParameters  { manageNoteSharesParameters_noteGuid :: P.Maybe LT.Text
  , manageNoteSharesParameters_membershipsToUpdate :: P.Maybe (Vector.Vector NoteMemberShareRelationship)
  , manageNoteSharesParameters_invitationsToUpdate :: P.Maybe (Vector.Vector NoteInvitationShareRelationship)
  , manageNoteSharesParameters_membershipsToUnshare :: P.Maybe (Vector.Vector I.Int32)
  , manageNoteSharesParameters_invitationsToUnshare :: P.Maybe (Vector.Vector I.Int64)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ManageNoteSharesParameters where
  hashWithSalt salt record = salt   `H.hashWithSalt` manageNoteSharesParameters_noteGuid record   `H.hashWithSalt` manageNoteSharesParameters_membershipsToUpdate record   `H.hashWithSalt` manageNoteSharesParameters_invitationsToUpdate record   `H.hashWithSalt` manageNoteSharesParameters_membershipsToUnshare record   `H.hashWithSalt` manageNoteSharesParameters_invitationsToUnshare record  
instance QC.Arbitrary ManageNoteSharesParameters where 
  arbitrary = M.liftM ManageNoteSharesParameters (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_ManageNoteSharesParameters = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ManageNoteSharesParameters{manageNoteSharesParameters_noteGuid = manageNoteSharesParameters_noteGuid obj} then P.Nothing else P.Just $ default_ManageNoteSharesParameters{manageNoteSharesParameters_noteGuid = manageNoteSharesParameters_noteGuid obj}
    , if obj == default_ManageNoteSharesParameters{manageNoteSharesParameters_membershipsToUpdate = manageNoteSharesParameters_membershipsToUpdate obj} then P.Nothing else P.Just $ default_ManageNoteSharesParameters{manageNoteSharesParameters_membershipsToUpdate = manageNoteSharesParameters_membershipsToUpdate obj}
    , if obj == default_ManageNoteSharesParameters{manageNoteSharesParameters_invitationsToUpdate = manageNoteSharesParameters_invitationsToUpdate obj} then P.Nothing else P.Just $ default_ManageNoteSharesParameters{manageNoteSharesParameters_invitationsToUpdate = manageNoteSharesParameters_invitationsToUpdate obj}
    , if obj == default_ManageNoteSharesParameters{manageNoteSharesParameters_membershipsToUnshare = manageNoteSharesParameters_membershipsToUnshare obj} then P.Nothing else P.Just $ default_ManageNoteSharesParameters{manageNoteSharesParameters_membershipsToUnshare = manageNoteSharesParameters_membershipsToUnshare obj}
    , if obj == default_ManageNoteSharesParameters{manageNoteSharesParameters_invitationsToUnshare = manageNoteSharesParameters_invitationsToUnshare obj} then P.Nothing else P.Just $ default_ManageNoteSharesParameters{manageNoteSharesParameters_invitationsToUnshare = manageNoteSharesParameters_invitationsToUnshare obj}
    ]
from_ManageNoteSharesParameters :: ManageNoteSharesParameters -> T.ThriftVal
from_ManageNoteSharesParameters record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v502 -> (1, ("noteGuid",T.TString $ E.encodeUtf8 _v502))) <$> manageNoteSharesParameters_noteGuid record
  , (\_v502 -> (2, ("membershipsToUpdate",T.TList (T.T_STRUCT typemap_NoteMemberShareRelationship) $ P.map (\_v504 -> from_NoteMemberShareRelationship _v504) $ Vector.toList _v502))) <$> manageNoteSharesParameters_membershipsToUpdate record
  , (\_v502 -> (3, ("invitationsToUpdate",T.TList (T.T_STRUCT typemap_NoteInvitationShareRelationship) $ P.map (\_v506 -> from_NoteInvitationShareRelationship _v506) $ Vector.toList _v502))) <$> manageNoteSharesParameters_invitationsToUpdate record
  , (\_v502 -> (4, ("membershipsToUnshare",T.TList T.T_I32 $ P.map (\_v508 -> T.TI32 _v508) $ Vector.toList _v502))) <$> manageNoteSharesParameters_membershipsToUnshare record
  , (\_v502 -> (5, ("invitationsToUnshare",T.TList T.T_I64 $ P.map (\_v510 -> T.TI64 _v510) $ Vector.toList _v502))) <$> manageNoteSharesParameters_invitationsToUnshare record
  ]
write_ManageNoteSharesParameters :: T.Protocol p => p -> ManageNoteSharesParameters -> P.IO ()
write_ManageNoteSharesParameters oprot record = T.writeVal oprot $ from_ManageNoteSharesParameters record
encode_ManageNoteSharesParameters :: T.StatelessProtocol p => p -> ManageNoteSharesParameters -> LBS.ByteString
encode_ManageNoteSharesParameters oprot record = T.serializeVal oprot $ from_ManageNoteSharesParameters record
to_ManageNoteSharesParameters :: T.ThriftVal -> ManageNoteSharesParameters
to_ManageNoteSharesParameters (T.TStruct fields) = ManageNoteSharesParameters{
  manageNoteSharesParameters_noteGuid = P.maybe (P.Nothing) (\(_,_val512) -> P.Just (case _val512 of {T.TString _val513 -> E.decodeUtf8 _val513; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  manageNoteSharesParameters_membershipsToUpdate = P.maybe (P.Nothing) (\(_,_val512) -> P.Just (case _val512 of {T.TList _ _val514 -> (Vector.fromList $ P.map (\_v515 -> (case _v515 of {T.TStruct _val516 -> (to_NoteMemberShareRelationship (T.TStruct _val516)); _ -> P.error "wrong type"})) _val514); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  manageNoteSharesParameters_invitationsToUpdate = P.maybe (P.Nothing) (\(_,_val512) -> P.Just (case _val512 of {T.TList _ _val517 -> (Vector.fromList $ P.map (\_v518 -> (case _v518 of {T.TStruct _val519 -> (to_NoteInvitationShareRelationship (T.TStruct _val519)); _ -> P.error "wrong type"})) _val517); _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  manageNoteSharesParameters_membershipsToUnshare = P.maybe (P.Nothing) (\(_,_val512) -> P.Just (case _val512 of {T.TList _ _val520 -> (Vector.fromList $ P.map (\_v521 -> (case _v521 of {T.TI32 _val522 -> _val522; _ -> P.error "wrong type"})) _val520); _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  manageNoteSharesParameters_invitationsToUnshare = P.maybe (P.Nothing) (\(_,_val512) -> P.Just (case _val512 of {T.TList _ _val523 -> (Vector.fromList $ P.map (\_v524 -> (case _v524 of {T.TI64 _val525 -> _val525; _ -> P.error "wrong type"})) _val523); _ -> P.error "wrong type"})) (Map.lookup (5) fields)
  }
to_ManageNoteSharesParameters _ = P.error "not a struct"
read_ManageNoteSharesParameters :: T.Protocol p => p -> P.IO ManageNoteSharesParameters
read_ManageNoteSharesParameters iprot = to_ManageNoteSharesParameters <$> T.readVal iprot (T.T_STRUCT typemap_ManageNoteSharesParameters)
decode_ManageNoteSharesParameters :: T.StatelessProtocol p => p -> LBS.ByteString -> ManageNoteSharesParameters
decode_ManageNoteSharesParameters iprot bs = to_ManageNoteSharesParameters $ T.deserializeVal iprot (T.T_STRUCT typemap_ManageNoteSharesParameters) bs
typemap_ManageNoteSharesParameters :: T.TypeMap
typemap_ManageNoteSharesParameters = Map.fromList [(1,("noteGuid",T.T_STRING)),(2,("membershipsToUpdate",(T.T_LIST (T.T_STRUCT typemap_NoteMemberShareRelationship)))),(3,("invitationsToUpdate",(T.T_LIST (T.T_STRUCT typemap_NoteInvitationShareRelationship)))),(4,("membershipsToUnshare",(T.T_LIST T.T_I32))),(5,("invitationsToUnshare",(T.T_LIST T.T_I64)))]
default_ManageNoteSharesParameters :: ManageNoteSharesParameters
default_ManageNoteSharesParameters = ManageNoteSharesParameters{
  manageNoteSharesParameters_noteGuid = P.Nothing,
  manageNoteSharesParameters_membershipsToUpdate = P.Nothing,
  manageNoteSharesParameters_invitationsToUpdate = P.Nothing,
  manageNoteSharesParameters_membershipsToUnshare = P.Nothing,
  manageNoteSharesParameters_invitationsToUnshare = P.Nothing}
data ManageNoteSharesError = ManageNoteSharesError  { manageNoteSharesError_identityID :: P.Maybe I.Int64
  , manageNoteSharesError_userID :: P.Maybe I.Int32
  , manageNoteSharesError_userException :: P.Maybe Errors_Types.EDAMUserException
  , manageNoteSharesError_notFoundException :: P.Maybe Errors_Types.EDAMNotFoundException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ManageNoteSharesError where
  hashWithSalt salt record = salt   `H.hashWithSalt` manageNoteSharesError_identityID record   `H.hashWithSalt` manageNoteSharesError_userID record   `H.hashWithSalt` manageNoteSharesError_userException record   `H.hashWithSalt` manageNoteSharesError_notFoundException record  
instance QC.Arbitrary ManageNoteSharesError where 
  arbitrary = M.liftM ManageNoteSharesError (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_ManageNoteSharesError = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ManageNoteSharesError{manageNoteSharesError_identityID = manageNoteSharesError_identityID obj} then P.Nothing else P.Just $ default_ManageNoteSharesError{manageNoteSharesError_identityID = manageNoteSharesError_identityID obj}
    , if obj == default_ManageNoteSharesError{manageNoteSharesError_userID = manageNoteSharesError_userID obj} then P.Nothing else P.Just $ default_ManageNoteSharesError{manageNoteSharesError_userID = manageNoteSharesError_userID obj}
    , if obj == default_ManageNoteSharesError{manageNoteSharesError_userException = manageNoteSharesError_userException obj} then P.Nothing else P.Just $ default_ManageNoteSharesError{manageNoteSharesError_userException = manageNoteSharesError_userException obj}
    , if obj == default_ManageNoteSharesError{manageNoteSharesError_notFoundException = manageNoteSharesError_notFoundException obj} then P.Nothing else P.Just $ default_ManageNoteSharesError{manageNoteSharesError_notFoundException = manageNoteSharesError_notFoundException obj}
    ]
from_ManageNoteSharesError :: ManageNoteSharesError -> T.ThriftVal
from_ManageNoteSharesError record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v528 -> (3, ("userException",Errors_Types.from_EDAMUserException _v528))) <$> manageNoteSharesError_userException record, (\_v528 -> (4, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v528))) <$> manageNoteSharesError_notFoundException record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v528 -> (1, ("identityID",T.TI64 _v528))) <$> manageNoteSharesError_identityID record
    , (\_v528 -> (2, ("userID",T.TI32 _v528))) <$> manageNoteSharesError_userID record
    , (\_v528 -> (3, ("userException",Errors_Types.from_EDAMUserException _v528))) <$> manageNoteSharesError_userException record
    , (\_v528 -> (4, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v528))) <$> manageNoteSharesError_notFoundException record
    ]
    )
write_ManageNoteSharesError :: T.Protocol p => p -> ManageNoteSharesError -> P.IO ()
write_ManageNoteSharesError oprot record = T.writeVal oprot $ from_ManageNoteSharesError record
encode_ManageNoteSharesError :: T.StatelessProtocol p => p -> ManageNoteSharesError -> LBS.ByteString
encode_ManageNoteSharesError oprot record = T.serializeVal oprot $ from_ManageNoteSharesError record
to_ManageNoteSharesError :: T.ThriftVal -> ManageNoteSharesError
to_ManageNoteSharesError (T.TStruct fields) = ManageNoteSharesError{
  manageNoteSharesError_identityID = P.maybe (P.Nothing) (\(_,_val530) -> P.Just (case _val530 of {T.TI64 _val531 -> _val531; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  manageNoteSharesError_userID = P.maybe (P.Nothing) (\(_,_val530) -> P.Just (case _val530 of {T.TI32 _val532 -> _val532; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  manageNoteSharesError_userException = P.maybe (P.Nothing) (\(_,_val530) -> P.Just (case _val530 of {T.TStruct _val533 -> (Errors_Types.to_EDAMUserException (T.TStruct _val533)); _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  manageNoteSharesError_notFoundException = P.maybe (P.Nothing) (\(_,_val530) -> P.Just (case _val530 of {T.TStruct _val534 -> (Errors_Types.to_EDAMNotFoundException (T.TStruct _val534)); _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_ManageNoteSharesError _ = P.error "not a struct"
read_ManageNoteSharesError :: T.Protocol p => p -> P.IO ManageNoteSharesError
read_ManageNoteSharesError iprot = to_ManageNoteSharesError <$> T.readVal iprot (T.T_STRUCT typemap_ManageNoteSharesError)
decode_ManageNoteSharesError :: T.StatelessProtocol p => p -> LBS.ByteString -> ManageNoteSharesError
decode_ManageNoteSharesError iprot bs = to_ManageNoteSharesError $ T.deserializeVal iprot (T.T_STRUCT typemap_ManageNoteSharesError) bs
typemap_ManageNoteSharesError :: T.TypeMap
typemap_ManageNoteSharesError = Map.fromList [(1,("identityID",T.T_I64)),(2,("userID",T.T_I32)),(3,("userException",(T.T_STRUCT Errors_Types.typemap_EDAMUserException))),(4,("notFoundException",(T.T_STRUCT Errors_Types.typemap_EDAMNotFoundException)))]
default_ManageNoteSharesError :: ManageNoteSharesError
default_ManageNoteSharesError = ManageNoteSharesError{
  manageNoteSharesError_identityID = P.Nothing,
  manageNoteSharesError_userID = P.Nothing,
  manageNoteSharesError_userException = P.Nothing,
  manageNoteSharesError_notFoundException = P.Nothing}
data ManageNoteSharesResult = ManageNoteSharesResult  { manageNoteSharesResult_errors :: P.Maybe (Vector.Vector ManageNoteSharesError)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ManageNoteSharesResult where
  hashWithSalt salt record = salt   `H.hashWithSalt` manageNoteSharesResult_errors record  
instance QC.Arbitrary ManageNoteSharesResult where 
  arbitrary = M.liftM ManageNoteSharesResult (M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_ManageNoteSharesResult = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ManageNoteSharesResult{manageNoteSharesResult_errors = manageNoteSharesResult_errors obj} then P.Nothing else P.Just $ default_ManageNoteSharesResult{manageNoteSharesResult_errors = manageNoteSharesResult_errors obj}
    ]
from_ManageNoteSharesResult :: ManageNoteSharesResult -> T.ThriftVal
from_ManageNoteSharesResult record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v537 -> (1, ("errors",T.TList (T.T_STRUCT typemap_ManageNoteSharesError) $ P.map (\_v539 -> from_ManageNoteSharesError _v539) $ Vector.toList _v537))) <$> manageNoteSharesResult_errors record
  ]
write_ManageNoteSharesResult :: T.Protocol p => p -> ManageNoteSharesResult -> P.IO ()
write_ManageNoteSharesResult oprot record = T.writeVal oprot $ from_ManageNoteSharesResult record
encode_ManageNoteSharesResult :: T.StatelessProtocol p => p -> ManageNoteSharesResult -> LBS.ByteString
encode_ManageNoteSharesResult oprot record = T.serializeVal oprot $ from_ManageNoteSharesResult record
to_ManageNoteSharesResult :: T.ThriftVal -> ManageNoteSharesResult
to_ManageNoteSharesResult (T.TStruct fields) = ManageNoteSharesResult{
  manageNoteSharesResult_errors = P.maybe (P.Nothing) (\(_,_val541) -> P.Just (case _val541 of {T.TList _ _val542 -> (Vector.fromList $ P.map (\_v543 -> (case _v543 of {T.TStruct _val544 -> (to_ManageNoteSharesError (T.TStruct _val544)); _ -> P.error "wrong type"})) _val542); _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_ManageNoteSharesResult _ = P.error "not a struct"
read_ManageNoteSharesResult :: T.Protocol p => p -> P.IO ManageNoteSharesResult
read_ManageNoteSharesResult iprot = to_ManageNoteSharesResult <$> T.readVal iprot (T.T_STRUCT typemap_ManageNoteSharesResult)
decode_ManageNoteSharesResult :: T.StatelessProtocol p => p -> LBS.ByteString -> ManageNoteSharesResult
decode_ManageNoteSharesResult iprot bs = to_ManageNoteSharesResult $ T.deserializeVal iprot (T.T_STRUCT typemap_ManageNoteSharesResult) bs
typemap_ManageNoteSharesResult :: T.TypeMap
typemap_ManageNoteSharesResult = Map.fromList [(1,("errors",(T.T_LIST (T.T_STRUCT typemap_ManageNoteSharesError))))]
default_ManageNoteSharesResult :: ManageNoteSharesResult
default_ManageNoteSharesResult = ManageNoteSharesResult{
  manageNoteSharesResult_errors = P.Nothing}
