{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-missing-fields #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-----------------------------------------------------------------
-- Autogenerated by Thrift Compiler (0.11.0)                      --
--                                                             --
-- DO NOT EDIT UNLESS YOU ARE SURE YOU KNOW WHAT YOU ARE DOING --
-----------------------------------------------------------------

module NoteStore where
import Prelude (($), (.), (>>=), (==), (++))
import qualified Prelude as P
import qualified Control.Exception as X
import qualified Control.Monad as M ( liftM, ap, when )
import Data.Functor ( (<$>) )
import qualified Data.ByteString.Lazy as LBS
import qualified Data.Hashable as H
import qualified Data.Int as I
import qualified Data.Maybe as M (catMaybes)
import qualified Data.Text.Lazy.Encoding as E ( decodeUtf8, encodeUtf8 )
import qualified Data.Text.Lazy as LT
import qualified GHC.Generics as G (Generic)
import qualified Data.Typeable as TY ( Typeable )
import qualified Data.HashMap.Strict as Map
import qualified Data.HashSet as Set
import qualified Data.Vector as Vector
import qualified Test.QuickCheck.Arbitrary as QC ( Arbitrary(..) )
import qualified Test.QuickCheck as QC ( elements )

import qualified Thrift as T
import qualified Thrift.Types as T
import qualified Thrift.Arbitraries as T

import qualified UserStore_Types
import qualified Types_Types
import qualified Errors_Types
import qualified Limits_Types


import NoteStore_Types
import qualified NoteStore_Iface as Iface
-- HELPER FUNCTIONS AND STRUCTURES --

data GetSyncState_args = GetSyncState_args  { getSyncState_args_authenticationToken :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetSyncState_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getSyncState_args_authenticationToken record  
instance QC.Arbitrary GetSyncState_args where 
  arbitrary = M.liftM GetSyncState_args (QC.arbitrary)
  shrink obj | obj == default_GetSyncState_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetSyncState_args{getSyncState_args_authenticationToken = getSyncState_args_authenticationToken obj} then P.Nothing else P.Just $ default_GetSyncState_args{getSyncState_args_authenticationToken = getSyncState_args_authenticationToken obj}
    ]
from_GetSyncState_args :: GetSyncState_args -> T.ThriftVal
from_GetSyncState_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v547 -> P.Just (1, ("authenticationToken",T.TString $ E.encodeUtf8 _v547))) $ getSyncState_args_authenticationToken record
  ]
write_GetSyncState_args :: T.Protocol p => p -> GetSyncState_args -> P.IO ()
write_GetSyncState_args oprot record = T.writeVal oprot $ from_GetSyncState_args record
encode_GetSyncState_args :: T.StatelessProtocol p => p -> GetSyncState_args -> LBS.ByteString
encode_GetSyncState_args oprot record = T.serializeVal oprot $ from_GetSyncState_args record
to_GetSyncState_args :: T.ThriftVal -> GetSyncState_args
to_GetSyncState_args (T.TStruct fields) = GetSyncState_args{
  getSyncState_args_authenticationToken = P.maybe (getSyncState_args_authenticationToken default_GetSyncState_args) (\(_,_val549) -> (case _val549 of {T.TString _val550 -> E.decodeUtf8 _val550; _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetSyncState_args _ = P.error "not a struct"
read_GetSyncState_args :: T.Protocol p => p -> P.IO GetSyncState_args
read_GetSyncState_args iprot = to_GetSyncState_args <$> T.readVal iprot (T.T_STRUCT typemap_GetSyncState_args)
decode_GetSyncState_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetSyncState_args
decode_GetSyncState_args iprot bs = to_GetSyncState_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetSyncState_args) bs
typemap_GetSyncState_args :: T.TypeMap
typemap_GetSyncState_args = Map.fromList [(1,("authenticationToken",T.T_STRING))]
default_GetSyncState_args :: GetSyncState_args
default_GetSyncState_args = GetSyncState_args{
  getSyncState_args_authenticationToken = ""}
data GetSyncState_result = GetSyncState_result  { getSyncState_result_success :: SyncState
  , getSyncState_result_userException :: P.Maybe Errors_Types.EDAMUserException
  , getSyncState_result_systemException :: P.Maybe Errors_Types.EDAMSystemException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetSyncState_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getSyncState_result_success record   `H.hashWithSalt` getSyncState_result_userException record   `H.hashWithSalt` getSyncState_result_systemException record  
instance QC.Arbitrary GetSyncState_result where 
  arbitrary = M.liftM GetSyncState_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetSyncState_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetSyncState_result{getSyncState_result_success = getSyncState_result_success obj} then P.Nothing else P.Just $ default_GetSyncState_result{getSyncState_result_success = getSyncState_result_success obj}
    , if obj == default_GetSyncState_result{getSyncState_result_userException = getSyncState_result_userException obj} then P.Nothing else P.Just $ default_GetSyncState_result{getSyncState_result_userException = getSyncState_result_userException obj}
    , if obj == default_GetSyncState_result{getSyncState_result_systemException = getSyncState_result_systemException obj} then P.Nothing else P.Just $ default_GetSyncState_result{getSyncState_result_systemException = getSyncState_result_systemException obj}
    ]
from_GetSyncState_result :: GetSyncState_result -> T.ThriftVal
from_GetSyncState_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v553 -> (1, ("userException",Errors_Types.from_EDAMUserException _v553))) <$> getSyncState_result_userException record, (\_v553 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v553))) <$> getSyncState_result_systemException record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v553 -> P.Just (0, ("success",from_SyncState _v553))) $ getSyncState_result_success record
    , (\_v553 -> (1, ("userException",Errors_Types.from_EDAMUserException _v553))) <$> getSyncState_result_userException record
    , (\_v553 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v553))) <$> getSyncState_result_systemException record
    ]
    )
write_GetSyncState_result :: T.Protocol p => p -> GetSyncState_result -> P.IO ()
write_GetSyncState_result oprot record = T.writeVal oprot $ from_GetSyncState_result record
encode_GetSyncState_result :: T.StatelessProtocol p => p -> GetSyncState_result -> LBS.ByteString
encode_GetSyncState_result oprot record = T.serializeVal oprot $ from_GetSyncState_result record
to_GetSyncState_result :: T.ThriftVal -> GetSyncState_result
to_GetSyncState_result (T.TStruct fields) = GetSyncState_result{
  getSyncState_result_success = P.maybe (getSyncState_result_success default_GetSyncState_result) (\(_,_val555) -> (case _val555 of {T.TStruct _val556 -> (to_SyncState (T.TStruct _val556)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getSyncState_result_userException = P.maybe (P.Nothing) (\(_,_val555) -> P.Just (case _val555 of {T.TStruct _val557 -> (Errors_Types.to_EDAMUserException (T.TStruct _val557)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  getSyncState_result_systemException = P.maybe (P.Nothing) (\(_,_val555) -> P.Just (case _val555 of {T.TStruct _val558 -> (Errors_Types.to_EDAMSystemException (T.TStruct _val558)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_GetSyncState_result _ = P.error "not a struct"
read_GetSyncState_result :: T.Protocol p => p -> P.IO GetSyncState_result
read_GetSyncState_result iprot = to_GetSyncState_result <$> T.readVal iprot (T.T_STRUCT typemap_GetSyncState_result)
decode_GetSyncState_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetSyncState_result
decode_GetSyncState_result iprot bs = to_GetSyncState_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetSyncState_result) bs
typemap_GetSyncState_result :: T.TypeMap
typemap_GetSyncState_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_SyncState))),(1,("userException",(T.T_STRUCT Errors_Types.typemap_EDAMUserException))),(2,("systemException",(T.T_STRUCT Errors_Types.typemap_EDAMSystemException)))]
default_GetSyncState_result :: GetSyncState_result
default_GetSyncState_result = GetSyncState_result{
  getSyncState_result_success = default_SyncState,
  getSyncState_result_userException = P.Nothing,
  getSyncState_result_systemException = P.Nothing}
data GetFilteredSyncChunk_args = GetFilteredSyncChunk_args  { getFilteredSyncChunk_args_authenticationToken :: LT.Text
  , getFilteredSyncChunk_args_afterUSN :: I.Int32
  , getFilteredSyncChunk_args_maxEntries :: I.Int32
  , getFilteredSyncChunk_args_filter :: SyncChunkFilter
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetFilteredSyncChunk_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getFilteredSyncChunk_args_authenticationToken record   `H.hashWithSalt` getFilteredSyncChunk_args_afterUSN record   `H.hashWithSalt` getFilteredSyncChunk_args_maxEntries record   `H.hashWithSalt` getFilteredSyncChunk_args_filter record  
instance QC.Arbitrary GetFilteredSyncChunk_args where 
  arbitrary = M.liftM GetFilteredSyncChunk_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GetFilteredSyncChunk_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetFilteredSyncChunk_args{getFilteredSyncChunk_args_authenticationToken = getFilteredSyncChunk_args_authenticationToken obj} then P.Nothing else P.Just $ default_GetFilteredSyncChunk_args{getFilteredSyncChunk_args_authenticationToken = getFilteredSyncChunk_args_authenticationToken obj}
    , if obj == default_GetFilteredSyncChunk_args{getFilteredSyncChunk_args_afterUSN = getFilteredSyncChunk_args_afterUSN obj} then P.Nothing else P.Just $ default_GetFilteredSyncChunk_args{getFilteredSyncChunk_args_afterUSN = getFilteredSyncChunk_args_afterUSN obj}
    , if obj == default_GetFilteredSyncChunk_args{getFilteredSyncChunk_args_maxEntries = getFilteredSyncChunk_args_maxEntries obj} then P.Nothing else P.Just $ default_GetFilteredSyncChunk_args{getFilteredSyncChunk_args_maxEntries = getFilteredSyncChunk_args_maxEntries obj}
    , if obj == default_GetFilteredSyncChunk_args{getFilteredSyncChunk_args_filter = getFilteredSyncChunk_args_filter obj} then P.Nothing else P.Just $ default_GetFilteredSyncChunk_args{getFilteredSyncChunk_args_filter = getFilteredSyncChunk_args_filter obj}
    ]
from_GetFilteredSyncChunk_args :: GetFilteredSyncChunk_args -> T.ThriftVal
from_GetFilteredSyncChunk_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v561 -> P.Just (1, ("authenticationToken",T.TString $ E.encodeUtf8 _v561))) $ getFilteredSyncChunk_args_authenticationToken record
  , (\_v561 -> P.Just (2, ("afterUSN",T.TI32 _v561))) $ getFilteredSyncChunk_args_afterUSN record
  , (\_v561 -> P.Just (3, ("maxEntries",T.TI32 _v561))) $ getFilteredSyncChunk_args_maxEntries record
  , (\_v561 -> P.Just (4, ("filter",from_SyncChunkFilter _v561))) $ getFilteredSyncChunk_args_filter record
  ]
write_GetFilteredSyncChunk_args :: T.Protocol p => p -> GetFilteredSyncChunk_args -> P.IO ()
write_GetFilteredSyncChunk_args oprot record = T.writeVal oprot $ from_GetFilteredSyncChunk_args record
encode_GetFilteredSyncChunk_args :: T.StatelessProtocol p => p -> GetFilteredSyncChunk_args -> LBS.ByteString
encode_GetFilteredSyncChunk_args oprot record = T.serializeVal oprot $ from_GetFilteredSyncChunk_args record
to_GetFilteredSyncChunk_args :: T.ThriftVal -> GetFilteredSyncChunk_args
to_GetFilteredSyncChunk_args (T.TStruct fields) = GetFilteredSyncChunk_args{
  getFilteredSyncChunk_args_authenticationToken = P.maybe (getFilteredSyncChunk_args_authenticationToken default_GetFilteredSyncChunk_args) (\(_,_val563) -> (case _val563 of {T.TString _val564 -> E.decodeUtf8 _val564; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  getFilteredSyncChunk_args_afterUSN = P.maybe (getFilteredSyncChunk_args_afterUSN default_GetFilteredSyncChunk_args) (\(_,_val563) -> (case _val563 of {T.TI32 _val565 -> _val565; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  getFilteredSyncChunk_args_maxEntries = P.maybe (getFilteredSyncChunk_args_maxEntries default_GetFilteredSyncChunk_args) (\(_,_val563) -> (case _val563 of {T.TI32 _val566 -> _val566; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  getFilteredSyncChunk_args_filter = P.maybe (getFilteredSyncChunk_args_filter default_GetFilteredSyncChunk_args) (\(_,_val563) -> (case _val563 of {T.TStruct _val567 -> (to_SyncChunkFilter (T.TStruct _val567)); _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_GetFilteredSyncChunk_args _ = P.error "not a struct"
read_GetFilteredSyncChunk_args :: T.Protocol p => p -> P.IO GetFilteredSyncChunk_args
read_GetFilteredSyncChunk_args iprot = to_GetFilteredSyncChunk_args <$> T.readVal iprot (T.T_STRUCT typemap_GetFilteredSyncChunk_args)
decode_GetFilteredSyncChunk_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetFilteredSyncChunk_args
decode_GetFilteredSyncChunk_args iprot bs = to_GetFilteredSyncChunk_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetFilteredSyncChunk_args) bs
typemap_GetFilteredSyncChunk_args :: T.TypeMap
typemap_GetFilteredSyncChunk_args = Map.fromList [(1,("authenticationToken",T.T_STRING)),(2,("afterUSN",T.T_I32)),(3,("maxEntries",T.T_I32)),(4,("filter",(T.T_STRUCT typemap_SyncChunkFilter)))]
default_GetFilteredSyncChunk_args :: GetFilteredSyncChunk_args
default_GetFilteredSyncChunk_args = GetFilteredSyncChunk_args{
  getFilteredSyncChunk_args_authenticationToken = "",
  getFilteredSyncChunk_args_afterUSN = 0,
  getFilteredSyncChunk_args_maxEntries = 0,
  getFilteredSyncChunk_args_filter = default_SyncChunkFilter}
data GetFilteredSyncChunk_result = GetFilteredSyncChunk_result  { getFilteredSyncChunk_result_success :: SyncChunk
  , getFilteredSyncChunk_result_userException :: P.Maybe Errors_Types.EDAMUserException
  , getFilteredSyncChunk_result_systemException :: P.Maybe Errors_Types.EDAMSystemException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetFilteredSyncChunk_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getFilteredSyncChunk_result_success record   `H.hashWithSalt` getFilteredSyncChunk_result_userException record   `H.hashWithSalt` getFilteredSyncChunk_result_systemException record  
instance QC.Arbitrary GetFilteredSyncChunk_result where 
  arbitrary = M.liftM GetFilteredSyncChunk_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetFilteredSyncChunk_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetFilteredSyncChunk_result{getFilteredSyncChunk_result_success = getFilteredSyncChunk_result_success obj} then P.Nothing else P.Just $ default_GetFilteredSyncChunk_result{getFilteredSyncChunk_result_success = getFilteredSyncChunk_result_success obj}
    , if obj == default_GetFilteredSyncChunk_result{getFilteredSyncChunk_result_userException = getFilteredSyncChunk_result_userException obj} then P.Nothing else P.Just $ default_GetFilteredSyncChunk_result{getFilteredSyncChunk_result_userException = getFilteredSyncChunk_result_userException obj}
    , if obj == default_GetFilteredSyncChunk_result{getFilteredSyncChunk_result_systemException = getFilteredSyncChunk_result_systemException obj} then P.Nothing else P.Just $ default_GetFilteredSyncChunk_result{getFilteredSyncChunk_result_systemException = getFilteredSyncChunk_result_systemException obj}
    ]
from_GetFilteredSyncChunk_result :: GetFilteredSyncChunk_result -> T.ThriftVal
from_GetFilteredSyncChunk_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v570 -> (1, ("userException",Errors_Types.from_EDAMUserException _v570))) <$> getFilteredSyncChunk_result_userException record, (\_v570 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v570))) <$> getFilteredSyncChunk_result_systemException record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v570 -> P.Just (0, ("success",from_SyncChunk _v570))) $ getFilteredSyncChunk_result_success record
    , (\_v570 -> (1, ("userException",Errors_Types.from_EDAMUserException _v570))) <$> getFilteredSyncChunk_result_userException record
    , (\_v570 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v570))) <$> getFilteredSyncChunk_result_systemException record
    ]
    )
write_GetFilteredSyncChunk_result :: T.Protocol p => p -> GetFilteredSyncChunk_result -> P.IO ()
write_GetFilteredSyncChunk_result oprot record = T.writeVal oprot $ from_GetFilteredSyncChunk_result record
encode_GetFilteredSyncChunk_result :: T.StatelessProtocol p => p -> GetFilteredSyncChunk_result -> LBS.ByteString
encode_GetFilteredSyncChunk_result oprot record = T.serializeVal oprot $ from_GetFilteredSyncChunk_result record
to_GetFilteredSyncChunk_result :: T.ThriftVal -> GetFilteredSyncChunk_result
to_GetFilteredSyncChunk_result (T.TStruct fields) = GetFilteredSyncChunk_result{
  getFilteredSyncChunk_result_success = P.maybe (getFilteredSyncChunk_result_success default_GetFilteredSyncChunk_result) (\(_,_val572) -> (case _val572 of {T.TStruct _val573 -> (to_SyncChunk (T.TStruct _val573)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getFilteredSyncChunk_result_userException = P.maybe (P.Nothing) (\(_,_val572) -> P.Just (case _val572 of {T.TStruct _val574 -> (Errors_Types.to_EDAMUserException (T.TStruct _val574)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  getFilteredSyncChunk_result_systemException = P.maybe (P.Nothing) (\(_,_val572) -> P.Just (case _val572 of {T.TStruct _val575 -> (Errors_Types.to_EDAMSystemException (T.TStruct _val575)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_GetFilteredSyncChunk_result _ = P.error "not a struct"
read_GetFilteredSyncChunk_result :: T.Protocol p => p -> P.IO GetFilteredSyncChunk_result
read_GetFilteredSyncChunk_result iprot = to_GetFilteredSyncChunk_result <$> T.readVal iprot (T.T_STRUCT typemap_GetFilteredSyncChunk_result)
decode_GetFilteredSyncChunk_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetFilteredSyncChunk_result
decode_GetFilteredSyncChunk_result iprot bs = to_GetFilteredSyncChunk_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetFilteredSyncChunk_result) bs
typemap_GetFilteredSyncChunk_result :: T.TypeMap
typemap_GetFilteredSyncChunk_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_SyncChunk))),(1,("userException",(T.T_STRUCT Errors_Types.typemap_EDAMUserException))),(2,("systemException",(T.T_STRUCT Errors_Types.typemap_EDAMSystemException)))]
default_GetFilteredSyncChunk_result :: GetFilteredSyncChunk_result
default_GetFilteredSyncChunk_result = GetFilteredSyncChunk_result{
  getFilteredSyncChunk_result_success = default_SyncChunk,
  getFilteredSyncChunk_result_userException = P.Nothing,
  getFilteredSyncChunk_result_systemException = P.Nothing}
data GetLinkedNotebookSyncState_args = GetLinkedNotebookSyncState_args  { getLinkedNotebookSyncState_args_authenticationToken :: LT.Text
  , getLinkedNotebookSyncState_args_linkedNotebook :: Types_Types.LinkedNotebook
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetLinkedNotebookSyncState_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getLinkedNotebookSyncState_args_authenticationToken record   `H.hashWithSalt` getLinkedNotebookSyncState_args_linkedNotebook record  
instance QC.Arbitrary GetLinkedNotebookSyncState_args where 
  arbitrary = M.liftM GetLinkedNotebookSyncState_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GetLinkedNotebookSyncState_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetLinkedNotebookSyncState_args{getLinkedNotebookSyncState_args_authenticationToken = getLinkedNotebookSyncState_args_authenticationToken obj} then P.Nothing else P.Just $ default_GetLinkedNotebookSyncState_args{getLinkedNotebookSyncState_args_authenticationToken = getLinkedNotebookSyncState_args_authenticationToken obj}
    , if obj == default_GetLinkedNotebookSyncState_args{getLinkedNotebookSyncState_args_linkedNotebook = getLinkedNotebookSyncState_args_linkedNotebook obj} then P.Nothing else P.Just $ default_GetLinkedNotebookSyncState_args{getLinkedNotebookSyncState_args_linkedNotebook = getLinkedNotebookSyncState_args_linkedNotebook obj}
    ]
from_GetLinkedNotebookSyncState_args :: GetLinkedNotebookSyncState_args -> T.ThriftVal
from_GetLinkedNotebookSyncState_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v578 -> P.Just (1, ("authenticationToken",T.TString $ E.encodeUtf8 _v578))) $ getLinkedNotebookSyncState_args_authenticationToken record
  , (\_v578 -> P.Just (2, ("linkedNotebook",Types_Types.from_LinkedNotebook _v578))) $ getLinkedNotebookSyncState_args_linkedNotebook record
  ]
write_GetLinkedNotebookSyncState_args :: T.Protocol p => p -> GetLinkedNotebookSyncState_args -> P.IO ()
write_GetLinkedNotebookSyncState_args oprot record = T.writeVal oprot $ from_GetLinkedNotebookSyncState_args record
encode_GetLinkedNotebookSyncState_args :: T.StatelessProtocol p => p -> GetLinkedNotebookSyncState_args -> LBS.ByteString
encode_GetLinkedNotebookSyncState_args oprot record = T.serializeVal oprot $ from_GetLinkedNotebookSyncState_args record
to_GetLinkedNotebookSyncState_args :: T.ThriftVal -> GetLinkedNotebookSyncState_args
to_GetLinkedNotebookSyncState_args (T.TStruct fields) = GetLinkedNotebookSyncState_args{
  getLinkedNotebookSyncState_args_authenticationToken = P.maybe (getLinkedNotebookSyncState_args_authenticationToken default_GetLinkedNotebookSyncState_args) (\(_,_val580) -> (case _val580 of {T.TString _val581 -> E.decodeUtf8 _val581; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  getLinkedNotebookSyncState_args_linkedNotebook = P.maybe (getLinkedNotebookSyncState_args_linkedNotebook default_GetLinkedNotebookSyncState_args) (\(_,_val580) -> (case _val580 of {T.TStruct _val582 -> (Types_Types.to_LinkedNotebook (T.TStruct _val582)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_GetLinkedNotebookSyncState_args _ = P.error "not a struct"
read_GetLinkedNotebookSyncState_args :: T.Protocol p => p -> P.IO GetLinkedNotebookSyncState_args
read_GetLinkedNotebookSyncState_args iprot = to_GetLinkedNotebookSyncState_args <$> T.readVal iprot (T.T_STRUCT typemap_GetLinkedNotebookSyncState_args)
decode_GetLinkedNotebookSyncState_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetLinkedNotebookSyncState_args
decode_GetLinkedNotebookSyncState_args iprot bs = to_GetLinkedNotebookSyncState_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetLinkedNotebookSyncState_args) bs
typemap_GetLinkedNotebookSyncState_args :: T.TypeMap
typemap_GetLinkedNotebookSyncState_args = Map.fromList [(1,("authenticationToken",T.T_STRING)),(2,("linkedNotebook",(T.T_STRUCT Types_Types.typemap_LinkedNotebook)))]
default_GetLinkedNotebookSyncState_args :: GetLinkedNotebookSyncState_args
default_GetLinkedNotebookSyncState_args = GetLinkedNotebookSyncState_args{
  getLinkedNotebookSyncState_args_authenticationToken = "",
  getLinkedNotebookSyncState_args_linkedNotebook = Types_Types.default_LinkedNotebook}
data GetLinkedNotebookSyncState_result = GetLinkedNotebookSyncState_result  { getLinkedNotebookSyncState_result_success :: SyncState
  , getLinkedNotebookSyncState_result_userException :: P.Maybe Errors_Types.EDAMUserException
  , getLinkedNotebookSyncState_result_systemException :: P.Maybe Errors_Types.EDAMSystemException
  , getLinkedNotebookSyncState_result_notFoundException :: P.Maybe Errors_Types.EDAMNotFoundException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetLinkedNotebookSyncState_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getLinkedNotebookSyncState_result_success record   `H.hashWithSalt` getLinkedNotebookSyncState_result_userException record   `H.hashWithSalt` getLinkedNotebookSyncState_result_systemException record   `H.hashWithSalt` getLinkedNotebookSyncState_result_notFoundException record  
instance QC.Arbitrary GetLinkedNotebookSyncState_result where 
  arbitrary = M.liftM GetLinkedNotebookSyncState_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetLinkedNotebookSyncState_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetLinkedNotebookSyncState_result{getLinkedNotebookSyncState_result_success = getLinkedNotebookSyncState_result_success obj} then P.Nothing else P.Just $ default_GetLinkedNotebookSyncState_result{getLinkedNotebookSyncState_result_success = getLinkedNotebookSyncState_result_success obj}
    , if obj == default_GetLinkedNotebookSyncState_result{getLinkedNotebookSyncState_result_userException = getLinkedNotebookSyncState_result_userException obj} then P.Nothing else P.Just $ default_GetLinkedNotebookSyncState_result{getLinkedNotebookSyncState_result_userException = getLinkedNotebookSyncState_result_userException obj}
    , if obj == default_GetLinkedNotebookSyncState_result{getLinkedNotebookSyncState_result_systemException = getLinkedNotebookSyncState_result_systemException obj} then P.Nothing else P.Just $ default_GetLinkedNotebookSyncState_result{getLinkedNotebookSyncState_result_systemException = getLinkedNotebookSyncState_result_systemException obj}
    , if obj == default_GetLinkedNotebookSyncState_result{getLinkedNotebookSyncState_result_notFoundException = getLinkedNotebookSyncState_result_notFoundException obj} then P.Nothing else P.Just $ default_GetLinkedNotebookSyncState_result{getLinkedNotebookSyncState_result_notFoundException = getLinkedNotebookSyncState_result_notFoundException obj}
    ]
from_GetLinkedNotebookSyncState_result :: GetLinkedNotebookSyncState_result -> T.ThriftVal
from_GetLinkedNotebookSyncState_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v585 -> (1, ("userException",Errors_Types.from_EDAMUserException _v585))) <$> getLinkedNotebookSyncState_result_userException record, (\_v585 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v585))) <$> getLinkedNotebookSyncState_result_systemException record, (\_v585 -> (3, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v585))) <$> getLinkedNotebookSyncState_result_notFoundException record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v585 -> P.Just (0, ("success",from_SyncState _v585))) $ getLinkedNotebookSyncState_result_success record
    , (\_v585 -> (1, ("userException",Errors_Types.from_EDAMUserException _v585))) <$> getLinkedNotebookSyncState_result_userException record
    , (\_v585 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v585))) <$> getLinkedNotebookSyncState_result_systemException record
    , (\_v585 -> (3, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v585))) <$> getLinkedNotebookSyncState_result_notFoundException record
    ]
    )
write_GetLinkedNotebookSyncState_result :: T.Protocol p => p -> GetLinkedNotebookSyncState_result -> P.IO ()
write_GetLinkedNotebookSyncState_result oprot record = T.writeVal oprot $ from_GetLinkedNotebookSyncState_result record
encode_GetLinkedNotebookSyncState_result :: T.StatelessProtocol p => p -> GetLinkedNotebookSyncState_result -> LBS.ByteString
encode_GetLinkedNotebookSyncState_result oprot record = T.serializeVal oprot $ from_GetLinkedNotebookSyncState_result record
to_GetLinkedNotebookSyncState_result :: T.ThriftVal -> GetLinkedNotebookSyncState_result
to_GetLinkedNotebookSyncState_result (T.TStruct fields) = GetLinkedNotebookSyncState_result{
  getLinkedNotebookSyncState_result_success = P.maybe (getLinkedNotebookSyncState_result_success default_GetLinkedNotebookSyncState_result) (\(_,_val587) -> (case _val587 of {T.TStruct _val588 -> (to_SyncState (T.TStruct _val588)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getLinkedNotebookSyncState_result_userException = P.maybe (P.Nothing) (\(_,_val587) -> P.Just (case _val587 of {T.TStruct _val589 -> (Errors_Types.to_EDAMUserException (T.TStruct _val589)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  getLinkedNotebookSyncState_result_systemException = P.maybe (P.Nothing) (\(_,_val587) -> P.Just (case _val587 of {T.TStruct _val590 -> (Errors_Types.to_EDAMSystemException (T.TStruct _val590)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  getLinkedNotebookSyncState_result_notFoundException = P.maybe (P.Nothing) (\(_,_val587) -> P.Just (case _val587 of {T.TStruct _val591 -> (Errors_Types.to_EDAMNotFoundException (T.TStruct _val591)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_GetLinkedNotebookSyncState_result _ = P.error "not a struct"
read_GetLinkedNotebookSyncState_result :: T.Protocol p => p -> P.IO GetLinkedNotebookSyncState_result
read_GetLinkedNotebookSyncState_result iprot = to_GetLinkedNotebookSyncState_result <$> T.readVal iprot (T.T_STRUCT typemap_GetLinkedNotebookSyncState_result)
decode_GetLinkedNotebookSyncState_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetLinkedNotebookSyncState_result
decode_GetLinkedNotebookSyncState_result iprot bs = to_GetLinkedNotebookSyncState_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetLinkedNotebookSyncState_result) bs
typemap_GetLinkedNotebookSyncState_result :: T.TypeMap
typemap_GetLinkedNotebookSyncState_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_SyncState))),(1,("userException",(T.T_STRUCT Errors_Types.typemap_EDAMUserException))),(2,("systemException",(T.T_STRUCT Errors_Types.typemap_EDAMSystemException))),(3,("notFoundException",(T.T_STRUCT Errors_Types.typemap_EDAMNotFoundException)))]
default_GetLinkedNotebookSyncState_result :: GetLinkedNotebookSyncState_result
default_GetLinkedNotebookSyncState_result = GetLinkedNotebookSyncState_result{
  getLinkedNotebookSyncState_result_success = default_SyncState,
  getLinkedNotebookSyncState_result_userException = P.Nothing,
  getLinkedNotebookSyncState_result_systemException = P.Nothing,
  getLinkedNotebookSyncState_result_notFoundException = P.Nothing}
data GetLinkedNotebookSyncChunk_args = GetLinkedNotebookSyncChunk_args  { getLinkedNotebookSyncChunk_args_authenticationToken :: LT.Text
  , getLinkedNotebookSyncChunk_args_linkedNotebook :: Types_Types.LinkedNotebook
  , getLinkedNotebookSyncChunk_args_afterUSN :: I.Int32
  , getLinkedNotebookSyncChunk_args_maxEntries :: I.Int32
  , getLinkedNotebookSyncChunk_args_fullSyncOnly :: P.Bool
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetLinkedNotebookSyncChunk_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getLinkedNotebookSyncChunk_args_authenticationToken record   `H.hashWithSalt` getLinkedNotebookSyncChunk_args_linkedNotebook record   `H.hashWithSalt` getLinkedNotebookSyncChunk_args_afterUSN record   `H.hashWithSalt` getLinkedNotebookSyncChunk_args_maxEntries record   `H.hashWithSalt` getLinkedNotebookSyncChunk_args_fullSyncOnly record  
instance QC.Arbitrary GetLinkedNotebookSyncChunk_args where 
  arbitrary = M.liftM GetLinkedNotebookSyncChunk_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GetLinkedNotebookSyncChunk_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetLinkedNotebookSyncChunk_args{getLinkedNotebookSyncChunk_args_authenticationToken = getLinkedNotebookSyncChunk_args_authenticationToken obj} then P.Nothing else P.Just $ default_GetLinkedNotebookSyncChunk_args{getLinkedNotebookSyncChunk_args_authenticationToken = getLinkedNotebookSyncChunk_args_authenticationToken obj}
    , if obj == default_GetLinkedNotebookSyncChunk_args{getLinkedNotebookSyncChunk_args_linkedNotebook = getLinkedNotebookSyncChunk_args_linkedNotebook obj} then P.Nothing else P.Just $ default_GetLinkedNotebookSyncChunk_args{getLinkedNotebookSyncChunk_args_linkedNotebook = getLinkedNotebookSyncChunk_args_linkedNotebook obj}
    , if obj == default_GetLinkedNotebookSyncChunk_args{getLinkedNotebookSyncChunk_args_afterUSN = getLinkedNotebookSyncChunk_args_afterUSN obj} then P.Nothing else P.Just $ default_GetLinkedNotebookSyncChunk_args{getLinkedNotebookSyncChunk_args_afterUSN = getLinkedNotebookSyncChunk_args_afterUSN obj}
    , if obj == default_GetLinkedNotebookSyncChunk_args{getLinkedNotebookSyncChunk_args_maxEntries = getLinkedNotebookSyncChunk_args_maxEntries obj} then P.Nothing else P.Just $ default_GetLinkedNotebookSyncChunk_args{getLinkedNotebookSyncChunk_args_maxEntries = getLinkedNotebookSyncChunk_args_maxEntries obj}
    , if obj == default_GetLinkedNotebookSyncChunk_args{getLinkedNotebookSyncChunk_args_fullSyncOnly = getLinkedNotebookSyncChunk_args_fullSyncOnly obj} then P.Nothing else P.Just $ default_GetLinkedNotebookSyncChunk_args{getLinkedNotebookSyncChunk_args_fullSyncOnly = getLinkedNotebookSyncChunk_args_fullSyncOnly obj}
    ]
from_GetLinkedNotebookSyncChunk_args :: GetLinkedNotebookSyncChunk_args -> T.ThriftVal
from_GetLinkedNotebookSyncChunk_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v594 -> P.Just (1, ("authenticationToken",T.TString $ E.encodeUtf8 _v594))) $ getLinkedNotebookSyncChunk_args_authenticationToken record
  , (\_v594 -> P.Just (2, ("linkedNotebook",Types_Types.from_LinkedNotebook _v594))) $ getLinkedNotebookSyncChunk_args_linkedNotebook record
  , (\_v594 -> P.Just (3, ("afterUSN",T.TI32 _v594))) $ getLinkedNotebookSyncChunk_args_afterUSN record
  , (\_v594 -> P.Just (4, ("maxEntries",T.TI32 _v594))) $ getLinkedNotebookSyncChunk_args_maxEntries record
  , (\_v594 -> P.Just (5, ("fullSyncOnly",T.TBool _v594))) $ getLinkedNotebookSyncChunk_args_fullSyncOnly record
  ]
write_GetLinkedNotebookSyncChunk_args :: T.Protocol p => p -> GetLinkedNotebookSyncChunk_args -> P.IO ()
write_GetLinkedNotebookSyncChunk_args oprot record = T.writeVal oprot $ from_GetLinkedNotebookSyncChunk_args record
encode_GetLinkedNotebookSyncChunk_args :: T.StatelessProtocol p => p -> GetLinkedNotebookSyncChunk_args -> LBS.ByteString
encode_GetLinkedNotebookSyncChunk_args oprot record = T.serializeVal oprot $ from_GetLinkedNotebookSyncChunk_args record
to_GetLinkedNotebookSyncChunk_args :: T.ThriftVal -> GetLinkedNotebookSyncChunk_args
to_GetLinkedNotebookSyncChunk_args (T.TStruct fields) = GetLinkedNotebookSyncChunk_args{
  getLinkedNotebookSyncChunk_args_authenticationToken = P.maybe (getLinkedNotebookSyncChunk_args_authenticationToken default_GetLinkedNotebookSyncChunk_args) (\(_,_val596) -> (case _val596 of {T.TString _val597 -> E.decodeUtf8 _val597; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  getLinkedNotebookSyncChunk_args_linkedNotebook = P.maybe (getLinkedNotebookSyncChunk_args_linkedNotebook default_GetLinkedNotebookSyncChunk_args) (\(_,_val596) -> (case _val596 of {T.TStruct _val598 -> (Types_Types.to_LinkedNotebook (T.TStruct _val598)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  getLinkedNotebookSyncChunk_args_afterUSN = P.maybe (getLinkedNotebookSyncChunk_args_afterUSN default_GetLinkedNotebookSyncChunk_args) (\(_,_val596) -> (case _val596 of {T.TI32 _val599 -> _val599; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  getLinkedNotebookSyncChunk_args_maxEntries = P.maybe (getLinkedNotebookSyncChunk_args_maxEntries default_GetLinkedNotebookSyncChunk_args) (\(_,_val596) -> (case _val596 of {T.TI32 _val600 -> _val600; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  getLinkedNotebookSyncChunk_args_fullSyncOnly = P.maybe (getLinkedNotebookSyncChunk_args_fullSyncOnly default_GetLinkedNotebookSyncChunk_args) (\(_,_val596) -> (case _val596 of {T.TBool _val601 -> _val601; _ -> P.error "wrong type"})) (Map.lookup (5) fields)
  }
to_GetLinkedNotebookSyncChunk_args _ = P.error "not a struct"
read_GetLinkedNotebookSyncChunk_args :: T.Protocol p => p -> P.IO GetLinkedNotebookSyncChunk_args
read_GetLinkedNotebookSyncChunk_args iprot = to_GetLinkedNotebookSyncChunk_args <$> T.readVal iprot (T.T_STRUCT typemap_GetLinkedNotebookSyncChunk_args)
decode_GetLinkedNotebookSyncChunk_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetLinkedNotebookSyncChunk_args
decode_GetLinkedNotebookSyncChunk_args iprot bs = to_GetLinkedNotebookSyncChunk_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetLinkedNotebookSyncChunk_args) bs
typemap_GetLinkedNotebookSyncChunk_args :: T.TypeMap
typemap_GetLinkedNotebookSyncChunk_args = Map.fromList [(1,("authenticationToken",T.T_STRING)),(2,("linkedNotebook",(T.T_STRUCT Types_Types.typemap_LinkedNotebook))),(3,("afterUSN",T.T_I32)),(4,("maxEntries",T.T_I32)),(5,("fullSyncOnly",T.T_BOOL))]
default_GetLinkedNotebookSyncChunk_args :: GetLinkedNotebookSyncChunk_args
default_GetLinkedNotebookSyncChunk_args = GetLinkedNotebookSyncChunk_args{
  getLinkedNotebookSyncChunk_args_authenticationToken = "",
  getLinkedNotebookSyncChunk_args_linkedNotebook = Types_Types.default_LinkedNotebook,
  getLinkedNotebookSyncChunk_args_afterUSN = 0,
  getLinkedNotebookSyncChunk_args_maxEntries = 0,
  getLinkedNotebookSyncChunk_args_fullSyncOnly = P.False}
data GetLinkedNotebookSyncChunk_result = GetLinkedNotebookSyncChunk_result  { getLinkedNotebookSyncChunk_result_success :: SyncChunk
  , getLinkedNotebookSyncChunk_result_userException :: P.Maybe Errors_Types.EDAMUserException
  , getLinkedNotebookSyncChunk_result_systemException :: P.Maybe Errors_Types.EDAMSystemException
  , getLinkedNotebookSyncChunk_result_notFoundException :: P.Maybe Errors_Types.EDAMNotFoundException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetLinkedNotebookSyncChunk_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getLinkedNotebookSyncChunk_result_success record   `H.hashWithSalt` getLinkedNotebookSyncChunk_result_userException record   `H.hashWithSalt` getLinkedNotebookSyncChunk_result_systemException record   `H.hashWithSalt` getLinkedNotebookSyncChunk_result_notFoundException record  
instance QC.Arbitrary GetLinkedNotebookSyncChunk_result where 
  arbitrary = M.liftM GetLinkedNotebookSyncChunk_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetLinkedNotebookSyncChunk_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetLinkedNotebookSyncChunk_result{getLinkedNotebookSyncChunk_result_success = getLinkedNotebookSyncChunk_result_success obj} then P.Nothing else P.Just $ default_GetLinkedNotebookSyncChunk_result{getLinkedNotebookSyncChunk_result_success = getLinkedNotebookSyncChunk_result_success obj}
    , if obj == default_GetLinkedNotebookSyncChunk_result{getLinkedNotebookSyncChunk_result_userException = getLinkedNotebookSyncChunk_result_userException obj} then P.Nothing else P.Just $ default_GetLinkedNotebookSyncChunk_result{getLinkedNotebookSyncChunk_result_userException = getLinkedNotebookSyncChunk_result_userException obj}
    , if obj == default_GetLinkedNotebookSyncChunk_result{getLinkedNotebookSyncChunk_result_systemException = getLinkedNotebookSyncChunk_result_systemException obj} then P.Nothing else P.Just $ default_GetLinkedNotebookSyncChunk_result{getLinkedNotebookSyncChunk_result_systemException = getLinkedNotebookSyncChunk_result_systemException obj}
    , if obj == default_GetLinkedNotebookSyncChunk_result{getLinkedNotebookSyncChunk_result_notFoundException = getLinkedNotebookSyncChunk_result_notFoundException obj} then P.Nothing else P.Just $ default_GetLinkedNotebookSyncChunk_result{getLinkedNotebookSyncChunk_result_notFoundException = getLinkedNotebookSyncChunk_result_notFoundException obj}
    ]
from_GetLinkedNotebookSyncChunk_result :: GetLinkedNotebookSyncChunk_result -> T.ThriftVal
from_GetLinkedNotebookSyncChunk_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v604 -> (1, ("userException",Errors_Types.from_EDAMUserException _v604))) <$> getLinkedNotebookSyncChunk_result_userException record, (\_v604 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v604))) <$> getLinkedNotebookSyncChunk_result_systemException record, (\_v604 -> (3, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v604))) <$> getLinkedNotebookSyncChunk_result_notFoundException record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v604 -> P.Just (0, ("success",from_SyncChunk _v604))) $ getLinkedNotebookSyncChunk_result_success record
    , (\_v604 -> (1, ("userException",Errors_Types.from_EDAMUserException _v604))) <$> getLinkedNotebookSyncChunk_result_userException record
    , (\_v604 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v604))) <$> getLinkedNotebookSyncChunk_result_systemException record
    , (\_v604 -> (3, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v604))) <$> getLinkedNotebookSyncChunk_result_notFoundException record
    ]
    )
write_GetLinkedNotebookSyncChunk_result :: T.Protocol p => p -> GetLinkedNotebookSyncChunk_result -> P.IO ()
write_GetLinkedNotebookSyncChunk_result oprot record = T.writeVal oprot $ from_GetLinkedNotebookSyncChunk_result record
encode_GetLinkedNotebookSyncChunk_result :: T.StatelessProtocol p => p -> GetLinkedNotebookSyncChunk_result -> LBS.ByteString
encode_GetLinkedNotebookSyncChunk_result oprot record = T.serializeVal oprot $ from_GetLinkedNotebookSyncChunk_result record
to_GetLinkedNotebookSyncChunk_result :: T.ThriftVal -> GetLinkedNotebookSyncChunk_result
to_GetLinkedNotebookSyncChunk_result (T.TStruct fields) = GetLinkedNotebookSyncChunk_result{
  getLinkedNotebookSyncChunk_result_success = P.maybe (getLinkedNotebookSyncChunk_result_success default_GetLinkedNotebookSyncChunk_result) (\(_,_val606) -> (case _val606 of {T.TStruct _val607 -> (to_SyncChunk (T.TStruct _val607)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getLinkedNotebookSyncChunk_result_userException = P.maybe (P.Nothing) (\(_,_val606) -> P.Just (case _val606 of {T.TStruct _val608 -> (Errors_Types.to_EDAMUserException (T.TStruct _val608)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  getLinkedNotebookSyncChunk_result_systemException = P.maybe (P.Nothing) (\(_,_val606) -> P.Just (case _val606 of {T.TStruct _val609 -> (Errors_Types.to_EDAMSystemException (T.TStruct _val609)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  getLinkedNotebookSyncChunk_result_notFoundException = P.maybe (P.Nothing) (\(_,_val606) -> P.Just (case _val606 of {T.TStruct _val610 -> (Errors_Types.to_EDAMNotFoundException (T.TStruct _val610)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_GetLinkedNotebookSyncChunk_result _ = P.error "not a struct"
read_GetLinkedNotebookSyncChunk_result :: T.Protocol p => p -> P.IO GetLinkedNotebookSyncChunk_result
read_GetLinkedNotebookSyncChunk_result iprot = to_GetLinkedNotebookSyncChunk_result <$> T.readVal iprot (T.T_STRUCT typemap_GetLinkedNotebookSyncChunk_result)
decode_GetLinkedNotebookSyncChunk_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetLinkedNotebookSyncChunk_result
decode_GetLinkedNotebookSyncChunk_result iprot bs = to_GetLinkedNotebookSyncChunk_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetLinkedNotebookSyncChunk_result) bs
typemap_GetLinkedNotebookSyncChunk_result :: T.TypeMap
typemap_GetLinkedNotebookSyncChunk_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_SyncChunk))),(1,("userException",(T.T_STRUCT Errors_Types.typemap_EDAMUserException))),(2,("systemException",(T.T_STRUCT Errors_Types.typemap_EDAMSystemException))),(3,("notFoundException",(T.T_STRUCT Errors_Types.typemap_EDAMNotFoundException)))]
default_GetLinkedNotebookSyncChunk_result :: GetLinkedNotebookSyncChunk_result
default_GetLinkedNotebookSyncChunk_result = GetLinkedNotebookSyncChunk_result{
  getLinkedNotebookSyncChunk_result_success = default_SyncChunk,
  getLinkedNotebookSyncChunk_result_userException = P.Nothing,
  getLinkedNotebookSyncChunk_result_systemException = P.Nothing,
  getLinkedNotebookSyncChunk_result_notFoundException = P.Nothing}
data ListNotebooks_args = ListNotebooks_args  { listNotebooks_args_authenticationToken :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ListNotebooks_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` listNotebooks_args_authenticationToken record  
instance QC.Arbitrary ListNotebooks_args where 
  arbitrary = M.liftM ListNotebooks_args (QC.arbitrary)
  shrink obj | obj == default_ListNotebooks_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ListNotebooks_args{listNotebooks_args_authenticationToken = listNotebooks_args_authenticationToken obj} then P.Nothing else P.Just $ default_ListNotebooks_args{listNotebooks_args_authenticationToken = listNotebooks_args_authenticationToken obj}
    ]
from_ListNotebooks_args :: ListNotebooks_args -> T.ThriftVal
from_ListNotebooks_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v613 -> P.Just (1, ("authenticationToken",T.TString $ E.encodeUtf8 _v613))) $ listNotebooks_args_authenticationToken record
  ]
write_ListNotebooks_args :: T.Protocol p => p -> ListNotebooks_args -> P.IO ()
write_ListNotebooks_args oprot record = T.writeVal oprot $ from_ListNotebooks_args record
encode_ListNotebooks_args :: T.StatelessProtocol p => p -> ListNotebooks_args -> LBS.ByteString
encode_ListNotebooks_args oprot record = T.serializeVal oprot $ from_ListNotebooks_args record
to_ListNotebooks_args :: T.ThriftVal -> ListNotebooks_args
to_ListNotebooks_args (T.TStruct fields) = ListNotebooks_args{
  listNotebooks_args_authenticationToken = P.maybe (listNotebooks_args_authenticationToken default_ListNotebooks_args) (\(_,_val615) -> (case _val615 of {T.TString _val616 -> E.decodeUtf8 _val616; _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_ListNotebooks_args _ = P.error "not a struct"
read_ListNotebooks_args :: T.Protocol p => p -> P.IO ListNotebooks_args
read_ListNotebooks_args iprot = to_ListNotebooks_args <$> T.readVal iprot (T.T_STRUCT typemap_ListNotebooks_args)
decode_ListNotebooks_args :: T.StatelessProtocol p => p -> LBS.ByteString -> ListNotebooks_args
decode_ListNotebooks_args iprot bs = to_ListNotebooks_args $ T.deserializeVal iprot (T.T_STRUCT typemap_ListNotebooks_args) bs
typemap_ListNotebooks_args :: T.TypeMap
typemap_ListNotebooks_args = Map.fromList [(1,("authenticationToken",T.T_STRING))]
default_ListNotebooks_args :: ListNotebooks_args
default_ListNotebooks_args = ListNotebooks_args{
  listNotebooks_args_authenticationToken = ""}
data ListNotebooks_result = ListNotebooks_result  { listNotebooks_result_success :: (Vector.Vector Types_Types.Notebook)
  , listNotebooks_result_userException :: P.Maybe Errors_Types.EDAMUserException
  , listNotebooks_result_systemException :: P.Maybe Errors_Types.EDAMSystemException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ListNotebooks_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` listNotebooks_result_success record   `H.hashWithSalt` listNotebooks_result_userException record   `H.hashWithSalt` listNotebooks_result_systemException record  
instance QC.Arbitrary ListNotebooks_result where 
  arbitrary = M.liftM ListNotebooks_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_ListNotebooks_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ListNotebooks_result{listNotebooks_result_success = listNotebooks_result_success obj} then P.Nothing else P.Just $ default_ListNotebooks_result{listNotebooks_result_success = listNotebooks_result_success obj}
    , if obj == default_ListNotebooks_result{listNotebooks_result_userException = listNotebooks_result_userException obj} then P.Nothing else P.Just $ default_ListNotebooks_result{listNotebooks_result_userException = listNotebooks_result_userException obj}
    , if obj == default_ListNotebooks_result{listNotebooks_result_systemException = listNotebooks_result_systemException obj} then P.Nothing else P.Just $ default_ListNotebooks_result{listNotebooks_result_systemException = listNotebooks_result_systemException obj}
    ]
from_ListNotebooks_result :: ListNotebooks_result -> T.ThriftVal
from_ListNotebooks_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v619 -> (1, ("userException",Errors_Types.from_EDAMUserException _v619))) <$> listNotebooks_result_userException record, (\_v619 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v619))) <$> listNotebooks_result_systemException record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v619 -> P.Just (0, ("success",T.TList (T.T_STRUCT Types_Types.typemap_Notebook) $ P.map (\_v621 -> Types_Types.from_Notebook _v621) $ Vector.toList _v619))) $ listNotebooks_result_success record
    , (\_v619 -> (1, ("userException",Errors_Types.from_EDAMUserException _v619))) <$> listNotebooks_result_userException record
    , (\_v619 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v619))) <$> listNotebooks_result_systemException record
    ]
    )
write_ListNotebooks_result :: T.Protocol p => p -> ListNotebooks_result -> P.IO ()
write_ListNotebooks_result oprot record = T.writeVal oprot $ from_ListNotebooks_result record
encode_ListNotebooks_result :: T.StatelessProtocol p => p -> ListNotebooks_result -> LBS.ByteString
encode_ListNotebooks_result oprot record = T.serializeVal oprot $ from_ListNotebooks_result record
to_ListNotebooks_result :: T.ThriftVal -> ListNotebooks_result
to_ListNotebooks_result (T.TStruct fields) = ListNotebooks_result{
  listNotebooks_result_success = P.maybe (listNotebooks_result_success default_ListNotebooks_result) (\(_,_val623) -> (case _val623 of {T.TList _ _val624 -> (Vector.fromList $ P.map (\_v625 -> (case _v625 of {T.TStruct _val626 -> (Types_Types.to_Notebook (T.TStruct _val626)); _ -> P.error "wrong type"})) _val624); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  listNotebooks_result_userException = P.maybe (P.Nothing) (\(_,_val623) -> P.Just (case _val623 of {T.TStruct _val627 -> (Errors_Types.to_EDAMUserException (T.TStruct _val627)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  listNotebooks_result_systemException = P.maybe (P.Nothing) (\(_,_val623) -> P.Just (case _val623 of {T.TStruct _val628 -> (Errors_Types.to_EDAMSystemException (T.TStruct _val628)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_ListNotebooks_result _ = P.error "not a struct"
read_ListNotebooks_result :: T.Protocol p => p -> P.IO ListNotebooks_result
read_ListNotebooks_result iprot = to_ListNotebooks_result <$> T.readVal iprot (T.T_STRUCT typemap_ListNotebooks_result)
decode_ListNotebooks_result :: T.StatelessProtocol p => p -> LBS.ByteString -> ListNotebooks_result
decode_ListNotebooks_result iprot bs = to_ListNotebooks_result $ T.deserializeVal iprot (T.T_STRUCT typemap_ListNotebooks_result) bs
typemap_ListNotebooks_result :: T.TypeMap
typemap_ListNotebooks_result = Map.fromList [(0,("success",(T.T_LIST (T.T_STRUCT Types_Types.typemap_Notebook)))),(1,("userException",(T.T_STRUCT Errors_Types.typemap_EDAMUserException))),(2,("systemException",(T.T_STRUCT Errors_Types.typemap_EDAMSystemException)))]
default_ListNotebooks_result :: ListNotebooks_result
default_ListNotebooks_result = ListNotebooks_result{
  listNotebooks_result_success = Vector.empty,
  listNotebooks_result_userException = P.Nothing,
  listNotebooks_result_systemException = P.Nothing}
data ListAccessibleBusinessNotebooks_args = ListAccessibleBusinessNotebooks_args  { listAccessibleBusinessNotebooks_args_authenticationToken :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ListAccessibleBusinessNotebooks_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` listAccessibleBusinessNotebooks_args_authenticationToken record  
instance QC.Arbitrary ListAccessibleBusinessNotebooks_args where 
  arbitrary = M.liftM ListAccessibleBusinessNotebooks_args (QC.arbitrary)
  shrink obj | obj == default_ListAccessibleBusinessNotebooks_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ListAccessibleBusinessNotebooks_args{listAccessibleBusinessNotebooks_args_authenticationToken = listAccessibleBusinessNotebooks_args_authenticationToken obj} then P.Nothing else P.Just $ default_ListAccessibleBusinessNotebooks_args{listAccessibleBusinessNotebooks_args_authenticationToken = listAccessibleBusinessNotebooks_args_authenticationToken obj}
    ]
from_ListAccessibleBusinessNotebooks_args :: ListAccessibleBusinessNotebooks_args -> T.ThriftVal
from_ListAccessibleBusinessNotebooks_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v631 -> P.Just (1, ("authenticationToken",T.TString $ E.encodeUtf8 _v631))) $ listAccessibleBusinessNotebooks_args_authenticationToken record
  ]
write_ListAccessibleBusinessNotebooks_args :: T.Protocol p => p -> ListAccessibleBusinessNotebooks_args -> P.IO ()
write_ListAccessibleBusinessNotebooks_args oprot record = T.writeVal oprot $ from_ListAccessibleBusinessNotebooks_args record
encode_ListAccessibleBusinessNotebooks_args :: T.StatelessProtocol p => p -> ListAccessibleBusinessNotebooks_args -> LBS.ByteString
encode_ListAccessibleBusinessNotebooks_args oprot record = T.serializeVal oprot $ from_ListAccessibleBusinessNotebooks_args record
to_ListAccessibleBusinessNotebooks_args :: T.ThriftVal -> ListAccessibleBusinessNotebooks_args
to_ListAccessibleBusinessNotebooks_args (T.TStruct fields) = ListAccessibleBusinessNotebooks_args{
  listAccessibleBusinessNotebooks_args_authenticationToken = P.maybe (listAccessibleBusinessNotebooks_args_authenticationToken default_ListAccessibleBusinessNotebooks_args) (\(_,_val633) -> (case _val633 of {T.TString _val634 -> E.decodeUtf8 _val634; _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_ListAccessibleBusinessNotebooks_args _ = P.error "not a struct"
read_ListAccessibleBusinessNotebooks_args :: T.Protocol p => p -> P.IO ListAccessibleBusinessNotebooks_args
read_ListAccessibleBusinessNotebooks_args iprot = to_ListAccessibleBusinessNotebooks_args <$> T.readVal iprot (T.T_STRUCT typemap_ListAccessibleBusinessNotebooks_args)
decode_ListAccessibleBusinessNotebooks_args :: T.StatelessProtocol p => p -> LBS.ByteString -> ListAccessibleBusinessNotebooks_args
decode_ListAccessibleBusinessNotebooks_args iprot bs = to_ListAccessibleBusinessNotebooks_args $ T.deserializeVal iprot (T.T_STRUCT typemap_ListAccessibleBusinessNotebooks_args) bs
typemap_ListAccessibleBusinessNotebooks_args :: T.TypeMap
typemap_ListAccessibleBusinessNotebooks_args = Map.fromList [(1,("authenticationToken",T.T_STRING))]
default_ListAccessibleBusinessNotebooks_args :: ListAccessibleBusinessNotebooks_args
default_ListAccessibleBusinessNotebooks_args = ListAccessibleBusinessNotebooks_args{
  listAccessibleBusinessNotebooks_args_authenticationToken = ""}
data ListAccessibleBusinessNotebooks_result = ListAccessibleBusinessNotebooks_result  { listAccessibleBusinessNotebooks_result_success :: (Vector.Vector Types_Types.Notebook)
  , listAccessibleBusinessNotebooks_result_userException :: P.Maybe Errors_Types.EDAMUserException
  , listAccessibleBusinessNotebooks_result_systemException :: P.Maybe Errors_Types.EDAMSystemException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ListAccessibleBusinessNotebooks_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` listAccessibleBusinessNotebooks_result_success record   `H.hashWithSalt` listAccessibleBusinessNotebooks_result_userException record   `H.hashWithSalt` listAccessibleBusinessNotebooks_result_systemException record  
instance QC.Arbitrary ListAccessibleBusinessNotebooks_result where 
  arbitrary = M.liftM ListAccessibleBusinessNotebooks_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_ListAccessibleBusinessNotebooks_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ListAccessibleBusinessNotebooks_result{listAccessibleBusinessNotebooks_result_success = listAccessibleBusinessNotebooks_result_success obj} then P.Nothing else P.Just $ default_ListAccessibleBusinessNotebooks_result{listAccessibleBusinessNotebooks_result_success = listAccessibleBusinessNotebooks_result_success obj}
    , if obj == default_ListAccessibleBusinessNotebooks_result{listAccessibleBusinessNotebooks_result_userException = listAccessibleBusinessNotebooks_result_userException obj} then P.Nothing else P.Just $ default_ListAccessibleBusinessNotebooks_result{listAccessibleBusinessNotebooks_result_userException = listAccessibleBusinessNotebooks_result_userException obj}
    , if obj == default_ListAccessibleBusinessNotebooks_result{listAccessibleBusinessNotebooks_result_systemException = listAccessibleBusinessNotebooks_result_systemException obj} then P.Nothing else P.Just $ default_ListAccessibleBusinessNotebooks_result{listAccessibleBusinessNotebooks_result_systemException = listAccessibleBusinessNotebooks_result_systemException obj}
    ]
from_ListAccessibleBusinessNotebooks_result :: ListAccessibleBusinessNotebooks_result -> T.ThriftVal
from_ListAccessibleBusinessNotebooks_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v637 -> (1, ("userException",Errors_Types.from_EDAMUserException _v637))) <$> listAccessibleBusinessNotebooks_result_userException record, (\_v637 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v637))) <$> listAccessibleBusinessNotebooks_result_systemException record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v637 -> P.Just (0, ("success",T.TList (T.T_STRUCT Types_Types.typemap_Notebook) $ P.map (\_v639 -> Types_Types.from_Notebook _v639) $ Vector.toList _v637))) $ listAccessibleBusinessNotebooks_result_success record
    , (\_v637 -> (1, ("userException",Errors_Types.from_EDAMUserException _v637))) <$> listAccessibleBusinessNotebooks_result_userException record
    , (\_v637 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v637))) <$> listAccessibleBusinessNotebooks_result_systemException record
    ]
    )
write_ListAccessibleBusinessNotebooks_result :: T.Protocol p => p -> ListAccessibleBusinessNotebooks_result -> P.IO ()
write_ListAccessibleBusinessNotebooks_result oprot record = T.writeVal oprot $ from_ListAccessibleBusinessNotebooks_result record
encode_ListAccessibleBusinessNotebooks_result :: T.StatelessProtocol p => p -> ListAccessibleBusinessNotebooks_result -> LBS.ByteString
encode_ListAccessibleBusinessNotebooks_result oprot record = T.serializeVal oprot $ from_ListAccessibleBusinessNotebooks_result record
to_ListAccessibleBusinessNotebooks_result :: T.ThriftVal -> ListAccessibleBusinessNotebooks_result
to_ListAccessibleBusinessNotebooks_result (T.TStruct fields) = ListAccessibleBusinessNotebooks_result{
  listAccessibleBusinessNotebooks_result_success = P.maybe (listAccessibleBusinessNotebooks_result_success default_ListAccessibleBusinessNotebooks_result) (\(_,_val641) -> (case _val641 of {T.TList _ _val642 -> (Vector.fromList $ P.map (\_v643 -> (case _v643 of {T.TStruct _val644 -> (Types_Types.to_Notebook (T.TStruct _val644)); _ -> P.error "wrong type"})) _val642); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  listAccessibleBusinessNotebooks_result_userException = P.maybe (P.Nothing) (\(_,_val641) -> P.Just (case _val641 of {T.TStruct _val645 -> (Errors_Types.to_EDAMUserException (T.TStruct _val645)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  listAccessibleBusinessNotebooks_result_systemException = P.maybe (P.Nothing) (\(_,_val641) -> P.Just (case _val641 of {T.TStruct _val646 -> (Errors_Types.to_EDAMSystemException (T.TStruct _val646)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_ListAccessibleBusinessNotebooks_result _ = P.error "not a struct"
read_ListAccessibleBusinessNotebooks_result :: T.Protocol p => p -> P.IO ListAccessibleBusinessNotebooks_result
read_ListAccessibleBusinessNotebooks_result iprot = to_ListAccessibleBusinessNotebooks_result <$> T.readVal iprot (T.T_STRUCT typemap_ListAccessibleBusinessNotebooks_result)
decode_ListAccessibleBusinessNotebooks_result :: T.StatelessProtocol p => p -> LBS.ByteString -> ListAccessibleBusinessNotebooks_result
decode_ListAccessibleBusinessNotebooks_result iprot bs = to_ListAccessibleBusinessNotebooks_result $ T.deserializeVal iprot (T.T_STRUCT typemap_ListAccessibleBusinessNotebooks_result) bs
typemap_ListAccessibleBusinessNotebooks_result :: T.TypeMap
typemap_ListAccessibleBusinessNotebooks_result = Map.fromList [(0,("success",(T.T_LIST (T.T_STRUCT Types_Types.typemap_Notebook)))),(1,("userException",(T.T_STRUCT Errors_Types.typemap_EDAMUserException))),(2,("systemException",(T.T_STRUCT Errors_Types.typemap_EDAMSystemException)))]
default_ListAccessibleBusinessNotebooks_result :: ListAccessibleBusinessNotebooks_result
default_ListAccessibleBusinessNotebooks_result = ListAccessibleBusinessNotebooks_result{
  listAccessibleBusinessNotebooks_result_success = Vector.empty,
  listAccessibleBusinessNotebooks_result_userException = P.Nothing,
  listAccessibleBusinessNotebooks_result_systemException = P.Nothing}
data GetNotebook_args = GetNotebook_args  { getNotebook_args_authenticationToken :: LT.Text
  , getNotebook_args_guid :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetNotebook_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getNotebook_args_authenticationToken record   `H.hashWithSalt` getNotebook_args_guid record  
instance QC.Arbitrary GetNotebook_args where 
  arbitrary = M.liftM GetNotebook_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GetNotebook_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetNotebook_args{getNotebook_args_authenticationToken = getNotebook_args_authenticationToken obj} then P.Nothing else P.Just $ default_GetNotebook_args{getNotebook_args_authenticationToken = getNotebook_args_authenticationToken obj}
    , if obj == default_GetNotebook_args{getNotebook_args_guid = getNotebook_args_guid obj} then P.Nothing else P.Just $ default_GetNotebook_args{getNotebook_args_guid = getNotebook_args_guid obj}
    ]
from_GetNotebook_args :: GetNotebook_args -> T.ThriftVal
from_GetNotebook_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v649 -> P.Just (1, ("authenticationToken",T.TString $ E.encodeUtf8 _v649))) $ getNotebook_args_authenticationToken record
  , (\_v649 -> P.Just (2, ("guid",T.TString $ E.encodeUtf8 _v649))) $ getNotebook_args_guid record
  ]
write_GetNotebook_args :: T.Protocol p => p -> GetNotebook_args -> P.IO ()
write_GetNotebook_args oprot record = T.writeVal oprot $ from_GetNotebook_args record
encode_GetNotebook_args :: T.StatelessProtocol p => p -> GetNotebook_args -> LBS.ByteString
encode_GetNotebook_args oprot record = T.serializeVal oprot $ from_GetNotebook_args record
to_GetNotebook_args :: T.ThriftVal -> GetNotebook_args
to_GetNotebook_args (T.TStruct fields) = GetNotebook_args{
  getNotebook_args_authenticationToken = P.maybe (getNotebook_args_authenticationToken default_GetNotebook_args) (\(_,_val651) -> (case _val651 of {T.TString _val652 -> E.decodeUtf8 _val652; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  getNotebook_args_guid = P.maybe (getNotebook_args_guid default_GetNotebook_args) (\(_,_val651) -> (case _val651 of {T.TString _val653 -> E.decodeUtf8 _val653; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_GetNotebook_args _ = P.error "not a struct"
read_GetNotebook_args :: T.Protocol p => p -> P.IO GetNotebook_args
read_GetNotebook_args iprot = to_GetNotebook_args <$> T.readVal iprot (T.T_STRUCT typemap_GetNotebook_args)
decode_GetNotebook_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetNotebook_args
decode_GetNotebook_args iprot bs = to_GetNotebook_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetNotebook_args) bs
typemap_GetNotebook_args :: T.TypeMap
typemap_GetNotebook_args = Map.fromList [(1,("authenticationToken",T.T_STRING)),(2,("guid",T.T_STRING))]
default_GetNotebook_args :: GetNotebook_args
default_GetNotebook_args = GetNotebook_args{
  getNotebook_args_authenticationToken = "",
  getNotebook_args_guid = ""}
data GetNotebook_result = GetNotebook_result  { getNotebook_result_success :: Types_Types.Notebook
  , getNotebook_result_userException :: P.Maybe Errors_Types.EDAMUserException
  , getNotebook_result_systemException :: P.Maybe Errors_Types.EDAMSystemException
  , getNotebook_result_notFoundException :: P.Maybe Errors_Types.EDAMNotFoundException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetNotebook_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getNotebook_result_success record   `H.hashWithSalt` getNotebook_result_userException record   `H.hashWithSalt` getNotebook_result_systemException record   `H.hashWithSalt` getNotebook_result_notFoundException record  
instance QC.Arbitrary GetNotebook_result where 
  arbitrary = M.liftM GetNotebook_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetNotebook_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetNotebook_result{getNotebook_result_success = getNotebook_result_success obj} then P.Nothing else P.Just $ default_GetNotebook_result{getNotebook_result_success = getNotebook_result_success obj}
    , if obj == default_GetNotebook_result{getNotebook_result_userException = getNotebook_result_userException obj} then P.Nothing else P.Just $ default_GetNotebook_result{getNotebook_result_userException = getNotebook_result_userException obj}
    , if obj == default_GetNotebook_result{getNotebook_result_systemException = getNotebook_result_systemException obj} then P.Nothing else P.Just $ default_GetNotebook_result{getNotebook_result_systemException = getNotebook_result_systemException obj}
    , if obj == default_GetNotebook_result{getNotebook_result_notFoundException = getNotebook_result_notFoundException obj} then P.Nothing else P.Just $ default_GetNotebook_result{getNotebook_result_notFoundException = getNotebook_result_notFoundException obj}
    ]
from_GetNotebook_result :: GetNotebook_result -> T.ThriftVal
from_GetNotebook_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v656 -> (1, ("userException",Errors_Types.from_EDAMUserException _v656))) <$> getNotebook_result_userException record, (\_v656 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v656))) <$> getNotebook_result_systemException record, (\_v656 -> (3, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v656))) <$> getNotebook_result_notFoundException record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v656 -> P.Just (0, ("success",Types_Types.from_Notebook _v656))) $ getNotebook_result_success record
    , (\_v656 -> (1, ("userException",Errors_Types.from_EDAMUserException _v656))) <$> getNotebook_result_userException record
    , (\_v656 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v656))) <$> getNotebook_result_systemException record
    , (\_v656 -> (3, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v656))) <$> getNotebook_result_notFoundException record
    ]
    )
write_GetNotebook_result :: T.Protocol p => p -> GetNotebook_result -> P.IO ()
write_GetNotebook_result oprot record = T.writeVal oprot $ from_GetNotebook_result record
encode_GetNotebook_result :: T.StatelessProtocol p => p -> GetNotebook_result -> LBS.ByteString
encode_GetNotebook_result oprot record = T.serializeVal oprot $ from_GetNotebook_result record
to_GetNotebook_result :: T.ThriftVal -> GetNotebook_result
to_GetNotebook_result (T.TStruct fields) = GetNotebook_result{
  getNotebook_result_success = P.maybe (getNotebook_result_success default_GetNotebook_result) (\(_,_val658) -> (case _val658 of {T.TStruct _val659 -> (Types_Types.to_Notebook (T.TStruct _val659)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getNotebook_result_userException = P.maybe (P.Nothing) (\(_,_val658) -> P.Just (case _val658 of {T.TStruct _val660 -> (Errors_Types.to_EDAMUserException (T.TStruct _val660)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  getNotebook_result_systemException = P.maybe (P.Nothing) (\(_,_val658) -> P.Just (case _val658 of {T.TStruct _val661 -> (Errors_Types.to_EDAMSystemException (T.TStruct _val661)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  getNotebook_result_notFoundException = P.maybe (P.Nothing) (\(_,_val658) -> P.Just (case _val658 of {T.TStruct _val662 -> (Errors_Types.to_EDAMNotFoundException (T.TStruct _val662)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_GetNotebook_result _ = P.error "not a struct"
read_GetNotebook_result :: T.Protocol p => p -> P.IO GetNotebook_result
read_GetNotebook_result iprot = to_GetNotebook_result <$> T.readVal iprot (T.T_STRUCT typemap_GetNotebook_result)
decode_GetNotebook_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetNotebook_result
decode_GetNotebook_result iprot bs = to_GetNotebook_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetNotebook_result) bs
typemap_GetNotebook_result :: T.TypeMap
typemap_GetNotebook_result = Map.fromList [(0,("success",(T.T_STRUCT Types_Types.typemap_Notebook))),(1,("userException",(T.T_STRUCT Errors_Types.typemap_EDAMUserException))),(2,("systemException",(T.T_STRUCT Errors_Types.typemap_EDAMSystemException))),(3,("notFoundException",(T.T_STRUCT Errors_Types.typemap_EDAMNotFoundException)))]
default_GetNotebook_result :: GetNotebook_result
default_GetNotebook_result = GetNotebook_result{
  getNotebook_result_success = Types_Types.default_Notebook,
  getNotebook_result_userException = P.Nothing,
  getNotebook_result_systemException = P.Nothing,
  getNotebook_result_notFoundException = P.Nothing}
data GetDefaultNotebook_args = GetDefaultNotebook_args  { getDefaultNotebook_args_authenticationToken :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetDefaultNotebook_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getDefaultNotebook_args_authenticationToken record  
instance QC.Arbitrary GetDefaultNotebook_args where 
  arbitrary = M.liftM GetDefaultNotebook_args (QC.arbitrary)
  shrink obj | obj == default_GetDefaultNotebook_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetDefaultNotebook_args{getDefaultNotebook_args_authenticationToken = getDefaultNotebook_args_authenticationToken obj} then P.Nothing else P.Just $ default_GetDefaultNotebook_args{getDefaultNotebook_args_authenticationToken = getDefaultNotebook_args_authenticationToken obj}
    ]
from_GetDefaultNotebook_args :: GetDefaultNotebook_args -> T.ThriftVal
from_GetDefaultNotebook_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v665 -> P.Just (1, ("authenticationToken",T.TString $ E.encodeUtf8 _v665))) $ getDefaultNotebook_args_authenticationToken record
  ]
write_GetDefaultNotebook_args :: T.Protocol p => p -> GetDefaultNotebook_args -> P.IO ()
write_GetDefaultNotebook_args oprot record = T.writeVal oprot $ from_GetDefaultNotebook_args record
encode_GetDefaultNotebook_args :: T.StatelessProtocol p => p -> GetDefaultNotebook_args -> LBS.ByteString
encode_GetDefaultNotebook_args oprot record = T.serializeVal oprot $ from_GetDefaultNotebook_args record
to_GetDefaultNotebook_args :: T.ThriftVal -> GetDefaultNotebook_args
to_GetDefaultNotebook_args (T.TStruct fields) = GetDefaultNotebook_args{
  getDefaultNotebook_args_authenticationToken = P.maybe (getDefaultNotebook_args_authenticationToken default_GetDefaultNotebook_args) (\(_,_val667) -> (case _val667 of {T.TString _val668 -> E.decodeUtf8 _val668; _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetDefaultNotebook_args _ = P.error "not a struct"
read_GetDefaultNotebook_args :: T.Protocol p => p -> P.IO GetDefaultNotebook_args
read_GetDefaultNotebook_args iprot = to_GetDefaultNotebook_args <$> T.readVal iprot (T.T_STRUCT typemap_GetDefaultNotebook_args)
decode_GetDefaultNotebook_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetDefaultNotebook_args
decode_GetDefaultNotebook_args iprot bs = to_GetDefaultNotebook_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetDefaultNotebook_args) bs
typemap_GetDefaultNotebook_args :: T.TypeMap
typemap_GetDefaultNotebook_args = Map.fromList [(1,("authenticationToken",T.T_STRING))]
default_GetDefaultNotebook_args :: GetDefaultNotebook_args
default_GetDefaultNotebook_args = GetDefaultNotebook_args{
  getDefaultNotebook_args_authenticationToken = ""}
data GetDefaultNotebook_result = GetDefaultNotebook_result  { getDefaultNotebook_result_success :: Types_Types.Notebook
  , getDefaultNotebook_result_userException :: P.Maybe Errors_Types.EDAMUserException
  , getDefaultNotebook_result_systemException :: P.Maybe Errors_Types.EDAMSystemException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetDefaultNotebook_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getDefaultNotebook_result_success record   `H.hashWithSalt` getDefaultNotebook_result_userException record   `H.hashWithSalt` getDefaultNotebook_result_systemException record  
instance QC.Arbitrary GetDefaultNotebook_result where 
  arbitrary = M.liftM GetDefaultNotebook_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetDefaultNotebook_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetDefaultNotebook_result{getDefaultNotebook_result_success = getDefaultNotebook_result_success obj} then P.Nothing else P.Just $ default_GetDefaultNotebook_result{getDefaultNotebook_result_success = getDefaultNotebook_result_success obj}
    , if obj == default_GetDefaultNotebook_result{getDefaultNotebook_result_userException = getDefaultNotebook_result_userException obj} then P.Nothing else P.Just $ default_GetDefaultNotebook_result{getDefaultNotebook_result_userException = getDefaultNotebook_result_userException obj}
    , if obj == default_GetDefaultNotebook_result{getDefaultNotebook_result_systemException = getDefaultNotebook_result_systemException obj} then P.Nothing else P.Just $ default_GetDefaultNotebook_result{getDefaultNotebook_result_systemException = getDefaultNotebook_result_systemException obj}
    ]
from_GetDefaultNotebook_result :: GetDefaultNotebook_result -> T.ThriftVal
from_GetDefaultNotebook_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v671 -> (1, ("userException",Errors_Types.from_EDAMUserException _v671))) <$> getDefaultNotebook_result_userException record, (\_v671 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v671))) <$> getDefaultNotebook_result_systemException record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v671 -> P.Just (0, ("success",Types_Types.from_Notebook _v671))) $ getDefaultNotebook_result_success record
    , (\_v671 -> (1, ("userException",Errors_Types.from_EDAMUserException _v671))) <$> getDefaultNotebook_result_userException record
    , (\_v671 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v671))) <$> getDefaultNotebook_result_systemException record
    ]
    )
write_GetDefaultNotebook_result :: T.Protocol p => p -> GetDefaultNotebook_result -> P.IO ()
write_GetDefaultNotebook_result oprot record = T.writeVal oprot $ from_GetDefaultNotebook_result record
encode_GetDefaultNotebook_result :: T.StatelessProtocol p => p -> GetDefaultNotebook_result -> LBS.ByteString
encode_GetDefaultNotebook_result oprot record = T.serializeVal oprot $ from_GetDefaultNotebook_result record
to_GetDefaultNotebook_result :: T.ThriftVal -> GetDefaultNotebook_result
to_GetDefaultNotebook_result (T.TStruct fields) = GetDefaultNotebook_result{
  getDefaultNotebook_result_success = P.maybe (getDefaultNotebook_result_success default_GetDefaultNotebook_result) (\(_,_val673) -> (case _val673 of {T.TStruct _val674 -> (Types_Types.to_Notebook (T.TStruct _val674)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getDefaultNotebook_result_userException = P.maybe (P.Nothing) (\(_,_val673) -> P.Just (case _val673 of {T.TStruct _val675 -> (Errors_Types.to_EDAMUserException (T.TStruct _val675)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  getDefaultNotebook_result_systemException = P.maybe (P.Nothing) (\(_,_val673) -> P.Just (case _val673 of {T.TStruct _val676 -> (Errors_Types.to_EDAMSystemException (T.TStruct _val676)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_GetDefaultNotebook_result _ = P.error "not a struct"
read_GetDefaultNotebook_result :: T.Protocol p => p -> P.IO GetDefaultNotebook_result
read_GetDefaultNotebook_result iprot = to_GetDefaultNotebook_result <$> T.readVal iprot (T.T_STRUCT typemap_GetDefaultNotebook_result)
decode_GetDefaultNotebook_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetDefaultNotebook_result
decode_GetDefaultNotebook_result iprot bs = to_GetDefaultNotebook_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetDefaultNotebook_result) bs
typemap_GetDefaultNotebook_result :: T.TypeMap
typemap_GetDefaultNotebook_result = Map.fromList [(0,("success",(T.T_STRUCT Types_Types.typemap_Notebook))),(1,("userException",(T.T_STRUCT Errors_Types.typemap_EDAMUserException))),(2,("systemException",(T.T_STRUCT Errors_Types.typemap_EDAMSystemException)))]
default_GetDefaultNotebook_result :: GetDefaultNotebook_result
default_GetDefaultNotebook_result = GetDefaultNotebook_result{
  getDefaultNotebook_result_success = Types_Types.default_Notebook,
  getDefaultNotebook_result_userException = P.Nothing,
  getDefaultNotebook_result_systemException = P.Nothing}
data CreateNotebook_args = CreateNotebook_args  { createNotebook_args_authenticationToken :: LT.Text
  , createNotebook_args_notebook :: Types_Types.Notebook
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable CreateNotebook_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` createNotebook_args_authenticationToken record   `H.hashWithSalt` createNotebook_args_notebook record  
instance QC.Arbitrary CreateNotebook_args where 
  arbitrary = M.liftM CreateNotebook_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_CreateNotebook_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_CreateNotebook_args{createNotebook_args_authenticationToken = createNotebook_args_authenticationToken obj} then P.Nothing else P.Just $ default_CreateNotebook_args{createNotebook_args_authenticationToken = createNotebook_args_authenticationToken obj}
    , if obj == default_CreateNotebook_args{createNotebook_args_notebook = createNotebook_args_notebook obj} then P.Nothing else P.Just $ default_CreateNotebook_args{createNotebook_args_notebook = createNotebook_args_notebook obj}
    ]
from_CreateNotebook_args :: CreateNotebook_args -> T.ThriftVal
from_CreateNotebook_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v679 -> P.Just (1, ("authenticationToken",T.TString $ E.encodeUtf8 _v679))) $ createNotebook_args_authenticationToken record
  , (\_v679 -> P.Just (2, ("notebook",Types_Types.from_Notebook _v679))) $ createNotebook_args_notebook record
  ]
write_CreateNotebook_args :: T.Protocol p => p -> CreateNotebook_args -> P.IO ()
write_CreateNotebook_args oprot record = T.writeVal oprot $ from_CreateNotebook_args record
encode_CreateNotebook_args :: T.StatelessProtocol p => p -> CreateNotebook_args -> LBS.ByteString
encode_CreateNotebook_args oprot record = T.serializeVal oprot $ from_CreateNotebook_args record
to_CreateNotebook_args :: T.ThriftVal -> CreateNotebook_args
to_CreateNotebook_args (T.TStruct fields) = CreateNotebook_args{
  createNotebook_args_authenticationToken = P.maybe (createNotebook_args_authenticationToken default_CreateNotebook_args) (\(_,_val681) -> (case _val681 of {T.TString _val682 -> E.decodeUtf8 _val682; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  createNotebook_args_notebook = P.maybe (createNotebook_args_notebook default_CreateNotebook_args) (\(_,_val681) -> (case _val681 of {T.TStruct _val683 -> (Types_Types.to_Notebook (T.TStruct _val683)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_CreateNotebook_args _ = P.error "not a struct"
read_CreateNotebook_args :: T.Protocol p => p -> P.IO CreateNotebook_args
read_CreateNotebook_args iprot = to_CreateNotebook_args <$> T.readVal iprot (T.T_STRUCT typemap_CreateNotebook_args)
decode_CreateNotebook_args :: T.StatelessProtocol p => p -> LBS.ByteString -> CreateNotebook_args
decode_CreateNotebook_args iprot bs = to_CreateNotebook_args $ T.deserializeVal iprot (T.T_STRUCT typemap_CreateNotebook_args) bs
typemap_CreateNotebook_args :: T.TypeMap
typemap_CreateNotebook_args = Map.fromList [(1,("authenticationToken",T.T_STRING)),(2,("notebook",(T.T_STRUCT Types_Types.typemap_Notebook)))]
default_CreateNotebook_args :: CreateNotebook_args
default_CreateNotebook_args = CreateNotebook_args{
  createNotebook_args_authenticationToken = "",
  createNotebook_args_notebook = Types_Types.default_Notebook}
data CreateNotebook_result = CreateNotebook_result  { createNotebook_result_success :: Types_Types.Notebook
  , createNotebook_result_userException :: P.Maybe Errors_Types.EDAMUserException
  , createNotebook_result_systemException :: P.Maybe Errors_Types.EDAMSystemException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable CreateNotebook_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` createNotebook_result_success record   `H.hashWithSalt` createNotebook_result_userException record   `H.hashWithSalt` createNotebook_result_systemException record  
instance QC.Arbitrary CreateNotebook_result where 
  arbitrary = M.liftM CreateNotebook_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_CreateNotebook_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_CreateNotebook_result{createNotebook_result_success = createNotebook_result_success obj} then P.Nothing else P.Just $ default_CreateNotebook_result{createNotebook_result_success = createNotebook_result_success obj}
    , if obj == default_CreateNotebook_result{createNotebook_result_userException = createNotebook_result_userException obj} then P.Nothing else P.Just $ default_CreateNotebook_result{createNotebook_result_userException = createNotebook_result_userException obj}
    , if obj == default_CreateNotebook_result{createNotebook_result_systemException = createNotebook_result_systemException obj} then P.Nothing else P.Just $ default_CreateNotebook_result{createNotebook_result_systemException = createNotebook_result_systemException obj}
    ]
from_CreateNotebook_result :: CreateNotebook_result -> T.ThriftVal
from_CreateNotebook_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v686 -> (1, ("userException",Errors_Types.from_EDAMUserException _v686))) <$> createNotebook_result_userException record, (\_v686 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v686))) <$> createNotebook_result_systemException record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v686 -> P.Just (0, ("success",Types_Types.from_Notebook _v686))) $ createNotebook_result_success record
    , (\_v686 -> (1, ("userException",Errors_Types.from_EDAMUserException _v686))) <$> createNotebook_result_userException record
    , (\_v686 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v686))) <$> createNotebook_result_systemException record
    ]
    )
write_CreateNotebook_result :: T.Protocol p => p -> CreateNotebook_result -> P.IO ()
write_CreateNotebook_result oprot record = T.writeVal oprot $ from_CreateNotebook_result record
encode_CreateNotebook_result :: T.StatelessProtocol p => p -> CreateNotebook_result -> LBS.ByteString
encode_CreateNotebook_result oprot record = T.serializeVal oprot $ from_CreateNotebook_result record
to_CreateNotebook_result :: T.ThriftVal -> CreateNotebook_result
to_CreateNotebook_result (T.TStruct fields) = CreateNotebook_result{
  createNotebook_result_success = P.maybe (createNotebook_result_success default_CreateNotebook_result) (\(_,_val688) -> (case _val688 of {T.TStruct _val689 -> (Types_Types.to_Notebook (T.TStruct _val689)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  createNotebook_result_userException = P.maybe (P.Nothing) (\(_,_val688) -> P.Just (case _val688 of {T.TStruct _val690 -> (Errors_Types.to_EDAMUserException (T.TStruct _val690)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  createNotebook_result_systemException = P.maybe (P.Nothing) (\(_,_val688) -> P.Just (case _val688 of {T.TStruct _val691 -> (Errors_Types.to_EDAMSystemException (T.TStruct _val691)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_CreateNotebook_result _ = P.error "not a struct"
read_CreateNotebook_result :: T.Protocol p => p -> P.IO CreateNotebook_result
read_CreateNotebook_result iprot = to_CreateNotebook_result <$> T.readVal iprot (T.T_STRUCT typemap_CreateNotebook_result)
decode_CreateNotebook_result :: T.StatelessProtocol p => p -> LBS.ByteString -> CreateNotebook_result
decode_CreateNotebook_result iprot bs = to_CreateNotebook_result $ T.deserializeVal iprot (T.T_STRUCT typemap_CreateNotebook_result) bs
typemap_CreateNotebook_result :: T.TypeMap
typemap_CreateNotebook_result = Map.fromList [(0,("success",(T.T_STRUCT Types_Types.typemap_Notebook))),(1,("userException",(T.T_STRUCT Errors_Types.typemap_EDAMUserException))),(2,("systemException",(T.T_STRUCT Errors_Types.typemap_EDAMSystemException)))]
default_CreateNotebook_result :: CreateNotebook_result
default_CreateNotebook_result = CreateNotebook_result{
  createNotebook_result_success = Types_Types.default_Notebook,
  createNotebook_result_userException = P.Nothing,
  createNotebook_result_systemException = P.Nothing}
data UpdateNotebook_args = UpdateNotebook_args  { updateNotebook_args_authenticationToken :: LT.Text
  , updateNotebook_args_notebook :: Types_Types.Notebook
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateNotebook_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateNotebook_args_authenticationToken record   `H.hashWithSalt` updateNotebook_args_notebook record  
instance QC.Arbitrary UpdateNotebook_args where 
  arbitrary = M.liftM UpdateNotebook_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_UpdateNotebook_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateNotebook_args{updateNotebook_args_authenticationToken = updateNotebook_args_authenticationToken obj} then P.Nothing else P.Just $ default_UpdateNotebook_args{updateNotebook_args_authenticationToken = updateNotebook_args_authenticationToken obj}
    , if obj == default_UpdateNotebook_args{updateNotebook_args_notebook = updateNotebook_args_notebook obj} then P.Nothing else P.Just $ default_UpdateNotebook_args{updateNotebook_args_notebook = updateNotebook_args_notebook obj}
    ]
from_UpdateNotebook_args :: UpdateNotebook_args -> T.ThriftVal
from_UpdateNotebook_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v694 -> P.Just (1, ("authenticationToken",T.TString $ E.encodeUtf8 _v694))) $ updateNotebook_args_authenticationToken record
  , (\_v694 -> P.Just (2, ("notebook",Types_Types.from_Notebook _v694))) $ updateNotebook_args_notebook record
  ]
write_UpdateNotebook_args :: T.Protocol p => p -> UpdateNotebook_args -> P.IO ()
write_UpdateNotebook_args oprot record = T.writeVal oprot $ from_UpdateNotebook_args record
encode_UpdateNotebook_args :: T.StatelessProtocol p => p -> UpdateNotebook_args -> LBS.ByteString
encode_UpdateNotebook_args oprot record = T.serializeVal oprot $ from_UpdateNotebook_args record
to_UpdateNotebook_args :: T.ThriftVal -> UpdateNotebook_args
to_UpdateNotebook_args (T.TStruct fields) = UpdateNotebook_args{
  updateNotebook_args_authenticationToken = P.maybe (updateNotebook_args_authenticationToken default_UpdateNotebook_args) (\(_,_val696) -> (case _val696 of {T.TString _val697 -> E.decodeUtf8 _val697; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  updateNotebook_args_notebook = P.maybe (updateNotebook_args_notebook default_UpdateNotebook_args) (\(_,_val696) -> (case _val696 of {T.TStruct _val698 -> (Types_Types.to_Notebook (T.TStruct _val698)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_UpdateNotebook_args _ = P.error "not a struct"
read_UpdateNotebook_args :: T.Protocol p => p -> P.IO UpdateNotebook_args
read_UpdateNotebook_args iprot = to_UpdateNotebook_args <$> T.readVal iprot (T.T_STRUCT typemap_UpdateNotebook_args)
decode_UpdateNotebook_args :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateNotebook_args
decode_UpdateNotebook_args iprot bs = to_UpdateNotebook_args $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateNotebook_args) bs
typemap_UpdateNotebook_args :: T.TypeMap
typemap_UpdateNotebook_args = Map.fromList [(1,("authenticationToken",T.T_STRING)),(2,("notebook",(T.T_STRUCT Types_Types.typemap_Notebook)))]
default_UpdateNotebook_args :: UpdateNotebook_args
default_UpdateNotebook_args = UpdateNotebook_args{
  updateNotebook_args_authenticationToken = "",
  updateNotebook_args_notebook = Types_Types.default_Notebook}
data UpdateNotebook_result = UpdateNotebook_result  { updateNotebook_result_success :: I.Int32
  , updateNotebook_result_userException :: P.Maybe Errors_Types.EDAMUserException
  , updateNotebook_result_systemException :: P.Maybe Errors_Types.EDAMSystemException
  , updateNotebook_result_notFoundException :: P.Maybe Errors_Types.EDAMNotFoundException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateNotebook_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateNotebook_result_success record   `H.hashWithSalt` updateNotebook_result_userException record   `H.hashWithSalt` updateNotebook_result_systemException record   `H.hashWithSalt` updateNotebook_result_notFoundException record  
instance QC.Arbitrary UpdateNotebook_result where 
  arbitrary = M.liftM UpdateNotebook_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_UpdateNotebook_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateNotebook_result{updateNotebook_result_success = updateNotebook_result_success obj} then P.Nothing else P.Just $ default_UpdateNotebook_result{updateNotebook_result_success = updateNotebook_result_success obj}
    , if obj == default_UpdateNotebook_result{updateNotebook_result_userException = updateNotebook_result_userException obj} then P.Nothing else P.Just $ default_UpdateNotebook_result{updateNotebook_result_userException = updateNotebook_result_userException obj}
    , if obj == default_UpdateNotebook_result{updateNotebook_result_systemException = updateNotebook_result_systemException obj} then P.Nothing else P.Just $ default_UpdateNotebook_result{updateNotebook_result_systemException = updateNotebook_result_systemException obj}
    , if obj == default_UpdateNotebook_result{updateNotebook_result_notFoundException = updateNotebook_result_notFoundException obj} then P.Nothing else P.Just $ default_UpdateNotebook_result{updateNotebook_result_notFoundException = updateNotebook_result_notFoundException obj}
    ]
from_UpdateNotebook_result :: UpdateNotebook_result -> T.ThriftVal
from_UpdateNotebook_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v701 -> (1, ("userException",Errors_Types.from_EDAMUserException _v701))) <$> updateNotebook_result_userException record, (\_v701 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v701))) <$> updateNotebook_result_systemException record, (\_v701 -> (3, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v701))) <$> updateNotebook_result_notFoundException record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v701 -> P.Just (0, ("success",T.TI32 _v701))) $ updateNotebook_result_success record
    , (\_v701 -> (1, ("userException",Errors_Types.from_EDAMUserException _v701))) <$> updateNotebook_result_userException record
    , (\_v701 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v701))) <$> updateNotebook_result_systemException record
    , (\_v701 -> (3, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v701))) <$> updateNotebook_result_notFoundException record
    ]
    )
write_UpdateNotebook_result :: T.Protocol p => p -> UpdateNotebook_result -> P.IO ()
write_UpdateNotebook_result oprot record = T.writeVal oprot $ from_UpdateNotebook_result record
encode_UpdateNotebook_result :: T.StatelessProtocol p => p -> UpdateNotebook_result -> LBS.ByteString
encode_UpdateNotebook_result oprot record = T.serializeVal oprot $ from_UpdateNotebook_result record
to_UpdateNotebook_result :: T.ThriftVal -> UpdateNotebook_result
to_UpdateNotebook_result (T.TStruct fields) = UpdateNotebook_result{
  updateNotebook_result_success = P.maybe (updateNotebook_result_success default_UpdateNotebook_result) (\(_,_val703) -> (case _val703 of {T.TI32 _val704 -> _val704; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  updateNotebook_result_userException = P.maybe (P.Nothing) (\(_,_val703) -> P.Just (case _val703 of {T.TStruct _val705 -> (Errors_Types.to_EDAMUserException (T.TStruct _val705)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  updateNotebook_result_systemException = P.maybe (P.Nothing) (\(_,_val703) -> P.Just (case _val703 of {T.TStruct _val706 -> (Errors_Types.to_EDAMSystemException (T.TStruct _val706)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  updateNotebook_result_notFoundException = P.maybe (P.Nothing) (\(_,_val703) -> P.Just (case _val703 of {T.TStruct _val707 -> (Errors_Types.to_EDAMNotFoundException (T.TStruct _val707)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_UpdateNotebook_result _ = P.error "not a struct"
read_UpdateNotebook_result :: T.Protocol p => p -> P.IO UpdateNotebook_result
read_UpdateNotebook_result iprot = to_UpdateNotebook_result <$> T.readVal iprot (T.T_STRUCT typemap_UpdateNotebook_result)
decode_UpdateNotebook_result :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateNotebook_result
decode_UpdateNotebook_result iprot bs = to_UpdateNotebook_result $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateNotebook_result) bs
typemap_UpdateNotebook_result :: T.TypeMap
typemap_UpdateNotebook_result = Map.fromList [(0,("success",T.T_I32)),(1,("userException",(T.T_STRUCT Errors_Types.typemap_EDAMUserException))),(2,("systemException",(T.T_STRUCT Errors_Types.typemap_EDAMSystemException))),(3,("notFoundException",(T.T_STRUCT Errors_Types.typemap_EDAMNotFoundException)))]
default_UpdateNotebook_result :: UpdateNotebook_result
default_UpdateNotebook_result = UpdateNotebook_result{
  updateNotebook_result_success = 0,
  updateNotebook_result_userException = P.Nothing,
  updateNotebook_result_systemException = P.Nothing,
  updateNotebook_result_notFoundException = P.Nothing}
data ExpungeNotebook_args = ExpungeNotebook_args  { expungeNotebook_args_authenticationToken :: LT.Text
  , expungeNotebook_args_guid :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ExpungeNotebook_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` expungeNotebook_args_authenticationToken record   `H.hashWithSalt` expungeNotebook_args_guid record  
instance QC.Arbitrary ExpungeNotebook_args where 
  arbitrary = M.liftM ExpungeNotebook_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_ExpungeNotebook_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ExpungeNotebook_args{expungeNotebook_args_authenticationToken = expungeNotebook_args_authenticationToken obj} then P.Nothing else P.Just $ default_ExpungeNotebook_args{expungeNotebook_args_authenticationToken = expungeNotebook_args_authenticationToken obj}
    , if obj == default_ExpungeNotebook_args{expungeNotebook_args_guid = expungeNotebook_args_guid obj} then P.Nothing else P.Just $ default_ExpungeNotebook_args{expungeNotebook_args_guid = expungeNotebook_args_guid obj}
    ]
from_ExpungeNotebook_args :: ExpungeNotebook_args -> T.ThriftVal
from_ExpungeNotebook_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v710 -> P.Just (1, ("authenticationToken",T.TString $ E.encodeUtf8 _v710))) $ expungeNotebook_args_authenticationToken record
  , (\_v710 -> P.Just (2, ("guid",T.TString $ E.encodeUtf8 _v710))) $ expungeNotebook_args_guid record
  ]
write_ExpungeNotebook_args :: T.Protocol p => p -> ExpungeNotebook_args -> P.IO ()
write_ExpungeNotebook_args oprot record = T.writeVal oprot $ from_ExpungeNotebook_args record
encode_ExpungeNotebook_args :: T.StatelessProtocol p => p -> ExpungeNotebook_args -> LBS.ByteString
encode_ExpungeNotebook_args oprot record = T.serializeVal oprot $ from_ExpungeNotebook_args record
to_ExpungeNotebook_args :: T.ThriftVal -> ExpungeNotebook_args
to_ExpungeNotebook_args (T.TStruct fields) = ExpungeNotebook_args{
  expungeNotebook_args_authenticationToken = P.maybe (expungeNotebook_args_authenticationToken default_ExpungeNotebook_args) (\(_,_val712) -> (case _val712 of {T.TString _val713 -> E.decodeUtf8 _val713; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  expungeNotebook_args_guid = P.maybe (expungeNotebook_args_guid default_ExpungeNotebook_args) (\(_,_val712) -> (case _val712 of {T.TString _val714 -> E.decodeUtf8 _val714; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_ExpungeNotebook_args _ = P.error "not a struct"
read_ExpungeNotebook_args :: T.Protocol p => p -> P.IO ExpungeNotebook_args
read_ExpungeNotebook_args iprot = to_ExpungeNotebook_args <$> T.readVal iprot (T.T_STRUCT typemap_ExpungeNotebook_args)
decode_ExpungeNotebook_args :: T.StatelessProtocol p => p -> LBS.ByteString -> ExpungeNotebook_args
decode_ExpungeNotebook_args iprot bs = to_ExpungeNotebook_args $ T.deserializeVal iprot (T.T_STRUCT typemap_ExpungeNotebook_args) bs
typemap_ExpungeNotebook_args :: T.TypeMap
typemap_ExpungeNotebook_args = Map.fromList [(1,("authenticationToken",T.T_STRING)),(2,("guid",T.T_STRING))]
default_ExpungeNotebook_args :: ExpungeNotebook_args
default_ExpungeNotebook_args = ExpungeNotebook_args{
  expungeNotebook_args_authenticationToken = "",
  expungeNotebook_args_guid = ""}
data ExpungeNotebook_result = ExpungeNotebook_result  { expungeNotebook_result_success :: I.Int32
  , expungeNotebook_result_userException :: P.Maybe Errors_Types.EDAMUserException
  , expungeNotebook_result_systemException :: P.Maybe Errors_Types.EDAMSystemException
  , expungeNotebook_result_notFoundException :: P.Maybe Errors_Types.EDAMNotFoundException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ExpungeNotebook_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` expungeNotebook_result_success record   `H.hashWithSalt` expungeNotebook_result_userException record   `H.hashWithSalt` expungeNotebook_result_systemException record   `H.hashWithSalt` expungeNotebook_result_notFoundException record  
instance QC.Arbitrary ExpungeNotebook_result where 
  arbitrary = M.liftM ExpungeNotebook_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_ExpungeNotebook_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ExpungeNotebook_result{expungeNotebook_result_success = expungeNotebook_result_success obj} then P.Nothing else P.Just $ default_ExpungeNotebook_result{expungeNotebook_result_success = expungeNotebook_result_success obj}
    , if obj == default_ExpungeNotebook_result{expungeNotebook_result_userException = expungeNotebook_result_userException obj} then P.Nothing else P.Just $ default_ExpungeNotebook_result{expungeNotebook_result_userException = expungeNotebook_result_userException obj}
    , if obj == default_ExpungeNotebook_result{expungeNotebook_result_systemException = expungeNotebook_result_systemException obj} then P.Nothing else P.Just $ default_ExpungeNotebook_result{expungeNotebook_result_systemException = expungeNotebook_result_systemException obj}
    , if obj == default_ExpungeNotebook_result{expungeNotebook_result_notFoundException = expungeNotebook_result_notFoundException obj} then P.Nothing else P.Just $ default_ExpungeNotebook_result{expungeNotebook_result_notFoundException = expungeNotebook_result_notFoundException obj}
    ]
from_ExpungeNotebook_result :: ExpungeNotebook_result -> T.ThriftVal
from_ExpungeNotebook_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v717 -> (1, ("userException",Errors_Types.from_EDAMUserException _v717))) <$> expungeNotebook_result_userException record, (\_v717 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v717))) <$> expungeNotebook_result_systemException record, (\_v717 -> (3, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v717))) <$> expungeNotebook_result_notFoundException record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v717 -> P.Just (0, ("success",T.TI32 _v717))) $ expungeNotebook_result_success record
    , (\_v717 -> (1, ("userException",Errors_Types.from_EDAMUserException _v717))) <$> expungeNotebook_result_userException record
    , (\_v717 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v717))) <$> expungeNotebook_result_systemException record
    , (\_v717 -> (3, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v717))) <$> expungeNotebook_result_notFoundException record
    ]
    )
write_ExpungeNotebook_result :: T.Protocol p => p -> ExpungeNotebook_result -> P.IO ()
write_ExpungeNotebook_result oprot record = T.writeVal oprot $ from_ExpungeNotebook_result record
encode_ExpungeNotebook_result :: T.StatelessProtocol p => p -> ExpungeNotebook_result -> LBS.ByteString
encode_ExpungeNotebook_result oprot record = T.serializeVal oprot $ from_ExpungeNotebook_result record
to_ExpungeNotebook_result :: T.ThriftVal -> ExpungeNotebook_result
to_ExpungeNotebook_result (T.TStruct fields) = ExpungeNotebook_result{
  expungeNotebook_result_success = P.maybe (expungeNotebook_result_success default_ExpungeNotebook_result) (\(_,_val719) -> (case _val719 of {T.TI32 _val720 -> _val720; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  expungeNotebook_result_userException = P.maybe (P.Nothing) (\(_,_val719) -> P.Just (case _val719 of {T.TStruct _val721 -> (Errors_Types.to_EDAMUserException (T.TStruct _val721)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  expungeNotebook_result_systemException = P.maybe (P.Nothing) (\(_,_val719) -> P.Just (case _val719 of {T.TStruct _val722 -> (Errors_Types.to_EDAMSystemException (T.TStruct _val722)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  expungeNotebook_result_notFoundException = P.maybe (P.Nothing) (\(_,_val719) -> P.Just (case _val719 of {T.TStruct _val723 -> (Errors_Types.to_EDAMNotFoundException (T.TStruct _val723)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_ExpungeNotebook_result _ = P.error "not a struct"
read_ExpungeNotebook_result :: T.Protocol p => p -> P.IO ExpungeNotebook_result
read_ExpungeNotebook_result iprot = to_ExpungeNotebook_result <$> T.readVal iprot (T.T_STRUCT typemap_ExpungeNotebook_result)
decode_ExpungeNotebook_result :: T.StatelessProtocol p => p -> LBS.ByteString -> ExpungeNotebook_result
decode_ExpungeNotebook_result iprot bs = to_ExpungeNotebook_result $ T.deserializeVal iprot (T.T_STRUCT typemap_ExpungeNotebook_result) bs
typemap_ExpungeNotebook_result :: T.TypeMap
typemap_ExpungeNotebook_result = Map.fromList [(0,("success",T.T_I32)),(1,("userException",(T.T_STRUCT Errors_Types.typemap_EDAMUserException))),(2,("systemException",(T.T_STRUCT Errors_Types.typemap_EDAMSystemException))),(3,("notFoundException",(T.T_STRUCT Errors_Types.typemap_EDAMNotFoundException)))]
default_ExpungeNotebook_result :: ExpungeNotebook_result
default_ExpungeNotebook_result = ExpungeNotebook_result{
  expungeNotebook_result_success = 0,
  expungeNotebook_result_userException = P.Nothing,
  expungeNotebook_result_systemException = P.Nothing,
  expungeNotebook_result_notFoundException = P.Nothing}
data ListTags_args = ListTags_args  { listTags_args_authenticationToken :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ListTags_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` listTags_args_authenticationToken record  
instance QC.Arbitrary ListTags_args where 
  arbitrary = M.liftM ListTags_args (QC.arbitrary)
  shrink obj | obj == default_ListTags_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ListTags_args{listTags_args_authenticationToken = listTags_args_authenticationToken obj} then P.Nothing else P.Just $ default_ListTags_args{listTags_args_authenticationToken = listTags_args_authenticationToken obj}
    ]
from_ListTags_args :: ListTags_args -> T.ThriftVal
from_ListTags_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v726 -> P.Just (1, ("authenticationToken",T.TString $ E.encodeUtf8 _v726))) $ listTags_args_authenticationToken record
  ]
write_ListTags_args :: T.Protocol p => p -> ListTags_args -> P.IO ()
write_ListTags_args oprot record = T.writeVal oprot $ from_ListTags_args record
encode_ListTags_args :: T.StatelessProtocol p => p -> ListTags_args -> LBS.ByteString
encode_ListTags_args oprot record = T.serializeVal oprot $ from_ListTags_args record
to_ListTags_args :: T.ThriftVal -> ListTags_args
to_ListTags_args (T.TStruct fields) = ListTags_args{
  listTags_args_authenticationToken = P.maybe (listTags_args_authenticationToken default_ListTags_args) (\(_,_val728) -> (case _val728 of {T.TString _val729 -> E.decodeUtf8 _val729; _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_ListTags_args _ = P.error "not a struct"
read_ListTags_args :: T.Protocol p => p -> P.IO ListTags_args
read_ListTags_args iprot = to_ListTags_args <$> T.readVal iprot (T.T_STRUCT typemap_ListTags_args)
decode_ListTags_args :: T.StatelessProtocol p => p -> LBS.ByteString -> ListTags_args
decode_ListTags_args iprot bs = to_ListTags_args $ T.deserializeVal iprot (T.T_STRUCT typemap_ListTags_args) bs
typemap_ListTags_args :: T.TypeMap
typemap_ListTags_args = Map.fromList [(1,("authenticationToken",T.T_STRING))]
default_ListTags_args :: ListTags_args
default_ListTags_args = ListTags_args{
  listTags_args_authenticationToken = ""}
data ListTags_result = ListTags_result  { listTags_result_success :: (Vector.Vector Types_Types.Tag)
  , listTags_result_userException :: P.Maybe Errors_Types.EDAMUserException
  , listTags_result_systemException :: P.Maybe Errors_Types.EDAMSystemException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ListTags_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` listTags_result_success record   `H.hashWithSalt` listTags_result_userException record   `H.hashWithSalt` listTags_result_systemException record  
instance QC.Arbitrary ListTags_result where 
  arbitrary = M.liftM ListTags_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_ListTags_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ListTags_result{listTags_result_success = listTags_result_success obj} then P.Nothing else P.Just $ default_ListTags_result{listTags_result_success = listTags_result_success obj}
    , if obj == default_ListTags_result{listTags_result_userException = listTags_result_userException obj} then P.Nothing else P.Just $ default_ListTags_result{listTags_result_userException = listTags_result_userException obj}
    , if obj == default_ListTags_result{listTags_result_systemException = listTags_result_systemException obj} then P.Nothing else P.Just $ default_ListTags_result{listTags_result_systemException = listTags_result_systemException obj}
    ]
from_ListTags_result :: ListTags_result -> T.ThriftVal
from_ListTags_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v732 -> (1, ("userException",Errors_Types.from_EDAMUserException _v732))) <$> listTags_result_userException record, (\_v732 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v732))) <$> listTags_result_systemException record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v732 -> P.Just (0, ("success",T.TList (T.T_STRUCT Types_Types.typemap_Tag) $ P.map (\_v734 -> Types_Types.from_Tag _v734) $ Vector.toList _v732))) $ listTags_result_success record
    , (\_v732 -> (1, ("userException",Errors_Types.from_EDAMUserException _v732))) <$> listTags_result_userException record
    , (\_v732 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v732))) <$> listTags_result_systemException record
    ]
    )
write_ListTags_result :: T.Protocol p => p -> ListTags_result -> P.IO ()
write_ListTags_result oprot record = T.writeVal oprot $ from_ListTags_result record
encode_ListTags_result :: T.StatelessProtocol p => p -> ListTags_result -> LBS.ByteString
encode_ListTags_result oprot record = T.serializeVal oprot $ from_ListTags_result record
to_ListTags_result :: T.ThriftVal -> ListTags_result
to_ListTags_result (T.TStruct fields) = ListTags_result{
  listTags_result_success = P.maybe (listTags_result_success default_ListTags_result) (\(_,_val736) -> (case _val736 of {T.TList _ _val737 -> (Vector.fromList $ P.map (\_v738 -> (case _v738 of {T.TStruct _val739 -> (Types_Types.to_Tag (T.TStruct _val739)); _ -> P.error "wrong type"})) _val737); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  listTags_result_userException = P.maybe (P.Nothing) (\(_,_val736) -> P.Just (case _val736 of {T.TStruct _val740 -> (Errors_Types.to_EDAMUserException (T.TStruct _val740)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  listTags_result_systemException = P.maybe (P.Nothing) (\(_,_val736) -> P.Just (case _val736 of {T.TStruct _val741 -> (Errors_Types.to_EDAMSystemException (T.TStruct _val741)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_ListTags_result _ = P.error "not a struct"
read_ListTags_result :: T.Protocol p => p -> P.IO ListTags_result
read_ListTags_result iprot = to_ListTags_result <$> T.readVal iprot (T.T_STRUCT typemap_ListTags_result)
decode_ListTags_result :: T.StatelessProtocol p => p -> LBS.ByteString -> ListTags_result
decode_ListTags_result iprot bs = to_ListTags_result $ T.deserializeVal iprot (T.T_STRUCT typemap_ListTags_result) bs
typemap_ListTags_result :: T.TypeMap
typemap_ListTags_result = Map.fromList [(0,("success",(T.T_LIST (T.T_STRUCT Types_Types.typemap_Tag)))),(1,("userException",(T.T_STRUCT Errors_Types.typemap_EDAMUserException))),(2,("systemException",(T.T_STRUCT Errors_Types.typemap_EDAMSystemException)))]
default_ListTags_result :: ListTags_result
default_ListTags_result = ListTags_result{
  listTags_result_success = Vector.empty,
  listTags_result_userException = P.Nothing,
  listTags_result_systemException = P.Nothing}
data ListTagsByNotebook_args = ListTagsByNotebook_args  { listTagsByNotebook_args_authenticationToken :: LT.Text
  , listTagsByNotebook_args_notebookGuid :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ListTagsByNotebook_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` listTagsByNotebook_args_authenticationToken record   `H.hashWithSalt` listTagsByNotebook_args_notebookGuid record  
instance QC.Arbitrary ListTagsByNotebook_args where 
  arbitrary = M.liftM ListTagsByNotebook_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_ListTagsByNotebook_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ListTagsByNotebook_args{listTagsByNotebook_args_authenticationToken = listTagsByNotebook_args_authenticationToken obj} then P.Nothing else P.Just $ default_ListTagsByNotebook_args{listTagsByNotebook_args_authenticationToken = listTagsByNotebook_args_authenticationToken obj}
    , if obj == default_ListTagsByNotebook_args{listTagsByNotebook_args_notebookGuid = listTagsByNotebook_args_notebookGuid obj} then P.Nothing else P.Just $ default_ListTagsByNotebook_args{listTagsByNotebook_args_notebookGuid = listTagsByNotebook_args_notebookGuid obj}
    ]
from_ListTagsByNotebook_args :: ListTagsByNotebook_args -> T.ThriftVal
from_ListTagsByNotebook_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v744 -> P.Just (1, ("authenticationToken",T.TString $ E.encodeUtf8 _v744))) $ listTagsByNotebook_args_authenticationToken record
  , (\_v744 -> P.Just (2, ("notebookGuid",T.TString $ E.encodeUtf8 _v744))) $ listTagsByNotebook_args_notebookGuid record
  ]
write_ListTagsByNotebook_args :: T.Protocol p => p -> ListTagsByNotebook_args -> P.IO ()
write_ListTagsByNotebook_args oprot record = T.writeVal oprot $ from_ListTagsByNotebook_args record
encode_ListTagsByNotebook_args :: T.StatelessProtocol p => p -> ListTagsByNotebook_args -> LBS.ByteString
encode_ListTagsByNotebook_args oprot record = T.serializeVal oprot $ from_ListTagsByNotebook_args record
to_ListTagsByNotebook_args :: T.ThriftVal -> ListTagsByNotebook_args
to_ListTagsByNotebook_args (T.TStruct fields) = ListTagsByNotebook_args{
  listTagsByNotebook_args_authenticationToken = P.maybe (listTagsByNotebook_args_authenticationToken default_ListTagsByNotebook_args) (\(_,_val746) -> (case _val746 of {T.TString _val747 -> E.decodeUtf8 _val747; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  listTagsByNotebook_args_notebookGuid = P.maybe (listTagsByNotebook_args_notebookGuid default_ListTagsByNotebook_args) (\(_,_val746) -> (case _val746 of {T.TString _val748 -> E.decodeUtf8 _val748; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_ListTagsByNotebook_args _ = P.error "not a struct"
read_ListTagsByNotebook_args :: T.Protocol p => p -> P.IO ListTagsByNotebook_args
read_ListTagsByNotebook_args iprot = to_ListTagsByNotebook_args <$> T.readVal iprot (T.T_STRUCT typemap_ListTagsByNotebook_args)
decode_ListTagsByNotebook_args :: T.StatelessProtocol p => p -> LBS.ByteString -> ListTagsByNotebook_args
decode_ListTagsByNotebook_args iprot bs = to_ListTagsByNotebook_args $ T.deserializeVal iprot (T.T_STRUCT typemap_ListTagsByNotebook_args) bs
typemap_ListTagsByNotebook_args :: T.TypeMap
typemap_ListTagsByNotebook_args = Map.fromList [(1,("authenticationToken",T.T_STRING)),(2,("notebookGuid",T.T_STRING))]
default_ListTagsByNotebook_args :: ListTagsByNotebook_args
default_ListTagsByNotebook_args = ListTagsByNotebook_args{
  listTagsByNotebook_args_authenticationToken = "",
  listTagsByNotebook_args_notebookGuid = ""}
data ListTagsByNotebook_result = ListTagsByNotebook_result  { listTagsByNotebook_result_success :: (Vector.Vector Types_Types.Tag)
  , listTagsByNotebook_result_userException :: P.Maybe Errors_Types.EDAMUserException
  , listTagsByNotebook_result_systemException :: P.Maybe Errors_Types.EDAMSystemException
  , listTagsByNotebook_result_notFoundException :: P.Maybe Errors_Types.EDAMNotFoundException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ListTagsByNotebook_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` listTagsByNotebook_result_success record   `H.hashWithSalt` listTagsByNotebook_result_userException record   `H.hashWithSalt` listTagsByNotebook_result_systemException record   `H.hashWithSalt` listTagsByNotebook_result_notFoundException record  
instance QC.Arbitrary ListTagsByNotebook_result where 
  arbitrary = M.liftM ListTagsByNotebook_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_ListTagsByNotebook_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ListTagsByNotebook_result{listTagsByNotebook_result_success = listTagsByNotebook_result_success obj} then P.Nothing else P.Just $ default_ListTagsByNotebook_result{listTagsByNotebook_result_success = listTagsByNotebook_result_success obj}
    , if obj == default_ListTagsByNotebook_result{listTagsByNotebook_result_userException = listTagsByNotebook_result_userException obj} then P.Nothing else P.Just $ default_ListTagsByNotebook_result{listTagsByNotebook_result_userException = listTagsByNotebook_result_userException obj}
    , if obj == default_ListTagsByNotebook_result{listTagsByNotebook_result_systemException = listTagsByNotebook_result_systemException obj} then P.Nothing else P.Just $ default_ListTagsByNotebook_result{listTagsByNotebook_result_systemException = listTagsByNotebook_result_systemException obj}
    , if obj == default_ListTagsByNotebook_result{listTagsByNotebook_result_notFoundException = listTagsByNotebook_result_notFoundException obj} then P.Nothing else P.Just $ default_ListTagsByNotebook_result{listTagsByNotebook_result_notFoundException = listTagsByNotebook_result_notFoundException obj}
    ]
from_ListTagsByNotebook_result :: ListTagsByNotebook_result -> T.ThriftVal
from_ListTagsByNotebook_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v751 -> (1, ("userException",Errors_Types.from_EDAMUserException _v751))) <$> listTagsByNotebook_result_userException record, (\_v751 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v751))) <$> listTagsByNotebook_result_systemException record, (\_v751 -> (3, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v751))) <$> listTagsByNotebook_result_notFoundException record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v751 -> P.Just (0, ("success",T.TList (T.T_STRUCT Types_Types.typemap_Tag) $ P.map (\_v753 -> Types_Types.from_Tag _v753) $ Vector.toList _v751))) $ listTagsByNotebook_result_success record
    , (\_v751 -> (1, ("userException",Errors_Types.from_EDAMUserException _v751))) <$> listTagsByNotebook_result_userException record
    , (\_v751 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v751))) <$> listTagsByNotebook_result_systemException record
    , (\_v751 -> (3, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v751))) <$> listTagsByNotebook_result_notFoundException record
    ]
    )
write_ListTagsByNotebook_result :: T.Protocol p => p -> ListTagsByNotebook_result -> P.IO ()
write_ListTagsByNotebook_result oprot record = T.writeVal oprot $ from_ListTagsByNotebook_result record
encode_ListTagsByNotebook_result :: T.StatelessProtocol p => p -> ListTagsByNotebook_result -> LBS.ByteString
encode_ListTagsByNotebook_result oprot record = T.serializeVal oprot $ from_ListTagsByNotebook_result record
to_ListTagsByNotebook_result :: T.ThriftVal -> ListTagsByNotebook_result
to_ListTagsByNotebook_result (T.TStruct fields) = ListTagsByNotebook_result{
  listTagsByNotebook_result_success = P.maybe (listTagsByNotebook_result_success default_ListTagsByNotebook_result) (\(_,_val755) -> (case _val755 of {T.TList _ _val756 -> (Vector.fromList $ P.map (\_v757 -> (case _v757 of {T.TStruct _val758 -> (Types_Types.to_Tag (T.TStruct _val758)); _ -> P.error "wrong type"})) _val756); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  listTagsByNotebook_result_userException = P.maybe (P.Nothing) (\(_,_val755) -> P.Just (case _val755 of {T.TStruct _val759 -> (Errors_Types.to_EDAMUserException (T.TStruct _val759)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  listTagsByNotebook_result_systemException = P.maybe (P.Nothing) (\(_,_val755) -> P.Just (case _val755 of {T.TStruct _val760 -> (Errors_Types.to_EDAMSystemException (T.TStruct _val760)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  listTagsByNotebook_result_notFoundException = P.maybe (P.Nothing) (\(_,_val755) -> P.Just (case _val755 of {T.TStruct _val761 -> (Errors_Types.to_EDAMNotFoundException (T.TStruct _val761)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_ListTagsByNotebook_result _ = P.error "not a struct"
read_ListTagsByNotebook_result :: T.Protocol p => p -> P.IO ListTagsByNotebook_result
read_ListTagsByNotebook_result iprot = to_ListTagsByNotebook_result <$> T.readVal iprot (T.T_STRUCT typemap_ListTagsByNotebook_result)
decode_ListTagsByNotebook_result :: T.StatelessProtocol p => p -> LBS.ByteString -> ListTagsByNotebook_result
decode_ListTagsByNotebook_result iprot bs = to_ListTagsByNotebook_result $ T.deserializeVal iprot (T.T_STRUCT typemap_ListTagsByNotebook_result) bs
typemap_ListTagsByNotebook_result :: T.TypeMap
typemap_ListTagsByNotebook_result = Map.fromList [(0,("success",(T.T_LIST (T.T_STRUCT Types_Types.typemap_Tag)))),(1,("userException",(T.T_STRUCT Errors_Types.typemap_EDAMUserException))),(2,("systemException",(T.T_STRUCT Errors_Types.typemap_EDAMSystemException))),(3,("notFoundException",(T.T_STRUCT Errors_Types.typemap_EDAMNotFoundException)))]
default_ListTagsByNotebook_result :: ListTagsByNotebook_result
default_ListTagsByNotebook_result = ListTagsByNotebook_result{
  listTagsByNotebook_result_success = Vector.empty,
  listTagsByNotebook_result_userException = P.Nothing,
  listTagsByNotebook_result_systemException = P.Nothing,
  listTagsByNotebook_result_notFoundException = P.Nothing}
data GetTag_args = GetTag_args  { getTag_args_authenticationToken :: LT.Text
  , getTag_args_guid :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetTag_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getTag_args_authenticationToken record   `H.hashWithSalt` getTag_args_guid record  
instance QC.Arbitrary GetTag_args where 
  arbitrary = M.liftM GetTag_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GetTag_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetTag_args{getTag_args_authenticationToken = getTag_args_authenticationToken obj} then P.Nothing else P.Just $ default_GetTag_args{getTag_args_authenticationToken = getTag_args_authenticationToken obj}
    , if obj == default_GetTag_args{getTag_args_guid = getTag_args_guid obj} then P.Nothing else P.Just $ default_GetTag_args{getTag_args_guid = getTag_args_guid obj}
    ]
from_GetTag_args :: GetTag_args -> T.ThriftVal
from_GetTag_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v764 -> P.Just (1, ("authenticationToken",T.TString $ E.encodeUtf8 _v764))) $ getTag_args_authenticationToken record
  , (\_v764 -> P.Just (2, ("guid",T.TString $ E.encodeUtf8 _v764))) $ getTag_args_guid record
  ]
write_GetTag_args :: T.Protocol p => p -> GetTag_args -> P.IO ()
write_GetTag_args oprot record = T.writeVal oprot $ from_GetTag_args record
encode_GetTag_args :: T.StatelessProtocol p => p -> GetTag_args -> LBS.ByteString
encode_GetTag_args oprot record = T.serializeVal oprot $ from_GetTag_args record
to_GetTag_args :: T.ThriftVal -> GetTag_args
to_GetTag_args (T.TStruct fields) = GetTag_args{
  getTag_args_authenticationToken = P.maybe (getTag_args_authenticationToken default_GetTag_args) (\(_,_val766) -> (case _val766 of {T.TString _val767 -> E.decodeUtf8 _val767; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  getTag_args_guid = P.maybe (getTag_args_guid default_GetTag_args) (\(_,_val766) -> (case _val766 of {T.TString _val768 -> E.decodeUtf8 _val768; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_GetTag_args _ = P.error "not a struct"
read_GetTag_args :: T.Protocol p => p -> P.IO GetTag_args
read_GetTag_args iprot = to_GetTag_args <$> T.readVal iprot (T.T_STRUCT typemap_GetTag_args)
decode_GetTag_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetTag_args
decode_GetTag_args iprot bs = to_GetTag_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetTag_args) bs
typemap_GetTag_args :: T.TypeMap
typemap_GetTag_args = Map.fromList [(1,("authenticationToken",T.T_STRING)),(2,("guid",T.T_STRING))]
default_GetTag_args :: GetTag_args
default_GetTag_args = GetTag_args{
  getTag_args_authenticationToken = "",
  getTag_args_guid = ""}
data GetTag_result = GetTag_result  { getTag_result_success :: Types_Types.Tag
  , getTag_result_userException :: P.Maybe Errors_Types.EDAMUserException
  , getTag_result_systemException :: P.Maybe Errors_Types.EDAMSystemException
  , getTag_result_notFoundException :: P.Maybe Errors_Types.EDAMNotFoundException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetTag_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getTag_result_success record   `H.hashWithSalt` getTag_result_userException record   `H.hashWithSalt` getTag_result_systemException record   `H.hashWithSalt` getTag_result_notFoundException record  
instance QC.Arbitrary GetTag_result where 
  arbitrary = M.liftM GetTag_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetTag_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetTag_result{getTag_result_success = getTag_result_success obj} then P.Nothing else P.Just $ default_GetTag_result{getTag_result_success = getTag_result_success obj}
    , if obj == default_GetTag_result{getTag_result_userException = getTag_result_userException obj} then P.Nothing else P.Just $ default_GetTag_result{getTag_result_userException = getTag_result_userException obj}
    , if obj == default_GetTag_result{getTag_result_systemException = getTag_result_systemException obj} then P.Nothing else P.Just $ default_GetTag_result{getTag_result_systemException = getTag_result_systemException obj}
    , if obj == default_GetTag_result{getTag_result_notFoundException = getTag_result_notFoundException obj} then P.Nothing else P.Just $ default_GetTag_result{getTag_result_notFoundException = getTag_result_notFoundException obj}
    ]
from_GetTag_result :: GetTag_result -> T.ThriftVal
from_GetTag_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v771 -> (1, ("userException",Errors_Types.from_EDAMUserException _v771))) <$> getTag_result_userException record, (\_v771 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v771))) <$> getTag_result_systemException record, (\_v771 -> (3, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v771))) <$> getTag_result_notFoundException record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v771 -> P.Just (0, ("success",Types_Types.from_Tag _v771))) $ getTag_result_success record
    , (\_v771 -> (1, ("userException",Errors_Types.from_EDAMUserException _v771))) <$> getTag_result_userException record
    , (\_v771 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v771))) <$> getTag_result_systemException record
    , (\_v771 -> (3, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v771))) <$> getTag_result_notFoundException record
    ]
    )
write_GetTag_result :: T.Protocol p => p -> GetTag_result -> P.IO ()
write_GetTag_result oprot record = T.writeVal oprot $ from_GetTag_result record
encode_GetTag_result :: T.StatelessProtocol p => p -> GetTag_result -> LBS.ByteString
encode_GetTag_result oprot record = T.serializeVal oprot $ from_GetTag_result record
to_GetTag_result :: T.ThriftVal -> GetTag_result
to_GetTag_result (T.TStruct fields) = GetTag_result{
  getTag_result_success = P.maybe (getTag_result_success default_GetTag_result) (\(_,_val773) -> (case _val773 of {T.TStruct _val774 -> (Types_Types.to_Tag (T.TStruct _val774)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getTag_result_userException = P.maybe (P.Nothing) (\(_,_val773) -> P.Just (case _val773 of {T.TStruct _val775 -> (Errors_Types.to_EDAMUserException (T.TStruct _val775)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  getTag_result_systemException = P.maybe (P.Nothing) (\(_,_val773) -> P.Just (case _val773 of {T.TStruct _val776 -> (Errors_Types.to_EDAMSystemException (T.TStruct _val776)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  getTag_result_notFoundException = P.maybe (P.Nothing) (\(_,_val773) -> P.Just (case _val773 of {T.TStruct _val777 -> (Errors_Types.to_EDAMNotFoundException (T.TStruct _val777)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_GetTag_result _ = P.error "not a struct"
read_GetTag_result :: T.Protocol p => p -> P.IO GetTag_result
read_GetTag_result iprot = to_GetTag_result <$> T.readVal iprot (T.T_STRUCT typemap_GetTag_result)
decode_GetTag_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetTag_result
decode_GetTag_result iprot bs = to_GetTag_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetTag_result) bs
typemap_GetTag_result :: T.TypeMap
typemap_GetTag_result = Map.fromList [(0,("success",(T.T_STRUCT Types_Types.typemap_Tag))),(1,("userException",(T.T_STRUCT Errors_Types.typemap_EDAMUserException))),(2,("systemException",(T.T_STRUCT Errors_Types.typemap_EDAMSystemException))),(3,("notFoundException",(T.T_STRUCT Errors_Types.typemap_EDAMNotFoundException)))]
default_GetTag_result :: GetTag_result
default_GetTag_result = GetTag_result{
  getTag_result_success = Types_Types.default_Tag,
  getTag_result_userException = P.Nothing,
  getTag_result_systemException = P.Nothing,
  getTag_result_notFoundException = P.Nothing}
data CreateTag_args = CreateTag_args  { createTag_args_authenticationToken :: LT.Text
  , createTag_args_tag :: Types_Types.Tag
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable CreateTag_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` createTag_args_authenticationToken record   `H.hashWithSalt` createTag_args_tag record  
instance QC.Arbitrary CreateTag_args where 
  arbitrary = M.liftM CreateTag_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_CreateTag_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_CreateTag_args{createTag_args_authenticationToken = createTag_args_authenticationToken obj} then P.Nothing else P.Just $ default_CreateTag_args{createTag_args_authenticationToken = createTag_args_authenticationToken obj}
    , if obj == default_CreateTag_args{createTag_args_tag = createTag_args_tag obj} then P.Nothing else P.Just $ default_CreateTag_args{createTag_args_tag = createTag_args_tag obj}
    ]
from_CreateTag_args :: CreateTag_args -> T.ThriftVal
from_CreateTag_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v780 -> P.Just (1, ("authenticationToken",T.TString $ E.encodeUtf8 _v780))) $ createTag_args_authenticationToken record
  , (\_v780 -> P.Just (2, ("tag",Types_Types.from_Tag _v780))) $ createTag_args_tag record
  ]
write_CreateTag_args :: T.Protocol p => p -> CreateTag_args -> P.IO ()
write_CreateTag_args oprot record = T.writeVal oprot $ from_CreateTag_args record
encode_CreateTag_args :: T.StatelessProtocol p => p -> CreateTag_args -> LBS.ByteString
encode_CreateTag_args oprot record = T.serializeVal oprot $ from_CreateTag_args record
to_CreateTag_args :: T.ThriftVal -> CreateTag_args
to_CreateTag_args (T.TStruct fields) = CreateTag_args{
  createTag_args_authenticationToken = P.maybe (createTag_args_authenticationToken default_CreateTag_args) (\(_,_val782) -> (case _val782 of {T.TString _val783 -> E.decodeUtf8 _val783; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  createTag_args_tag = P.maybe (createTag_args_tag default_CreateTag_args) (\(_,_val782) -> (case _val782 of {T.TStruct _val784 -> (Types_Types.to_Tag (T.TStruct _val784)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_CreateTag_args _ = P.error "not a struct"
read_CreateTag_args :: T.Protocol p => p -> P.IO CreateTag_args
read_CreateTag_args iprot = to_CreateTag_args <$> T.readVal iprot (T.T_STRUCT typemap_CreateTag_args)
decode_CreateTag_args :: T.StatelessProtocol p => p -> LBS.ByteString -> CreateTag_args
decode_CreateTag_args iprot bs = to_CreateTag_args $ T.deserializeVal iprot (T.T_STRUCT typemap_CreateTag_args) bs
typemap_CreateTag_args :: T.TypeMap
typemap_CreateTag_args = Map.fromList [(1,("authenticationToken",T.T_STRING)),(2,("tag",(T.T_STRUCT Types_Types.typemap_Tag)))]
default_CreateTag_args :: CreateTag_args
default_CreateTag_args = CreateTag_args{
  createTag_args_authenticationToken = "",
  createTag_args_tag = Types_Types.default_Tag}
data CreateTag_result = CreateTag_result  { createTag_result_success :: Types_Types.Tag
  , createTag_result_userException :: P.Maybe Errors_Types.EDAMUserException
  , createTag_result_systemException :: P.Maybe Errors_Types.EDAMSystemException
  , createTag_result_notFoundException :: P.Maybe Errors_Types.EDAMNotFoundException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable CreateTag_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` createTag_result_success record   `H.hashWithSalt` createTag_result_userException record   `H.hashWithSalt` createTag_result_systemException record   `H.hashWithSalt` createTag_result_notFoundException record  
instance QC.Arbitrary CreateTag_result where 
  arbitrary = M.liftM CreateTag_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_CreateTag_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_CreateTag_result{createTag_result_success = createTag_result_success obj} then P.Nothing else P.Just $ default_CreateTag_result{createTag_result_success = createTag_result_success obj}
    , if obj == default_CreateTag_result{createTag_result_userException = createTag_result_userException obj} then P.Nothing else P.Just $ default_CreateTag_result{createTag_result_userException = createTag_result_userException obj}
    , if obj == default_CreateTag_result{createTag_result_systemException = createTag_result_systemException obj} then P.Nothing else P.Just $ default_CreateTag_result{createTag_result_systemException = createTag_result_systemException obj}
    , if obj == default_CreateTag_result{createTag_result_notFoundException = createTag_result_notFoundException obj} then P.Nothing else P.Just $ default_CreateTag_result{createTag_result_notFoundException = createTag_result_notFoundException obj}
    ]
from_CreateTag_result :: CreateTag_result -> T.ThriftVal
from_CreateTag_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v787 -> (1, ("userException",Errors_Types.from_EDAMUserException _v787))) <$> createTag_result_userException record, (\_v787 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v787))) <$> createTag_result_systemException record, (\_v787 -> (3, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v787))) <$> createTag_result_notFoundException record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v787 -> P.Just (0, ("success",Types_Types.from_Tag _v787))) $ createTag_result_success record
    , (\_v787 -> (1, ("userException",Errors_Types.from_EDAMUserException _v787))) <$> createTag_result_userException record
    , (\_v787 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v787))) <$> createTag_result_systemException record
    , (\_v787 -> (3, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v787))) <$> createTag_result_notFoundException record
    ]
    )
write_CreateTag_result :: T.Protocol p => p -> CreateTag_result -> P.IO ()
write_CreateTag_result oprot record = T.writeVal oprot $ from_CreateTag_result record
encode_CreateTag_result :: T.StatelessProtocol p => p -> CreateTag_result -> LBS.ByteString
encode_CreateTag_result oprot record = T.serializeVal oprot $ from_CreateTag_result record
to_CreateTag_result :: T.ThriftVal -> CreateTag_result
to_CreateTag_result (T.TStruct fields) = CreateTag_result{
  createTag_result_success = P.maybe (createTag_result_success default_CreateTag_result) (\(_,_val789) -> (case _val789 of {T.TStruct _val790 -> (Types_Types.to_Tag (T.TStruct _val790)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  createTag_result_userException = P.maybe (P.Nothing) (\(_,_val789) -> P.Just (case _val789 of {T.TStruct _val791 -> (Errors_Types.to_EDAMUserException (T.TStruct _val791)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  createTag_result_systemException = P.maybe (P.Nothing) (\(_,_val789) -> P.Just (case _val789 of {T.TStruct _val792 -> (Errors_Types.to_EDAMSystemException (T.TStruct _val792)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  createTag_result_notFoundException = P.maybe (P.Nothing) (\(_,_val789) -> P.Just (case _val789 of {T.TStruct _val793 -> (Errors_Types.to_EDAMNotFoundException (T.TStruct _val793)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_CreateTag_result _ = P.error "not a struct"
read_CreateTag_result :: T.Protocol p => p -> P.IO CreateTag_result
read_CreateTag_result iprot = to_CreateTag_result <$> T.readVal iprot (T.T_STRUCT typemap_CreateTag_result)
decode_CreateTag_result :: T.StatelessProtocol p => p -> LBS.ByteString -> CreateTag_result
decode_CreateTag_result iprot bs = to_CreateTag_result $ T.deserializeVal iprot (T.T_STRUCT typemap_CreateTag_result) bs
typemap_CreateTag_result :: T.TypeMap
typemap_CreateTag_result = Map.fromList [(0,("success",(T.T_STRUCT Types_Types.typemap_Tag))),(1,("userException",(T.T_STRUCT Errors_Types.typemap_EDAMUserException))),(2,("systemException",(T.T_STRUCT Errors_Types.typemap_EDAMSystemException))),(3,("notFoundException",(T.T_STRUCT Errors_Types.typemap_EDAMNotFoundException)))]
default_CreateTag_result :: CreateTag_result
default_CreateTag_result = CreateTag_result{
  createTag_result_success = Types_Types.default_Tag,
  createTag_result_userException = P.Nothing,
  createTag_result_systemException = P.Nothing,
  createTag_result_notFoundException = P.Nothing}
data UpdateTag_args = UpdateTag_args  { updateTag_args_authenticationToken :: LT.Text
  , updateTag_args_tag :: Types_Types.Tag
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateTag_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateTag_args_authenticationToken record   `H.hashWithSalt` updateTag_args_tag record  
instance QC.Arbitrary UpdateTag_args where 
  arbitrary = M.liftM UpdateTag_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_UpdateTag_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateTag_args{updateTag_args_authenticationToken = updateTag_args_authenticationToken obj} then P.Nothing else P.Just $ default_UpdateTag_args{updateTag_args_authenticationToken = updateTag_args_authenticationToken obj}
    , if obj == default_UpdateTag_args{updateTag_args_tag = updateTag_args_tag obj} then P.Nothing else P.Just $ default_UpdateTag_args{updateTag_args_tag = updateTag_args_tag obj}
    ]
from_UpdateTag_args :: UpdateTag_args -> T.ThriftVal
from_UpdateTag_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v796 -> P.Just (1, ("authenticationToken",T.TString $ E.encodeUtf8 _v796))) $ updateTag_args_authenticationToken record
  , (\_v796 -> P.Just (2, ("tag",Types_Types.from_Tag _v796))) $ updateTag_args_tag record
  ]
write_UpdateTag_args :: T.Protocol p => p -> UpdateTag_args -> P.IO ()
write_UpdateTag_args oprot record = T.writeVal oprot $ from_UpdateTag_args record
encode_UpdateTag_args :: T.StatelessProtocol p => p -> UpdateTag_args -> LBS.ByteString
encode_UpdateTag_args oprot record = T.serializeVal oprot $ from_UpdateTag_args record
to_UpdateTag_args :: T.ThriftVal -> UpdateTag_args
to_UpdateTag_args (T.TStruct fields) = UpdateTag_args{
  updateTag_args_authenticationToken = P.maybe (updateTag_args_authenticationToken default_UpdateTag_args) (\(_,_val798) -> (case _val798 of {T.TString _val799 -> E.decodeUtf8 _val799; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  updateTag_args_tag = P.maybe (updateTag_args_tag default_UpdateTag_args) (\(_,_val798) -> (case _val798 of {T.TStruct _val800 -> (Types_Types.to_Tag (T.TStruct _val800)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_UpdateTag_args _ = P.error "not a struct"
read_UpdateTag_args :: T.Protocol p => p -> P.IO UpdateTag_args
read_UpdateTag_args iprot = to_UpdateTag_args <$> T.readVal iprot (T.T_STRUCT typemap_UpdateTag_args)
decode_UpdateTag_args :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateTag_args
decode_UpdateTag_args iprot bs = to_UpdateTag_args $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateTag_args) bs
typemap_UpdateTag_args :: T.TypeMap
typemap_UpdateTag_args = Map.fromList [(1,("authenticationToken",T.T_STRING)),(2,("tag",(T.T_STRUCT Types_Types.typemap_Tag)))]
default_UpdateTag_args :: UpdateTag_args
default_UpdateTag_args = UpdateTag_args{
  updateTag_args_authenticationToken = "",
  updateTag_args_tag = Types_Types.default_Tag}
data UpdateTag_result = UpdateTag_result  { updateTag_result_success :: I.Int32
  , updateTag_result_userException :: P.Maybe Errors_Types.EDAMUserException
  , updateTag_result_systemException :: P.Maybe Errors_Types.EDAMSystemException
  , updateTag_result_notFoundException :: P.Maybe Errors_Types.EDAMNotFoundException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateTag_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateTag_result_success record   `H.hashWithSalt` updateTag_result_userException record   `H.hashWithSalt` updateTag_result_systemException record   `H.hashWithSalt` updateTag_result_notFoundException record  
instance QC.Arbitrary UpdateTag_result where 
  arbitrary = M.liftM UpdateTag_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_UpdateTag_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateTag_result{updateTag_result_success = updateTag_result_success obj} then P.Nothing else P.Just $ default_UpdateTag_result{updateTag_result_success = updateTag_result_success obj}
    , if obj == default_UpdateTag_result{updateTag_result_userException = updateTag_result_userException obj} then P.Nothing else P.Just $ default_UpdateTag_result{updateTag_result_userException = updateTag_result_userException obj}
    , if obj == default_UpdateTag_result{updateTag_result_systemException = updateTag_result_systemException obj} then P.Nothing else P.Just $ default_UpdateTag_result{updateTag_result_systemException = updateTag_result_systemException obj}
    , if obj == default_UpdateTag_result{updateTag_result_notFoundException = updateTag_result_notFoundException obj} then P.Nothing else P.Just $ default_UpdateTag_result{updateTag_result_notFoundException = updateTag_result_notFoundException obj}
    ]
from_UpdateTag_result :: UpdateTag_result -> T.ThriftVal
from_UpdateTag_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v803 -> (1, ("userException",Errors_Types.from_EDAMUserException _v803))) <$> updateTag_result_userException record, (\_v803 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v803))) <$> updateTag_result_systemException record, (\_v803 -> (3, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v803))) <$> updateTag_result_notFoundException record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v803 -> P.Just (0, ("success",T.TI32 _v803))) $ updateTag_result_success record
    , (\_v803 -> (1, ("userException",Errors_Types.from_EDAMUserException _v803))) <$> updateTag_result_userException record
    , (\_v803 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v803))) <$> updateTag_result_systemException record
    , (\_v803 -> (3, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v803))) <$> updateTag_result_notFoundException record
    ]
    )
write_UpdateTag_result :: T.Protocol p => p -> UpdateTag_result -> P.IO ()
write_UpdateTag_result oprot record = T.writeVal oprot $ from_UpdateTag_result record
encode_UpdateTag_result :: T.StatelessProtocol p => p -> UpdateTag_result -> LBS.ByteString
encode_UpdateTag_result oprot record = T.serializeVal oprot $ from_UpdateTag_result record
to_UpdateTag_result :: T.ThriftVal -> UpdateTag_result
to_UpdateTag_result (T.TStruct fields) = UpdateTag_result{
  updateTag_result_success = P.maybe (updateTag_result_success default_UpdateTag_result) (\(_,_val805) -> (case _val805 of {T.TI32 _val806 -> _val806; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  updateTag_result_userException = P.maybe (P.Nothing) (\(_,_val805) -> P.Just (case _val805 of {T.TStruct _val807 -> (Errors_Types.to_EDAMUserException (T.TStruct _val807)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  updateTag_result_systemException = P.maybe (P.Nothing) (\(_,_val805) -> P.Just (case _val805 of {T.TStruct _val808 -> (Errors_Types.to_EDAMSystemException (T.TStruct _val808)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  updateTag_result_notFoundException = P.maybe (P.Nothing) (\(_,_val805) -> P.Just (case _val805 of {T.TStruct _val809 -> (Errors_Types.to_EDAMNotFoundException (T.TStruct _val809)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_UpdateTag_result _ = P.error "not a struct"
read_UpdateTag_result :: T.Protocol p => p -> P.IO UpdateTag_result
read_UpdateTag_result iprot = to_UpdateTag_result <$> T.readVal iprot (T.T_STRUCT typemap_UpdateTag_result)
decode_UpdateTag_result :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateTag_result
decode_UpdateTag_result iprot bs = to_UpdateTag_result $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateTag_result) bs
typemap_UpdateTag_result :: T.TypeMap
typemap_UpdateTag_result = Map.fromList [(0,("success",T.T_I32)),(1,("userException",(T.T_STRUCT Errors_Types.typemap_EDAMUserException))),(2,("systemException",(T.T_STRUCT Errors_Types.typemap_EDAMSystemException))),(3,("notFoundException",(T.T_STRUCT Errors_Types.typemap_EDAMNotFoundException)))]
default_UpdateTag_result :: UpdateTag_result
default_UpdateTag_result = UpdateTag_result{
  updateTag_result_success = 0,
  updateTag_result_userException = P.Nothing,
  updateTag_result_systemException = P.Nothing,
  updateTag_result_notFoundException = P.Nothing}
data UntagAll_args = UntagAll_args  { untagAll_args_authenticationToken :: LT.Text
  , untagAll_args_guid :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UntagAll_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` untagAll_args_authenticationToken record   `H.hashWithSalt` untagAll_args_guid record  
instance QC.Arbitrary UntagAll_args where 
  arbitrary = M.liftM UntagAll_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_UntagAll_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UntagAll_args{untagAll_args_authenticationToken = untagAll_args_authenticationToken obj} then P.Nothing else P.Just $ default_UntagAll_args{untagAll_args_authenticationToken = untagAll_args_authenticationToken obj}
    , if obj == default_UntagAll_args{untagAll_args_guid = untagAll_args_guid obj} then P.Nothing else P.Just $ default_UntagAll_args{untagAll_args_guid = untagAll_args_guid obj}
    ]
from_UntagAll_args :: UntagAll_args -> T.ThriftVal
from_UntagAll_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v812 -> P.Just (1, ("authenticationToken",T.TString $ E.encodeUtf8 _v812))) $ untagAll_args_authenticationToken record
  , (\_v812 -> P.Just (2, ("guid",T.TString $ E.encodeUtf8 _v812))) $ untagAll_args_guid record
  ]
write_UntagAll_args :: T.Protocol p => p -> UntagAll_args -> P.IO ()
write_UntagAll_args oprot record = T.writeVal oprot $ from_UntagAll_args record
encode_UntagAll_args :: T.StatelessProtocol p => p -> UntagAll_args -> LBS.ByteString
encode_UntagAll_args oprot record = T.serializeVal oprot $ from_UntagAll_args record
to_UntagAll_args :: T.ThriftVal -> UntagAll_args
to_UntagAll_args (T.TStruct fields) = UntagAll_args{
  untagAll_args_authenticationToken = P.maybe (untagAll_args_authenticationToken default_UntagAll_args) (\(_,_val814) -> (case _val814 of {T.TString _val815 -> E.decodeUtf8 _val815; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  untagAll_args_guid = P.maybe (untagAll_args_guid default_UntagAll_args) (\(_,_val814) -> (case _val814 of {T.TString _val816 -> E.decodeUtf8 _val816; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_UntagAll_args _ = P.error "not a struct"
read_UntagAll_args :: T.Protocol p => p -> P.IO UntagAll_args
read_UntagAll_args iprot = to_UntagAll_args <$> T.readVal iprot (T.T_STRUCT typemap_UntagAll_args)
decode_UntagAll_args :: T.StatelessProtocol p => p -> LBS.ByteString -> UntagAll_args
decode_UntagAll_args iprot bs = to_UntagAll_args $ T.deserializeVal iprot (T.T_STRUCT typemap_UntagAll_args) bs
typemap_UntagAll_args :: T.TypeMap
typemap_UntagAll_args = Map.fromList [(1,("authenticationToken",T.T_STRING)),(2,("guid",T.T_STRING))]
default_UntagAll_args :: UntagAll_args
default_UntagAll_args = UntagAll_args{
  untagAll_args_authenticationToken = "",
  untagAll_args_guid = ""}
data UntagAll_result = UntagAll_result  { untagAll_result_userException :: P.Maybe Errors_Types.EDAMUserException
  , untagAll_result_systemException :: P.Maybe Errors_Types.EDAMSystemException
  , untagAll_result_notFoundException :: P.Maybe Errors_Types.EDAMNotFoundException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UntagAll_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` untagAll_result_userException record   `H.hashWithSalt` untagAll_result_systemException record   `H.hashWithSalt` untagAll_result_notFoundException record  
instance QC.Arbitrary UntagAll_result where 
  arbitrary = M.liftM UntagAll_result (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_UntagAll_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UntagAll_result{untagAll_result_userException = untagAll_result_userException obj} then P.Nothing else P.Just $ default_UntagAll_result{untagAll_result_userException = untagAll_result_userException obj}
    , if obj == default_UntagAll_result{untagAll_result_systemException = untagAll_result_systemException obj} then P.Nothing else P.Just $ default_UntagAll_result{untagAll_result_systemException = untagAll_result_systemException obj}
    , if obj == default_UntagAll_result{untagAll_result_notFoundException = untagAll_result_notFoundException obj} then P.Nothing else P.Just $ default_UntagAll_result{untagAll_result_notFoundException = untagAll_result_notFoundException obj}
    ]
from_UntagAll_result :: UntagAll_result -> T.ThriftVal
from_UntagAll_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v819 -> (1, ("userException",Errors_Types.from_EDAMUserException _v819))) <$> untagAll_result_userException record, (\_v819 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v819))) <$> untagAll_result_systemException record, (\_v819 -> (3, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v819))) <$> untagAll_result_notFoundException record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v819 -> (1, ("userException",Errors_Types.from_EDAMUserException _v819))) <$> untagAll_result_userException record
    , (\_v819 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v819))) <$> untagAll_result_systemException record
    , (\_v819 -> (3, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v819))) <$> untagAll_result_notFoundException record
    ]
    )
write_UntagAll_result :: T.Protocol p => p -> UntagAll_result -> P.IO ()
write_UntagAll_result oprot record = T.writeVal oprot $ from_UntagAll_result record
encode_UntagAll_result :: T.StatelessProtocol p => p -> UntagAll_result -> LBS.ByteString
encode_UntagAll_result oprot record = T.serializeVal oprot $ from_UntagAll_result record
to_UntagAll_result :: T.ThriftVal -> UntagAll_result
to_UntagAll_result (T.TStruct fields) = UntagAll_result{
  untagAll_result_userException = P.maybe (P.Nothing) (\(_,_val821) -> P.Just (case _val821 of {T.TStruct _val822 -> (Errors_Types.to_EDAMUserException (T.TStruct _val822)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  untagAll_result_systemException = P.maybe (P.Nothing) (\(_,_val821) -> P.Just (case _val821 of {T.TStruct _val823 -> (Errors_Types.to_EDAMSystemException (T.TStruct _val823)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  untagAll_result_notFoundException = P.maybe (P.Nothing) (\(_,_val821) -> P.Just (case _val821 of {T.TStruct _val824 -> (Errors_Types.to_EDAMNotFoundException (T.TStruct _val824)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_UntagAll_result _ = P.error "not a struct"
read_UntagAll_result :: T.Protocol p => p -> P.IO UntagAll_result
read_UntagAll_result iprot = to_UntagAll_result <$> T.readVal iprot (T.T_STRUCT typemap_UntagAll_result)
decode_UntagAll_result :: T.StatelessProtocol p => p -> LBS.ByteString -> UntagAll_result
decode_UntagAll_result iprot bs = to_UntagAll_result $ T.deserializeVal iprot (T.T_STRUCT typemap_UntagAll_result) bs
typemap_UntagAll_result :: T.TypeMap
typemap_UntagAll_result = Map.fromList [(1,("userException",(T.T_STRUCT Errors_Types.typemap_EDAMUserException))),(2,("systemException",(T.T_STRUCT Errors_Types.typemap_EDAMSystemException))),(3,("notFoundException",(T.T_STRUCT Errors_Types.typemap_EDAMNotFoundException)))]
default_UntagAll_result :: UntagAll_result
default_UntagAll_result = UntagAll_result{
  untagAll_result_userException = P.Nothing,
  untagAll_result_systemException = P.Nothing,
  untagAll_result_notFoundException = P.Nothing}
data ExpungeTag_args = ExpungeTag_args  { expungeTag_args_authenticationToken :: LT.Text
  , expungeTag_args_guid :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ExpungeTag_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` expungeTag_args_authenticationToken record   `H.hashWithSalt` expungeTag_args_guid record  
instance QC.Arbitrary ExpungeTag_args where 
  arbitrary = M.liftM ExpungeTag_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_ExpungeTag_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ExpungeTag_args{expungeTag_args_authenticationToken = expungeTag_args_authenticationToken obj} then P.Nothing else P.Just $ default_ExpungeTag_args{expungeTag_args_authenticationToken = expungeTag_args_authenticationToken obj}
    , if obj == default_ExpungeTag_args{expungeTag_args_guid = expungeTag_args_guid obj} then P.Nothing else P.Just $ default_ExpungeTag_args{expungeTag_args_guid = expungeTag_args_guid obj}
    ]
from_ExpungeTag_args :: ExpungeTag_args -> T.ThriftVal
from_ExpungeTag_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v827 -> P.Just (1, ("authenticationToken",T.TString $ E.encodeUtf8 _v827))) $ expungeTag_args_authenticationToken record
  , (\_v827 -> P.Just (2, ("guid",T.TString $ E.encodeUtf8 _v827))) $ expungeTag_args_guid record
  ]
write_ExpungeTag_args :: T.Protocol p => p -> ExpungeTag_args -> P.IO ()
write_ExpungeTag_args oprot record = T.writeVal oprot $ from_ExpungeTag_args record
encode_ExpungeTag_args :: T.StatelessProtocol p => p -> ExpungeTag_args -> LBS.ByteString
encode_ExpungeTag_args oprot record = T.serializeVal oprot $ from_ExpungeTag_args record
to_ExpungeTag_args :: T.ThriftVal -> ExpungeTag_args
to_ExpungeTag_args (T.TStruct fields) = ExpungeTag_args{
  expungeTag_args_authenticationToken = P.maybe (expungeTag_args_authenticationToken default_ExpungeTag_args) (\(_,_val829) -> (case _val829 of {T.TString _val830 -> E.decodeUtf8 _val830; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  expungeTag_args_guid = P.maybe (expungeTag_args_guid default_ExpungeTag_args) (\(_,_val829) -> (case _val829 of {T.TString _val831 -> E.decodeUtf8 _val831; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_ExpungeTag_args _ = P.error "not a struct"
read_ExpungeTag_args :: T.Protocol p => p -> P.IO ExpungeTag_args
read_ExpungeTag_args iprot = to_ExpungeTag_args <$> T.readVal iprot (T.T_STRUCT typemap_ExpungeTag_args)
decode_ExpungeTag_args :: T.StatelessProtocol p => p -> LBS.ByteString -> ExpungeTag_args
decode_ExpungeTag_args iprot bs = to_ExpungeTag_args $ T.deserializeVal iprot (T.T_STRUCT typemap_ExpungeTag_args) bs
typemap_ExpungeTag_args :: T.TypeMap
typemap_ExpungeTag_args = Map.fromList [(1,("authenticationToken",T.T_STRING)),(2,("guid",T.T_STRING))]
default_ExpungeTag_args :: ExpungeTag_args
default_ExpungeTag_args = ExpungeTag_args{
  expungeTag_args_authenticationToken = "",
  expungeTag_args_guid = ""}
data ExpungeTag_result = ExpungeTag_result  { expungeTag_result_success :: I.Int32
  , expungeTag_result_userException :: P.Maybe Errors_Types.EDAMUserException
  , expungeTag_result_systemException :: P.Maybe Errors_Types.EDAMSystemException
  , expungeTag_result_notFoundException :: P.Maybe Errors_Types.EDAMNotFoundException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ExpungeTag_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` expungeTag_result_success record   `H.hashWithSalt` expungeTag_result_userException record   `H.hashWithSalt` expungeTag_result_systemException record   `H.hashWithSalt` expungeTag_result_notFoundException record  
instance QC.Arbitrary ExpungeTag_result where 
  arbitrary = M.liftM ExpungeTag_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_ExpungeTag_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ExpungeTag_result{expungeTag_result_success = expungeTag_result_success obj} then P.Nothing else P.Just $ default_ExpungeTag_result{expungeTag_result_success = expungeTag_result_success obj}
    , if obj == default_ExpungeTag_result{expungeTag_result_userException = expungeTag_result_userException obj} then P.Nothing else P.Just $ default_ExpungeTag_result{expungeTag_result_userException = expungeTag_result_userException obj}
    , if obj == default_ExpungeTag_result{expungeTag_result_systemException = expungeTag_result_systemException obj} then P.Nothing else P.Just $ default_ExpungeTag_result{expungeTag_result_systemException = expungeTag_result_systemException obj}
    , if obj == default_ExpungeTag_result{expungeTag_result_notFoundException = expungeTag_result_notFoundException obj} then P.Nothing else P.Just $ default_ExpungeTag_result{expungeTag_result_notFoundException = expungeTag_result_notFoundException obj}
    ]
from_ExpungeTag_result :: ExpungeTag_result -> T.ThriftVal
from_ExpungeTag_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v834 -> (1, ("userException",Errors_Types.from_EDAMUserException _v834))) <$> expungeTag_result_userException record, (\_v834 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v834))) <$> expungeTag_result_systemException record, (\_v834 -> (3, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v834))) <$> expungeTag_result_notFoundException record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v834 -> P.Just (0, ("success",T.TI32 _v834))) $ expungeTag_result_success record
    , (\_v834 -> (1, ("userException",Errors_Types.from_EDAMUserException _v834))) <$> expungeTag_result_userException record
    , (\_v834 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v834))) <$> expungeTag_result_systemException record
    , (\_v834 -> (3, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v834))) <$> expungeTag_result_notFoundException record
    ]
    )
write_ExpungeTag_result :: T.Protocol p => p -> ExpungeTag_result -> P.IO ()
write_ExpungeTag_result oprot record = T.writeVal oprot $ from_ExpungeTag_result record
encode_ExpungeTag_result :: T.StatelessProtocol p => p -> ExpungeTag_result -> LBS.ByteString
encode_ExpungeTag_result oprot record = T.serializeVal oprot $ from_ExpungeTag_result record
to_ExpungeTag_result :: T.ThriftVal -> ExpungeTag_result
to_ExpungeTag_result (T.TStruct fields) = ExpungeTag_result{
  expungeTag_result_success = P.maybe (expungeTag_result_success default_ExpungeTag_result) (\(_,_val836) -> (case _val836 of {T.TI32 _val837 -> _val837; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  expungeTag_result_userException = P.maybe (P.Nothing) (\(_,_val836) -> P.Just (case _val836 of {T.TStruct _val838 -> (Errors_Types.to_EDAMUserException (T.TStruct _val838)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  expungeTag_result_systemException = P.maybe (P.Nothing) (\(_,_val836) -> P.Just (case _val836 of {T.TStruct _val839 -> (Errors_Types.to_EDAMSystemException (T.TStruct _val839)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  expungeTag_result_notFoundException = P.maybe (P.Nothing) (\(_,_val836) -> P.Just (case _val836 of {T.TStruct _val840 -> (Errors_Types.to_EDAMNotFoundException (T.TStruct _val840)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_ExpungeTag_result _ = P.error "not a struct"
read_ExpungeTag_result :: T.Protocol p => p -> P.IO ExpungeTag_result
read_ExpungeTag_result iprot = to_ExpungeTag_result <$> T.readVal iprot (T.T_STRUCT typemap_ExpungeTag_result)
decode_ExpungeTag_result :: T.StatelessProtocol p => p -> LBS.ByteString -> ExpungeTag_result
decode_ExpungeTag_result iprot bs = to_ExpungeTag_result $ T.deserializeVal iprot (T.T_STRUCT typemap_ExpungeTag_result) bs
typemap_ExpungeTag_result :: T.TypeMap
typemap_ExpungeTag_result = Map.fromList [(0,("success",T.T_I32)),(1,("userException",(T.T_STRUCT Errors_Types.typemap_EDAMUserException))),(2,("systemException",(T.T_STRUCT Errors_Types.typemap_EDAMSystemException))),(3,("notFoundException",(T.T_STRUCT Errors_Types.typemap_EDAMNotFoundException)))]
default_ExpungeTag_result :: ExpungeTag_result
default_ExpungeTag_result = ExpungeTag_result{
  expungeTag_result_success = 0,
  expungeTag_result_userException = P.Nothing,
  expungeTag_result_systemException = P.Nothing,
  expungeTag_result_notFoundException = P.Nothing}
data ListSearches_args = ListSearches_args  { listSearches_args_authenticationToken :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ListSearches_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` listSearches_args_authenticationToken record  
instance QC.Arbitrary ListSearches_args where 
  arbitrary = M.liftM ListSearches_args (QC.arbitrary)
  shrink obj | obj == default_ListSearches_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ListSearches_args{listSearches_args_authenticationToken = listSearches_args_authenticationToken obj} then P.Nothing else P.Just $ default_ListSearches_args{listSearches_args_authenticationToken = listSearches_args_authenticationToken obj}
    ]
from_ListSearches_args :: ListSearches_args -> T.ThriftVal
from_ListSearches_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v843 -> P.Just (1, ("authenticationToken",T.TString $ E.encodeUtf8 _v843))) $ listSearches_args_authenticationToken record
  ]
write_ListSearches_args :: T.Protocol p => p -> ListSearches_args -> P.IO ()
write_ListSearches_args oprot record = T.writeVal oprot $ from_ListSearches_args record
encode_ListSearches_args :: T.StatelessProtocol p => p -> ListSearches_args -> LBS.ByteString
encode_ListSearches_args oprot record = T.serializeVal oprot $ from_ListSearches_args record
to_ListSearches_args :: T.ThriftVal -> ListSearches_args
to_ListSearches_args (T.TStruct fields) = ListSearches_args{
  listSearches_args_authenticationToken = P.maybe (listSearches_args_authenticationToken default_ListSearches_args) (\(_,_val845) -> (case _val845 of {T.TString _val846 -> E.decodeUtf8 _val846; _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_ListSearches_args _ = P.error "not a struct"
read_ListSearches_args :: T.Protocol p => p -> P.IO ListSearches_args
read_ListSearches_args iprot = to_ListSearches_args <$> T.readVal iprot (T.T_STRUCT typemap_ListSearches_args)
decode_ListSearches_args :: T.StatelessProtocol p => p -> LBS.ByteString -> ListSearches_args
decode_ListSearches_args iprot bs = to_ListSearches_args $ T.deserializeVal iprot (T.T_STRUCT typemap_ListSearches_args) bs
typemap_ListSearches_args :: T.TypeMap
typemap_ListSearches_args = Map.fromList [(1,("authenticationToken",T.T_STRING))]
default_ListSearches_args :: ListSearches_args
default_ListSearches_args = ListSearches_args{
  listSearches_args_authenticationToken = ""}
data ListSearches_result = ListSearches_result  { listSearches_result_success :: (Vector.Vector Types_Types.SavedSearch)
  , listSearches_result_userException :: P.Maybe Errors_Types.EDAMUserException
  , listSearches_result_systemException :: P.Maybe Errors_Types.EDAMSystemException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ListSearches_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` listSearches_result_success record   `H.hashWithSalt` listSearches_result_userException record   `H.hashWithSalt` listSearches_result_systemException record  
instance QC.Arbitrary ListSearches_result where 
  arbitrary = M.liftM ListSearches_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_ListSearches_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ListSearches_result{listSearches_result_success = listSearches_result_success obj} then P.Nothing else P.Just $ default_ListSearches_result{listSearches_result_success = listSearches_result_success obj}
    , if obj == default_ListSearches_result{listSearches_result_userException = listSearches_result_userException obj} then P.Nothing else P.Just $ default_ListSearches_result{listSearches_result_userException = listSearches_result_userException obj}
    , if obj == default_ListSearches_result{listSearches_result_systemException = listSearches_result_systemException obj} then P.Nothing else P.Just $ default_ListSearches_result{listSearches_result_systemException = listSearches_result_systemException obj}
    ]
from_ListSearches_result :: ListSearches_result -> T.ThriftVal
from_ListSearches_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v849 -> (1, ("userException",Errors_Types.from_EDAMUserException _v849))) <$> listSearches_result_userException record, (\_v849 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v849))) <$> listSearches_result_systemException record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v849 -> P.Just (0, ("success",T.TList (T.T_STRUCT Types_Types.typemap_SavedSearch) $ P.map (\_v851 -> Types_Types.from_SavedSearch _v851) $ Vector.toList _v849))) $ listSearches_result_success record
    , (\_v849 -> (1, ("userException",Errors_Types.from_EDAMUserException _v849))) <$> listSearches_result_userException record
    , (\_v849 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v849))) <$> listSearches_result_systemException record
    ]
    )
write_ListSearches_result :: T.Protocol p => p -> ListSearches_result -> P.IO ()
write_ListSearches_result oprot record = T.writeVal oprot $ from_ListSearches_result record
encode_ListSearches_result :: T.StatelessProtocol p => p -> ListSearches_result -> LBS.ByteString
encode_ListSearches_result oprot record = T.serializeVal oprot $ from_ListSearches_result record
to_ListSearches_result :: T.ThriftVal -> ListSearches_result
to_ListSearches_result (T.TStruct fields) = ListSearches_result{
  listSearches_result_success = P.maybe (listSearches_result_success default_ListSearches_result) (\(_,_val853) -> (case _val853 of {T.TList _ _val854 -> (Vector.fromList $ P.map (\_v855 -> (case _v855 of {T.TStruct _val856 -> (Types_Types.to_SavedSearch (T.TStruct _val856)); _ -> P.error "wrong type"})) _val854); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  listSearches_result_userException = P.maybe (P.Nothing) (\(_,_val853) -> P.Just (case _val853 of {T.TStruct _val857 -> (Errors_Types.to_EDAMUserException (T.TStruct _val857)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  listSearches_result_systemException = P.maybe (P.Nothing) (\(_,_val853) -> P.Just (case _val853 of {T.TStruct _val858 -> (Errors_Types.to_EDAMSystemException (T.TStruct _val858)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_ListSearches_result _ = P.error "not a struct"
read_ListSearches_result :: T.Protocol p => p -> P.IO ListSearches_result
read_ListSearches_result iprot = to_ListSearches_result <$> T.readVal iprot (T.T_STRUCT typemap_ListSearches_result)
decode_ListSearches_result :: T.StatelessProtocol p => p -> LBS.ByteString -> ListSearches_result
decode_ListSearches_result iprot bs = to_ListSearches_result $ T.deserializeVal iprot (T.T_STRUCT typemap_ListSearches_result) bs
typemap_ListSearches_result :: T.TypeMap
typemap_ListSearches_result = Map.fromList [(0,("success",(T.T_LIST (T.T_STRUCT Types_Types.typemap_SavedSearch)))),(1,("userException",(T.T_STRUCT Errors_Types.typemap_EDAMUserException))),(2,("systemException",(T.T_STRUCT Errors_Types.typemap_EDAMSystemException)))]
default_ListSearches_result :: ListSearches_result
default_ListSearches_result = ListSearches_result{
  listSearches_result_success = Vector.empty,
  listSearches_result_userException = P.Nothing,
  listSearches_result_systemException = P.Nothing}
data GetSearch_args = GetSearch_args  { getSearch_args_authenticationToken :: LT.Text
  , getSearch_args_guid :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetSearch_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getSearch_args_authenticationToken record   `H.hashWithSalt` getSearch_args_guid record  
instance QC.Arbitrary GetSearch_args where 
  arbitrary = M.liftM GetSearch_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GetSearch_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetSearch_args{getSearch_args_authenticationToken = getSearch_args_authenticationToken obj} then P.Nothing else P.Just $ default_GetSearch_args{getSearch_args_authenticationToken = getSearch_args_authenticationToken obj}
    , if obj == default_GetSearch_args{getSearch_args_guid = getSearch_args_guid obj} then P.Nothing else P.Just $ default_GetSearch_args{getSearch_args_guid = getSearch_args_guid obj}
    ]
from_GetSearch_args :: GetSearch_args -> T.ThriftVal
from_GetSearch_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v861 -> P.Just (1, ("authenticationToken",T.TString $ E.encodeUtf8 _v861))) $ getSearch_args_authenticationToken record
  , (\_v861 -> P.Just (2, ("guid",T.TString $ E.encodeUtf8 _v861))) $ getSearch_args_guid record
  ]
write_GetSearch_args :: T.Protocol p => p -> GetSearch_args -> P.IO ()
write_GetSearch_args oprot record = T.writeVal oprot $ from_GetSearch_args record
encode_GetSearch_args :: T.StatelessProtocol p => p -> GetSearch_args -> LBS.ByteString
encode_GetSearch_args oprot record = T.serializeVal oprot $ from_GetSearch_args record
to_GetSearch_args :: T.ThriftVal -> GetSearch_args
to_GetSearch_args (T.TStruct fields) = GetSearch_args{
  getSearch_args_authenticationToken = P.maybe (getSearch_args_authenticationToken default_GetSearch_args) (\(_,_val863) -> (case _val863 of {T.TString _val864 -> E.decodeUtf8 _val864; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  getSearch_args_guid = P.maybe (getSearch_args_guid default_GetSearch_args) (\(_,_val863) -> (case _val863 of {T.TString _val865 -> E.decodeUtf8 _val865; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_GetSearch_args _ = P.error "not a struct"
read_GetSearch_args :: T.Protocol p => p -> P.IO GetSearch_args
read_GetSearch_args iprot = to_GetSearch_args <$> T.readVal iprot (T.T_STRUCT typemap_GetSearch_args)
decode_GetSearch_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetSearch_args
decode_GetSearch_args iprot bs = to_GetSearch_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetSearch_args) bs
typemap_GetSearch_args :: T.TypeMap
typemap_GetSearch_args = Map.fromList [(1,("authenticationToken",T.T_STRING)),(2,("guid",T.T_STRING))]
default_GetSearch_args :: GetSearch_args
default_GetSearch_args = GetSearch_args{
  getSearch_args_authenticationToken = "",
  getSearch_args_guid = ""}
data GetSearch_result = GetSearch_result  { getSearch_result_success :: Types_Types.SavedSearch
  , getSearch_result_userException :: P.Maybe Errors_Types.EDAMUserException
  , getSearch_result_systemException :: P.Maybe Errors_Types.EDAMSystemException
  , getSearch_result_notFoundException :: P.Maybe Errors_Types.EDAMNotFoundException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetSearch_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getSearch_result_success record   `H.hashWithSalt` getSearch_result_userException record   `H.hashWithSalt` getSearch_result_systemException record   `H.hashWithSalt` getSearch_result_notFoundException record  
instance QC.Arbitrary GetSearch_result where 
  arbitrary = M.liftM GetSearch_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetSearch_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetSearch_result{getSearch_result_success = getSearch_result_success obj} then P.Nothing else P.Just $ default_GetSearch_result{getSearch_result_success = getSearch_result_success obj}
    , if obj == default_GetSearch_result{getSearch_result_userException = getSearch_result_userException obj} then P.Nothing else P.Just $ default_GetSearch_result{getSearch_result_userException = getSearch_result_userException obj}
    , if obj == default_GetSearch_result{getSearch_result_systemException = getSearch_result_systemException obj} then P.Nothing else P.Just $ default_GetSearch_result{getSearch_result_systemException = getSearch_result_systemException obj}
    , if obj == default_GetSearch_result{getSearch_result_notFoundException = getSearch_result_notFoundException obj} then P.Nothing else P.Just $ default_GetSearch_result{getSearch_result_notFoundException = getSearch_result_notFoundException obj}
    ]
from_GetSearch_result :: GetSearch_result -> T.ThriftVal
from_GetSearch_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v868 -> (1, ("userException",Errors_Types.from_EDAMUserException _v868))) <$> getSearch_result_userException record, (\_v868 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v868))) <$> getSearch_result_systemException record, (\_v868 -> (3, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v868))) <$> getSearch_result_notFoundException record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v868 -> P.Just (0, ("success",Types_Types.from_SavedSearch _v868))) $ getSearch_result_success record
    , (\_v868 -> (1, ("userException",Errors_Types.from_EDAMUserException _v868))) <$> getSearch_result_userException record
    , (\_v868 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v868))) <$> getSearch_result_systemException record
    , (\_v868 -> (3, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v868))) <$> getSearch_result_notFoundException record
    ]
    )
write_GetSearch_result :: T.Protocol p => p -> GetSearch_result -> P.IO ()
write_GetSearch_result oprot record = T.writeVal oprot $ from_GetSearch_result record
encode_GetSearch_result :: T.StatelessProtocol p => p -> GetSearch_result -> LBS.ByteString
encode_GetSearch_result oprot record = T.serializeVal oprot $ from_GetSearch_result record
to_GetSearch_result :: T.ThriftVal -> GetSearch_result
to_GetSearch_result (T.TStruct fields) = GetSearch_result{
  getSearch_result_success = P.maybe (getSearch_result_success default_GetSearch_result) (\(_,_val870) -> (case _val870 of {T.TStruct _val871 -> (Types_Types.to_SavedSearch (T.TStruct _val871)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getSearch_result_userException = P.maybe (P.Nothing) (\(_,_val870) -> P.Just (case _val870 of {T.TStruct _val872 -> (Errors_Types.to_EDAMUserException (T.TStruct _val872)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  getSearch_result_systemException = P.maybe (P.Nothing) (\(_,_val870) -> P.Just (case _val870 of {T.TStruct _val873 -> (Errors_Types.to_EDAMSystemException (T.TStruct _val873)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  getSearch_result_notFoundException = P.maybe (P.Nothing) (\(_,_val870) -> P.Just (case _val870 of {T.TStruct _val874 -> (Errors_Types.to_EDAMNotFoundException (T.TStruct _val874)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_GetSearch_result _ = P.error "not a struct"
read_GetSearch_result :: T.Protocol p => p -> P.IO GetSearch_result
read_GetSearch_result iprot = to_GetSearch_result <$> T.readVal iprot (T.T_STRUCT typemap_GetSearch_result)
decode_GetSearch_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetSearch_result
decode_GetSearch_result iprot bs = to_GetSearch_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetSearch_result) bs
typemap_GetSearch_result :: T.TypeMap
typemap_GetSearch_result = Map.fromList [(0,("success",(T.T_STRUCT Types_Types.typemap_SavedSearch))),(1,("userException",(T.T_STRUCT Errors_Types.typemap_EDAMUserException))),(2,("systemException",(T.T_STRUCT Errors_Types.typemap_EDAMSystemException))),(3,("notFoundException",(T.T_STRUCT Errors_Types.typemap_EDAMNotFoundException)))]
default_GetSearch_result :: GetSearch_result
default_GetSearch_result = GetSearch_result{
  getSearch_result_success = Types_Types.default_SavedSearch,
  getSearch_result_userException = P.Nothing,
  getSearch_result_systemException = P.Nothing,
  getSearch_result_notFoundException = P.Nothing}
data CreateSearch_args = CreateSearch_args  { createSearch_args_authenticationToken :: LT.Text
  , createSearch_args_search :: Types_Types.SavedSearch
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable CreateSearch_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` createSearch_args_authenticationToken record   `H.hashWithSalt` createSearch_args_search record  
instance QC.Arbitrary CreateSearch_args where 
  arbitrary = M.liftM CreateSearch_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_CreateSearch_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_CreateSearch_args{createSearch_args_authenticationToken = createSearch_args_authenticationToken obj} then P.Nothing else P.Just $ default_CreateSearch_args{createSearch_args_authenticationToken = createSearch_args_authenticationToken obj}
    , if obj == default_CreateSearch_args{createSearch_args_search = createSearch_args_search obj} then P.Nothing else P.Just $ default_CreateSearch_args{createSearch_args_search = createSearch_args_search obj}
    ]
from_CreateSearch_args :: CreateSearch_args -> T.ThriftVal
from_CreateSearch_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v877 -> P.Just (1, ("authenticationToken",T.TString $ E.encodeUtf8 _v877))) $ createSearch_args_authenticationToken record
  , (\_v877 -> P.Just (2, ("search",Types_Types.from_SavedSearch _v877))) $ createSearch_args_search record
  ]
write_CreateSearch_args :: T.Protocol p => p -> CreateSearch_args -> P.IO ()
write_CreateSearch_args oprot record = T.writeVal oprot $ from_CreateSearch_args record
encode_CreateSearch_args :: T.StatelessProtocol p => p -> CreateSearch_args -> LBS.ByteString
encode_CreateSearch_args oprot record = T.serializeVal oprot $ from_CreateSearch_args record
to_CreateSearch_args :: T.ThriftVal -> CreateSearch_args
to_CreateSearch_args (T.TStruct fields) = CreateSearch_args{
  createSearch_args_authenticationToken = P.maybe (createSearch_args_authenticationToken default_CreateSearch_args) (\(_,_val879) -> (case _val879 of {T.TString _val880 -> E.decodeUtf8 _val880; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  createSearch_args_search = P.maybe (createSearch_args_search default_CreateSearch_args) (\(_,_val879) -> (case _val879 of {T.TStruct _val881 -> (Types_Types.to_SavedSearch (T.TStruct _val881)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_CreateSearch_args _ = P.error "not a struct"
read_CreateSearch_args :: T.Protocol p => p -> P.IO CreateSearch_args
read_CreateSearch_args iprot = to_CreateSearch_args <$> T.readVal iprot (T.T_STRUCT typemap_CreateSearch_args)
decode_CreateSearch_args :: T.StatelessProtocol p => p -> LBS.ByteString -> CreateSearch_args
decode_CreateSearch_args iprot bs = to_CreateSearch_args $ T.deserializeVal iprot (T.T_STRUCT typemap_CreateSearch_args) bs
typemap_CreateSearch_args :: T.TypeMap
typemap_CreateSearch_args = Map.fromList [(1,("authenticationToken",T.T_STRING)),(2,("search",(T.T_STRUCT Types_Types.typemap_SavedSearch)))]
default_CreateSearch_args :: CreateSearch_args
default_CreateSearch_args = CreateSearch_args{
  createSearch_args_authenticationToken = "",
  createSearch_args_search = Types_Types.default_SavedSearch}
data CreateSearch_result = CreateSearch_result  { createSearch_result_success :: Types_Types.SavedSearch
  , createSearch_result_userException :: P.Maybe Errors_Types.EDAMUserException
  , createSearch_result_systemException :: P.Maybe Errors_Types.EDAMSystemException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable CreateSearch_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` createSearch_result_success record   `H.hashWithSalt` createSearch_result_userException record   `H.hashWithSalt` createSearch_result_systemException record  
instance QC.Arbitrary CreateSearch_result where 
  arbitrary = M.liftM CreateSearch_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_CreateSearch_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_CreateSearch_result{createSearch_result_success = createSearch_result_success obj} then P.Nothing else P.Just $ default_CreateSearch_result{createSearch_result_success = createSearch_result_success obj}
    , if obj == default_CreateSearch_result{createSearch_result_userException = createSearch_result_userException obj} then P.Nothing else P.Just $ default_CreateSearch_result{createSearch_result_userException = createSearch_result_userException obj}
    , if obj == default_CreateSearch_result{createSearch_result_systemException = createSearch_result_systemException obj} then P.Nothing else P.Just $ default_CreateSearch_result{createSearch_result_systemException = createSearch_result_systemException obj}
    ]
from_CreateSearch_result :: CreateSearch_result -> T.ThriftVal
from_CreateSearch_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v884 -> (1, ("userException",Errors_Types.from_EDAMUserException _v884))) <$> createSearch_result_userException record, (\_v884 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v884))) <$> createSearch_result_systemException record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v884 -> P.Just (0, ("success",Types_Types.from_SavedSearch _v884))) $ createSearch_result_success record
    , (\_v884 -> (1, ("userException",Errors_Types.from_EDAMUserException _v884))) <$> createSearch_result_userException record
    , (\_v884 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v884))) <$> createSearch_result_systemException record
    ]
    )
write_CreateSearch_result :: T.Protocol p => p -> CreateSearch_result -> P.IO ()
write_CreateSearch_result oprot record = T.writeVal oprot $ from_CreateSearch_result record
encode_CreateSearch_result :: T.StatelessProtocol p => p -> CreateSearch_result -> LBS.ByteString
encode_CreateSearch_result oprot record = T.serializeVal oprot $ from_CreateSearch_result record
to_CreateSearch_result :: T.ThriftVal -> CreateSearch_result
to_CreateSearch_result (T.TStruct fields) = CreateSearch_result{
  createSearch_result_success = P.maybe (createSearch_result_success default_CreateSearch_result) (\(_,_val886) -> (case _val886 of {T.TStruct _val887 -> (Types_Types.to_SavedSearch (T.TStruct _val887)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  createSearch_result_userException = P.maybe (P.Nothing) (\(_,_val886) -> P.Just (case _val886 of {T.TStruct _val888 -> (Errors_Types.to_EDAMUserException (T.TStruct _val888)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  createSearch_result_systemException = P.maybe (P.Nothing) (\(_,_val886) -> P.Just (case _val886 of {T.TStruct _val889 -> (Errors_Types.to_EDAMSystemException (T.TStruct _val889)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_CreateSearch_result _ = P.error "not a struct"
read_CreateSearch_result :: T.Protocol p => p -> P.IO CreateSearch_result
read_CreateSearch_result iprot = to_CreateSearch_result <$> T.readVal iprot (T.T_STRUCT typemap_CreateSearch_result)
decode_CreateSearch_result :: T.StatelessProtocol p => p -> LBS.ByteString -> CreateSearch_result
decode_CreateSearch_result iprot bs = to_CreateSearch_result $ T.deserializeVal iprot (T.T_STRUCT typemap_CreateSearch_result) bs
typemap_CreateSearch_result :: T.TypeMap
typemap_CreateSearch_result = Map.fromList [(0,("success",(T.T_STRUCT Types_Types.typemap_SavedSearch))),(1,("userException",(T.T_STRUCT Errors_Types.typemap_EDAMUserException))),(2,("systemException",(T.T_STRUCT Errors_Types.typemap_EDAMSystemException)))]
default_CreateSearch_result :: CreateSearch_result
default_CreateSearch_result = CreateSearch_result{
  createSearch_result_success = Types_Types.default_SavedSearch,
  createSearch_result_userException = P.Nothing,
  createSearch_result_systemException = P.Nothing}
data UpdateSearch_args = UpdateSearch_args  { updateSearch_args_authenticationToken :: LT.Text
  , updateSearch_args_search :: Types_Types.SavedSearch
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateSearch_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateSearch_args_authenticationToken record   `H.hashWithSalt` updateSearch_args_search record  
instance QC.Arbitrary UpdateSearch_args where 
  arbitrary = M.liftM UpdateSearch_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_UpdateSearch_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateSearch_args{updateSearch_args_authenticationToken = updateSearch_args_authenticationToken obj} then P.Nothing else P.Just $ default_UpdateSearch_args{updateSearch_args_authenticationToken = updateSearch_args_authenticationToken obj}
    , if obj == default_UpdateSearch_args{updateSearch_args_search = updateSearch_args_search obj} then P.Nothing else P.Just $ default_UpdateSearch_args{updateSearch_args_search = updateSearch_args_search obj}
    ]
from_UpdateSearch_args :: UpdateSearch_args -> T.ThriftVal
from_UpdateSearch_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v892 -> P.Just (1, ("authenticationToken",T.TString $ E.encodeUtf8 _v892))) $ updateSearch_args_authenticationToken record
  , (\_v892 -> P.Just (2, ("search",Types_Types.from_SavedSearch _v892))) $ updateSearch_args_search record
  ]
write_UpdateSearch_args :: T.Protocol p => p -> UpdateSearch_args -> P.IO ()
write_UpdateSearch_args oprot record = T.writeVal oprot $ from_UpdateSearch_args record
encode_UpdateSearch_args :: T.StatelessProtocol p => p -> UpdateSearch_args -> LBS.ByteString
encode_UpdateSearch_args oprot record = T.serializeVal oprot $ from_UpdateSearch_args record
to_UpdateSearch_args :: T.ThriftVal -> UpdateSearch_args
to_UpdateSearch_args (T.TStruct fields) = UpdateSearch_args{
  updateSearch_args_authenticationToken = P.maybe (updateSearch_args_authenticationToken default_UpdateSearch_args) (\(_,_val894) -> (case _val894 of {T.TString _val895 -> E.decodeUtf8 _val895; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  updateSearch_args_search = P.maybe (updateSearch_args_search default_UpdateSearch_args) (\(_,_val894) -> (case _val894 of {T.TStruct _val896 -> (Types_Types.to_SavedSearch (T.TStruct _val896)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_UpdateSearch_args _ = P.error "not a struct"
read_UpdateSearch_args :: T.Protocol p => p -> P.IO UpdateSearch_args
read_UpdateSearch_args iprot = to_UpdateSearch_args <$> T.readVal iprot (T.T_STRUCT typemap_UpdateSearch_args)
decode_UpdateSearch_args :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateSearch_args
decode_UpdateSearch_args iprot bs = to_UpdateSearch_args $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateSearch_args) bs
typemap_UpdateSearch_args :: T.TypeMap
typemap_UpdateSearch_args = Map.fromList [(1,("authenticationToken",T.T_STRING)),(2,("search",(T.T_STRUCT Types_Types.typemap_SavedSearch)))]
default_UpdateSearch_args :: UpdateSearch_args
default_UpdateSearch_args = UpdateSearch_args{
  updateSearch_args_authenticationToken = "",
  updateSearch_args_search = Types_Types.default_SavedSearch}
data UpdateSearch_result = UpdateSearch_result  { updateSearch_result_success :: I.Int32
  , updateSearch_result_userException :: P.Maybe Errors_Types.EDAMUserException
  , updateSearch_result_systemException :: P.Maybe Errors_Types.EDAMSystemException
  , updateSearch_result_notFoundException :: P.Maybe Errors_Types.EDAMNotFoundException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateSearch_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateSearch_result_success record   `H.hashWithSalt` updateSearch_result_userException record   `H.hashWithSalt` updateSearch_result_systemException record   `H.hashWithSalt` updateSearch_result_notFoundException record  
instance QC.Arbitrary UpdateSearch_result where 
  arbitrary = M.liftM UpdateSearch_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_UpdateSearch_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateSearch_result{updateSearch_result_success = updateSearch_result_success obj} then P.Nothing else P.Just $ default_UpdateSearch_result{updateSearch_result_success = updateSearch_result_success obj}
    , if obj == default_UpdateSearch_result{updateSearch_result_userException = updateSearch_result_userException obj} then P.Nothing else P.Just $ default_UpdateSearch_result{updateSearch_result_userException = updateSearch_result_userException obj}
    , if obj == default_UpdateSearch_result{updateSearch_result_systemException = updateSearch_result_systemException obj} then P.Nothing else P.Just $ default_UpdateSearch_result{updateSearch_result_systemException = updateSearch_result_systemException obj}
    , if obj == default_UpdateSearch_result{updateSearch_result_notFoundException = updateSearch_result_notFoundException obj} then P.Nothing else P.Just $ default_UpdateSearch_result{updateSearch_result_notFoundException = updateSearch_result_notFoundException obj}
    ]
from_UpdateSearch_result :: UpdateSearch_result -> T.ThriftVal
from_UpdateSearch_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v899 -> (1, ("userException",Errors_Types.from_EDAMUserException _v899))) <$> updateSearch_result_userException record, (\_v899 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v899))) <$> updateSearch_result_systemException record, (\_v899 -> (3, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v899))) <$> updateSearch_result_notFoundException record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v899 -> P.Just (0, ("success",T.TI32 _v899))) $ updateSearch_result_success record
    , (\_v899 -> (1, ("userException",Errors_Types.from_EDAMUserException _v899))) <$> updateSearch_result_userException record
    , (\_v899 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v899))) <$> updateSearch_result_systemException record
    , (\_v899 -> (3, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v899))) <$> updateSearch_result_notFoundException record
    ]
    )
write_UpdateSearch_result :: T.Protocol p => p -> UpdateSearch_result -> P.IO ()
write_UpdateSearch_result oprot record = T.writeVal oprot $ from_UpdateSearch_result record
encode_UpdateSearch_result :: T.StatelessProtocol p => p -> UpdateSearch_result -> LBS.ByteString
encode_UpdateSearch_result oprot record = T.serializeVal oprot $ from_UpdateSearch_result record
to_UpdateSearch_result :: T.ThriftVal -> UpdateSearch_result
to_UpdateSearch_result (T.TStruct fields) = UpdateSearch_result{
  updateSearch_result_success = P.maybe (updateSearch_result_success default_UpdateSearch_result) (\(_,_val901) -> (case _val901 of {T.TI32 _val902 -> _val902; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  updateSearch_result_userException = P.maybe (P.Nothing) (\(_,_val901) -> P.Just (case _val901 of {T.TStruct _val903 -> (Errors_Types.to_EDAMUserException (T.TStruct _val903)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  updateSearch_result_systemException = P.maybe (P.Nothing) (\(_,_val901) -> P.Just (case _val901 of {T.TStruct _val904 -> (Errors_Types.to_EDAMSystemException (T.TStruct _val904)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  updateSearch_result_notFoundException = P.maybe (P.Nothing) (\(_,_val901) -> P.Just (case _val901 of {T.TStruct _val905 -> (Errors_Types.to_EDAMNotFoundException (T.TStruct _val905)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_UpdateSearch_result _ = P.error "not a struct"
read_UpdateSearch_result :: T.Protocol p => p -> P.IO UpdateSearch_result
read_UpdateSearch_result iprot = to_UpdateSearch_result <$> T.readVal iprot (T.T_STRUCT typemap_UpdateSearch_result)
decode_UpdateSearch_result :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateSearch_result
decode_UpdateSearch_result iprot bs = to_UpdateSearch_result $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateSearch_result) bs
typemap_UpdateSearch_result :: T.TypeMap
typemap_UpdateSearch_result = Map.fromList [(0,("success",T.T_I32)),(1,("userException",(T.T_STRUCT Errors_Types.typemap_EDAMUserException))),(2,("systemException",(T.T_STRUCT Errors_Types.typemap_EDAMSystemException))),(3,("notFoundException",(T.T_STRUCT Errors_Types.typemap_EDAMNotFoundException)))]
default_UpdateSearch_result :: UpdateSearch_result
default_UpdateSearch_result = UpdateSearch_result{
  updateSearch_result_success = 0,
  updateSearch_result_userException = P.Nothing,
  updateSearch_result_systemException = P.Nothing,
  updateSearch_result_notFoundException = P.Nothing}
data ExpungeSearch_args = ExpungeSearch_args  { expungeSearch_args_authenticationToken :: LT.Text
  , expungeSearch_args_guid :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ExpungeSearch_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` expungeSearch_args_authenticationToken record   `H.hashWithSalt` expungeSearch_args_guid record  
instance QC.Arbitrary ExpungeSearch_args where 
  arbitrary = M.liftM ExpungeSearch_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_ExpungeSearch_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ExpungeSearch_args{expungeSearch_args_authenticationToken = expungeSearch_args_authenticationToken obj} then P.Nothing else P.Just $ default_ExpungeSearch_args{expungeSearch_args_authenticationToken = expungeSearch_args_authenticationToken obj}
    , if obj == default_ExpungeSearch_args{expungeSearch_args_guid = expungeSearch_args_guid obj} then P.Nothing else P.Just $ default_ExpungeSearch_args{expungeSearch_args_guid = expungeSearch_args_guid obj}
    ]
from_ExpungeSearch_args :: ExpungeSearch_args -> T.ThriftVal
from_ExpungeSearch_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v908 -> P.Just (1, ("authenticationToken",T.TString $ E.encodeUtf8 _v908))) $ expungeSearch_args_authenticationToken record
  , (\_v908 -> P.Just (2, ("guid",T.TString $ E.encodeUtf8 _v908))) $ expungeSearch_args_guid record
  ]
write_ExpungeSearch_args :: T.Protocol p => p -> ExpungeSearch_args -> P.IO ()
write_ExpungeSearch_args oprot record = T.writeVal oprot $ from_ExpungeSearch_args record
encode_ExpungeSearch_args :: T.StatelessProtocol p => p -> ExpungeSearch_args -> LBS.ByteString
encode_ExpungeSearch_args oprot record = T.serializeVal oprot $ from_ExpungeSearch_args record
to_ExpungeSearch_args :: T.ThriftVal -> ExpungeSearch_args
to_ExpungeSearch_args (T.TStruct fields) = ExpungeSearch_args{
  expungeSearch_args_authenticationToken = P.maybe (expungeSearch_args_authenticationToken default_ExpungeSearch_args) (\(_,_val910) -> (case _val910 of {T.TString _val911 -> E.decodeUtf8 _val911; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  expungeSearch_args_guid = P.maybe (expungeSearch_args_guid default_ExpungeSearch_args) (\(_,_val910) -> (case _val910 of {T.TString _val912 -> E.decodeUtf8 _val912; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_ExpungeSearch_args _ = P.error "not a struct"
read_ExpungeSearch_args :: T.Protocol p => p -> P.IO ExpungeSearch_args
read_ExpungeSearch_args iprot = to_ExpungeSearch_args <$> T.readVal iprot (T.T_STRUCT typemap_ExpungeSearch_args)
decode_ExpungeSearch_args :: T.StatelessProtocol p => p -> LBS.ByteString -> ExpungeSearch_args
decode_ExpungeSearch_args iprot bs = to_ExpungeSearch_args $ T.deserializeVal iprot (T.T_STRUCT typemap_ExpungeSearch_args) bs
typemap_ExpungeSearch_args :: T.TypeMap
typemap_ExpungeSearch_args = Map.fromList [(1,("authenticationToken",T.T_STRING)),(2,("guid",T.T_STRING))]
default_ExpungeSearch_args :: ExpungeSearch_args
default_ExpungeSearch_args = ExpungeSearch_args{
  expungeSearch_args_authenticationToken = "",
  expungeSearch_args_guid = ""}
data ExpungeSearch_result = ExpungeSearch_result  { expungeSearch_result_success :: I.Int32
  , expungeSearch_result_userException :: P.Maybe Errors_Types.EDAMUserException
  , expungeSearch_result_systemException :: P.Maybe Errors_Types.EDAMSystemException
  , expungeSearch_result_notFoundException :: P.Maybe Errors_Types.EDAMNotFoundException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ExpungeSearch_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` expungeSearch_result_success record   `H.hashWithSalt` expungeSearch_result_userException record   `H.hashWithSalt` expungeSearch_result_systemException record   `H.hashWithSalt` expungeSearch_result_notFoundException record  
instance QC.Arbitrary ExpungeSearch_result where 
  arbitrary = M.liftM ExpungeSearch_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_ExpungeSearch_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ExpungeSearch_result{expungeSearch_result_success = expungeSearch_result_success obj} then P.Nothing else P.Just $ default_ExpungeSearch_result{expungeSearch_result_success = expungeSearch_result_success obj}
    , if obj == default_ExpungeSearch_result{expungeSearch_result_userException = expungeSearch_result_userException obj} then P.Nothing else P.Just $ default_ExpungeSearch_result{expungeSearch_result_userException = expungeSearch_result_userException obj}
    , if obj == default_ExpungeSearch_result{expungeSearch_result_systemException = expungeSearch_result_systemException obj} then P.Nothing else P.Just $ default_ExpungeSearch_result{expungeSearch_result_systemException = expungeSearch_result_systemException obj}
    , if obj == default_ExpungeSearch_result{expungeSearch_result_notFoundException = expungeSearch_result_notFoundException obj} then P.Nothing else P.Just $ default_ExpungeSearch_result{expungeSearch_result_notFoundException = expungeSearch_result_notFoundException obj}
    ]
from_ExpungeSearch_result :: ExpungeSearch_result -> T.ThriftVal
from_ExpungeSearch_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v915 -> (1, ("userException",Errors_Types.from_EDAMUserException _v915))) <$> expungeSearch_result_userException record, (\_v915 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v915))) <$> expungeSearch_result_systemException record, (\_v915 -> (3, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v915))) <$> expungeSearch_result_notFoundException record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v915 -> P.Just (0, ("success",T.TI32 _v915))) $ expungeSearch_result_success record
    , (\_v915 -> (1, ("userException",Errors_Types.from_EDAMUserException _v915))) <$> expungeSearch_result_userException record
    , (\_v915 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v915))) <$> expungeSearch_result_systemException record
    , (\_v915 -> (3, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v915))) <$> expungeSearch_result_notFoundException record
    ]
    )
write_ExpungeSearch_result :: T.Protocol p => p -> ExpungeSearch_result -> P.IO ()
write_ExpungeSearch_result oprot record = T.writeVal oprot $ from_ExpungeSearch_result record
encode_ExpungeSearch_result :: T.StatelessProtocol p => p -> ExpungeSearch_result -> LBS.ByteString
encode_ExpungeSearch_result oprot record = T.serializeVal oprot $ from_ExpungeSearch_result record
to_ExpungeSearch_result :: T.ThriftVal -> ExpungeSearch_result
to_ExpungeSearch_result (T.TStruct fields) = ExpungeSearch_result{
  expungeSearch_result_success = P.maybe (expungeSearch_result_success default_ExpungeSearch_result) (\(_,_val917) -> (case _val917 of {T.TI32 _val918 -> _val918; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  expungeSearch_result_userException = P.maybe (P.Nothing) (\(_,_val917) -> P.Just (case _val917 of {T.TStruct _val919 -> (Errors_Types.to_EDAMUserException (T.TStruct _val919)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  expungeSearch_result_systemException = P.maybe (P.Nothing) (\(_,_val917) -> P.Just (case _val917 of {T.TStruct _val920 -> (Errors_Types.to_EDAMSystemException (T.TStruct _val920)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  expungeSearch_result_notFoundException = P.maybe (P.Nothing) (\(_,_val917) -> P.Just (case _val917 of {T.TStruct _val921 -> (Errors_Types.to_EDAMNotFoundException (T.TStruct _val921)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_ExpungeSearch_result _ = P.error "not a struct"
read_ExpungeSearch_result :: T.Protocol p => p -> P.IO ExpungeSearch_result
read_ExpungeSearch_result iprot = to_ExpungeSearch_result <$> T.readVal iprot (T.T_STRUCT typemap_ExpungeSearch_result)
decode_ExpungeSearch_result :: T.StatelessProtocol p => p -> LBS.ByteString -> ExpungeSearch_result
decode_ExpungeSearch_result iprot bs = to_ExpungeSearch_result $ T.deserializeVal iprot (T.T_STRUCT typemap_ExpungeSearch_result) bs
typemap_ExpungeSearch_result :: T.TypeMap
typemap_ExpungeSearch_result = Map.fromList [(0,("success",T.T_I32)),(1,("userException",(T.T_STRUCT Errors_Types.typemap_EDAMUserException))),(2,("systemException",(T.T_STRUCT Errors_Types.typemap_EDAMSystemException))),(3,("notFoundException",(T.T_STRUCT Errors_Types.typemap_EDAMNotFoundException)))]
default_ExpungeSearch_result :: ExpungeSearch_result
default_ExpungeSearch_result = ExpungeSearch_result{
  expungeSearch_result_success = 0,
  expungeSearch_result_userException = P.Nothing,
  expungeSearch_result_systemException = P.Nothing,
  expungeSearch_result_notFoundException = P.Nothing}
data FindNoteOffset_args = FindNoteOffset_args  { findNoteOffset_args_authenticationToken :: LT.Text
  , findNoteOffset_args_filter :: NoteFilter
  , findNoteOffset_args_guid :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable FindNoteOffset_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` findNoteOffset_args_authenticationToken record   `H.hashWithSalt` findNoteOffset_args_filter record   `H.hashWithSalt` findNoteOffset_args_guid record  
instance QC.Arbitrary FindNoteOffset_args where 
  arbitrary = M.liftM FindNoteOffset_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_FindNoteOffset_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_FindNoteOffset_args{findNoteOffset_args_authenticationToken = findNoteOffset_args_authenticationToken obj} then P.Nothing else P.Just $ default_FindNoteOffset_args{findNoteOffset_args_authenticationToken = findNoteOffset_args_authenticationToken obj}
    , if obj == default_FindNoteOffset_args{findNoteOffset_args_filter = findNoteOffset_args_filter obj} then P.Nothing else P.Just $ default_FindNoteOffset_args{findNoteOffset_args_filter = findNoteOffset_args_filter obj}
    , if obj == default_FindNoteOffset_args{findNoteOffset_args_guid = findNoteOffset_args_guid obj} then P.Nothing else P.Just $ default_FindNoteOffset_args{findNoteOffset_args_guid = findNoteOffset_args_guid obj}
    ]
from_FindNoteOffset_args :: FindNoteOffset_args -> T.ThriftVal
from_FindNoteOffset_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v924 -> P.Just (1, ("authenticationToken",T.TString $ E.encodeUtf8 _v924))) $ findNoteOffset_args_authenticationToken record
  , (\_v924 -> P.Just (2, ("filter",from_NoteFilter _v924))) $ findNoteOffset_args_filter record
  , (\_v924 -> P.Just (3, ("guid",T.TString $ E.encodeUtf8 _v924))) $ findNoteOffset_args_guid record
  ]
write_FindNoteOffset_args :: T.Protocol p => p -> FindNoteOffset_args -> P.IO ()
write_FindNoteOffset_args oprot record = T.writeVal oprot $ from_FindNoteOffset_args record
encode_FindNoteOffset_args :: T.StatelessProtocol p => p -> FindNoteOffset_args -> LBS.ByteString
encode_FindNoteOffset_args oprot record = T.serializeVal oprot $ from_FindNoteOffset_args record
to_FindNoteOffset_args :: T.ThriftVal -> FindNoteOffset_args
to_FindNoteOffset_args (T.TStruct fields) = FindNoteOffset_args{
  findNoteOffset_args_authenticationToken = P.maybe (findNoteOffset_args_authenticationToken default_FindNoteOffset_args) (\(_,_val926) -> (case _val926 of {T.TString _val927 -> E.decodeUtf8 _val927; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  findNoteOffset_args_filter = P.maybe (findNoteOffset_args_filter default_FindNoteOffset_args) (\(_,_val926) -> (case _val926 of {T.TStruct _val928 -> (to_NoteFilter (T.TStruct _val928)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  findNoteOffset_args_guid = P.maybe (findNoteOffset_args_guid default_FindNoteOffset_args) (\(_,_val926) -> (case _val926 of {T.TString _val929 -> E.decodeUtf8 _val929; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_FindNoteOffset_args _ = P.error "not a struct"
read_FindNoteOffset_args :: T.Protocol p => p -> P.IO FindNoteOffset_args
read_FindNoteOffset_args iprot = to_FindNoteOffset_args <$> T.readVal iprot (T.T_STRUCT typemap_FindNoteOffset_args)
decode_FindNoteOffset_args :: T.StatelessProtocol p => p -> LBS.ByteString -> FindNoteOffset_args
decode_FindNoteOffset_args iprot bs = to_FindNoteOffset_args $ T.deserializeVal iprot (T.T_STRUCT typemap_FindNoteOffset_args) bs
typemap_FindNoteOffset_args :: T.TypeMap
typemap_FindNoteOffset_args = Map.fromList [(1,("authenticationToken",T.T_STRING)),(2,("filter",(T.T_STRUCT typemap_NoteFilter))),(3,("guid",T.T_STRING))]
default_FindNoteOffset_args :: FindNoteOffset_args
default_FindNoteOffset_args = FindNoteOffset_args{
  findNoteOffset_args_authenticationToken = "",
  findNoteOffset_args_filter = default_NoteFilter,
  findNoteOffset_args_guid = ""}
data FindNoteOffset_result = FindNoteOffset_result  { findNoteOffset_result_success :: I.Int32
  , findNoteOffset_result_userException :: P.Maybe Errors_Types.EDAMUserException
  , findNoteOffset_result_systemException :: P.Maybe Errors_Types.EDAMSystemException
  , findNoteOffset_result_notFoundException :: P.Maybe Errors_Types.EDAMNotFoundException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable FindNoteOffset_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` findNoteOffset_result_success record   `H.hashWithSalt` findNoteOffset_result_userException record   `H.hashWithSalt` findNoteOffset_result_systemException record   `H.hashWithSalt` findNoteOffset_result_notFoundException record  
instance QC.Arbitrary FindNoteOffset_result where 
  arbitrary = M.liftM FindNoteOffset_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_FindNoteOffset_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_FindNoteOffset_result{findNoteOffset_result_success = findNoteOffset_result_success obj} then P.Nothing else P.Just $ default_FindNoteOffset_result{findNoteOffset_result_success = findNoteOffset_result_success obj}
    , if obj == default_FindNoteOffset_result{findNoteOffset_result_userException = findNoteOffset_result_userException obj} then P.Nothing else P.Just $ default_FindNoteOffset_result{findNoteOffset_result_userException = findNoteOffset_result_userException obj}
    , if obj == default_FindNoteOffset_result{findNoteOffset_result_systemException = findNoteOffset_result_systemException obj} then P.Nothing else P.Just $ default_FindNoteOffset_result{findNoteOffset_result_systemException = findNoteOffset_result_systemException obj}
    , if obj == default_FindNoteOffset_result{findNoteOffset_result_notFoundException = findNoteOffset_result_notFoundException obj} then P.Nothing else P.Just $ default_FindNoteOffset_result{findNoteOffset_result_notFoundException = findNoteOffset_result_notFoundException obj}
    ]
from_FindNoteOffset_result :: FindNoteOffset_result -> T.ThriftVal
from_FindNoteOffset_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v932 -> (1, ("userException",Errors_Types.from_EDAMUserException _v932))) <$> findNoteOffset_result_userException record, (\_v932 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v932))) <$> findNoteOffset_result_systemException record, (\_v932 -> (3, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v932))) <$> findNoteOffset_result_notFoundException record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v932 -> P.Just (0, ("success",T.TI32 _v932))) $ findNoteOffset_result_success record
    , (\_v932 -> (1, ("userException",Errors_Types.from_EDAMUserException _v932))) <$> findNoteOffset_result_userException record
    , (\_v932 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v932))) <$> findNoteOffset_result_systemException record
    , (\_v932 -> (3, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v932))) <$> findNoteOffset_result_notFoundException record
    ]
    )
write_FindNoteOffset_result :: T.Protocol p => p -> FindNoteOffset_result -> P.IO ()
write_FindNoteOffset_result oprot record = T.writeVal oprot $ from_FindNoteOffset_result record
encode_FindNoteOffset_result :: T.StatelessProtocol p => p -> FindNoteOffset_result -> LBS.ByteString
encode_FindNoteOffset_result oprot record = T.serializeVal oprot $ from_FindNoteOffset_result record
to_FindNoteOffset_result :: T.ThriftVal -> FindNoteOffset_result
to_FindNoteOffset_result (T.TStruct fields) = FindNoteOffset_result{
  findNoteOffset_result_success = P.maybe (findNoteOffset_result_success default_FindNoteOffset_result) (\(_,_val934) -> (case _val934 of {T.TI32 _val935 -> _val935; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  findNoteOffset_result_userException = P.maybe (P.Nothing) (\(_,_val934) -> P.Just (case _val934 of {T.TStruct _val936 -> (Errors_Types.to_EDAMUserException (T.TStruct _val936)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  findNoteOffset_result_systemException = P.maybe (P.Nothing) (\(_,_val934) -> P.Just (case _val934 of {T.TStruct _val937 -> (Errors_Types.to_EDAMSystemException (T.TStruct _val937)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  findNoteOffset_result_notFoundException = P.maybe (P.Nothing) (\(_,_val934) -> P.Just (case _val934 of {T.TStruct _val938 -> (Errors_Types.to_EDAMNotFoundException (T.TStruct _val938)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_FindNoteOffset_result _ = P.error "not a struct"
read_FindNoteOffset_result :: T.Protocol p => p -> P.IO FindNoteOffset_result
read_FindNoteOffset_result iprot = to_FindNoteOffset_result <$> T.readVal iprot (T.T_STRUCT typemap_FindNoteOffset_result)
decode_FindNoteOffset_result :: T.StatelessProtocol p => p -> LBS.ByteString -> FindNoteOffset_result
decode_FindNoteOffset_result iprot bs = to_FindNoteOffset_result $ T.deserializeVal iprot (T.T_STRUCT typemap_FindNoteOffset_result) bs
typemap_FindNoteOffset_result :: T.TypeMap
typemap_FindNoteOffset_result = Map.fromList [(0,("success",T.T_I32)),(1,("userException",(T.T_STRUCT Errors_Types.typemap_EDAMUserException))),(2,("systemException",(T.T_STRUCT Errors_Types.typemap_EDAMSystemException))),(3,("notFoundException",(T.T_STRUCT Errors_Types.typemap_EDAMNotFoundException)))]
default_FindNoteOffset_result :: FindNoteOffset_result
default_FindNoteOffset_result = FindNoteOffset_result{
  findNoteOffset_result_success = 0,
  findNoteOffset_result_userException = P.Nothing,
  findNoteOffset_result_systemException = P.Nothing,
  findNoteOffset_result_notFoundException = P.Nothing}
data FindNotesMetadata_args = FindNotesMetadata_args  { findNotesMetadata_args_authenticationToken :: LT.Text
  , findNotesMetadata_args_filter :: NoteFilter
  , findNotesMetadata_args_offset :: I.Int32
  , findNotesMetadata_args_maxNotes :: I.Int32
  , findNotesMetadata_args_resultSpec :: NotesMetadataResultSpec
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable FindNotesMetadata_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` findNotesMetadata_args_authenticationToken record   `H.hashWithSalt` findNotesMetadata_args_filter record   `H.hashWithSalt` findNotesMetadata_args_offset record   `H.hashWithSalt` findNotesMetadata_args_maxNotes record   `H.hashWithSalt` findNotesMetadata_args_resultSpec record  
instance QC.Arbitrary FindNotesMetadata_args where 
  arbitrary = M.liftM FindNotesMetadata_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_FindNotesMetadata_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_FindNotesMetadata_args{findNotesMetadata_args_authenticationToken = findNotesMetadata_args_authenticationToken obj} then P.Nothing else P.Just $ default_FindNotesMetadata_args{findNotesMetadata_args_authenticationToken = findNotesMetadata_args_authenticationToken obj}
    , if obj == default_FindNotesMetadata_args{findNotesMetadata_args_filter = findNotesMetadata_args_filter obj} then P.Nothing else P.Just $ default_FindNotesMetadata_args{findNotesMetadata_args_filter = findNotesMetadata_args_filter obj}
    , if obj == default_FindNotesMetadata_args{findNotesMetadata_args_offset = findNotesMetadata_args_offset obj} then P.Nothing else P.Just $ default_FindNotesMetadata_args{findNotesMetadata_args_offset = findNotesMetadata_args_offset obj}
    , if obj == default_FindNotesMetadata_args{findNotesMetadata_args_maxNotes = findNotesMetadata_args_maxNotes obj} then P.Nothing else P.Just $ default_FindNotesMetadata_args{findNotesMetadata_args_maxNotes = findNotesMetadata_args_maxNotes obj}
    , if obj == default_FindNotesMetadata_args{findNotesMetadata_args_resultSpec = findNotesMetadata_args_resultSpec obj} then P.Nothing else P.Just $ default_FindNotesMetadata_args{findNotesMetadata_args_resultSpec = findNotesMetadata_args_resultSpec obj}
    ]
from_FindNotesMetadata_args :: FindNotesMetadata_args -> T.ThriftVal
from_FindNotesMetadata_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v941 -> P.Just (1, ("authenticationToken",T.TString $ E.encodeUtf8 _v941))) $ findNotesMetadata_args_authenticationToken record
  , (\_v941 -> P.Just (2, ("filter",from_NoteFilter _v941))) $ findNotesMetadata_args_filter record
  , (\_v941 -> P.Just (3, ("offset",T.TI32 _v941))) $ findNotesMetadata_args_offset record
  , (\_v941 -> P.Just (4, ("maxNotes",T.TI32 _v941))) $ findNotesMetadata_args_maxNotes record
  , (\_v941 -> P.Just (5, ("resultSpec",from_NotesMetadataResultSpec _v941))) $ findNotesMetadata_args_resultSpec record
  ]
write_FindNotesMetadata_args :: T.Protocol p => p -> FindNotesMetadata_args -> P.IO ()
write_FindNotesMetadata_args oprot record = T.writeVal oprot $ from_FindNotesMetadata_args record
encode_FindNotesMetadata_args :: T.StatelessProtocol p => p -> FindNotesMetadata_args -> LBS.ByteString
encode_FindNotesMetadata_args oprot record = T.serializeVal oprot $ from_FindNotesMetadata_args record
to_FindNotesMetadata_args :: T.ThriftVal -> FindNotesMetadata_args
to_FindNotesMetadata_args (T.TStruct fields) = FindNotesMetadata_args{
  findNotesMetadata_args_authenticationToken = P.maybe (findNotesMetadata_args_authenticationToken default_FindNotesMetadata_args) (\(_,_val943) -> (case _val943 of {T.TString _val944 -> E.decodeUtf8 _val944; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  findNotesMetadata_args_filter = P.maybe (findNotesMetadata_args_filter default_FindNotesMetadata_args) (\(_,_val943) -> (case _val943 of {T.TStruct _val945 -> (to_NoteFilter (T.TStruct _val945)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  findNotesMetadata_args_offset = P.maybe (findNotesMetadata_args_offset default_FindNotesMetadata_args) (\(_,_val943) -> (case _val943 of {T.TI32 _val946 -> _val946; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  findNotesMetadata_args_maxNotes = P.maybe (findNotesMetadata_args_maxNotes default_FindNotesMetadata_args) (\(_,_val943) -> (case _val943 of {T.TI32 _val947 -> _val947; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  findNotesMetadata_args_resultSpec = P.maybe (findNotesMetadata_args_resultSpec default_FindNotesMetadata_args) (\(_,_val943) -> (case _val943 of {T.TStruct _val948 -> (to_NotesMetadataResultSpec (T.TStruct _val948)); _ -> P.error "wrong type"})) (Map.lookup (5) fields)
  }
to_FindNotesMetadata_args _ = P.error "not a struct"
read_FindNotesMetadata_args :: T.Protocol p => p -> P.IO FindNotesMetadata_args
read_FindNotesMetadata_args iprot = to_FindNotesMetadata_args <$> T.readVal iprot (T.T_STRUCT typemap_FindNotesMetadata_args)
decode_FindNotesMetadata_args :: T.StatelessProtocol p => p -> LBS.ByteString -> FindNotesMetadata_args
decode_FindNotesMetadata_args iprot bs = to_FindNotesMetadata_args $ T.deserializeVal iprot (T.T_STRUCT typemap_FindNotesMetadata_args) bs
typemap_FindNotesMetadata_args :: T.TypeMap
typemap_FindNotesMetadata_args = Map.fromList [(1,("authenticationToken",T.T_STRING)),(2,("filter",(T.T_STRUCT typemap_NoteFilter))),(3,("offset",T.T_I32)),(4,("maxNotes",T.T_I32)),(5,("resultSpec",(T.T_STRUCT typemap_NotesMetadataResultSpec)))]
default_FindNotesMetadata_args :: FindNotesMetadata_args
default_FindNotesMetadata_args = FindNotesMetadata_args{
  findNotesMetadata_args_authenticationToken = "",
  findNotesMetadata_args_filter = default_NoteFilter,
  findNotesMetadata_args_offset = 0,
  findNotesMetadata_args_maxNotes = 0,
  findNotesMetadata_args_resultSpec = default_NotesMetadataResultSpec}
data FindNotesMetadata_result = FindNotesMetadata_result  { findNotesMetadata_result_success :: NotesMetadataList
  , findNotesMetadata_result_userException :: P.Maybe Errors_Types.EDAMUserException
  , findNotesMetadata_result_systemException :: P.Maybe Errors_Types.EDAMSystemException
  , findNotesMetadata_result_notFoundException :: P.Maybe Errors_Types.EDAMNotFoundException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable FindNotesMetadata_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` findNotesMetadata_result_success record   `H.hashWithSalt` findNotesMetadata_result_userException record   `H.hashWithSalt` findNotesMetadata_result_systemException record   `H.hashWithSalt` findNotesMetadata_result_notFoundException record  
instance QC.Arbitrary FindNotesMetadata_result where 
  arbitrary = M.liftM FindNotesMetadata_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_FindNotesMetadata_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_FindNotesMetadata_result{findNotesMetadata_result_success = findNotesMetadata_result_success obj} then P.Nothing else P.Just $ default_FindNotesMetadata_result{findNotesMetadata_result_success = findNotesMetadata_result_success obj}
    , if obj == default_FindNotesMetadata_result{findNotesMetadata_result_userException = findNotesMetadata_result_userException obj} then P.Nothing else P.Just $ default_FindNotesMetadata_result{findNotesMetadata_result_userException = findNotesMetadata_result_userException obj}
    , if obj == default_FindNotesMetadata_result{findNotesMetadata_result_systemException = findNotesMetadata_result_systemException obj} then P.Nothing else P.Just $ default_FindNotesMetadata_result{findNotesMetadata_result_systemException = findNotesMetadata_result_systemException obj}
    , if obj == default_FindNotesMetadata_result{findNotesMetadata_result_notFoundException = findNotesMetadata_result_notFoundException obj} then P.Nothing else P.Just $ default_FindNotesMetadata_result{findNotesMetadata_result_notFoundException = findNotesMetadata_result_notFoundException obj}
    ]
from_FindNotesMetadata_result :: FindNotesMetadata_result -> T.ThriftVal
from_FindNotesMetadata_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v951 -> (1, ("userException",Errors_Types.from_EDAMUserException _v951))) <$> findNotesMetadata_result_userException record, (\_v951 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v951))) <$> findNotesMetadata_result_systemException record, (\_v951 -> (3, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v951))) <$> findNotesMetadata_result_notFoundException record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v951 -> P.Just (0, ("success",from_NotesMetadataList _v951))) $ findNotesMetadata_result_success record
    , (\_v951 -> (1, ("userException",Errors_Types.from_EDAMUserException _v951))) <$> findNotesMetadata_result_userException record
    , (\_v951 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v951))) <$> findNotesMetadata_result_systemException record
    , (\_v951 -> (3, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v951))) <$> findNotesMetadata_result_notFoundException record
    ]
    )
write_FindNotesMetadata_result :: T.Protocol p => p -> FindNotesMetadata_result -> P.IO ()
write_FindNotesMetadata_result oprot record = T.writeVal oprot $ from_FindNotesMetadata_result record
encode_FindNotesMetadata_result :: T.StatelessProtocol p => p -> FindNotesMetadata_result -> LBS.ByteString
encode_FindNotesMetadata_result oprot record = T.serializeVal oprot $ from_FindNotesMetadata_result record
to_FindNotesMetadata_result :: T.ThriftVal -> FindNotesMetadata_result
to_FindNotesMetadata_result (T.TStruct fields) = FindNotesMetadata_result{
  findNotesMetadata_result_success = P.maybe (findNotesMetadata_result_success default_FindNotesMetadata_result) (\(_,_val953) -> (case _val953 of {T.TStruct _val954 -> (to_NotesMetadataList (T.TStruct _val954)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  findNotesMetadata_result_userException = P.maybe (P.Nothing) (\(_,_val953) -> P.Just (case _val953 of {T.TStruct _val955 -> (Errors_Types.to_EDAMUserException (T.TStruct _val955)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  findNotesMetadata_result_systemException = P.maybe (P.Nothing) (\(_,_val953) -> P.Just (case _val953 of {T.TStruct _val956 -> (Errors_Types.to_EDAMSystemException (T.TStruct _val956)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  findNotesMetadata_result_notFoundException = P.maybe (P.Nothing) (\(_,_val953) -> P.Just (case _val953 of {T.TStruct _val957 -> (Errors_Types.to_EDAMNotFoundException (T.TStruct _val957)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_FindNotesMetadata_result _ = P.error "not a struct"
read_FindNotesMetadata_result :: T.Protocol p => p -> P.IO FindNotesMetadata_result
read_FindNotesMetadata_result iprot = to_FindNotesMetadata_result <$> T.readVal iprot (T.T_STRUCT typemap_FindNotesMetadata_result)
decode_FindNotesMetadata_result :: T.StatelessProtocol p => p -> LBS.ByteString -> FindNotesMetadata_result
decode_FindNotesMetadata_result iprot bs = to_FindNotesMetadata_result $ T.deserializeVal iprot (T.T_STRUCT typemap_FindNotesMetadata_result) bs
typemap_FindNotesMetadata_result :: T.TypeMap
typemap_FindNotesMetadata_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_NotesMetadataList))),(1,("userException",(T.T_STRUCT Errors_Types.typemap_EDAMUserException))),(2,("systemException",(T.T_STRUCT Errors_Types.typemap_EDAMSystemException))),(3,("notFoundException",(T.T_STRUCT Errors_Types.typemap_EDAMNotFoundException)))]
default_FindNotesMetadata_result :: FindNotesMetadata_result
default_FindNotesMetadata_result = FindNotesMetadata_result{
  findNotesMetadata_result_success = default_NotesMetadataList,
  findNotesMetadata_result_userException = P.Nothing,
  findNotesMetadata_result_systemException = P.Nothing,
  findNotesMetadata_result_notFoundException = P.Nothing}
data FindNoteCounts_args = FindNoteCounts_args  { findNoteCounts_args_authenticationToken :: LT.Text
  , findNoteCounts_args_filter :: NoteFilter
  , findNoteCounts_args_withTrash :: P.Bool
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable FindNoteCounts_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` findNoteCounts_args_authenticationToken record   `H.hashWithSalt` findNoteCounts_args_filter record   `H.hashWithSalt` findNoteCounts_args_withTrash record  
instance QC.Arbitrary FindNoteCounts_args where 
  arbitrary = M.liftM FindNoteCounts_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_FindNoteCounts_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_FindNoteCounts_args{findNoteCounts_args_authenticationToken = findNoteCounts_args_authenticationToken obj} then P.Nothing else P.Just $ default_FindNoteCounts_args{findNoteCounts_args_authenticationToken = findNoteCounts_args_authenticationToken obj}
    , if obj == default_FindNoteCounts_args{findNoteCounts_args_filter = findNoteCounts_args_filter obj} then P.Nothing else P.Just $ default_FindNoteCounts_args{findNoteCounts_args_filter = findNoteCounts_args_filter obj}
    , if obj == default_FindNoteCounts_args{findNoteCounts_args_withTrash = findNoteCounts_args_withTrash obj} then P.Nothing else P.Just $ default_FindNoteCounts_args{findNoteCounts_args_withTrash = findNoteCounts_args_withTrash obj}
    ]
from_FindNoteCounts_args :: FindNoteCounts_args -> T.ThriftVal
from_FindNoteCounts_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v960 -> P.Just (1, ("authenticationToken",T.TString $ E.encodeUtf8 _v960))) $ findNoteCounts_args_authenticationToken record
  , (\_v960 -> P.Just (2, ("filter",from_NoteFilter _v960))) $ findNoteCounts_args_filter record
  , (\_v960 -> P.Just (3, ("withTrash",T.TBool _v960))) $ findNoteCounts_args_withTrash record
  ]
write_FindNoteCounts_args :: T.Protocol p => p -> FindNoteCounts_args -> P.IO ()
write_FindNoteCounts_args oprot record = T.writeVal oprot $ from_FindNoteCounts_args record
encode_FindNoteCounts_args :: T.StatelessProtocol p => p -> FindNoteCounts_args -> LBS.ByteString
encode_FindNoteCounts_args oprot record = T.serializeVal oprot $ from_FindNoteCounts_args record
to_FindNoteCounts_args :: T.ThriftVal -> FindNoteCounts_args
to_FindNoteCounts_args (T.TStruct fields) = FindNoteCounts_args{
  findNoteCounts_args_authenticationToken = P.maybe (findNoteCounts_args_authenticationToken default_FindNoteCounts_args) (\(_,_val962) -> (case _val962 of {T.TString _val963 -> E.decodeUtf8 _val963; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  findNoteCounts_args_filter = P.maybe (findNoteCounts_args_filter default_FindNoteCounts_args) (\(_,_val962) -> (case _val962 of {T.TStruct _val964 -> (to_NoteFilter (T.TStruct _val964)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  findNoteCounts_args_withTrash = P.maybe (findNoteCounts_args_withTrash default_FindNoteCounts_args) (\(_,_val962) -> (case _val962 of {T.TBool _val965 -> _val965; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_FindNoteCounts_args _ = P.error "not a struct"
read_FindNoteCounts_args :: T.Protocol p => p -> P.IO FindNoteCounts_args
read_FindNoteCounts_args iprot = to_FindNoteCounts_args <$> T.readVal iprot (T.T_STRUCT typemap_FindNoteCounts_args)
decode_FindNoteCounts_args :: T.StatelessProtocol p => p -> LBS.ByteString -> FindNoteCounts_args
decode_FindNoteCounts_args iprot bs = to_FindNoteCounts_args $ T.deserializeVal iprot (T.T_STRUCT typemap_FindNoteCounts_args) bs
typemap_FindNoteCounts_args :: T.TypeMap
typemap_FindNoteCounts_args = Map.fromList [(1,("authenticationToken",T.T_STRING)),(2,("filter",(T.T_STRUCT typemap_NoteFilter))),(3,("withTrash",T.T_BOOL))]
default_FindNoteCounts_args :: FindNoteCounts_args
default_FindNoteCounts_args = FindNoteCounts_args{
  findNoteCounts_args_authenticationToken = "",
  findNoteCounts_args_filter = default_NoteFilter,
  findNoteCounts_args_withTrash = P.False}
data FindNoteCounts_result = FindNoteCounts_result  { findNoteCounts_result_success :: NoteCollectionCounts
  , findNoteCounts_result_userException :: P.Maybe Errors_Types.EDAMUserException
  , findNoteCounts_result_systemException :: P.Maybe Errors_Types.EDAMSystemException
  , findNoteCounts_result_notFoundException :: P.Maybe Errors_Types.EDAMNotFoundException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable FindNoteCounts_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` findNoteCounts_result_success record   `H.hashWithSalt` findNoteCounts_result_userException record   `H.hashWithSalt` findNoteCounts_result_systemException record   `H.hashWithSalt` findNoteCounts_result_notFoundException record  
instance QC.Arbitrary FindNoteCounts_result where 
  arbitrary = M.liftM FindNoteCounts_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_FindNoteCounts_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_FindNoteCounts_result{findNoteCounts_result_success = findNoteCounts_result_success obj} then P.Nothing else P.Just $ default_FindNoteCounts_result{findNoteCounts_result_success = findNoteCounts_result_success obj}
    , if obj == default_FindNoteCounts_result{findNoteCounts_result_userException = findNoteCounts_result_userException obj} then P.Nothing else P.Just $ default_FindNoteCounts_result{findNoteCounts_result_userException = findNoteCounts_result_userException obj}
    , if obj == default_FindNoteCounts_result{findNoteCounts_result_systemException = findNoteCounts_result_systemException obj} then P.Nothing else P.Just $ default_FindNoteCounts_result{findNoteCounts_result_systemException = findNoteCounts_result_systemException obj}
    , if obj == default_FindNoteCounts_result{findNoteCounts_result_notFoundException = findNoteCounts_result_notFoundException obj} then P.Nothing else P.Just $ default_FindNoteCounts_result{findNoteCounts_result_notFoundException = findNoteCounts_result_notFoundException obj}
    ]
from_FindNoteCounts_result :: FindNoteCounts_result -> T.ThriftVal
from_FindNoteCounts_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v968 -> (1, ("userException",Errors_Types.from_EDAMUserException _v968))) <$> findNoteCounts_result_userException record, (\_v968 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v968))) <$> findNoteCounts_result_systemException record, (\_v968 -> (3, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v968))) <$> findNoteCounts_result_notFoundException record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v968 -> P.Just (0, ("success",from_NoteCollectionCounts _v968))) $ findNoteCounts_result_success record
    , (\_v968 -> (1, ("userException",Errors_Types.from_EDAMUserException _v968))) <$> findNoteCounts_result_userException record
    , (\_v968 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v968))) <$> findNoteCounts_result_systemException record
    , (\_v968 -> (3, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v968))) <$> findNoteCounts_result_notFoundException record
    ]
    )
write_FindNoteCounts_result :: T.Protocol p => p -> FindNoteCounts_result -> P.IO ()
write_FindNoteCounts_result oprot record = T.writeVal oprot $ from_FindNoteCounts_result record
encode_FindNoteCounts_result :: T.StatelessProtocol p => p -> FindNoteCounts_result -> LBS.ByteString
encode_FindNoteCounts_result oprot record = T.serializeVal oprot $ from_FindNoteCounts_result record
to_FindNoteCounts_result :: T.ThriftVal -> FindNoteCounts_result
to_FindNoteCounts_result (T.TStruct fields) = FindNoteCounts_result{
  findNoteCounts_result_success = P.maybe (findNoteCounts_result_success default_FindNoteCounts_result) (\(_,_val970) -> (case _val970 of {T.TStruct _val971 -> (to_NoteCollectionCounts (T.TStruct _val971)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  findNoteCounts_result_userException = P.maybe (P.Nothing) (\(_,_val970) -> P.Just (case _val970 of {T.TStruct _val972 -> (Errors_Types.to_EDAMUserException (T.TStruct _val972)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  findNoteCounts_result_systemException = P.maybe (P.Nothing) (\(_,_val970) -> P.Just (case _val970 of {T.TStruct _val973 -> (Errors_Types.to_EDAMSystemException (T.TStruct _val973)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  findNoteCounts_result_notFoundException = P.maybe (P.Nothing) (\(_,_val970) -> P.Just (case _val970 of {T.TStruct _val974 -> (Errors_Types.to_EDAMNotFoundException (T.TStruct _val974)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_FindNoteCounts_result _ = P.error "not a struct"
read_FindNoteCounts_result :: T.Protocol p => p -> P.IO FindNoteCounts_result
read_FindNoteCounts_result iprot = to_FindNoteCounts_result <$> T.readVal iprot (T.T_STRUCT typemap_FindNoteCounts_result)
decode_FindNoteCounts_result :: T.StatelessProtocol p => p -> LBS.ByteString -> FindNoteCounts_result
decode_FindNoteCounts_result iprot bs = to_FindNoteCounts_result $ T.deserializeVal iprot (T.T_STRUCT typemap_FindNoteCounts_result) bs
typemap_FindNoteCounts_result :: T.TypeMap
typemap_FindNoteCounts_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_NoteCollectionCounts))),(1,("userException",(T.T_STRUCT Errors_Types.typemap_EDAMUserException))),(2,("systemException",(T.T_STRUCT Errors_Types.typemap_EDAMSystemException))),(3,("notFoundException",(T.T_STRUCT Errors_Types.typemap_EDAMNotFoundException)))]
default_FindNoteCounts_result :: FindNoteCounts_result
default_FindNoteCounts_result = FindNoteCounts_result{
  findNoteCounts_result_success = default_NoteCollectionCounts,
  findNoteCounts_result_userException = P.Nothing,
  findNoteCounts_result_systemException = P.Nothing,
  findNoteCounts_result_notFoundException = P.Nothing}
data GetNoteWithResultSpec_args = GetNoteWithResultSpec_args  { getNoteWithResultSpec_args_authenticationToken :: LT.Text
  , getNoteWithResultSpec_args_guid :: LT.Text
  , getNoteWithResultSpec_args_resultSpec :: NoteResultSpec
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetNoteWithResultSpec_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getNoteWithResultSpec_args_authenticationToken record   `H.hashWithSalt` getNoteWithResultSpec_args_guid record   `H.hashWithSalt` getNoteWithResultSpec_args_resultSpec record  
instance QC.Arbitrary GetNoteWithResultSpec_args where 
  arbitrary = M.liftM GetNoteWithResultSpec_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GetNoteWithResultSpec_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetNoteWithResultSpec_args{getNoteWithResultSpec_args_authenticationToken = getNoteWithResultSpec_args_authenticationToken obj} then P.Nothing else P.Just $ default_GetNoteWithResultSpec_args{getNoteWithResultSpec_args_authenticationToken = getNoteWithResultSpec_args_authenticationToken obj}
    , if obj == default_GetNoteWithResultSpec_args{getNoteWithResultSpec_args_guid = getNoteWithResultSpec_args_guid obj} then P.Nothing else P.Just $ default_GetNoteWithResultSpec_args{getNoteWithResultSpec_args_guid = getNoteWithResultSpec_args_guid obj}
    , if obj == default_GetNoteWithResultSpec_args{getNoteWithResultSpec_args_resultSpec = getNoteWithResultSpec_args_resultSpec obj} then P.Nothing else P.Just $ default_GetNoteWithResultSpec_args{getNoteWithResultSpec_args_resultSpec = getNoteWithResultSpec_args_resultSpec obj}
    ]
from_GetNoteWithResultSpec_args :: GetNoteWithResultSpec_args -> T.ThriftVal
from_GetNoteWithResultSpec_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v977 -> P.Just (1, ("authenticationToken",T.TString $ E.encodeUtf8 _v977))) $ getNoteWithResultSpec_args_authenticationToken record
  , (\_v977 -> P.Just (2, ("guid",T.TString $ E.encodeUtf8 _v977))) $ getNoteWithResultSpec_args_guid record
  , (\_v977 -> P.Just (3, ("resultSpec",from_NoteResultSpec _v977))) $ getNoteWithResultSpec_args_resultSpec record
  ]
write_GetNoteWithResultSpec_args :: T.Protocol p => p -> GetNoteWithResultSpec_args -> P.IO ()
write_GetNoteWithResultSpec_args oprot record = T.writeVal oprot $ from_GetNoteWithResultSpec_args record
encode_GetNoteWithResultSpec_args :: T.StatelessProtocol p => p -> GetNoteWithResultSpec_args -> LBS.ByteString
encode_GetNoteWithResultSpec_args oprot record = T.serializeVal oprot $ from_GetNoteWithResultSpec_args record
to_GetNoteWithResultSpec_args :: T.ThriftVal -> GetNoteWithResultSpec_args
to_GetNoteWithResultSpec_args (T.TStruct fields) = GetNoteWithResultSpec_args{
  getNoteWithResultSpec_args_authenticationToken = P.maybe (getNoteWithResultSpec_args_authenticationToken default_GetNoteWithResultSpec_args) (\(_,_val979) -> (case _val979 of {T.TString _val980 -> E.decodeUtf8 _val980; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  getNoteWithResultSpec_args_guid = P.maybe (getNoteWithResultSpec_args_guid default_GetNoteWithResultSpec_args) (\(_,_val979) -> (case _val979 of {T.TString _val981 -> E.decodeUtf8 _val981; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  getNoteWithResultSpec_args_resultSpec = P.maybe (getNoteWithResultSpec_args_resultSpec default_GetNoteWithResultSpec_args) (\(_,_val979) -> (case _val979 of {T.TStruct _val982 -> (to_NoteResultSpec (T.TStruct _val982)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_GetNoteWithResultSpec_args _ = P.error "not a struct"
read_GetNoteWithResultSpec_args :: T.Protocol p => p -> P.IO GetNoteWithResultSpec_args
read_GetNoteWithResultSpec_args iprot = to_GetNoteWithResultSpec_args <$> T.readVal iprot (T.T_STRUCT typemap_GetNoteWithResultSpec_args)
decode_GetNoteWithResultSpec_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetNoteWithResultSpec_args
decode_GetNoteWithResultSpec_args iprot bs = to_GetNoteWithResultSpec_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetNoteWithResultSpec_args) bs
typemap_GetNoteWithResultSpec_args :: T.TypeMap
typemap_GetNoteWithResultSpec_args = Map.fromList [(1,("authenticationToken",T.T_STRING)),(2,("guid",T.T_STRING)),(3,("resultSpec",(T.T_STRUCT typemap_NoteResultSpec)))]
default_GetNoteWithResultSpec_args :: GetNoteWithResultSpec_args
default_GetNoteWithResultSpec_args = GetNoteWithResultSpec_args{
  getNoteWithResultSpec_args_authenticationToken = "",
  getNoteWithResultSpec_args_guid = "",
  getNoteWithResultSpec_args_resultSpec = default_NoteResultSpec}
data GetNoteWithResultSpec_result = GetNoteWithResultSpec_result  { getNoteWithResultSpec_result_success :: Types_Types.Note
  , getNoteWithResultSpec_result_userException :: P.Maybe Errors_Types.EDAMUserException
  , getNoteWithResultSpec_result_systemException :: P.Maybe Errors_Types.EDAMSystemException
  , getNoteWithResultSpec_result_notFoundException :: P.Maybe Errors_Types.EDAMNotFoundException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetNoteWithResultSpec_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getNoteWithResultSpec_result_success record   `H.hashWithSalt` getNoteWithResultSpec_result_userException record   `H.hashWithSalt` getNoteWithResultSpec_result_systemException record   `H.hashWithSalt` getNoteWithResultSpec_result_notFoundException record  
instance QC.Arbitrary GetNoteWithResultSpec_result where 
  arbitrary = M.liftM GetNoteWithResultSpec_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetNoteWithResultSpec_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetNoteWithResultSpec_result{getNoteWithResultSpec_result_success = getNoteWithResultSpec_result_success obj} then P.Nothing else P.Just $ default_GetNoteWithResultSpec_result{getNoteWithResultSpec_result_success = getNoteWithResultSpec_result_success obj}
    , if obj == default_GetNoteWithResultSpec_result{getNoteWithResultSpec_result_userException = getNoteWithResultSpec_result_userException obj} then P.Nothing else P.Just $ default_GetNoteWithResultSpec_result{getNoteWithResultSpec_result_userException = getNoteWithResultSpec_result_userException obj}
    , if obj == default_GetNoteWithResultSpec_result{getNoteWithResultSpec_result_systemException = getNoteWithResultSpec_result_systemException obj} then P.Nothing else P.Just $ default_GetNoteWithResultSpec_result{getNoteWithResultSpec_result_systemException = getNoteWithResultSpec_result_systemException obj}
    , if obj == default_GetNoteWithResultSpec_result{getNoteWithResultSpec_result_notFoundException = getNoteWithResultSpec_result_notFoundException obj} then P.Nothing else P.Just $ default_GetNoteWithResultSpec_result{getNoteWithResultSpec_result_notFoundException = getNoteWithResultSpec_result_notFoundException obj}
    ]
from_GetNoteWithResultSpec_result :: GetNoteWithResultSpec_result -> T.ThriftVal
from_GetNoteWithResultSpec_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v985 -> (1, ("userException",Errors_Types.from_EDAMUserException _v985))) <$> getNoteWithResultSpec_result_userException record, (\_v985 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v985))) <$> getNoteWithResultSpec_result_systemException record, (\_v985 -> (3, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v985))) <$> getNoteWithResultSpec_result_notFoundException record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v985 -> P.Just (0, ("success",Types_Types.from_Note _v985))) $ getNoteWithResultSpec_result_success record
    , (\_v985 -> (1, ("userException",Errors_Types.from_EDAMUserException _v985))) <$> getNoteWithResultSpec_result_userException record
    , (\_v985 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v985))) <$> getNoteWithResultSpec_result_systemException record
    , (\_v985 -> (3, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v985))) <$> getNoteWithResultSpec_result_notFoundException record
    ]
    )
write_GetNoteWithResultSpec_result :: T.Protocol p => p -> GetNoteWithResultSpec_result -> P.IO ()
write_GetNoteWithResultSpec_result oprot record = T.writeVal oprot $ from_GetNoteWithResultSpec_result record
encode_GetNoteWithResultSpec_result :: T.StatelessProtocol p => p -> GetNoteWithResultSpec_result -> LBS.ByteString
encode_GetNoteWithResultSpec_result oprot record = T.serializeVal oprot $ from_GetNoteWithResultSpec_result record
to_GetNoteWithResultSpec_result :: T.ThriftVal -> GetNoteWithResultSpec_result
to_GetNoteWithResultSpec_result (T.TStruct fields) = GetNoteWithResultSpec_result{
  getNoteWithResultSpec_result_success = P.maybe (getNoteWithResultSpec_result_success default_GetNoteWithResultSpec_result) (\(_,_val987) -> (case _val987 of {T.TStruct _val988 -> (Types_Types.to_Note (T.TStruct _val988)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getNoteWithResultSpec_result_userException = P.maybe (P.Nothing) (\(_,_val987) -> P.Just (case _val987 of {T.TStruct _val989 -> (Errors_Types.to_EDAMUserException (T.TStruct _val989)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  getNoteWithResultSpec_result_systemException = P.maybe (P.Nothing) (\(_,_val987) -> P.Just (case _val987 of {T.TStruct _val990 -> (Errors_Types.to_EDAMSystemException (T.TStruct _val990)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  getNoteWithResultSpec_result_notFoundException = P.maybe (P.Nothing) (\(_,_val987) -> P.Just (case _val987 of {T.TStruct _val991 -> (Errors_Types.to_EDAMNotFoundException (T.TStruct _val991)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_GetNoteWithResultSpec_result _ = P.error "not a struct"
read_GetNoteWithResultSpec_result :: T.Protocol p => p -> P.IO GetNoteWithResultSpec_result
read_GetNoteWithResultSpec_result iprot = to_GetNoteWithResultSpec_result <$> T.readVal iprot (T.T_STRUCT typemap_GetNoteWithResultSpec_result)
decode_GetNoteWithResultSpec_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetNoteWithResultSpec_result
decode_GetNoteWithResultSpec_result iprot bs = to_GetNoteWithResultSpec_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetNoteWithResultSpec_result) bs
typemap_GetNoteWithResultSpec_result :: T.TypeMap
typemap_GetNoteWithResultSpec_result = Map.fromList [(0,("success",(T.T_STRUCT Types_Types.typemap_Note))),(1,("userException",(T.T_STRUCT Errors_Types.typemap_EDAMUserException))),(2,("systemException",(T.T_STRUCT Errors_Types.typemap_EDAMSystemException))),(3,("notFoundException",(T.T_STRUCT Errors_Types.typemap_EDAMNotFoundException)))]
default_GetNoteWithResultSpec_result :: GetNoteWithResultSpec_result
default_GetNoteWithResultSpec_result = GetNoteWithResultSpec_result{
  getNoteWithResultSpec_result_success = Types_Types.default_Note,
  getNoteWithResultSpec_result_userException = P.Nothing,
  getNoteWithResultSpec_result_systemException = P.Nothing,
  getNoteWithResultSpec_result_notFoundException = P.Nothing}
data GetNote_args = GetNote_args  { getNote_args_authenticationToken :: LT.Text
  , getNote_args_guid :: LT.Text
  , getNote_args_withContent :: P.Bool
  , getNote_args_withResourcesData :: P.Bool
  , getNote_args_withResourcesRecognition :: P.Bool
  , getNote_args_withResourcesAlternateData :: P.Bool
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetNote_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getNote_args_authenticationToken record   `H.hashWithSalt` getNote_args_guid record   `H.hashWithSalt` getNote_args_withContent record   `H.hashWithSalt` getNote_args_withResourcesData record   `H.hashWithSalt` getNote_args_withResourcesRecognition record   `H.hashWithSalt` getNote_args_withResourcesAlternateData record  
instance QC.Arbitrary GetNote_args where 
  arbitrary = M.liftM GetNote_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GetNote_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetNote_args{getNote_args_authenticationToken = getNote_args_authenticationToken obj} then P.Nothing else P.Just $ default_GetNote_args{getNote_args_authenticationToken = getNote_args_authenticationToken obj}
    , if obj == default_GetNote_args{getNote_args_guid = getNote_args_guid obj} then P.Nothing else P.Just $ default_GetNote_args{getNote_args_guid = getNote_args_guid obj}
    , if obj == default_GetNote_args{getNote_args_withContent = getNote_args_withContent obj} then P.Nothing else P.Just $ default_GetNote_args{getNote_args_withContent = getNote_args_withContent obj}
    , if obj == default_GetNote_args{getNote_args_withResourcesData = getNote_args_withResourcesData obj} then P.Nothing else P.Just $ default_GetNote_args{getNote_args_withResourcesData = getNote_args_withResourcesData obj}
    , if obj == default_GetNote_args{getNote_args_withResourcesRecognition = getNote_args_withResourcesRecognition obj} then P.Nothing else P.Just $ default_GetNote_args{getNote_args_withResourcesRecognition = getNote_args_withResourcesRecognition obj}
    , if obj == default_GetNote_args{getNote_args_withResourcesAlternateData = getNote_args_withResourcesAlternateData obj} then P.Nothing else P.Just $ default_GetNote_args{getNote_args_withResourcesAlternateData = getNote_args_withResourcesAlternateData obj}
    ]
from_GetNote_args :: GetNote_args -> T.ThriftVal
from_GetNote_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v994 -> P.Just (1, ("authenticationToken",T.TString $ E.encodeUtf8 _v994))) $ getNote_args_authenticationToken record
  , (\_v994 -> P.Just (2, ("guid",T.TString $ E.encodeUtf8 _v994))) $ getNote_args_guid record
  , (\_v994 -> P.Just (3, ("withContent",T.TBool _v994))) $ getNote_args_withContent record
  , (\_v994 -> P.Just (4, ("withResourcesData",T.TBool _v994))) $ getNote_args_withResourcesData record
  , (\_v994 -> P.Just (5, ("withResourcesRecognition",T.TBool _v994))) $ getNote_args_withResourcesRecognition record
  , (\_v994 -> P.Just (6, ("withResourcesAlternateData",T.TBool _v994))) $ getNote_args_withResourcesAlternateData record
  ]
write_GetNote_args :: T.Protocol p => p -> GetNote_args -> P.IO ()
write_GetNote_args oprot record = T.writeVal oprot $ from_GetNote_args record
encode_GetNote_args :: T.StatelessProtocol p => p -> GetNote_args -> LBS.ByteString
encode_GetNote_args oprot record = T.serializeVal oprot $ from_GetNote_args record
to_GetNote_args :: T.ThriftVal -> GetNote_args
to_GetNote_args (T.TStruct fields) = GetNote_args{
  getNote_args_authenticationToken = P.maybe (getNote_args_authenticationToken default_GetNote_args) (\(_,_val996) -> (case _val996 of {T.TString _val997 -> E.decodeUtf8 _val997; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  getNote_args_guid = P.maybe (getNote_args_guid default_GetNote_args) (\(_,_val996) -> (case _val996 of {T.TString _val998 -> E.decodeUtf8 _val998; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  getNote_args_withContent = P.maybe (getNote_args_withContent default_GetNote_args) (\(_,_val996) -> (case _val996 of {T.TBool _val999 -> _val999; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  getNote_args_withResourcesData = P.maybe (getNote_args_withResourcesData default_GetNote_args) (\(_,_val996) -> (case _val996 of {T.TBool _val1000 -> _val1000; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  getNote_args_withResourcesRecognition = P.maybe (getNote_args_withResourcesRecognition default_GetNote_args) (\(_,_val996) -> (case _val996 of {T.TBool _val1001 -> _val1001; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  getNote_args_withResourcesAlternateData = P.maybe (getNote_args_withResourcesAlternateData default_GetNote_args) (\(_,_val996) -> (case _val996 of {T.TBool _val1002 -> _val1002; _ -> P.error "wrong type"})) (Map.lookup (6) fields)
  }
to_GetNote_args _ = P.error "not a struct"
read_GetNote_args :: T.Protocol p => p -> P.IO GetNote_args
read_GetNote_args iprot = to_GetNote_args <$> T.readVal iprot (T.T_STRUCT typemap_GetNote_args)
decode_GetNote_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetNote_args
decode_GetNote_args iprot bs = to_GetNote_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetNote_args) bs
typemap_GetNote_args :: T.TypeMap
typemap_GetNote_args = Map.fromList [(1,("authenticationToken",T.T_STRING)),(2,("guid",T.T_STRING)),(3,("withContent",T.T_BOOL)),(4,("withResourcesData",T.T_BOOL)),(5,("withResourcesRecognition",T.T_BOOL)),(6,("withResourcesAlternateData",T.T_BOOL))]
default_GetNote_args :: GetNote_args
default_GetNote_args = GetNote_args{
  getNote_args_authenticationToken = "",
  getNote_args_guid = "",
  getNote_args_withContent = P.False,
  getNote_args_withResourcesData = P.False,
  getNote_args_withResourcesRecognition = P.False,
  getNote_args_withResourcesAlternateData = P.False}
data GetNote_result = GetNote_result  { getNote_result_success :: Types_Types.Note
  , getNote_result_userException :: P.Maybe Errors_Types.EDAMUserException
  , getNote_result_systemException :: P.Maybe Errors_Types.EDAMSystemException
  , getNote_result_notFoundException :: P.Maybe Errors_Types.EDAMNotFoundException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetNote_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getNote_result_success record   `H.hashWithSalt` getNote_result_userException record   `H.hashWithSalt` getNote_result_systemException record   `H.hashWithSalt` getNote_result_notFoundException record  
instance QC.Arbitrary GetNote_result where 
  arbitrary = M.liftM GetNote_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetNote_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetNote_result{getNote_result_success = getNote_result_success obj} then P.Nothing else P.Just $ default_GetNote_result{getNote_result_success = getNote_result_success obj}
    , if obj == default_GetNote_result{getNote_result_userException = getNote_result_userException obj} then P.Nothing else P.Just $ default_GetNote_result{getNote_result_userException = getNote_result_userException obj}
    , if obj == default_GetNote_result{getNote_result_systemException = getNote_result_systemException obj} then P.Nothing else P.Just $ default_GetNote_result{getNote_result_systemException = getNote_result_systemException obj}
    , if obj == default_GetNote_result{getNote_result_notFoundException = getNote_result_notFoundException obj} then P.Nothing else P.Just $ default_GetNote_result{getNote_result_notFoundException = getNote_result_notFoundException obj}
    ]
from_GetNote_result :: GetNote_result -> T.ThriftVal
from_GetNote_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v1005 -> (1, ("userException",Errors_Types.from_EDAMUserException _v1005))) <$> getNote_result_userException record, (\_v1005 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v1005))) <$> getNote_result_systemException record, (\_v1005 -> (3, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v1005))) <$> getNote_result_notFoundException record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v1005 -> P.Just (0, ("success",Types_Types.from_Note _v1005))) $ getNote_result_success record
    , (\_v1005 -> (1, ("userException",Errors_Types.from_EDAMUserException _v1005))) <$> getNote_result_userException record
    , (\_v1005 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v1005))) <$> getNote_result_systemException record
    , (\_v1005 -> (3, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v1005))) <$> getNote_result_notFoundException record
    ]
    )
write_GetNote_result :: T.Protocol p => p -> GetNote_result -> P.IO ()
write_GetNote_result oprot record = T.writeVal oprot $ from_GetNote_result record
encode_GetNote_result :: T.StatelessProtocol p => p -> GetNote_result -> LBS.ByteString
encode_GetNote_result oprot record = T.serializeVal oprot $ from_GetNote_result record
to_GetNote_result :: T.ThriftVal -> GetNote_result
to_GetNote_result (T.TStruct fields) = GetNote_result{
  getNote_result_success = P.maybe (getNote_result_success default_GetNote_result) (\(_,_val1007) -> (case _val1007 of {T.TStruct _val1008 -> (Types_Types.to_Note (T.TStruct _val1008)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getNote_result_userException = P.maybe (P.Nothing) (\(_,_val1007) -> P.Just (case _val1007 of {T.TStruct _val1009 -> (Errors_Types.to_EDAMUserException (T.TStruct _val1009)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  getNote_result_systemException = P.maybe (P.Nothing) (\(_,_val1007) -> P.Just (case _val1007 of {T.TStruct _val1010 -> (Errors_Types.to_EDAMSystemException (T.TStruct _val1010)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  getNote_result_notFoundException = P.maybe (P.Nothing) (\(_,_val1007) -> P.Just (case _val1007 of {T.TStruct _val1011 -> (Errors_Types.to_EDAMNotFoundException (T.TStruct _val1011)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_GetNote_result _ = P.error "not a struct"
read_GetNote_result :: T.Protocol p => p -> P.IO GetNote_result
read_GetNote_result iprot = to_GetNote_result <$> T.readVal iprot (T.T_STRUCT typemap_GetNote_result)
decode_GetNote_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetNote_result
decode_GetNote_result iprot bs = to_GetNote_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetNote_result) bs
typemap_GetNote_result :: T.TypeMap
typemap_GetNote_result = Map.fromList [(0,("success",(T.T_STRUCT Types_Types.typemap_Note))),(1,("userException",(T.T_STRUCT Errors_Types.typemap_EDAMUserException))),(2,("systemException",(T.T_STRUCT Errors_Types.typemap_EDAMSystemException))),(3,("notFoundException",(T.T_STRUCT Errors_Types.typemap_EDAMNotFoundException)))]
default_GetNote_result :: GetNote_result
default_GetNote_result = GetNote_result{
  getNote_result_success = Types_Types.default_Note,
  getNote_result_userException = P.Nothing,
  getNote_result_systemException = P.Nothing,
  getNote_result_notFoundException = P.Nothing}
data GetNoteApplicationData_args = GetNoteApplicationData_args  { getNoteApplicationData_args_authenticationToken :: LT.Text
  , getNoteApplicationData_args_guid :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetNoteApplicationData_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getNoteApplicationData_args_authenticationToken record   `H.hashWithSalt` getNoteApplicationData_args_guid record  
instance QC.Arbitrary GetNoteApplicationData_args where 
  arbitrary = M.liftM GetNoteApplicationData_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GetNoteApplicationData_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetNoteApplicationData_args{getNoteApplicationData_args_authenticationToken = getNoteApplicationData_args_authenticationToken obj} then P.Nothing else P.Just $ default_GetNoteApplicationData_args{getNoteApplicationData_args_authenticationToken = getNoteApplicationData_args_authenticationToken obj}
    , if obj == default_GetNoteApplicationData_args{getNoteApplicationData_args_guid = getNoteApplicationData_args_guid obj} then P.Nothing else P.Just $ default_GetNoteApplicationData_args{getNoteApplicationData_args_guid = getNoteApplicationData_args_guid obj}
    ]
from_GetNoteApplicationData_args :: GetNoteApplicationData_args -> T.ThriftVal
from_GetNoteApplicationData_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1014 -> P.Just (1, ("authenticationToken",T.TString $ E.encodeUtf8 _v1014))) $ getNoteApplicationData_args_authenticationToken record
  , (\_v1014 -> P.Just (2, ("guid",T.TString $ E.encodeUtf8 _v1014))) $ getNoteApplicationData_args_guid record
  ]
write_GetNoteApplicationData_args :: T.Protocol p => p -> GetNoteApplicationData_args -> P.IO ()
write_GetNoteApplicationData_args oprot record = T.writeVal oprot $ from_GetNoteApplicationData_args record
encode_GetNoteApplicationData_args :: T.StatelessProtocol p => p -> GetNoteApplicationData_args -> LBS.ByteString
encode_GetNoteApplicationData_args oprot record = T.serializeVal oprot $ from_GetNoteApplicationData_args record
to_GetNoteApplicationData_args :: T.ThriftVal -> GetNoteApplicationData_args
to_GetNoteApplicationData_args (T.TStruct fields) = GetNoteApplicationData_args{
  getNoteApplicationData_args_authenticationToken = P.maybe (getNoteApplicationData_args_authenticationToken default_GetNoteApplicationData_args) (\(_,_val1016) -> (case _val1016 of {T.TString _val1017 -> E.decodeUtf8 _val1017; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  getNoteApplicationData_args_guid = P.maybe (getNoteApplicationData_args_guid default_GetNoteApplicationData_args) (\(_,_val1016) -> (case _val1016 of {T.TString _val1018 -> E.decodeUtf8 _val1018; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_GetNoteApplicationData_args _ = P.error "not a struct"
read_GetNoteApplicationData_args :: T.Protocol p => p -> P.IO GetNoteApplicationData_args
read_GetNoteApplicationData_args iprot = to_GetNoteApplicationData_args <$> T.readVal iprot (T.T_STRUCT typemap_GetNoteApplicationData_args)
decode_GetNoteApplicationData_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetNoteApplicationData_args
decode_GetNoteApplicationData_args iprot bs = to_GetNoteApplicationData_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetNoteApplicationData_args) bs
typemap_GetNoteApplicationData_args :: T.TypeMap
typemap_GetNoteApplicationData_args = Map.fromList [(1,("authenticationToken",T.T_STRING)),(2,("guid",T.T_STRING))]
default_GetNoteApplicationData_args :: GetNoteApplicationData_args
default_GetNoteApplicationData_args = GetNoteApplicationData_args{
  getNoteApplicationData_args_authenticationToken = "",
  getNoteApplicationData_args_guid = ""}
data GetNoteApplicationData_result = GetNoteApplicationData_result  { getNoteApplicationData_result_success :: Types_Types.LazyMap
  , getNoteApplicationData_result_userException :: P.Maybe Errors_Types.EDAMUserException
  , getNoteApplicationData_result_systemException :: P.Maybe Errors_Types.EDAMSystemException
  , getNoteApplicationData_result_notFoundException :: P.Maybe Errors_Types.EDAMNotFoundException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetNoteApplicationData_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getNoteApplicationData_result_success record   `H.hashWithSalt` getNoteApplicationData_result_userException record   `H.hashWithSalt` getNoteApplicationData_result_systemException record   `H.hashWithSalt` getNoteApplicationData_result_notFoundException record  
instance QC.Arbitrary GetNoteApplicationData_result where 
  arbitrary = M.liftM GetNoteApplicationData_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetNoteApplicationData_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetNoteApplicationData_result{getNoteApplicationData_result_success = getNoteApplicationData_result_success obj} then P.Nothing else P.Just $ default_GetNoteApplicationData_result{getNoteApplicationData_result_success = getNoteApplicationData_result_success obj}
    , if obj == default_GetNoteApplicationData_result{getNoteApplicationData_result_userException = getNoteApplicationData_result_userException obj} then P.Nothing else P.Just $ default_GetNoteApplicationData_result{getNoteApplicationData_result_userException = getNoteApplicationData_result_userException obj}
    , if obj == default_GetNoteApplicationData_result{getNoteApplicationData_result_systemException = getNoteApplicationData_result_systemException obj} then P.Nothing else P.Just $ default_GetNoteApplicationData_result{getNoteApplicationData_result_systemException = getNoteApplicationData_result_systemException obj}
    , if obj == default_GetNoteApplicationData_result{getNoteApplicationData_result_notFoundException = getNoteApplicationData_result_notFoundException obj} then P.Nothing else P.Just $ default_GetNoteApplicationData_result{getNoteApplicationData_result_notFoundException = getNoteApplicationData_result_notFoundException obj}
    ]
from_GetNoteApplicationData_result :: GetNoteApplicationData_result -> T.ThriftVal
from_GetNoteApplicationData_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v1021 -> (1, ("userException",Errors_Types.from_EDAMUserException _v1021))) <$> getNoteApplicationData_result_userException record, (\_v1021 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v1021))) <$> getNoteApplicationData_result_systemException record, (\_v1021 -> (3, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v1021))) <$> getNoteApplicationData_result_notFoundException record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v1021 -> P.Just (0, ("success",Types_Types.from_LazyMap _v1021))) $ getNoteApplicationData_result_success record
    , (\_v1021 -> (1, ("userException",Errors_Types.from_EDAMUserException _v1021))) <$> getNoteApplicationData_result_userException record
    , (\_v1021 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v1021))) <$> getNoteApplicationData_result_systemException record
    , (\_v1021 -> (3, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v1021))) <$> getNoteApplicationData_result_notFoundException record
    ]
    )
write_GetNoteApplicationData_result :: T.Protocol p => p -> GetNoteApplicationData_result -> P.IO ()
write_GetNoteApplicationData_result oprot record = T.writeVal oprot $ from_GetNoteApplicationData_result record
encode_GetNoteApplicationData_result :: T.StatelessProtocol p => p -> GetNoteApplicationData_result -> LBS.ByteString
encode_GetNoteApplicationData_result oprot record = T.serializeVal oprot $ from_GetNoteApplicationData_result record
to_GetNoteApplicationData_result :: T.ThriftVal -> GetNoteApplicationData_result
to_GetNoteApplicationData_result (T.TStruct fields) = GetNoteApplicationData_result{
  getNoteApplicationData_result_success = P.maybe (getNoteApplicationData_result_success default_GetNoteApplicationData_result) (\(_,_val1023) -> (case _val1023 of {T.TStruct _val1024 -> (Types_Types.to_LazyMap (T.TStruct _val1024)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getNoteApplicationData_result_userException = P.maybe (P.Nothing) (\(_,_val1023) -> P.Just (case _val1023 of {T.TStruct _val1025 -> (Errors_Types.to_EDAMUserException (T.TStruct _val1025)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  getNoteApplicationData_result_systemException = P.maybe (P.Nothing) (\(_,_val1023) -> P.Just (case _val1023 of {T.TStruct _val1026 -> (Errors_Types.to_EDAMSystemException (T.TStruct _val1026)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  getNoteApplicationData_result_notFoundException = P.maybe (P.Nothing) (\(_,_val1023) -> P.Just (case _val1023 of {T.TStruct _val1027 -> (Errors_Types.to_EDAMNotFoundException (T.TStruct _val1027)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_GetNoteApplicationData_result _ = P.error "not a struct"
read_GetNoteApplicationData_result :: T.Protocol p => p -> P.IO GetNoteApplicationData_result
read_GetNoteApplicationData_result iprot = to_GetNoteApplicationData_result <$> T.readVal iprot (T.T_STRUCT typemap_GetNoteApplicationData_result)
decode_GetNoteApplicationData_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetNoteApplicationData_result
decode_GetNoteApplicationData_result iprot bs = to_GetNoteApplicationData_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetNoteApplicationData_result) bs
typemap_GetNoteApplicationData_result :: T.TypeMap
typemap_GetNoteApplicationData_result = Map.fromList [(0,("success",(T.T_STRUCT Types_Types.typemap_LazyMap))),(1,("userException",(T.T_STRUCT Errors_Types.typemap_EDAMUserException))),(2,("systemException",(T.T_STRUCT Errors_Types.typemap_EDAMSystemException))),(3,("notFoundException",(T.T_STRUCT Errors_Types.typemap_EDAMNotFoundException)))]
default_GetNoteApplicationData_result :: GetNoteApplicationData_result
default_GetNoteApplicationData_result = GetNoteApplicationData_result{
  getNoteApplicationData_result_success = Types_Types.default_LazyMap,
  getNoteApplicationData_result_userException = P.Nothing,
  getNoteApplicationData_result_systemException = P.Nothing,
  getNoteApplicationData_result_notFoundException = P.Nothing}
data GetNoteApplicationDataEntry_args = GetNoteApplicationDataEntry_args  { getNoteApplicationDataEntry_args_authenticationToken :: LT.Text
  , getNoteApplicationDataEntry_args_guid :: LT.Text
  , getNoteApplicationDataEntry_args_key :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetNoteApplicationDataEntry_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getNoteApplicationDataEntry_args_authenticationToken record   `H.hashWithSalt` getNoteApplicationDataEntry_args_guid record   `H.hashWithSalt` getNoteApplicationDataEntry_args_key record  
instance QC.Arbitrary GetNoteApplicationDataEntry_args where 
  arbitrary = M.liftM GetNoteApplicationDataEntry_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GetNoteApplicationDataEntry_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetNoteApplicationDataEntry_args{getNoteApplicationDataEntry_args_authenticationToken = getNoteApplicationDataEntry_args_authenticationToken obj} then P.Nothing else P.Just $ default_GetNoteApplicationDataEntry_args{getNoteApplicationDataEntry_args_authenticationToken = getNoteApplicationDataEntry_args_authenticationToken obj}
    , if obj == default_GetNoteApplicationDataEntry_args{getNoteApplicationDataEntry_args_guid = getNoteApplicationDataEntry_args_guid obj} then P.Nothing else P.Just $ default_GetNoteApplicationDataEntry_args{getNoteApplicationDataEntry_args_guid = getNoteApplicationDataEntry_args_guid obj}
    , if obj == default_GetNoteApplicationDataEntry_args{getNoteApplicationDataEntry_args_key = getNoteApplicationDataEntry_args_key obj} then P.Nothing else P.Just $ default_GetNoteApplicationDataEntry_args{getNoteApplicationDataEntry_args_key = getNoteApplicationDataEntry_args_key obj}
    ]
from_GetNoteApplicationDataEntry_args :: GetNoteApplicationDataEntry_args -> T.ThriftVal
from_GetNoteApplicationDataEntry_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1030 -> P.Just (1, ("authenticationToken",T.TString $ E.encodeUtf8 _v1030))) $ getNoteApplicationDataEntry_args_authenticationToken record
  , (\_v1030 -> P.Just (2, ("guid",T.TString $ E.encodeUtf8 _v1030))) $ getNoteApplicationDataEntry_args_guid record
  , (\_v1030 -> P.Just (3, ("key",T.TString $ E.encodeUtf8 _v1030))) $ getNoteApplicationDataEntry_args_key record
  ]
write_GetNoteApplicationDataEntry_args :: T.Protocol p => p -> GetNoteApplicationDataEntry_args -> P.IO ()
write_GetNoteApplicationDataEntry_args oprot record = T.writeVal oprot $ from_GetNoteApplicationDataEntry_args record
encode_GetNoteApplicationDataEntry_args :: T.StatelessProtocol p => p -> GetNoteApplicationDataEntry_args -> LBS.ByteString
encode_GetNoteApplicationDataEntry_args oprot record = T.serializeVal oprot $ from_GetNoteApplicationDataEntry_args record
to_GetNoteApplicationDataEntry_args :: T.ThriftVal -> GetNoteApplicationDataEntry_args
to_GetNoteApplicationDataEntry_args (T.TStruct fields) = GetNoteApplicationDataEntry_args{
  getNoteApplicationDataEntry_args_authenticationToken = P.maybe (getNoteApplicationDataEntry_args_authenticationToken default_GetNoteApplicationDataEntry_args) (\(_,_val1032) -> (case _val1032 of {T.TString _val1033 -> E.decodeUtf8 _val1033; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  getNoteApplicationDataEntry_args_guid = P.maybe (getNoteApplicationDataEntry_args_guid default_GetNoteApplicationDataEntry_args) (\(_,_val1032) -> (case _val1032 of {T.TString _val1034 -> E.decodeUtf8 _val1034; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  getNoteApplicationDataEntry_args_key = P.maybe (getNoteApplicationDataEntry_args_key default_GetNoteApplicationDataEntry_args) (\(_,_val1032) -> (case _val1032 of {T.TString _val1035 -> E.decodeUtf8 _val1035; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_GetNoteApplicationDataEntry_args _ = P.error "not a struct"
read_GetNoteApplicationDataEntry_args :: T.Protocol p => p -> P.IO GetNoteApplicationDataEntry_args
read_GetNoteApplicationDataEntry_args iprot = to_GetNoteApplicationDataEntry_args <$> T.readVal iprot (T.T_STRUCT typemap_GetNoteApplicationDataEntry_args)
decode_GetNoteApplicationDataEntry_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetNoteApplicationDataEntry_args
decode_GetNoteApplicationDataEntry_args iprot bs = to_GetNoteApplicationDataEntry_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetNoteApplicationDataEntry_args) bs
typemap_GetNoteApplicationDataEntry_args :: T.TypeMap
typemap_GetNoteApplicationDataEntry_args = Map.fromList [(1,("authenticationToken",T.T_STRING)),(2,("guid",T.T_STRING)),(3,("key",T.T_STRING))]
default_GetNoteApplicationDataEntry_args :: GetNoteApplicationDataEntry_args
default_GetNoteApplicationDataEntry_args = GetNoteApplicationDataEntry_args{
  getNoteApplicationDataEntry_args_authenticationToken = "",
  getNoteApplicationDataEntry_args_guid = "",
  getNoteApplicationDataEntry_args_key = ""}
data GetNoteApplicationDataEntry_result = GetNoteApplicationDataEntry_result  { getNoteApplicationDataEntry_result_success :: LT.Text
  , getNoteApplicationDataEntry_result_userException :: P.Maybe Errors_Types.EDAMUserException
  , getNoteApplicationDataEntry_result_systemException :: P.Maybe Errors_Types.EDAMSystemException
  , getNoteApplicationDataEntry_result_notFoundException :: P.Maybe Errors_Types.EDAMNotFoundException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetNoteApplicationDataEntry_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getNoteApplicationDataEntry_result_success record   `H.hashWithSalt` getNoteApplicationDataEntry_result_userException record   `H.hashWithSalt` getNoteApplicationDataEntry_result_systemException record   `H.hashWithSalt` getNoteApplicationDataEntry_result_notFoundException record  
instance QC.Arbitrary GetNoteApplicationDataEntry_result where 
  arbitrary = M.liftM GetNoteApplicationDataEntry_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetNoteApplicationDataEntry_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetNoteApplicationDataEntry_result{getNoteApplicationDataEntry_result_success = getNoteApplicationDataEntry_result_success obj} then P.Nothing else P.Just $ default_GetNoteApplicationDataEntry_result{getNoteApplicationDataEntry_result_success = getNoteApplicationDataEntry_result_success obj}
    , if obj == default_GetNoteApplicationDataEntry_result{getNoteApplicationDataEntry_result_userException = getNoteApplicationDataEntry_result_userException obj} then P.Nothing else P.Just $ default_GetNoteApplicationDataEntry_result{getNoteApplicationDataEntry_result_userException = getNoteApplicationDataEntry_result_userException obj}
    , if obj == default_GetNoteApplicationDataEntry_result{getNoteApplicationDataEntry_result_systemException = getNoteApplicationDataEntry_result_systemException obj} then P.Nothing else P.Just $ default_GetNoteApplicationDataEntry_result{getNoteApplicationDataEntry_result_systemException = getNoteApplicationDataEntry_result_systemException obj}
    , if obj == default_GetNoteApplicationDataEntry_result{getNoteApplicationDataEntry_result_notFoundException = getNoteApplicationDataEntry_result_notFoundException obj} then P.Nothing else P.Just $ default_GetNoteApplicationDataEntry_result{getNoteApplicationDataEntry_result_notFoundException = getNoteApplicationDataEntry_result_notFoundException obj}
    ]
from_GetNoteApplicationDataEntry_result :: GetNoteApplicationDataEntry_result -> T.ThriftVal
from_GetNoteApplicationDataEntry_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v1038 -> (1, ("userException",Errors_Types.from_EDAMUserException _v1038))) <$> getNoteApplicationDataEntry_result_userException record, (\_v1038 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v1038))) <$> getNoteApplicationDataEntry_result_systemException record, (\_v1038 -> (3, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v1038))) <$> getNoteApplicationDataEntry_result_notFoundException record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v1038 -> P.Just (0, ("success",T.TString $ E.encodeUtf8 _v1038))) $ getNoteApplicationDataEntry_result_success record
    , (\_v1038 -> (1, ("userException",Errors_Types.from_EDAMUserException _v1038))) <$> getNoteApplicationDataEntry_result_userException record
    , (\_v1038 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v1038))) <$> getNoteApplicationDataEntry_result_systemException record
    , (\_v1038 -> (3, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v1038))) <$> getNoteApplicationDataEntry_result_notFoundException record
    ]
    )
write_GetNoteApplicationDataEntry_result :: T.Protocol p => p -> GetNoteApplicationDataEntry_result -> P.IO ()
write_GetNoteApplicationDataEntry_result oprot record = T.writeVal oprot $ from_GetNoteApplicationDataEntry_result record
encode_GetNoteApplicationDataEntry_result :: T.StatelessProtocol p => p -> GetNoteApplicationDataEntry_result -> LBS.ByteString
encode_GetNoteApplicationDataEntry_result oprot record = T.serializeVal oprot $ from_GetNoteApplicationDataEntry_result record
to_GetNoteApplicationDataEntry_result :: T.ThriftVal -> GetNoteApplicationDataEntry_result
to_GetNoteApplicationDataEntry_result (T.TStruct fields) = GetNoteApplicationDataEntry_result{
  getNoteApplicationDataEntry_result_success = P.maybe (getNoteApplicationDataEntry_result_success default_GetNoteApplicationDataEntry_result) (\(_,_val1040) -> (case _val1040 of {T.TString _val1041 -> E.decodeUtf8 _val1041; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getNoteApplicationDataEntry_result_userException = P.maybe (P.Nothing) (\(_,_val1040) -> P.Just (case _val1040 of {T.TStruct _val1042 -> (Errors_Types.to_EDAMUserException (T.TStruct _val1042)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  getNoteApplicationDataEntry_result_systemException = P.maybe (P.Nothing) (\(_,_val1040) -> P.Just (case _val1040 of {T.TStruct _val1043 -> (Errors_Types.to_EDAMSystemException (T.TStruct _val1043)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  getNoteApplicationDataEntry_result_notFoundException = P.maybe (P.Nothing) (\(_,_val1040) -> P.Just (case _val1040 of {T.TStruct _val1044 -> (Errors_Types.to_EDAMNotFoundException (T.TStruct _val1044)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_GetNoteApplicationDataEntry_result _ = P.error "not a struct"
read_GetNoteApplicationDataEntry_result :: T.Protocol p => p -> P.IO GetNoteApplicationDataEntry_result
read_GetNoteApplicationDataEntry_result iprot = to_GetNoteApplicationDataEntry_result <$> T.readVal iprot (T.T_STRUCT typemap_GetNoteApplicationDataEntry_result)
decode_GetNoteApplicationDataEntry_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetNoteApplicationDataEntry_result
decode_GetNoteApplicationDataEntry_result iprot bs = to_GetNoteApplicationDataEntry_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetNoteApplicationDataEntry_result) bs
typemap_GetNoteApplicationDataEntry_result :: T.TypeMap
typemap_GetNoteApplicationDataEntry_result = Map.fromList [(0,("success",T.T_STRING)),(1,("userException",(T.T_STRUCT Errors_Types.typemap_EDAMUserException))),(2,("systemException",(T.T_STRUCT Errors_Types.typemap_EDAMSystemException))),(3,("notFoundException",(T.T_STRUCT Errors_Types.typemap_EDAMNotFoundException)))]
default_GetNoteApplicationDataEntry_result :: GetNoteApplicationDataEntry_result
default_GetNoteApplicationDataEntry_result = GetNoteApplicationDataEntry_result{
  getNoteApplicationDataEntry_result_success = "",
  getNoteApplicationDataEntry_result_userException = P.Nothing,
  getNoteApplicationDataEntry_result_systemException = P.Nothing,
  getNoteApplicationDataEntry_result_notFoundException = P.Nothing}
data SetNoteApplicationDataEntry_args = SetNoteApplicationDataEntry_args  { setNoteApplicationDataEntry_args_authenticationToken :: LT.Text
  , setNoteApplicationDataEntry_args_guid :: LT.Text
  , setNoteApplicationDataEntry_args_key :: LT.Text
  , setNoteApplicationDataEntry_args_value :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SetNoteApplicationDataEntry_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` setNoteApplicationDataEntry_args_authenticationToken record   `H.hashWithSalt` setNoteApplicationDataEntry_args_guid record   `H.hashWithSalt` setNoteApplicationDataEntry_args_key record   `H.hashWithSalt` setNoteApplicationDataEntry_args_value record  
instance QC.Arbitrary SetNoteApplicationDataEntry_args where 
  arbitrary = M.liftM SetNoteApplicationDataEntry_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SetNoteApplicationDataEntry_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SetNoteApplicationDataEntry_args{setNoteApplicationDataEntry_args_authenticationToken = setNoteApplicationDataEntry_args_authenticationToken obj} then P.Nothing else P.Just $ default_SetNoteApplicationDataEntry_args{setNoteApplicationDataEntry_args_authenticationToken = setNoteApplicationDataEntry_args_authenticationToken obj}
    , if obj == default_SetNoteApplicationDataEntry_args{setNoteApplicationDataEntry_args_guid = setNoteApplicationDataEntry_args_guid obj} then P.Nothing else P.Just $ default_SetNoteApplicationDataEntry_args{setNoteApplicationDataEntry_args_guid = setNoteApplicationDataEntry_args_guid obj}
    , if obj == default_SetNoteApplicationDataEntry_args{setNoteApplicationDataEntry_args_key = setNoteApplicationDataEntry_args_key obj} then P.Nothing else P.Just $ default_SetNoteApplicationDataEntry_args{setNoteApplicationDataEntry_args_key = setNoteApplicationDataEntry_args_key obj}
    , if obj == default_SetNoteApplicationDataEntry_args{setNoteApplicationDataEntry_args_value = setNoteApplicationDataEntry_args_value obj} then P.Nothing else P.Just $ default_SetNoteApplicationDataEntry_args{setNoteApplicationDataEntry_args_value = setNoteApplicationDataEntry_args_value obj}
    ]
from_SetNoteApplicationDataEntry_args :: SetNoteApplicationDataEntry_args -> T.ThriftVal
from_SetNoteApplicationDataEntry_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1047 -> P.Just (1, ("authenticationToken",T.TString $ E.encodeUtf8 _v1047))) $ setNoteApplicationDataEntry_args_authenticationToken record
  , (\_v1047 -> P.Just (2, ("guid",T.TString $ E.encodeUtf8 _v1047))) $ setNoteApplicationDataEntry_args_guid record
  , (\_v1047 -> P.Just (3, ("key",T.TString $ E.encodeUtf8 _v1047))) $ setNoteApplicationDataEntry_args_key record
  , (\_v1047 -> P.Just (4, ("value",T.TString $ E.encodeUtf8 _v1047))) $ setNoteApplicationDataEntry_args_value record
  ]
write_SetNoteApplicationDataEntry_args :: T.Protocol p => p -> SetNoteApplicationDataEntry_args -> P.IO ()
write_SetNoteApplicationDataEntry_args oprot record = T.writeVal oprot $ from_SetNoteApplicationDataEntry_args record
encode_SetNoteApplicationDataEntry_args :: T.StatelessProtocol p => p -> SetNoteApplicationDataEntry_args -> LBS.ByteString
encode_SetNoteApplicationDataEntry_args oprot record = T.serializeVal oprot $ from_SetNoteApplicationDataEntry_args record
to_SetNoteApplicationDataEntry_args :: T.ThriftVal -> SetNoteApplicationDataEntry_args
to_SetNoteApplicationDataEntry_args (T.TStruct fields) = SetNoteApplicationDataEntry_args{
  setNoteApplicationDataEntry_args_authenticationToken = P.maybe (setNoteApplicationDataEntry_args_authenticationToken default_SetNoteApplicationDataEntry_args) (\(_,_val1049) -> (case _val1049 of {T.TString _val1050 -> E.decodeUtf8 _val1050; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  setNoteApplicationDataEntry_args_guid = P.maybe (setNoteApplicationDataEntry_args_guid default_SetNoteApplicationDataEntry_args) (\(_,_val1049) -> (case _val1049 of {T.TString _val1051 -> E.decodeUtf8 _val1051; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  setNoteApplicationDataEntry_args_key = P.maybe (setNoteApplicationDataEntry_args_key default_SetNoteApplicationDataEntry_args) (\(_,_val1049) -> (case _val1049 of {T.TString _val1052 -> E.decodeUtf8 _val1052; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  setNoteApplicationDataEntry_args_value = P.maybe (setNoteApplicationDataEntry_args_value default_SetNoteApplicationDataEntry_args) (\(_,_val1049) -> (case _val1049 of {T.TString _val1053 -> E.decodeUtf8 _val1053; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_SetNoteApplicationDataEntry_args _ = P.error "not a struct"
read_SetNoteApplicationDataEntry_args :: T.Protocol p => p -> P.IO SetNoteApplicationDataEntry_args
read_SetNoteApplicationDataEntry_args iprot = to_SetNoteApplicationDataEntry_args <$> T.readVal iprot (T.T_STRUCT typemap_SetNoteApplicationDataEntry_args)
decode_SetNoteApplicationDataEntry_args :: T.StatelessProtocol p => p -> LBS.ByteString -> SetNoteApplicationDataEntry_args
decode_SetNoteApplicationDataEntry_args iprot bs = to_SetNoteApplicationDataEntry_args $ T.deserializeVal iprot (T.T_STRUCT typemap_SetNoteApplicationDataEntry_args) bs
typemap_SetNoteApplicationDataEntry_args :: T.TypeMap
typemap_SetNoteApplicationDataEntry_args = Map.fromList [(1,("authenticationToken",T.T_STRING)),(2,("guid",T.T_STRING)),(3,("key",T.T_STRING)),(4,("value",T.T_STRING))]
default_SetNoteApplicationDataEntry_args :: SetNoteApplicationDataEntry_args
default_SetNoteApplicationDataEntry_args = SetNoteApplicationDataEntry_args{
  setNoteApplicationDataEntry_args_authenticationToken = "",
  setNoteApplicationDataEntry_args_guid = "",
  setNoteApplicationDataEntry_args_key = "",
  setNoteApplicationDataEntry_args_value = ""}
data SetNoteApplicationDataEntry_result = SetNoteApplicationDataEntry_result  { setNoteApplicationDataEntry_result_success :: I.Int32
  , setNoteApplicationDataEntry_result_userException :: P.Maybe Errors_Types.EDAMUserException
  , setNoteApplicationDataEntry_result_systemException :: P.Maybe Errors_Types.EDAMSystemException
  , setNoteApplicationDataEntry_result_notFoundException :: P.Maybe Errors_Types.EDAMNotFoundException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SetNoteApplicationDataEntry_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` setNoteApplicationDataEntry_result_success record   `H.hashWithSalt` setNoteApplicationDataEntry_result_userException record   `H.hashWithSalt` setNoteApplicationDataEntry_result_systemException record   `H.hashWithSalt` setNoteApplicationDataEntry_result_notFoundException record  
instance QC.Arbitrary SetNoteApplicationDataEntry_result where 
  arbitrary = M.liftM SetNoteApplicationDataEntry_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_SetNoteApplicationDataEntry_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SetNoteApplicationDataEntry_result{setNoteApplicationDataEntry_result_success = setNoteApplicationDataEntry_result_success obj} then P.Nothing else P.Just $ default_SetNoteApplicationDataEntry_result{setNoteApplicationDataEntry_result_success = setNoteApplicationDataEntry_result_success obj}
    , if obj == default_SetNoteApplicationDataEntry_result{setNoteApplicationDataEntry_result_userException = setNoteApplicationDataEntry_result_userException obj} then P.Nothing else P.Just $ default_SetNoteApplicationDataEntry_result{setNoteApplicationDataEntry_result_userException = setNoteApplicationDataEntry_result_userException obj}
    , if obj == default_SetNoteApplicationDataEntry_result{setNoteApplicationDataEntry_result_systemException = setNoteApplicationDataEntry_result_systemException obj} then P.Nothing else P.Just $ default_SetNoteApplicationDataEntry_result{setNoteApplicationDataEntry_result_systemException = setNoteApplicationDataEntry_result_systemException obj}
    , if obj == default_SetNoteApplicationDataEntry_result{setNoteApplicationDataEntry_result_notFoundException = setNoteApplicationDataEntry_result_notFoundException obj} then P.Nothing else P.Just $ default_SetNoteApplicationDataEntry_result{setNoteApplicationDataEntry_result_notFoundException = setNoteApplicationDataEntry_result_notFoundException obj}
    ]
from_SetNoteApplicationDataEntry_result :: SetNoteApplicationDataEntry_result -> T.ThriftVal
from_SetNoteApplicationDataEntry_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v1056 -> (1, ("userException",Errors_Types.from_EDAMUserException _v1056))) <$> setNoteApplicationDataEntry_result_userException record, (\_v1056 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v1056))) <$> setNoteApplicationDataEntry_result_systemException record, (\_v1056 -> (3, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v1056))) <$> setNoteApplicationDataEntry_result_notFoundException record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v1056 -> P.Just (0, ("success",T.TI32 _v1056))) $ setNoteApplicationDataEntry_result_success record
    , (\_v1056 -> (1, ("userException",Errors_Types.from_EDAMUserException _v1056))) <$> setNoteApplicationDataEntry_result_userException record
    , (\_v1056 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v1056))) <$> setNoteApplicationDataEntry_result_systemException record
    , (\_v1056 -> (3, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v1056))) <$> setNoteApplicationDataEntry_result_notFoundException record
    ]
    )
write_SetNoteApplicationDataEntry_result :: T.Protocol p => p -> SetNoteApplicationDataEntry_result -> P.IO ()
write_SetNoteApplicationDataEntry_result oprot record = T.writeVal oprot $ from_SetNoteApplicationDataEntry_result record
encode_SetNoteApplicationDataEntry_result :: T.StatelessProtocol p => p -> SetNoteApplicationDataEntry_result -> LBS.ByteString
encode_SetNoteApplicationDataEntry_result oprot record = T.serializeVal oprot $ from_SetNoteApplicationDataEntry_result record
to_SetNoteApplicationDataEntry_result :: T.ThriftVal -> SetNoteApplicationDataEntry_result
to_SetNoteApplicationDataEntry_result (T.TStruct fields) = SetNoteApplicationDataEntry_result{
  setNoteApplicationDataEntry_result_success = P.maybe (setNoteApplicationDataEntry_result_success default_SetNoteApplicationDataEntry_result) (\(_,_val1058) -> (case _val1058 of {T.TI32 _val1059 -> _val1059; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  setNoteApplicationDataEntry_result_userException = P.maybe (P.Nothing) (\(_,_val1058) -> P.Just (case _val1058 of {T.TStruct _val1060 -> (Errors_Types.to_EDAMUserException (T.TStruct _val1060)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  setNoteApplicationDataEntry_result_systemException = P.maybe (P.Nothing) (\(_,_val1058) -> P.Just (case _val1058 of {T.TStruct _val1061 -> (Errors_Types.to_EDAMSystemException (T.TStruct _val1061)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  setNoteApplicationDataEntry_result_notFoundException = P.maybe (P.Nothing) (\(_,_val1058) -> P.Just (case _val1058 of {T.TStruct _val1062 -> (Errors_Types.to_EDAMNotFoundException (T.TStruct _val1062)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_SetNoteApplicationDataEntry_result _ = P.error "not a struct"
read_SetNoteApplicationDataEntry_result :: T.Protocol p => p -> P.IO SetNoteApplicationDataEntry_result
read_SetNoteApplicationDataEntry_result iprot = to_SetNoteApplicationDataEntry_result <$> T.readVal iprot (T.T_STRUCT typemap_SetNoteApplicationDataEntry_result)
decode_SetNoteApplicationDataEntry_result :: T.StatelessProtocol p => p -> LBS.ByteString -> SetNoteApplicationDataEntry_result
decode_SetNoteApplicationDataEntry_result iprot bs = to_SetNoteApplicationDataEntry_result $ T.deserializeVal iprot (T.T_STRUCT typemap_SetNoteApplicationDataEntry_result) bs
typemap_SetNoteApplicationDataEntry_result :: T.TypeMap
typemap_SetNoteApplicationDataEntry_result = Map.fromList [(0,("success",T.T_I32)),(1,("userException",(T.T_STRUCT Errors_Types.typemap_EDAMUserException))),(2,("systemException",(T.T_STRUCT Errors_Types.typemap_EDAMSystemException))),(3,("notFoundException",(T.T_STRUCT Errors_Types.typemap_EDAMNotFoundException)))]
default_SetNoteApplicationDataEntry_result :: SetNoteApplicationDataEntry_result
default_SetNoteApplicationDataEntry_result = SetNoteApplicationDataEntry_result{
  setNoteApplicationDataEntry_result_success = 0,
  setNoteApplicationDataEntry_result_userException = P.Nothing,
  setNoteApplicationDataEntry_result_systemException = P.Nothing,
  setNoteApplicationDataEntry_result_notFoundException = P.Nothing}
data UnsetNoteApplicationDataEntry_args = UnsetNoteApplicationDataEntry_args  { unsetNoteApplicationDataEntry_args_authenticationToken :: LT.Text
  , unsetNoteApplicationDataEntry_args_guid :: LT.Text
  , unsetNoteApplicationDataEntry_args_key :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UnsetNoteApplicationDataEntry_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` unsetNoteApplicationDataEntry_args_authenticationToken record   `H.hashWithSalt` unsetNoteApplicationDataEntry_args_guid record   `H.hashWithSalt` unsetNoteApplicationDataEntry_args_key record  
instance QC.Arbitrary UnsetNoteApplicationDataEntry_args where 
  arbitrary = M.liftM UnsetNoteApplicationDataEntry_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_UnsetNoteApplicationDataEntry_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UnsetNoteApplicationDataEntry_args{unsetNoteApplicationDataEntry_args_authenticationToken = unsetNoteApplicationDataEntry_args_authenticationToken obj} then P.Nothing else P.Just $ default_UnsetNoteApplicationDataEntry_args{unsetNoteApplicationDataEntry_args_authenticationToken = unsetNoteApplicationDataEntry_args_authenticationToken obj}
    , if obj == default_UnsetNoteApplicationDataEntry_args{unsetNoteApplicationDataEntry_args_guid = unsetNoteApplicationDataEntry_args_guid obj} then P.Nothing else P.Just $ default_UnsetNoteApplicationDataEntry_args{unsetNoteApplicationDataEntry_args_guid = unsetNoteApplicationDataEntry_args_guid obj}
    , if obj == default_UnsetNoteApplicationDataEntry_args{unsetNoteApplicationDataEntry_args_key = unsetNoteApplicationDataEntry_args_key obj} then P.Nothing else P.Just $ default_UnsetNoteApplicationDataEntry_args{unsetNoteApplicationDataEntry_args_key = unsetNoteApplicationDataEntry_args_key obj}
    ]
from_UnsetNoteApplicationDataEntry_args :: UnsetNoteApplicationDataEntry_args -> T.ThriftVal
from_UnsetNoteApplicationDataEntry_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1065 -> P.Just (1, ("authenticationToken",T.TString $ E.encodeUtf8 _v1065))) $ unsetNoteApplicationDataEntry_args_authenticationToken record
  , (\_v1065 -> P.Just (2, ("guid",T.TString $ E.encodeUtf8 _v1065))) $ unsetNoteApplicationDataEntry_args_guid record
  , (\_v1065 -> P.Just (3, ("key",T.TString $ E.encodeUtf8 _v1065))) $ unsetNoteApplicationDataEntry_args_key record
  ]
write_UnsetNoteApplicationDataEntry_args :: T.Protocol p => p -> UnsetNoteApplicationDataEntry_args -> P.IO ()
write_UnsetNoteApplicationDataEntry_args oprot record = T.writeVal oprot $ from_UnsetNoteApplicationDataEntry_args record
encode_UnsetNoteApplicationDataEntry_args :: T.StatelessProtocol p => p -> UnsetNoteApplicationDataEntry_args -> LBS.ByteString
encode_UnsetNoteApplicationDataEntry_args oprot record = T.serializeVal oprot $ from_UnsetNoteApplicationDataEntry_args record
to_UnsetNoteApplicationDataEntry_args :: T.ThriftVal -> UnsetNoteApplicationDataEntry_args
to_UnsetNoteApplicationDataEntry_args (T.TStruct fields) = UnsetNoteApplicationDataEntry_args{
  unsetNoteApplicationDataEntry_args_authenticationToken = P.maybe (unsetNoteApplicationDataEntry_args_authenticationToken default_UnsetNoteApplicationDataEntry_args) (\(_,_val1067) -> (case _val1067 of {T.TString _val1068 -> E.decodeUtf8 _val1068; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  unsetNoteApplicationDataEntry_args_guid = P.maybe (unsetNoteApplicationDataEntry_args_guid default_UnsetNoteApplicationDataEntry_args) (\(_,_val1067) -> (case _val1067 of {T.TString _val1069 -> E.decodeUtf8 _val1069; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  unsetNoteApplicationDataEntry_args_key = P.maybe (unsetNoteApplicationDataEntry_args_key default_UnsetNoteApplicationDataEntry_args) (\(_,_val1067) -> (case _val1067 of {T.TString _val1070 -> E.decodeUtf8 _val1070; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_UnsetNoteApplicationDataEntry_args _ = P.error "not a struct"
read_UnsetNoteApplicationDataEntry_args :: T.Protocol p => p -> P.IO UnsetNoteApplicationDataEntry_args
read_UnsetNoteApplicationDataEntry_args iprot = to_UnsetNoteApplicationDataEntry_args <$> T.readVal iprot (T.T_STRUCT typemap_UnsetNoteApplicationDataEntry_args)
decode_UnsetNoteApplicationDataEntry_args :: T.StatelessProtocol p => p -> LBS.ByteString -> UnsetNoteApplicationDataEntry_args
decode_UnsetNoteApplicationDataEntry_args iprot bs = to_UnsetNoteApplicationDataEntry_args $ T.deserializeVal iprot (T.T_STRUCT typemap_UnsetNoteApplicationDataEntry_args) bs
typemap_UnsetNoteApplicationDataEntry_args :: T.TypeMap
typemap_UnsetNoteApplicationDataEntry_args = Map.fromList [(1,("authenticationToken",T.T_STRING)),(2,("guid",T.T_STRING)),(3,("key",T.T_STRING))]
default_UnsetNoteApplicationDataEntry_args :: UnsetNoteApplicationDataEntry_args
default_UnsetNoteApplicationDataEntry_args = UnsetNoteApplicationDataEntry_args{
  unsetNoteApplicationDataEntry_args_authenticationToken = "",
  unsetNoteApplicationDataEntry_args_guid = "",
  unsetNoteApplicationDataEntry_args_key = ""}
data UnsetNoteApplicationDataEntry_result = UnsetNoteApplicationDataEntry_result  { unsetNoteApplicationDataEntry_result_success :: I.Int32
  , unsetNoteApplicationDataEntry_result_userException :: P.Maybe Errors_Types.EDAMUserException
  , unsetNoteApplicationDataEntry_result_systemException :: P.Maybe Errors_Types.EDAMSystemException
  , unsetNoteApplicationDataEntry_result_notFoundException :: P.Maybe Errors_Types.EDAMNotFoundException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UnsetNoteApplicationDataEntry_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` unsetNoteApplicationDataEntry_result_success record   `H.hashWithSalt` unsetNoteApplicationDataEntry_result_userException record   `H.hashWithSalt` unsetNoteApplicationDataEntry_result_systemException record   `H.hashWithSalt` unsetNoteApplicationDataEntry_result_notFoundException record  
instance QC.Arbitrary UnsetNoteApplicationDataEntry_result where 
  arbitrary = M.liftM UnsetNoteApplicationDataEntry_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_UnsetNoteApplicationDataEntry_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UnsetNoteApplicationDataEntry_result{unsetNoteApplicationDataEntry_result_success = unsetNoteApplicationDataEntry_result_success obj} then P.Nothing else P.Just $ default_UnsetNoteApplicationDataEntry_result{unsetNoteApplicationDataEntry_result_success = unsetNoteApplicationDataEntry_result_success obj}
    , if obj == default_UnsetNoteApplicationDataEntry_result{unsetNoteApplicationDataEntry_result_userException = unsetNoteApplicationDataEntry_result_userException obj} then P.Nothing else P.Just $ default_UnsetNoteApplicationDataEntry_result{unsetNoteApplicationDataEntry_result_userException = unsetNoteApplicationDataEntry_result_userException obj}
    , if obj == default_UnsetNoteApplicationDataEntry_result{unsetNoteApplicationDataEntry_result_systemException = unsetNoteApplicationDataEntry_result_systemException obj} then P.Nothing else P.Just $ default_UnsetNoteApplicationDataEntry_result{unsetNoteApplicationDataEntry_result_systemException = unsetNoteApplicationDataEntry_result_systemException obj}
    , if obj == default_UnsetNoteApplicationDataEntry_result{unsetNoteApplicationDataEntry_result_notFoundException = unsetNoteApplicationDataEntry_result_notFoundException obj} then P.Nothing else P.Just $ default_UnsetNoteApplicationDataEntry_result{unsetNoteApplicationDataEntry_result_notFoundException = unsetNoteApplicationDataEntry_result_notFoundException obj}
    ]
from_UnsetNoteApplicationDataEntry_result :: UnsetNoteApplicationDataEntry_result -> T.ThriftVal
from_UnsetNoteApplicationDataEntry_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v1073 -> (1, ("userException",Errors_Types.from_EDAMUserException _v1073))) <$> unsetNoteApplicationDataEntry_result_userException record, (\_v1073 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v1073))) <$> unsetNoteApplicationDataEntry_result_systemException record, (\_v1073 -> (3, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v1073))) <$> unsetNoteApplicationDataEntry_result_notFoundException record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v1073 -> P.Just (0, ("success",T.TI32 _v1073))) $ unsetNoteApplicationDataEntry_result_success record
    , (\_v1073 -> (1, ("userException",Errors_Types.from_EDAMUserException _v1073))) <$> unsetNoteApplicationDataEntry_result_userException record
    , (\_v1073 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v1073))) <$> unsetNoteApplicationDataEntry_result_systemException record
    , (\_v1073 -> (3, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v1073))) <$> unsetNoteApplicationDataEntry_result_notFoundException record
    ]
    )
write_UnsetNoteApplicationDataEntry_result :: T.Protocol p => p -> UnsetNoteApplicationDataEntry_result -> P.IO ()
write_UnsetNoteApplicationDataEntry_result oprot record = T.writeVal oprot $ from_UnsetNoteApplicationDataEntry_result record
encode_UnsetNoteApplicationDataEntry_result :: T.StatelessProtocol p => p -> UnsetNoteApplicationDataEntry_result -> LBS.ByteString
encode_UnsetNoteApplicationDataEntry_result oprot record = T.serializeVal oprot $ from_UnsetNoteApplicationDataEntry_result record
to_UnsetNoteApplicationDataEntry_result :: T.ThriftVal -> UnsetNoteApplicationDataEntry_result
to_UnsetNoteApplicationDataEntry_result (T.TStruct fields) = UnsetNoteApplicationDataEntry_result{
  unsetNoteApplicationDataEntry_result_success = P.maybe (unsetNoteApplicationDataEntry_result_success default_UnsetNoteApplicationDataEntry_result) (\(_,_val1075) -> (case _val1075 of {T.TI32 _val1076 -> _val1076; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  unsetNoteApplicationDataEntry_result_userException = P.maybe (P.Nothing) (\(_,_val1075) -> P.Just (case _val1075 of {T.TStruct _val1077 -> (Errors_Types.to_EDAMUserException (T.TStruct _val1077)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  unsetNoteApplicationDataEntry_result_systemException = P.maybe (P.Nothing) (\(_,_val1075) -> P.Just (case _val1075 of {T.TStruct _val1078 -> (Errors_Types.to_EDAMSystemException (T.TStruct _val1078)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  unsetNoteApplicationDataEntry_result_notFoundException = P.maybe (P.Nothing) (\(_,_val1075) -> P.Just (case _val1075 of {T.TStruct _val1079 -> (Errors_Types.to_EDAMNotFoundException (T.TStruct _val1079)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_UnsetNoteApplicationDataEntry_result _ = P.error "not a struct"
read_UnsetNoteApplicationDataEntry_result :: T.Protocol p => p -> P.IO UnsetNoteApplicationDataEntry_result
read_UnsetNoteApplicationDataEntry_result iprot = to_UnsetNoteApplicationDataEntry_result <$> T.readVal iprot (T.T_STRUCT typemap_UnsetNoteApplicationDataEntry_result)
decode_UnsetNoteApplicationDataEntry_result :: T.StatelessProtocol p => p -> LBS.ByteString -> UnsetNoteApplicationDataEntry_result
decode_UnsetNoteApplicationDataEntry_result iprot bs = to_UnsetNoteApplicationDataEntry_result $ T.deserializeVal iprot (T.T_STRUCT typemap_UnsetNoteApplicationDataEntry_result) bs
typemap_UnsetNoteApplicationDataEntry_result :: T.TypeMap
typemap_UnsetNoteApplicationDataEntry_result = Map.fromList [(0,("success",T.T_I32)),(1,("userException",(T.T_STRUCT Errors_Types.typemap_EDAMUserException))),(2,("systemException",(T.T_STRUCT Errors_Types.typemap_EDAMSystemException))),(3,("notFoundException",(T.T_STRUCT Errors_Types.typemap_EDAMNotFoundException)))]
default_UnsetNoteApplicationDataEntry_result :: UnsetNoteApplicationDataEntry_result
default_UnsetNoteApplicationDataEntry_result = UnsetNoteApplicationDataEntry_result{
  unsetNoteApplicationDataEntry_result_success = 0,
  unsetNoteApplicationDataEntry_result_userException = P.Nothing,
  unsetNoteApplicationDataEntry_result_systemException = P.Nothing,
  unsetNoteApplicationDataEntry_result_notFoundException = P.Nothing}
data GetNoteContent_args = GetNoteContent_args  { getNoteContent_args_authenticationToken :: LT.Text
  , getNoteContent_args_guid :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetNoteContent_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getNoteContent_args_authenticationToken record   `H.hashWithSalt` getNoteContent_args_guid record  
instance QC.Arbitrary GetNoteContent_args where 
  arbitrary = M.liftM GetNoteContent_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GetNoteContent_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetNoteContent_args{getNoteContent_args_authenticationToken = getNoteContent_args_authenticationToken obj} then P.Nothing else P.Just $ default_GetNoteContent_args{getNoteContent_args_authenticationToken = getNoteContent_args_authenticationToken obj}
    , if obj == default_GetNoteContent_args{getNoteContent_args_guid = getNoteContent_args_guid obj} then P.Nothing else P.Just $ default_GetNoteContent_args{getNoteContent_args_guid = getNoteContent_args_guid obj}
    ]
from_GetNoteContent_args :: GetNoteContent_args -> T.ThriftVal
from_GetNoteContent_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1082 -> P.Just (1, ("authenticationToken",T.TString $ E.encodeUtf8 _v1082))) $ getNoteContent_args_authenticationToken record
  , (\_v1082 -> P.Just (2, ("guid",T.TString $ E.encodeUtf8 _v1082))) $ getNoteContent_args_guid record
  ]
write_GetNoteContent_args :: T.Protocol p => p -> GetNoteContent_args -> P.IO ()
write_GetNoteContent_args oprot record = T.writeVal oprot $ from_GetNoteContent_args record
encode_GetNoteContent_args :: T.StatelessProtocol p => p -> GetNoteContent_args -> LBS.ByteString
encode_GetNoteContent_args oprot record = T.serializeVal oprot $ from_GetNoteContent_args record
to_GetNoteContent_args :: T.ThriftVal -> GetNoteContent_args
to_GetNoteContent_args (T.TStruct fields) = GetNoteContent_args{
  getNoteContent_args_authenticationToken = P.maybe (getNoteContent_args_authenticationToken default_GetNoteContent_args) (\(_,_val1084) -> (case _val1084 of {T.TString _val1085 -> E.decodeUtf8 _val1085; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  getNoteContent_args_guid = P.maybe (getNoteContent_args_guid default_GetNoteContent_args) (\(_,_val1084) -> (case _val1084 of {T.TString _val1086 -> E.decodeUtf8 _val1086; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_GetNoteContent_args _ = P.error "not a struct"
read_GetNoteContent_args :: T.Protocol p => p -> P.IO GetNoteContent_args
read_GetNoteContent_args iprot = to_GetNoteContent_args <$> T.readVal iprot (T.T_STRUCT typemap_GetNoteContent_args)
decode_GetNoteContent_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetNoteContent_args
decode_GetNoteContent_args iprot bs = to_GetNoteContent_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetNoteContent_args) bs
typemap_GetNoteContent_args :: T.TypeMap
typemap_GetNoteContent_args = Map.fromList [(1,("authenticationToken",T.T_STRING)),(2,("guid",T.T_STRING))]
default_GetNoteContent_args :: GetNoteContent_args
default_GetNoteContent_args = GetNoteContent_args{
  getNoteContent_args_authenticationToken = "",
  getNoteContent_args_guid = ""}
data GetNoteContent_result = GetNoteContent_result  { getNoteContent_result_success :: LT.Text
  , getNoteContent_result_userException :: P.Maybe Errors_Types.EDAMUserException
  , getNoteContent_result_systemException :: P.Maybe Errors_Types.EDAMSystemException
  , getNoteContent_result_notFoundException :: P.Maybe Errors_Types.EDAMNotFoundException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetNoteContent_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getNoteContent_result_success record   `H.hashWithSalt` getNoteContent_result_userException record   `H.hashWithSalt` getNoteContent_result_systemException record   `H.hashWithSalt` getNoteContent_result_notFoundException record  
instance QC.Arbitrary GetNoteContent_result where 
  arbitrary = M.liftM GetNoteContent_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetNoteContent_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetNoteContent_result{getNoteContent_result_success = getNoteContent_result_success obj} then P.Nothing else P.Just $ default_GetNoteContent_result{getNoteContent_result_success = getNoteContent_result_success obj}
    , if obj == default_GetNoteContent_result{getNoteContent_result_userException = getNoteContent_result_userException obj} then P.Nothing else P.Just $ default_GetNoteContent_result{getNoteContent_result_userException = getNoteContent_result_userException obj}
    , if obj == default_GetNoteContent_result{getNoteContent_result_systemException = getNoteContent_result_systemException obj} then P.Nothing else P.Just $ default_GetNoteContent_result{getNoteContent_result_systemException = getNoteContent_result_systemException obj}
    , if obj == default_GetNoteContent_result{getNoteContent_result_notFoundException = getNoteContent_result_notFoundException obj} then P.Nothing else P.Just $ default_GetNoteContent_result{getNoteContent_result_notFoundException = getNoteContent_result_notFoundException obj}
    ]
from_GetNoteContent_result :: GetNoteContent_result -> T.ThriftVal
from_GetNoteContent_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v1089 -> (1, ("userException",Errors_Types.from_EDAMUserException _v1089))) <$> getNoteContent_result_userException record, (\_v1089 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v1089))) <$> getNoteContent_result_systemException record, (\_v1089 -> (3, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v1089))) <$> getNoteContent_result_notFoundException record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v1089 -> P.Just (0, ("success",T.TString $ E.encodeUtf8 _v1089))) $ getNoteContent_result_success record
    , (\_v1089 -> (1, ("userException",Errors_Types.from_EDAMUserException _v1089))) <$> getNoteContent_result_userException record
    , (\_v1089 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v1089))) <$> getNoteContent_result_systemException record
    , (\_v1089 -> (3, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v1089))) <$> getNoteContent_result_notFoundException record
    ]
    )
write_GetNoteContent_result :: T.Protocol p => p -> GetNoteContent_result -> P.IO ()
write_GetNoteContent_result oprot record = T.writeVal oprot $ from_GetNoteContent_result record
encode_GetNoteContent_result :: T.StatelessProtocol p => p -> GetNoteContent_result -> LBS.ByteString
encode_GetNoteContent_result oprot record = T.serializeVal oprot $ from_GetNoteContent_result record
to_GetNoteContent_result :: T.ThriftVal -> GetNoteContent_result
to_GetNoteContent_result (T.TStruct fields) = GetNoteContent_result{
  getNoteContent_result_success = P.maybe (getNoteContent_result_success default_GetNoteContent_result) (\(_,_val1091) -> (case _val1091 of {T.TString _val1092 -> E.decodeUtf8 _val1092; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getNoteContent_result_userException = P.maybe (P.Nothing) (\(_,_val1091) -> P.Just (case _val1091 of {T.TStruct _val1093 -> (Errors_Types.to_EDAMUserException (T.TStruct _val1093)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  getNoteContent_result_systemException = P.maybe (P.Nothing) (\(_,_val1091) -> P.Just (case _val1091 of {T.TStruct _val1094 -> (Errors_Types.to_EDAMSystemException (T.TStruct _val1094)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  getNoteContent_result_notFoundException = P.maybe (P.Nothing) (\(_,_val1091) -> P.Just (case _val1091 of {T.TStruct _val1095 -> (Errors_Types.to_EDAMNotFoundException (T.TStruct _val1095)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_GetNoteContent_result _ = P.error "not a struct"
read_GetNoteContent_result :: T.Protocol p => p -> P.IO GetNoteContent_result
read_GetNoteContent_result iprot = to_GetNoteContent_result <$> T.readVal iprot (T.T_STRUCT typemap_GetNoteContent_result)
decode_GetNoteContent_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetNoteContent_result
decode_GetNoteContent_result iprot bs = to_GetNoteContent_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetNoteContent_result) bs
typemap_GetNoteContent_result :: T.TypeMap
typemap_GetNoteContent_result = Map.fromList [(0,("success",T.T_STRING)),(1,("userException",(T.T_STRUCT Errors_Types.typemap_EDAMUserException))),(2,("systemException",(T.T_STRUCT Errors_Types.typemap_EDAMSystemException))),(3,("notFoundException",(T.T_STRUCT Errors_Types.typemap_EDAMNotFoundException)))]
default_GetNoteContent_result :: GetNoteContent_result
default_GetNoteContent_result = GetNoteContent_result{
  getNoteContent_result_success = "",
  getNoteContent_result_userException = P.Nothing,
  getNoteContent_result_systemException = P.Nothing,
  getNoteContent_result_notFoundException = P.Nothing}
data GetNoteSearchText_args = GetNoteSearchText_args  { getNoteSearchText_args_authenticationToken :: LT.Text
  , getNoteSearchText_args_guid :: LT.Text
  , getNoteSearchText_args_noteOnly :: P.Bool
  , getNoteSearchText_args_tokenizeForIndexing :: P.Bool
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetNoteSearchText_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getNoteSearchText_args_authenticationToken record   `H.hashWithSalt` getNoteSearchText_args_guid record   `H.hashWithSalt` getNoteSearchText_args_noteOnly record   `H.hashWithSalt` getNoteSearchText_args_tokenizeForIndexing record  
instance QC.Arbitrary GetNoteSearchText_args where 
  arbitrary = M.liftM GetNoteSearchText_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GetNoteSearchText_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetNoteSearchText_args{getNoteSearchText_args_authenticationToken = getNoteSearchText_args_authenticationToken obj} then P.Nothing else P.Just $ default_GetNoteSearchText_args{getNoteSearchText_args_authenticationToken = getNoteSearchText_args_authenticationToken obj}
    , if obj == default_GetNoteSearchText_args{getNoteSearchText_args_guid = getNoteSearchText_args_guid obj} then P.Nothing else P.Just $ default_GetNoteSearchText_args{getNoteSearchText_args_guid = getNoteSearchText_args_guid obj}
    , if obj == default_GetNoteSearchText_args{getNoteSearchText_args_noteOnly = getNoteSearchText_args_noteOnly obj} then P.Nothing else P.Just $ default_GetNoteSearchText_args{getNoteSearchText_args_noteOnly = getNoteSearchText_args_noteOnly obj}
    , if obj == default_GetNoteSearchText_args{getNoteSearchText_args_tokenizeForIndexing = getNoteSearchText_args_tokenizeForIndexing obj} then P.Nothing else P.Just $ default_GetNoteSearchText_args{getNoteSearchText_args_tokenizeForIndexing = getNoteSearchText_args_tokenizeForIndexing obj}
    ]
from_GetNoteSearchText_args :: GetNoteSearchText_args -> T.ThriftVal
from_GetNoteSearchText_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1098 -> P.Just (1, ("authenticationToken",T.TString $ E.encodeUtf8 _v1098))) $ getNoteSearchText_args_authenticationToken record
  , (\_v1098 -> P.Just (2, ("guid",T.TString $ E.encodeUtf8 _v1098))) $ getNoteSearchText_args_guid record
  , (\_v1098 -> P.Just (3, ("noteOnly",T.TBool _v1098))) $ getNoteSearchText_args_noteOnly record
  , (\_v1098 -> P.Just (4, ("tokenizeForIndexing",T.TBool _v1098))) $ getNoteSearchText_args_tokenizeForIndexing record
  ]
write_GetNoteSearchText_args :: T.Protocol p => p -> GetNoteSearchText_args -> P.IO ()
write_GetNoteSearchText_args oprot record = T.writeVal oprot $ from_GetNoteSearchText_args record
encode_GetNoteSearchText_args :: T.StatelessProtocol p => p -> GetNoteSearchText_args -> LBS.ByteString
encode_GetNoteSearchText_args oprot record = T.serializeVal oprot $ from_GetNoteSearchText_args record
to_GetNoteSearchText_args :: T.ThriftVal -> GetNoteSearchText_args
to_GetNoteSearchText_args (T.TStruct fields) = GetNoteSearchText_args{
  getNoteSearchText_args_authenticationToken = P.maybe (getNoteSearchText_args_authenticationToken default_GetNoteSearchText_args) (\(_,_val1100) -> (case _val1100 of {T.TString _val1101 -> E.decodeUtf8 _val1101; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  getNoteSearchText_args_guid = P.maybe (getNoteSearchText_args_guid default_GetNoteSearchText_args) (\(_,_val1100) -> (case _val1100 of {T.TString _val1102 -> E.decodeUtf8 _val1102; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  getNoteSearchText_args_noteOnly = P.maybe (getNoteSearchText_args_noteOnly default_GetNoteSearchText_args) (\(_,_val1100) -> (case _val1100 of {T.TBool _val1103 -> _val1103; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  getNoteSearchText_args_tokenizeForIndexing = P.maybe (getNoteSearchText_args_tokenizeForIndexing default_GetNoteSearchText_args) (\(_,_val1100) -> (case _val1100 of {T.TBool _val1104 -> _val1104; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_GetNoteSearchText_args _ = P.error "not a struct"
read_GetNoteSearchText_args :: T.Protocol p => p -> P.IO GetNoteSearchText_args
read_GetNoteSearchText_args iprot = to_GetNoteSearchText_args <$> T.readVal iprot (T.T_STRUCT typemap_GetNoteSearchText_args)
decode_GetNoteSearchText_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetNoteSearchText_args
decode_GetNoteSearchText_args iprot bs = to_GetNoteSearchText_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetNoteSearchText_args) bs
typemap_GetNoteSearchText_args :: T.TypeMap
typemap_GetNoteSearchText_args = Map.fromList [(1,("authenticationToken",T.T_STRING)),(2,("guid",T.T_STRING)),(3,("noteOnly",T.T_BOOL)),(4,("tokenizeForIndexing",T.T_BOOL))]
default_GetNoteSearchText_args :: GetNoteSearchText_args
default_GetNoteSearchText_args = GetNoteSearchText_args{
  getNoteSearchText_args_authenticationToken = "",
  getNoteSearchText_args_guid = "",
  getNoteSearchText_args_noteOnly = P.False,
  getNoteSearchText_args_tokenizeForIndexing = P.False}
data GetNoteSearchText_result = GetNoteSearchText_result  { getNoteSearchText_result_success :: LT.Text
  , getNoteSearchText_result_userException :: P.Maybe Errors_Types.EDAMUserException
  , getNoteSearchText_result_systemException :: P.Maybe Errors_Types.EDAMSystemException
  , getNoteSearchText_result_notFoundException :: P.Maybe Errors_Types.EDAMNotFoundException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetNoteSearchText_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getNoteSearchText_result_success record   `H.hashWithSalt` getNoteSearchText_result_userException record   `H.hashWithSalt` getNoteSearchText_result_systemException record   `H.hashWithSalt` getNoteSearchText_result_notFoundException record  
instance QC.Arbitrary GetNoteSearchText_result where 
  arbitrary = M.liftM GetNoteSearchText_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetNoteSearchText_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetNoteSearchText_result{getNoteSearchText_result_success = getNoteSearchText_result_success obj} then P.Nothing else P.Just $ default_GetNoteSearchText_result{getNoteSearchText_result_success = getNoteSearchText_result_success obj}
    , if obj == default_GetNoteSearchText_result{getNoteSearchText_result_userException = getNoteSearchText_result_userException obj} then P.Nothing else P.Just $ default_GetNoteSearchText_result{getNoteSearchText_result_userException = getNoteSearchText_result_userException obj}
    , if obj == default_GetNoteSearchText_result{getNoteSearchText_result_systemException = getNoteSearchText_result_systemException obj} then P.Nothing else P.Just $ default_GetNoteSearchText_result{getNoteSearchText_result_systemException = getNoteSearchText_result_systemException obj}
    , if obj == default_GetNoteSearchText_result{getNoteSearchText_result_notFoundException = getNoteSearchText_result_notFoundException obj} then P.Nothing else P.Just $ default_GetNoteSearchText_result{getNoteSearchText_result_notFoundException = getNoteSearchText_result_notFoundException obj}
    ]
from_GetNoteSearchText_result :: GetNoteSearchText_result -> T.ThriftVal
from_GetNoteSearchText_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v1107 -> (1, ("userException",Errors_Types.from_EDAMUserException _v1107))) <$> getNoteSearchText_result_userException record, (\_v1107 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v1107))) <$> getNoteSearchText_result_systemException record, (\_v1107 -> (3, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v1107))) <$> getNoteSearchText_result_notFoundException record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v1107 -> P.Just (0, ("success",T.TString $ E.encodeUtf8 _v1107))) $ getNoteSearchText_result_success record
    , (\_v1107 -> (1, ("userException",Errors_Types.from_EDAMUserException _v1107))) <$> getNoteSearchText_result_userException record
    , (\_v1107 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v1107))) <$> getNoteSearchText_result_systemException record
    , (\_v1107 -> (3, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v1107))) <$> getNoteSearchText_result_notFoundException record
    ]
    )
write_GetNoteSearchText_result :: T.Protocol p => p -> GetNoteSearchText_result -> P.IO ()
write_GetNoteSearchText_result oprot record = T.writeVal oprot $ from_GetNoteSearchText_result record
encode_GetNoteSearchText_result :: T.StatelessProtocol p => p -> GetNoteSearchText_result -> LBS.ByteString
encode_GetNoteSearchText_result oprot record = T.serializeVal oprot $ from_GetNoteSearchText_result record
to_GetNoteSearchText_result :: T.ThriftVal -> GetNoteSearchText_result
to_GetNoteSearchText_result (T.TStruct fields) = GetNoteSearchText_result{
  getNoteSearchText_result_success = P.maybe (getNoteSearchText_result_success default_GetNoteSearchText_result) (\(_,_val1109) -> (case _val1109 of {T.TString _val1110 -> E.decodeUtf8 _val1110; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getNoteSearchText_result_userException = P.maybe (P.Nothing) (\(_,_val1109) -> P.Just (case _val1109 of {T.TStruct _val1111 -> (Errors_Types.to_EDAMUserException (T.TStruct _val1111)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  getNoteSearchText_result_systemException = P.maybe (P.Nothing) (\(_,_val1109) -> P.Just (case _val1109 of {T.TStruct _val1112 -> (Errors_Types.to_EDAMSystemException (T.TStruct _val1112)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  getNoteSearchText_result_notFoundException = P.maybe (P.Nothing) (\(_,_val1109) -> P.Just (case _val1109 of {T.TStruct _val1113 -> (Errors_Types.to_EDAMNotFoundException (T.TStruct _val1113)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_GetNoteSearchText_result _ = P.error "not a struct"
read_GetNoteSearchText_result :: T.Protocol p => p -> P.IO GetNoteSearchText_result
read_GetNoteSearchText_result iprot = to_GetNoteSearchText_result <$> T.readVal iprot (T.T_STRUCT typemap_GetNoteSearchText_result)
decode_GetNoteSearchText_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetNoteSearchText_result
decode_GetNoteSearchText_result iprot bs = to_GetNoteSearchText_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetNoteSearchText_result) bs
typemap_GetNoteSearchText_result :: T.TypeMap
typemap_GetNoteSearchText_result = Map.fromList [(0,("success",T.T_STRING)),(1,("userException",(T.T_STRUCT Errors_Types.typemap_EDAMUserException))),(2,("systemException",(T.T_STRUCT Errors_Types.typemap_EDAMSystemException))),(3,("notFoundException",(T.T_STRUCT Errors_Types.typemap_EDAMNotFoundException)))]
default_GetNoteSearchText_result :: GetNoteSearchText_result
default_GetNoteSearchText_result = GetNoteSearchText_result{
  getNoteSearchText_result_success = "",
  getNoteSearchText_result_userException = P.Nothing,
  getNoteSearchText_result_systemException = P.Nothing,
  getNoteSearchText_result_notFoundException = P.Nothing}
data GetResourceSearchText_args = GetResourceSearchText_args  { getResourceSearchText_args_authenticationToken :: LT.Text
  , getResourceSearchText_args_guid :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetResourceSearchText_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getResourceSearchText_args_authenticationToken record   `H.hashWithSalt` getResourceSearchText_args_guid record  
instance QC.Arbitrary GetResourceSearchText_args where 
  arbitrary = M.liftM GetResourceSearchText_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GetResourceSearchText_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetResourceSearchText_args{getResourceSearchText_args_authenticationToken = getResourceSearchText_args_authenticationToken obj} then P.Nothing else P.Just $ default_GetResourceSearchText_args{getResourceSearchText_args_authenticationToken = getResourceSearchText_args_authenticationToken obj}
    , if obj == default_GetResourceSearchText_args{getResourceSearchText_args_guid = getResourceSearchText_args_guid obj} then P.Nothing else P.Just $ default_GetResourceSearchText_args{getResourceSearchText_args_guid = getResourceSearchText_args_guid obj}
    ]
from_GetResourceSearchText_args :: GetResourceSearchText_args -> T.ThriftVal
from_GetResourceSearchText_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1116 -> P.Just (1, ("authenticationToken",T.TString $ E.encodeUtf8 _v1116))) $ getResourceSearchText_args_authenticationToken record
  , (\_v1116 -> P.Just (2, ("guid",T.TString $ E.encodeUtf8 _v1116))) $ getResourceSearchText_args_guid record
  ]
write_GetResourceSearchText_args :: T.Protocol p => p -> GetResourceSearchText_args -> P.IO ()
write_GetResourceSearchText_args oprot record = T.writeVal oprot $ from_GetResourceSearchText_args record
encode_GetResourceSearchText_args :: T.StatelessProtocol p => p -> GetResourceSearchText_args -> LBS.ByteString
encode_GetResourceSearchText_args oprot record = T.serializeVal oprot $ from_GetResourceSearchText_args record
to_GetResourceSearchText_args :: T.ThriftVal -> GetResourceSearchText_args
to_GetResourceSearchText_args (T.TStruct fields) = GetResourceSearchText_args{
  getResourceSearchText_args_authenticationToken = P.maybe (getResourceSearchText_args_authenticationToken default_GetResourceSearchText_args) (\(_,_val1118) -> (case _val1118 of {T.TString _val1119 -> E.decodeUtf8 _val1119; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  getResourceSearchText_args_guid = P.maybe (getResourceSearchText_args_guid default_GetResourceSearchText_args) (\(_,_val1118) -> (case _val1118 of {T.TString _val1120 -> E.decodeUtf8 _val1120; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_GetResourceSearchText_args _ = P.error "not a struct"
read_GetResourceSearchText_args :: T.Protocol p => p -> P.IO GetResourceSearchText_args
read_GetResourceSearchText_args iprot = to_GetResourceSearchText_args <$> T.readVal iprot (T.T_STRUCT typemap_GetResourceSearchText_args)
decode_GetResourceSearchText_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetResourceSearchText_args
decode_GetResourceSearchText_args iprot bs = to_GetResourceSearchText_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetResourceSearchText_args) bs
typemap_GetResourceSearchText_args :: T.TypeMap
typemap_GetResourceSearchText_args = Map.fromList [(1,("authenticationToken",T.T_STRING)),(2,("guid",T.T_STRING))]
default_GetResourceSearchText_args :: GetResourceSearchText_args
default_GetResourceSearchText_args = GetResourceSearchText_args{
  getResourceSearchText_args_authenticationToken = "",
  getResourceSearchText_args_guid = ""}
data GetResourceSearchText_result = GetResourceSearchText_result  { getResourceSearchText_result_success :: LT.Text
  , getResourceSearchText_result_userException :: P.Maybe Errors_Types.EDAMUserException
  , getResourceSearchText_result_systemException :: P.Maybe Errors_Types.EDAMSystemException
  , getResourceSearchText_result_notFoundException :: P.Maybe Errors_Types.EDAMNotFoundException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetResourceSearchText_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getResourceSearchText_result_success record   `H.hashWithSalt` getResourceSearchText_result_userException record   `H.hashWithSalt` getResourceSearchText_result_systemException record   `H.hashWithSalt` getResourceSearchText_result_notFoundException record  
instance QC.Arbitrary GetResourceSearchText_result where 
  arbitrary = M.liftM GetResourceSearchText_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetResourceSearchText_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetResourceSearchText_result{getResourceSearchText_result_success = getResourceSearchText_result_success obj} then P.Nothing else P.Just $ default_GetResourceSearchText_result{getResourceSearchText_result_success = getResourceSearchText_result_success obj}
    , if obj == default_GetResourceSearchText_result{getResourceSearchText_result_userException = getResourceSearchText_result_userException obj} then P.Nothing else P.Just $ default_GetResourceSearchText_result{getResourceSearchText_result_userException = getResourceSearchText_result_userException obj}
    , if obj == default_GetResourceSearchText_result{getResourceSearchText_result_systemException = getResourceSearchText_result_systemException obj} then P.Nothing else P.Just $ default_GetResourceSearchText_result{getResourceSearchText_result_systemException = getResourceSearchText_result_systemException obj}
    , if obj == default_GetResourceSearchText_result{getResourceSearchText_result_notFoundException = getResourceSearchText_result_notFoundException obj} then P.Nothing else P.Just $ default_GetResourceSearchText_result{getResourceSearchText_result_notFoundException = getResourceSearchText_result_notFoundException obj}
    ]
from_GetResourceSearchText_result :: GetResourceSearchText_result -> T.ThriftVal
from_GetResourceSearchText_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v1123 -> (1, ("userException",Errors_Types.from_EDAMUserException _v1123))) <$> getResourceSearchText_result_userException record, (\_v1123 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v1123))) <$> getResourceSearchText_result_systemException record, (\_v1123 -> (3, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v1123))) <$> getResourceSearchText_result_notFoundException record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v1123 -> P.Just (0, ("success",T.TString $ E.encodeUtf8 _v1123))) $ getResourceSearchText_result_success record
    , (\_v1123 -> (1, ("userException",Errors_Types.from_EDAMUserException _v1123))) <$> getResourceSearchText_result_userException record
    , (\_v1123 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v1123))) <$> getResourceSearchText_result_systemException record
    , (\_v1123 -> (3, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v1123))) <$> getResourceSearchText_result_notFoundException record
    ]
    )
write_GetResourceSearchText_result :: T.Protocol p => p -> GetResourceSearchText_result -> P.IO ()
write_GetResourceSearchText_result oprot record = T.writeVal oprot $ from_GetResourceSearchText_result record
encode_GetResourceSearchText_result :: T.StatelessProtocol p => p -> GetResourceSearchText_result -> LBS.ByteString
encode_GetResourceSearchText_result oprot record = T.serializeVal oprot $ from_GetResourceSearchText_result record
to_GetResourceSearchText_result :: T.ThriftVal -> GetResourceSearchText_result
to_GetResourceSearchText_result (T.TStruct fields) = GetResourceSearchText_result{
  getResourceSearchText_result_success = P.maybe (getResourceSearchText_result_success default_GetResourceSearchText_result) (\(_,_val1125) -> (case _val1125 of {T.TString _val1126 -> E.decodeUtf8 _val1126; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getResourceSearchText_result_userException = P.maybe (P.Nothing) (\(_,_val1125) -> P.Just (case _val1125 of {T.TStruct _val1127 -> (Errors_Types.to_EDAMUserException (T.TStruct _val1127)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  getResourceSearchText_result_systemException = P.maybe (P.Nothing) (\(_,_val1125) -> P.Just (case _val1125 of {T.TStruct _val1128 -> (Errors_Types.to_EDAMSystemException (T.TStruct _val1128)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  getResourceSearchText_result_notFoundException = P.maybe (P.Nothing) (\(_,_val1125) -> P.Just (case _val1125 of {T.TStruct _val1129 -> (Errors_Types.to_EDAMNotFoundException (T.TStruct _val1129)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_GetResourceSearchText_result _ = P.error "not a struct"
read_GetResourceSearchText_result :: T.Protocol p => p -> P.IO GetResourceSearchText_result
read_GetResourceSearchText_result iprot = to_GetResourceSearchText_result <$> T.readVal iprot (T.T_STRUCT typemap_GetResourceSearchText_result)
decode_GetResourceSearchText_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetResourceSearchText_result
decode_GetResourceSearchText_result iprot bs = to_GetResourceSearchText_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetResourceSearchText_result) bs
typemap_GetResourceSearchText_result :: T.TypeMap
typemap_GetResourceSearchText_result = Map.fromList [(0,("success",T.T_STRING)),(1,("userException",(T.T_STRUCT Errors_Types.typemap_EDAMUserException))),(2,("systemException",(T.T_STRUCT Errors_Types.typemap_EDAMSystemException))),(3,("notFoundException",(T.T_STRUCT Errors_Types.typemap_EDAMNotFoundException)))]
default_GetResourceSearchText_result :: GetResourceSearchText_result
default_GetResourceSearchText_result = GetResourceSearchText_result{
  getResourceSearchText_result_success = "",
  getResourceSearchText_result_userException = P.Nothing,
  getResourceSearchText_result_systemException = P.Nothing,
  getResourceSearchText_result_notFoundException = P.Nothing}
data GetNoteTagNames_args = GetNoteTagNames_args  { getNoteTagNames_args_authenticationToken :: LT.Text
  , getNoteTagNames_args_guid :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetNoteTagNames_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getNoteTagNames_args_authenticationToken record   `H.hashWithSalt` getNoteTagNames_args_guid record  
instance QC.Arbitrary GetNoteTagNames_args where 
  arbitrary = M.liftM GetNoteTagNames_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GetNoteTagNames_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetNoteTagNames_args{getNoteTagNames_args_authenticationToken = getNoteTagNames_args_authenticationToken obj} then P.Nothing else P.Just $ default_GetNoteTagNames_args{getNoteTagNames_args_authenticationToken = getNoteTagNames_args_authenticationToken obj}
    , if obj == default_GetNoteTagNames_args{getNoteTagNames_args_guid = getNoteTagNames_args_guid obj} then P.Nothing else P.Just $ default_GetNoteTagNames_args{getNoteTagNames_args_guid = getNoteTagNames_args_guid obj}
    ]
from_GetNoteTagNames_args :: GetNoteTagNames_args -> T.ThriftVal
from_GetNoteTagNames_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1132 -> P.Just (1, ("authenticationToken",T.TString $ E.encodeUtf8 _v1132))) $ getNoteTagNames_args_authenticationToken record
  , (\_v1132 -> P.Just (2, ("guid",T.TString $ E.encodeUtf8 _v1132))) $ getNoteTagNames_args_guid record
  ]
write_GetNoteTagNames_args :: T.Protocol p => p -> GetNoteTagNames_args -> P.IO ()
write_GetNoteTagNames_args oprot record = T.writeVal oprot $ from_GetNoteTagNames_args record
encode_GetNoteTagNames_args :: T.StatelessProtocol p => p -> GetNoteTagNames_args -> LBS.ByteString
encode_GetNoteTagNames_args oprot record = T.serializeVal oprot $ from_GetNoteTagNames_args record
to_GetNoteTagNames_args :: T.ThriftVal -> GetNoteTagNames_args
to_GetNoteTagNames_args (T.TStruct fields) = GetNoteTagNames_args{
  getNoteTagNames_args_authenticationToken = P.maybe (getNoteTagNames_args_authenticationToken default_GetNoteTagNames_args) (\(_,_val1134) -> (case _val1134 of {T.TString _val1135 -> E.decodeUtf8 _val1135; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  getNoteTagNames_args_guid = P.maybe (getNoteTagNames_args_guid default_GetNoteTagNames_args) (\(_,_val1134) -> (case _val1134 of {T.TString _val1136 -> E.decodeUtf8 _val1136; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_GetNoteTagNames_args _ = P.error "not a struct"
read_GetNoteTagNames_args :: T.Protocol p => p -> P.IO GetNoteTagNames_args
read_GetNoteTagNames_args iprot = to_GetNoteTagNames_args <$> T.readVal iprot (T.T_STRUCT typemap_GetNoteTagNames_args)
decode_GetNoteTagNames_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetNoteTagNames_args
decode_GetNoteTagNames_args iprot bs = to_GetNoteTagNames_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetNoteTagNames_args) bs
typemap_GetNoteTagNames_args :: T.TypeMap
typemap_GetNoteTagNames_args = Map.fromList [(1,("authenticationToken",T.T_STRING)),(2,("guid",T.T_STRING))]
default_GetNoteTagNames_args :: GetNoteTagNames_args
default_GetNoteTagNames_args = GetNoteTagNames_args{
  getNoteTagNames_args_authenticationToken = "",
  getNoteTagNames_args_guid = ""}
data GetNoteTagNames_result = GetNoteTagNames_result  { getNoteTagNames_result_success :: (Vector.Vector LT.Text)
  , getNoteTagNames_result_userException :: P.Maybe Errors_Types.EDAMUserException
  , getNoteTagNames_result_systemException :: P.Maybe Errors_Types.EDAMSystemException
  , getNoteTagNames_result_notFoundException :: P.Maybe Errors_Types.EDAMNotFoundException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetNoteTagNames_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getNoteTagNames_result_success record   `H.hashWithSalt` getNoteTagNames_result_userException record   `H.hashWithSalt` getNoteTagNames_result_systemException record   `H.hashWithSalt` getNoteTagNames_result_notFoundException record  
instance QC.Arbitrary GetNoteTagNames_result where 
  arbitrary = M.liftM GetNoteTagNames_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetNoteTagNames_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetNoteTagNames_result{getNoteTagNames_result_success = getNoteTagNames_result_success obj} then P.Nothing else P.Just $ default_GetNoteTagNames_result{getNoteTagNames_result_success = getNoteTagNames_result_success obj}
    , if obj == default_GetNoteTagNames_result{getNoteTagNames_result_userException = getNoteTagNames_result_userException obj} then P.Nothing else P.Just $ default_GetNoteTagNames_result{getNoteTagNames_result_userException = getNoteTagNames_result_userException obj}
    , if obj == default_GetNoteTagNames_result{getNoteTagNames_result_systemException = getNoteTagNames_result_systemException obj} then P.Nothing else P.Just $ default_GetNoteTagNames_result{getNoteTagNames_result_systemException = getNoteTagNames_result_systemException obj}
    , if obj == default_GetNoteTagNames_result{getNoteTagNames_result_notFoundException = getNoteTagNames_result_notFoundException obj} then P.Nothing else P.Just $ default_GetNoteTagNames_result{getNoteTagNames_result_notFoundException = getNoteTagNames_result_notFoundException obj}
    ]
from_GetNoteTagNames_result :: GetNoteTagNames_result -> T.ThriftVal
from_GetNoteTagNames_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v1139 -> (1, ("userException",Errors_Types.from_EDAMUserException _v1139))) <$> getNoteTagNames_result_userException record, (\_v1139 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v1139))) <$> getNoteTagNames_result_systemException record, (\_v1139 -> (3, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v1139))) <$> getNoteTagNames_result_notFoundException record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v1139 -> P.Just (0, ("success",T.TList T.T_STRING $ P.map (\_v1141 -> T.TString $ E.encodeUtf8 _v1141) $ Vector.toList _v1139))) $ getNoteTagNames_result_success record
    , (\_v1139 -> (1, ("userException",Errors_Types.from_EDAMUserException _v1139))) <$> getNoteTagNames_result_userException record
    , (\_v1139 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v1139))) <$> getNoteTagNames_result_systemException record
    , (\_v1139 -> (3, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v1139))) <$> getNoteTagNames_result_notFoundException record
    ]
    )
write_GetNoteTagNames_result :: T.Protocol p => p -> GetNoteTagNames_result -> P.IO ()
write_GetNoteTagNames_result oprot record = T.writeVal oprot $ from_GetNoteTagNames_result record
encode_GetNoteTagNames_result :: T.StatelessProtocol p => p -> GetNoteTagNames_result -> LBS.ByteString
encode_GetNoteTagNames_result oprot record = T.serializeVal oprot $ from_GetNoteTagNames_result record
to_GetNoteTagNames_result :: T.ThriftVal -> GetNoteTagNames_result
to_GetNoteTagNames_result (T.TStruct fields) = GetNoteTagNames_result{
  getNoteTagNames_result_success = P.maybe (getNoteTagNames_result_success default_GetNoteTagNames_result) (\(_,_val1143) -> (case _val1143 of {T.TList _ _val1144 -> (Vector.fromList $ P.map (\_v1145 -> (case _v1145 of {T.TString _val1146 -> E.decodeUtf8 _val1146; _ -> P.error "wrong type"})) _val1144); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getNoteTagNames_result_userException = P.maybe (P.Nothing) (\(_,_val1143) -> P.Just (case _val1143 of {T.TStruct _val1147 -> (Errors_Types.to_EDAMUserException (T.TStruct _val1147)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  getNoteTagNames_result_systemException = P.maybe (P.Nothing) (\(_,_val1143) -> P.Just (case _val1143 of {T.TStruct _val1148 -> (Errors_Types.to_EDAMSystemException (T.TStruct _val1148)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  getNoteTagNames_result_notFoundException = P.maybe (P.Nothing) (\(_,_val1143) -> P.Just (case _val1143 of {T.TStruct _val1149 -> (Errors_Types.to_EDAMNotFoundException (T.TStruct _val1149)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_GetNoteTagNames_result _ = P.error "not a struct"
read_GetNoteTagNames_result :: T.Protocol p => p -> P.IO GetNoteTagNames_result
read_GetNoteTagNames_result iprot = to_GetNoteTagNames_result <$> T.readVal iprot (T.T_STRUCT typemap_GetNoteTagNames_result)
decode_GetNoteTagNames_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetNoteTagNames_result
decode_GetNoteTagNames_result iprot bs = to_GetNoteTagNames_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetNoteTagNames_result) bs
typemap_GetNoteTagNames_result :: T.TypeMap
typemap_GetNoteTagNames_result = Map.fromList [(0,("success",(T.T_LIST T.T_STRING))),(1,("userException",(T.T_STRUCT Errors_Types.typemap_EDAMUserException))),(2,("systemException",(T.T_STRUCT Errors_Types.typemap_EDAMSystemException))),(3,("notFoundException",(T.T_STRUCT Errors_Types.typemap_EDAMNotFoundException)))]
default_GetNoteTagNames_result :: GetNoteTagNames_result
default_GetNoteTagNames_result = GetNoteTagNames_result{
  getNoteTagNames_result_success = Vector.empty,
  getNoteTagNames_result_userException = P.Nothing,
  getNoteTagNames_result_systemException = P.Nothing,
  getNoteTagNames_result_notFoundException = P.Nothing}
data CreateNote_args = CreateNote_args  { createNote_args_authenticationToken :: LT.Text
  , createNote_args_note :: Types_Types.Note
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable CreateNote_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` createNote_args_authenticationToken record   `H.hashWithSalt` createNote_args_note record  
instance QC.Arbitrary CreateNote_args where 
  arbitrary = M.liftM CreateNote_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_CreateNote_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_CreateNote_args{createNote_args_authenticationToken = createNote_args_authenticationToken obj} then P.Nothing else P.Just $ default_CreateNote_args{createNote_args_authenticationToken = createNote_args_authenticationToken obj}
    , if obj == default_CreateNote_args{createNote_args_note = createNote_args_note obj} then P.Nothing else P.Just $ default_CreateNote_args{createNote_args_note = createNote_args_note obj}
    ]
from_CreateNote_args :: CreateNote_args -> T.ThriftVal
from_CreateNote_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1152 -> P.Just (1, ("authenticationToken",T.TString $ E.encodeUtf8 _v1152))) $ createNote_args_authenticationToken record
  , (\_v1152 -> P.Just (2, ("note",Types_Types.from_Note _v1152))) $ createNote_args_note record
  ]
write_CreateNote_args :: T.Protocol p => p -> CreateNote_args -> P.IO ()
write_CreateNote_args oprot record = T.writeVal oprot $ from_CreateNote_args record
encode_CreateNote_args :: T.StatelessProtocol p => p -> CreateNote_args -> LBS.ByteString
encode_CreateNote_args oprot record = T.serializeVal oprot $ from_CreateNote_args record
to_CreateNote_args :: T.ThriftVal -> CreateNote_args
to_CreateNote_args (T.TStruct fields) = CreateNote_args{
  createNote_args_authenticationToken = P.maybe (createNote_args_authenticationToken default_CreateNote_args) (\(_,_val1154) -> (case _val1154 of {T.TString _val1155 -> E.decodeUtf8 _val1155; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  createNote_args_note = P.maybe (createNote_args_note default_CreateNote_args) (\(_,_val1154) -> (case _val1154 of {T.TStruct _val1156 -> (Types_Types.to_Note (T.TStruct _val1156)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_CreateNote_args _ = P.error "not a struct"
read_CreateNote_args :: T.Protocol p => p -> P.IO CreateNote_args
read_CreateNote_args iprot = to_CreateNote_args <$> T.readVal iprot (T.T_STRUCT typemap_CreateNote_args)
decode_CreateNote_args :: T.StatelessProtocol p => p -> LBS.ByteString -> CreateNote_args
decode_CreateNote_args iprot bs = to_CreateNote_args $ T.deserializeVal iprot (T.T_STRUCT typemap_CreateNote_args) bs
typemap_CreateNote_args :: T.TypeMap
typemap_CreateNote_args = Map.fromList [(1,("authenticationToken",T.T_STRING)),(2,("note",(T.T_STRUCT Types_Types.typemap_Note)))]
default_CreateNote_args :: CreateNote_args
default_CreateNote_args = CreateNote_args{
  createNote_args_authenticationToken = "",
  createNote_args_note = Types_Types.default_Note}
data CreateNote_result = CreateNote_result  { createNote_result_success :: Types_Types.Note
  , createNote_result_userException :: P.Maybe Errors_Types.EDAMUserException
  , createNote_result_systemException :: P.Maybe Errors_Types.EDAMSystemException
  , createNote_result_notFoundException :: P.Maybe Errors_Types.EDAMNotFoundException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable CreateNote_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` createNote_result_success record   `H.hashWithSalt` createNote_result_userException record   `H.hashWithSalt` createNote_result_systemException record   `H.hashWithSalt` createNote_result_notFoundException record  
instance QC.Arbitrary CreateNote_result where 
  arbitrary = M.liftM CreateNote_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_CreateNote_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_CreateNote_result{createNote_result_success = createNote_result_success obj} then P.Nothing else P.Just $ default_CreateNote_result{createNote_result_success = createNote_result_success obj}
    , if obj == default_CreateNote_result{createNote_result_userException = createNote_result_userException obj} then P.Nothing else P.Just $ default_CreateNote_result{createNote_result_userException = createNote_result_userException obj}
    , if obj == default_CreateNote_result{createNote_result_systemException = createNote_result_systemException obj} then P.Nothing else P.Just $ default_CreateNote_result{createNote_result_systemException = createNote_result_systemException obj}
    , if obj == default_CreateNote_result{createNote_result_notFoundException = createNote_result_notFoundException obj} then P.Nothing else P.Just $ default_CreateNote_result{createNote_result_notFoundException = createNote_result_notFoundException obj}
    ]
from_CreateNote_result :: CreateNote_result -> T.ThriftVal
from_CreateNote_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v1159 -> (1, ("userException",Errors_Types.from_EDAMUserException _v1159))) <$> createNote_result_userException record, (\_v1159 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v1159))) <$> createNote_result_systemException record, (\_v1159 -> (3, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v1159))) <$> createNote_result_notFoundException record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v1159 -> P.Just (0, ("success",Types_Types.from_Note _v1159))) $ createNote_result_success record
    , (\_v1159 -> (1, ("userException",Errors_Types.from_EDAMUserException _v1159))) <$> createNote_result_userException record
    , (\_v1159 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v1159))) <$> createNote_result_systemException record
    , (\_v1159 -> (3, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v1159))) <$> createNote_result_notFoundException record
    ]
    )
write_CreateNote_result :: T.Protocol p => p -> CreateNote_result -> P.IO ()
write_CreateNote_result oprot record = T.writeVal oprot $ from_CreateNote_result record
encode_CreateNote_result :: T.StatelessProtocol p => p -> CreateNote_result -> LBS.ByteString
encode_CreateNote_result oprot record = T.serializeVal oprot $ from_CreateNote_result record
to_CreateNote_result :: T.ThriftVal -> CreateNote_result
to_CreateNote_result (T.TStruct fields) = CreateNote_result{
  createNote_result_success = P.maybe (createNote_result_success default_CreateNote_result) (\(_,_val1161) -> (case _val1161 of {T.TStruct _val1162 -> (Types_Types.to_Note (T.TStruct _val1162)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  createNote_result_userException = P.maybe (P.Nothing) (\(_,_val1161) -> P.Just (case _val1161 of {T.TStruct _val1163 -> (Errors_Types.to_EDAMUserException (T.TStruct _val1163)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  createNote_result_systemException = P.maybe (P.Nothing) (\(_,_val1161) -> P.Just (case _val1161 of {T.TStruct _val1164 -> (Errors_Types.to_EDAMSystemException (T.TStruct _val1164)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  createNote_result_notFoundException = P.maybe (P.Nothing) (\(_,_val1161) -> P.Just (case _val1161 of {T.TStruct _val1165 -> (Errors_Types.to_EDAMNotFoundException (T.TStruct _val1165)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_CreateNote_result _ = P.error "not a struct"
read_CreateNote_result :: T.Protocol p => p -> P.IO CreateNote_result
read_CreateNote_result iprot = to_CreateNote_result <$> T.readVal iprot (T.T_STRUCT typemap_CreateNote_result)
decode_CreateNote_result :: T.StatelessProtocol p => p -> LBS.ByteString -> CreateNote_result
decode_CreateNote_result iprot bs = to_CreateNote_result $ T.deserializeVal iprot (T.T_STRUCT typemap_CreateNote_result) bs
typemap_CreateNote_result :: T.TypeMap
typemap_CreateNote_result = Map.fromList [(0,("success",(T.T_STRUCT Types_Types.typemap_Note))),(1,("userException",(T.T_STRUCT Errors_Types.typemap_EDAMUserException))),(2,("systemException",(T.T_STRUCT Errors_Types.typemap_EDAMSystemException))),(3,("notFoundException",(T.T_STRUCT Errors_Types.typemap_EDAMNotFoundException)))]
default_CreateNote_result :: CreateNote_result
default_CreateNote_result = CreateNote_result{
  createNote_result_success = Types_Types.default_Note,
  createNote_result_userException = P.Nothing,
  createNote_result_systemException = P.Nothing,
  createNote_result_notFoundException = P.Nothing}
data UpdateNote_args = UpdateNote_args  { updateNote_args_authenticationToken :: LT.Text
  , updateNote_args_note :: Types_Types.Note
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateNote_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateNote_args_authenticationToken record   `H.hashWithSalt` updateNote_args_note record  
instance QC.Arbitrary UpdateNote_args where 
  arbitrary = M.liftM UpdateNote_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_UpdateNote_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateNote_args{updateNote_args_authenticationToken = updateNote_args_authenticationToken obj} then P.Nothing else P.Just $ default_UpdateNote_args{updateNote_args_authenticationToken = updateNote_args_authenticationToken obj}
    , if obj == default_UpdateNote_args{updateNote_args_note = updateNote_args_note obj} then P.Nothing else P.Just $ default_UpdateNote_args{updateNote_args_note = updateNote_args_note obj}
    ]
from_UpdateNote_args :: UpdateNote_args -> T.ThriftVal
from_UpdateNote_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1168 -> P.Just (1, ("authenticationToken",T.TString $ E.encodeUtf8 _v1168))) $ updateNote_args_authenticationToken record
  , (\_v1168 -> P.Just (2, ("note",Types_Types.from_Note _v1168))) $ updateNote_args_note record
  ]
write_UpdateNote_args :: T.Protocol p => p -> UpdateNote_args -> P.IO ()
write_UpdateNote_args oprot record = T.writeVal oprot $ from_UpdateNote_args record
encode_UpdateNote_args :: T.StatelessProtocol p => p -> UpdateNote_args -> LBS.ByteString
encode_UpdateNote_args oprot record = T.serializeVal oprot $ from_UpdateNote_args record
to_UpdateNote_args :: T.ThriftVal -> UpdateNote_args
to_UpdateNote_args (T.TStruct fields) = UpdateNote_args{
  updateNote_args_authenticationToken = P.maybe (updateNote_args_authenticationToken default_UpdateNote_args) (\(_,_val1170) -> (case _val1170 of {T.TString _val1171 -> E.decodeUtf8 _val1171; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  updateNote_args_note = P.maybe (updateNote_args_note default_UpdateNote_args) (\(_,_val1170) -> (case _val1170 of {T.TStruct _val1172 -> (Types_Types.to_Note (T.TStruct _val1172)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_UpdateNote_args _ = P.error "not a struct"
read_UpdateNote_args :: T.Protocol p => p -> P.IO UpdateNote_args
read_UpdateNote_args iprot = to_UpdateNote_args <$> T.readVal iprot (T.T_STRUCT typemap_UpdateNote_args)
decode_UpdateNote_args :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateNote_args
decode_UpdateNote_args iprot bs = to_UpdateNote_args $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateNote_args) bs
typemap_UpdateNote_args :: T.TypeMap
typemap_UpdateNote_args = Map.fromList [(1,("authenticationToken",T.T_STRING)),(2,("note",(T.T_STRUCT Types_Types.typemap_Note)))]
default_UpdateNote_args :: UpdateNote_args
default_UpdateNote_args = UpdateNote_args{
  updateNote_args_authenticationToken = "",
  updateNote_args_note = Types_Types.default_Note}
data UpdateNote_result = UpdateNote_result  { updateNote_result_success :: Types_Types.Note
  , updateNote_result_userException :: P.Maybe Errors_Types.EDAMUserException
  , updateNote_result_systemException :: P.Maybe Errors_Types.EDAMSystemException
  , updateNote_result_notFoundException :: P.Maybe Errors_Types.EDAMNotFoundException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateNote_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateNote_result_success record   `H.hashWithSalt` updateNote_result_userException record   `H.hashWithSalt` updateNote_result_systemException record   `H.hashWithSalt` updateNote_result_notFoundException record  
instance QC.Arbitrary UpdateNote_result where 
  arbitrary = M.liftM UpdateNote_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_UpdateNote_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateNote_result{updateNote_result_success = updateNote_result_success obj} then P.Nothing else P.Just $ default_UpdateNote_result{updateNote_result_success = updateNote_result_success obj}
    , if obj == default_UpdateNote_result{updateNote_result_userException = updateNote_result_userException obj} then P.Nothing else P.Just $ default_UpdateNote_result{updateNote_result_userException = updateNote_result_userException obj}
    , if obj == default_UpdateNote_result{updateNote_result_systemException = updateNote_result_systemException obj} then P.Nothing else P.Just $ default_UpdateNote_result{updateNote_result_systemException = updateNote_result_systemException obj}
    , if obj == default_UpdateNote_result{updateNote_result_notFoundException = updateNote_result_notFoundException obj} then P.Nothing else P.Just $ default_UpdateNote_result{updateNote_result_notFoundException = updateNote_result_notFoundException obj}
    ]
from_UpdateNote_result :: UpdateNote_result -> T.ThriftVal
from_UpdateNote_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v1175 -> (1, ("userException",Errors_Types.from_EDAMUserException _v1175))) <$> updateNote_result_userException record, (\_v1175 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v1175))) <$> updateNote_result_systemException record, (\_v1175 -> (3, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v1175))) <$> updateNote_result_notFoundException record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v1175 -> P.Just (0, ("success",Types_Types.from_Note _v1175))) $ updateNote_result_success record
    , (\_v1175 -> (1, ("userException",Errors_Types.from_EDAMUserException _v1175))) <$> updateNote_result_userException record
    , (\_v1175 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v1175))) <$> updateNote_result_systemException record
    , (\_v1175 -> (3, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v1175))) <$> updateNote_result_notFoundException record
    ]
    )
write_UpdateNote_result :: T.Protocol p => p -> UpdateNote_result -> P.IO ()
write_UpdateNote_result oprot record = T.writeVal oprot $ from_UpdateNote_result record
encode_UpdateNote_result :: T.StatelessProtocol p => p -> UpdateNote_result -> LBS.ByteString
encode_UpdateNote_result oprot record = T.serializeVal oprot $ from_UpdateNote_result record
to_UpdateNote_result :: T.ThriftVal -> UpdateNote_result
to_UpdateNote_result (T.TStruct fields) = UpdateNote_result{
  updateNote_result_success = P.maybe (updateNote_result_success default_UpdateNote_result) (\(_,_val1177) -> (case _val1177 of {T.TStruct _val1178 -> (Types_Types.to_Note (T.TStruct _val1178)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  updateNote_result_userException = P.maybe (P.Nothing) (\(_,_val1177) -> P.Just (case _val1177 of {T.TStruct _val1179 -> (Errors_Types.to_EDAMUserException (T.TStruct _val1179)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  updateNote_result_systemException = P.maybe (P.Nothing) (\(_,_val1177) -> P.Just (case _val1177 of {T.TStruct _val1180 -> (Errors_Types.to_EDAMSystemException (T.TStruct _val1180)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  updateNote_result_notFoundException = P.maybe (P.Nothing) (\(_,_val1177) -> P.Just (case _val1177 of {T.TStruct _val1181 -> (Errors_Types.to_EDAMNotFoundException (T.TStruct _val1181)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_UpdateNote_result _ = P.error "not a struct"
read_UpdateNote_result :: T.Protocol p => p -> P.IO UpdateNote_result
read_UpdateNote_result iprot = to_UpdateNote_result <$> T.readVal iprot (T.T_STRUCT typemap_UpdateNote_result)
decode_UpdateNote_result :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateNote_result
decode_UpdateNote_result iprot bs = to_UpdateNote_result $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateNote_result) bs
typemap_UpdateNote_result :: T.TypeMap
typemap_UpdateNote_result = Map.fromList [(0,("success",(T.T_STRUCT Types_Types.typemap_Note))),(1,("userException",(T.T_STRUCT Errors_Types.typemap_EDAMUserException))),(2,("systemException",(T.T_STRUCT Errors_Types.typemap_EDAMSystemException))),(3,("notFoundException",(T.T_STRUCT Errors_Types.typemap_EDAMNotFoundException)))]
default_UpdateNote_result :: UpdateNote_result
default_UpdateNote_result = UpdateNote_result{
  updateNote_result_success = Types_Types.default_Note,
  updateNote_result_userException = P.Nothing,
  updateNote_result_systemException = P.Nothing,
  updateNote_result_notFoundException = P.Nothing}
data DeleteNote_args = DeleteNote_args  { deleteNote_args_authenticationToken :: LT.Text
  , deleteNote_args_guid :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable DeleteNote_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` deleteNote_args_authenticationToken record   `H.hashWithSalt` deleteNote_args_guid record  
instance QC.Arbitrary DeleteNote_args where 
  arbitrary = M.liftM DeleteNote_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_DeleteNote_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_DeleteNote_args{deleteNote_args_authenticationToken = deleteNote_args_authenticationToken obj} then P.Nothing else P.Just $ default_DeleteNote_args{deleteNote_args_authenticationToken = deleteNote_args_authenticationToken obj}
    , if obj == default_DeleteNote_args{deleteNote_args_guid = deleteNote_args_guid obj} then P.Nothing else P.Just $ default_DeleteNote_args{deleteNote_args_guid = deleteNote_args_guid obj}
    ]
from_DeleteNote_args :: DeleteNote_args -> T.ThriftVal
from_DeleteNote_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1184 -> P.Just (1, ("authenticationToken",T.TString $ E.encodeUtf8 _v1184))) $ deleteNote_args_authenticationToken record
  , (\_v1184 -> P.Just (2, ("guid",T.TString $ E.encodeUtf8 _v1184))) $ deleteNote_args_guid record
  ]
write_DeleteNote_args :: T.Protocol p => p -> DeleteNote_args -> P.IO ()
write_DeleteNote_args oprot record = T.writeVal oprot $ from_DeleteNote_args record
encode_DeleteNote_args :: T.StatelessProtocol p => p -> DeleteNote_args -> LBS.ByteString
encode_DeleteNote_args oprot record = T.serializeVal oprot $ from_DeleteNote_args record
to_DeleteNote_args :: T.ThriftVal -> DeleteNote_args
to_DeleteNote_args (T.TStruct fields) = DeleteNote_args{
  deleteNote_args_authenticationToken = P.maybe (deleteNote_args_authenticationToken default_DeleteNote_args) (\(_,_val1186) -> (case _val1186 of {T.TString _val1187 -> E.decodeUtf8 _val1187; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  deleteNote_args_guid = P.maybe (deleteNote_args_guid default_DeleteNote_args) (\(_,_val1186) -> (case _val1186 of {T.TString _val1188 -> E.decodeUtf8 _val1188; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_DeleteNote_args _ = P.error "not a struct"
read_DeleteNote_args :: T.Protocol p => p -> P.IO DeleteNote_args
read_DeleteNote_args iprot = to_DeleteNote_args <$> T.readVal iprot (T.T_STRUCT typemap_DeleteNote_args)
decode_DeleteNote_args :: T.StatelessProtocol p => p -> LBS.ByteString -> DeleteNote_args
decode_DeleteNote_args iprot bs = to_DeleteNote_args $ T.deserializeVal iprot (T.T_STRUCT typemap_DeleteNote_args) bs
typemap_DeleteNote_args :: T.TypeMap
typemap_DeleteNote_args = Map.fromList [(1,("authenticationToken",T.T_STRING)),(2,("guid",T.T_STRING))]
default_DeleteNote_args :: DeleteNote_args
default_DeleteNote_args = DeleteNote_args{
  deleteNote_args_authenticationToken = "",
  deleteNote_args_guid = ""}
data DeleteNote_result = DeleteNote_result  { deleteNote_result_success :: I.Int32
  , deleteNote_result_userException :: P.Maybe Errors_Types.EDAMUserException
  , deleteNote_result_systemException :: P.Maybe Errors_Types.EDAMSystemException
  , deleteNote_result_notFoundException :: P.Maybe Errors_Types.EDAMNotFoundException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable DeleteNote_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` deleteNote_result_success record   `H.hashWithSalt` deleteNote_result_userException record   `H.hashWithSalt` deleteNote_result_systemException record   `H.hashWithSalt` deleteNote_result_notFoundException record  
instance QC.Arbitrary DeleteNote_result where 
  arbitrary = M.liftM DeleteNote_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_DeleteNote_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_DeleteNote_result{deleteNote_result_success = deleteNote_result_success obj} then P.Nothing else P.Just $ default_DeleteNote_result{deleteNote_result_success = deleteNote_result_success obj}
    , if obj == default_DeleteNote_result{deleteNote_result_userException = deleteNote_result_userException obj} then P.Nothing else P.Just $ default_DeleteNote_result{deleteNote_result_userException = deleteNote_result_userException obj}
    , if obj == default_DeleteNote_result{deleteNote_result_systemException = deleteNote_result_systemException obj} then P.Nothing else P.Just $ default_DeleteNote_result{deleteNote_result_systemException = deleteNote_result_systemException obj}
    , if obj == default_DeleteNote_result{deleteNote_result_notFoundException = deleteNote_result_notFoundException obj} then P.Nothing else P.Just $ default_DeleteNote_result{deleteNote_result_notFoundException = deleteNote_result_notFoundException obj}
    ]
from_DeleteNote_result :: DeleteNote_result -> T.ThriftVal
from_DeleteNote_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v1191 -> (1, ("userException",Errors_Types.from_EDAMUserException _v1191))) <$> deleteNote_result_userException record, (\_v1191 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v1191))) <$> deleteNote_result_systemException record, (\_v1191 -> (3, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v1191))) <$> deleteNote_result_notFoundException record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v1191 -> P.Just (0, ("success",T.TI32 _v1191))) $ deleteNote_result_success record
    , (\_v1191 -> (1, ("userException",Errors_Types.from_EDAMUserException _v1191))) <$> deleteNote_result_userException record
    , (\_v1191 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v1191))) <$> deleteNote_result_systemException record
    , (\_v1191 -> (3, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v1191))) <$> deleteNote_result_notFoundException record
    ]
    )
write_DeleteNote_result :: T.Protocol p => p -> DeleteNote_result -> P.IO ()
write_DeleteNote_result oprot record = T.writeVal oprot $ from_DeleteNote_result record
encode_DeleteNote_result :: T.StatelessProtocol p => p -> DeleteNote_result -> LBS.ByteString
encode_DeleteNote_result oprot record = T.serializeVal oprot $ from_DeleteNote_result record
to_DeleteNote_result :: T.ThriftVal -> DeleteNote_result
to_DeleteNote_result (T.TStruct fields) = DeleteNote_result{
  deleteNote_result_success = P.maybe (deleteNote_result_success default_DeleteNote_result) (\(_,_val1193) -> (case _val1193 of {T.TI32 _val1194 -> _val1194; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  deleteNote_result_userException = P.maybe (P.Nothing) (\(_,_val1193) -> P.Just (case _val1193 of {T.TStruct _val1195 -> (Errors_Types.to_EDAMUserException (T.TStruct _val1195)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  deleteNote_result_systemException = P.maybe (P.Nothing) (\(_,_val1193) -> P.Just (case _val1193 of {T.TStruct _val1196 -> (Errors_Types.to_EDAMSystemException (T.TStruct _val1196)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  deleteNote_result_notFoundException = P.maybe (P.Nothing) (\(_,_val1193) -> P.Just (case _val1193 of {T.TStruct _val1197 -> (Errors_Types.to_EDAMNotFoundException (T.TStruct _val1197)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_DeleteNote_result _ = P.error "not a struct"
read_DeleteNote_result :: T.Protocol p => p -> P.IO DeleteNote_result
read_DeleteNote_result iprot = to_DeleteNote_result <$> T.readVal iprot (T.T_STRUCT typemap_DeleteNote_result)
decode_DeleteNote_result :: T.StatelessProtocol p => p -> LBS.ByteString -> DeleteNote_result
decode_DeleteNote_result iprot bs = to_DeleteNote_result $ T.deserializeVal iprot (T.T_STRUCT typemap_DeleteNote_result) bs
typemap_DeleteNote_result :: T.TypeMap
typemap_DeleteNote_result = Map.fromList [(0,("success",T.T_I32)),(1,("userException",(T.T_STRUCT Errors_Types.typemap_EDAMUserException))),(2,("systemException",(T.T_STRUCT Errors_Types.typemap_EDAMSystemException))),(3,("notFoundException",(T.T_STRUCT Errors_Types.typemap_EDAMNotFoundException)))]
default_DeleteNote_result :: DeleteNote_result
default_DeleteNote_result = DeleteNote_result{
  deleteNote_result_success = 0,
  deleteNote_result_userException = P.Nothing,
  deleteNote_result_systemException = P.Nothing,
  deleteNote_result_notFoundException = P.Nothing}
data ExpungeNote_args = ExpungeNote_args  { expungeNote_args_authenticationToken :: LT.Text
  , expungeNote_args_guid :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ExpungeNote_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` expungeNote_args_authenticationToken record   `H.hashWithSalt` expungeNote_args_guid record  
instance QC.Arbitrary ExpungeNote_args where 
  arbitrary = M.liftM ExpungeNote_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_ExpungeNote_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ExpungeNote_args{expungeNote_args_authenticationToken = expungeNote_args_authenticationToken obj} then P.Nothing else P.Just $ default_ExpungeNote_args{expungeNote_args_authenticationToken = expungeNote_args_authenticationToken obj}
    , if obj == default_ExpungeNote_args{expungeNote_args_guid = expungeNote_args_guid obj} then P.Nothing else P.Just $ default_ExpungeNote_args{expungeNote_args_guid = expungeNote_args_guid obj}
    ]
from_ExpungeNote_args :: ExpungeNote_args -> T.ThriftVal
from_ExpungeNote_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1200 -> P.Just (1, ("authenticationToken",T.TString $ E.encodeUtf8 _v1200))) $ expungeNote_args_authenticationToken record
  , (\_v1200 -> P.Just (2, ("guid",T.TString $ E.encodeUtf8 _v1200))) $ expungeNote_args_guid record
  ]
write_ExpungeNote_args :: T.Protocol p => p -> ExpungeNote_args -> P.IO ()
write_ExpungeNote_args oprot record = T.writeVal oprot $ from_ExpungeNote_args record
encode_ExpungeNote_args :: T.StatelessProtocol p => p -> ExpungeNote_args -> LBS.ByteString
encode_ExpungeNote_args oprot record = T.serializeVal oprot $ from_ExpungeNote_args record
to_ExpungeNote_args :: T.ThriftVal -> ExpungeNote_args
to_ExpungeNote_args (T.TStruct fields) = ExpungeNote_args{
  expungeNote_args_authenticationToken = P.maybe (expungeNote_args_authenticationToken default_ExpungeNote_args) (\(_,_val1202) -> (case _val1202 of {T.TString _val1203 -> E.decodeUtf8 _val1203; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  expungeNote_args_guid = P.maybe (expungeNote_args_guid default_ExpungeNote_args) (\(_,_val1202) -> (case _val1202 of {T.TString _val1204 -> E.decodeUtf8 _val1204; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_ExpungeNote_args _ = P.error "not a struct"
read_ExpungeNote_args :: T.Protocol p => p -> P.IO ExpungeNote_args
read_ExpungeNote_args iprot = to_ExpungeNote_args <$> T.readVal iprot (T.T_STRUCT typemap_ExpungeNote_args)
decode_ExpungeNote_args :: T.StatelessProtocol p => p -> LBS.ByteString -> ExpungeNote_args
decode_ExpungeNote_args iprot bs = to_ExpungeNote_args $ T.deserializeVal iprot (T.T_STRUCT typemap_ExpungeNote_args) bs
typemap_ExpungeNote_args :: T.TypeMap
typemap_ExpungeNote_args = Map.fromList [(1,("authenticationToken",T.T_STRING)),(2,("guid",T.T_STRING))]
default_ExpungeNote_args :: ExpungeNote_args
default_ExpungeNote_args = ExpungeNote_args{
  expungeNote_args_authenticationToken = "",
  expungeNote_args_guid = ""}
data ExpungeNote_result = ExpungeNote_result  { expungeNote_result_success :: I.Int32
  , expungeNote_result_userException :: P.Maybe Errors_Types.EDAMUserException
  , expungeNote_result_systemException :: P.Maybe Errors_Types.EDAMSystemException
  , expungeNote_result_notFoundException :: P.Maybe Errors_Types.EDAMNotFoundException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ExpungeNote_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` expungeNote_result_success record   `H.hashWithSalt` expungeNote_result_userException record   `H.hashWithSalt` expungeNote_result_systemException record   `H.hashWithSalt` expungeNote_result_notFoundException record  
instance QC.Arbitrary ExpungeNote_result where 
  arbitrary = M.liftM ExpungeNote_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_ExpungeNote_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ExpungeNote_result{expungeNote_result_success = expungeNote_result_success obj} then P.Nothing else P.Just $ default_ExpungeNote_result{expungeNote_result_success = expungeNote_result_success obj}
    , if obj == default_ExpungeNote_result{expungeNote_result_userException = expungeNote_result_userException obj} then P.Nothing else P.Just $ default_ExpungeNote_result{expungeNote_result_userException = expungeNote_result_userException obj}
    , if obj == default_ExpungeNote_result{expungeNote_result_systemException = expungeNote_result_systemException obj} then P.Nothing else P.Just $ default_ExpungeNote_result{expungeNote_result_systemException = expungeNote_result_systemException obj}
    , if obj == default_ExpungeNote_result{expungeNote_result_notFoundException = expungeNote_result_notFoundException obj} then P.Nothing else P.Just $ default_ExpungeNote_result{expungeNote_result_notFoundException = expungeNote_result_notFoundException obj}
    ]
from_ExpungeNote_result :: ExpungeNote_result -> T.ThriftVal
from_ExpungeNote_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v1207 -> (1, ("userException",Errors_Types.from_EDAMUserException _v1207))) <$> expungeNote_result_userException record, (\_v1207 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v1207))) <$> expungeNote_result_systemException record, (\_v1207 -> (3, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v1207))) <$> expungeNote_result_notFoundException record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v1207 -> P.Just (0, ("success",T.TI32 _v1207))) $ expungeNote_result_success record
    , (\_v1207 -> (1, ("userException",Errors_Types.from_EDAMUserException _v1207))) <$> expungeNote_result_userException record
    , (\_v1207 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v1207))) <$> expungeNote_result_systemException record
    , (\_v1207 -> (3, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v1207))) <$> expungeNote_result_notFoundException record
    ]
    )
write_ExpungeNote_result :: T.Protocol p => p -> ExpungeNote_result -> P.IO ()
write_ExpungeNote_result oprot record = T.writeVal oprot $ from_ExpungeNote_result record
encode_ExpungeNote_result :: T.StatelessProtocol p => p -> ExpungeNote_result -> LBS.ByteString
encode_ExpungeNote_result oprot record = T.serializeVal oprot $ from_ExpungeNote_result record
to_ExpungeNote_result :: T.ThriftVal -> ExpungeNote_result
to_ExpungeNote_result (T.TStruct fields) = ExpungeNote_result{
  expungeNote_result_success = P.maybe (expungeNote_result_success default_ExpungeNote_result) (\(_,_val1209) -> (case _val1209 of {T.TI32 _val1210 -> _val1210; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  expungeNote_result_userException = P.maybe (P.Nothing) (\(_,_val1209) -> P.Just (case _val1209 of {T.TStruct _val1211 -> (Errors_Types.to_EDAMUserException (T.TStruct _val1211)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  expungeNote_result_systemException = P.maybe (P.Nothing) (\(_,_val1209) -> P.Just (case _val1209 of {T.TStruct _val1212 -> (Errors_Types.to_EDAMSystemException (T.TStruct _val1212)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  expungeNote_result_notFoundException = P.maybe (P.Nothing) (\(_,_val1209) -> P.Just (case _val1209 of {T.TStruct _val1213 -> (Errors_Types.to_EDAMNotFoundException (T.TStruct _val1213)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_ExpungeNote_result _ = P.error "not a struct"
read_ExpungeNote_result :: T.Protocol p => p -> P.IO ExpungeNote_result
read_ExpungeNote_result iprot = to_ExpungeNote_result <$> T.readVal iprot (T.T_STRUCT typemap_ExpungeNote_result)
decode_ExpungeNote_result :: T.StatelessProtocol p => p -> LBS.ByteString -> ExpungeNote_result
decode_ExpungeNote_result iprot bs = to_ExpungeNote_result $ T.deserializeVal iprot (T.T_STRUCT typemap_ExpungeNote_result) bs
typemap_ExpungeNote_result :: T.TypeMap
typemap_ExpungeNote_result = Map.fromList [(0,("success",T.T_I32)),(1,("userException",(T.T_STRUCT Errors_Types.typemap_EDAMUserException))),(2,("systemException",(T.T_STRUCT Errors_Types.typemap_EDAMSystemException))),(3,("notFoundException",(T.T_STRUCT Errors_Types.typemap_EDAMNotFoundException)))]
default_ExpungeNote_result :: ExpungeNote_result
default_ExpungeNote_result = ExpungeNote_result{
  expungeNote_result_success = 0,
  expungeNote_result_userException = P.Nothing,
  expungeNote_result_systemException = P.Nothing,
  expungeNote_result_notFoundException = P.Nothing}
data CopyNote_args = CopyNote_args  { copyNote_args_authenticationToken :: LT.Text
  , copyNote_args_noteGuid :: LT.Text
  , copyNote_args_toNotebookGuid :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable CopyNote_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` copyNote_args_authenticationToken record   `H.hashWithSalt` copyNote_args_noteGuid record   `H.hashWithSalt` copyNote_args_toNotebookGuid record  
instance QC.Arbitrary CopyNote_args where 
  arbitrary = M.liftM CopyNote_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_CopyNote_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_CopyNote_args{copyNote_args_authenticationToken = copyNote_args_authenticationToken obj} then P.Nothing else P.Just $ default_CopyNote_args{copyNote_args_authenticationToken = copyNote_args_authenticationToken obj}
    , if obj == default_CopyNote_args{copyNote_args_noteGuid = copyNote_args_noteGuid obj} then P.Nothing else P.Just $ default_CopyNote_args{copyNote_args_noteGuid = copyNote_args_noteGuid obj}
    , if obj == default_CopyNote_args{copyNote_args_toNotebookGuid = copyNote_args_toNotebookGuid obj} then P.Nothing else P.Just $ default_CopyNote_args{copyNote_args_toNotebookGuid = copyNote_args_toNotebookGuid obj}
    ]
from_CopyNote_args :: CopyNote_args -> T.ThriftVal
from_CopyNote_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1216 -> P.Just (1, ("authenticationToken",T.TString $ E.encodeUtf8 _v1216))) $ copyNote_args_authenticationToken record
  , (\_v1216 -> P.Just (2, ("noteGuid",T.TString $ E.encodeUtf8 _v1216))) $ copyNote_args_noteGuid record
  , (\_v1216 -> P.Just (3, ("toNotebookGuid",T.TString $ E.encodeUtf8 _v1216))) $ copyNote_args_toNotebookGuid record
  ]
write_CopyNote_args :: T.Protocol p => p -> CopyNote_args -> P.IO ()
write_CopyNote_args oprot record = T.writeVal oprot $ from_CopyNote_args record
encode_CopyNote_args :: T.StatelessProtocol p => p -> CopyNote_args -> LBS.ByteString
encode_CopyNote_args oprot record = T.serializeVal oprot $ from_CopyNote_args record
to_CopyNote_args :: T.ThriftVal -> CopyNote_args
to_CopyNote_args (T.TStruct fields) = CopyNote_args{
  copyNote_args_authenticationToken = P.maybe (copyNote_args_authenticationToken default_CopyNote_args) (\(_,_val1218) -> (case _val1218 of {T.TString _val1219 -> E.decodeUtf8 _val1219; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  copyNote_args_noteGuid = P.maybe (copyNote_args_noteGuid default_CopyNote_args) (\(_,_val1218) -> (case _val1218 of {T.TString _val1220 -> E.decodeUtf8 _val1220; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  copyNote_args_toNotebookGuid = P.maybe (copyNote_args_toNotebookGuid default_CopyNote_args) (\(_,_val1218) -> (case _val1218 of {T.TString _val1221 -> E.decodeUtf8 _val1221; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_CopyNote_args _ = P.error "not a struct"
read_CopyNote_args :: T.Protocol p => p -> P.IO CopyNote_args
read_CopyNote_args iprot = to_CopyNote_args <$> T.readVal iprot (T.T_STRUCT typemap_CopyNote_args)
decode_CopyNote_args :: T.StatelessProtocol p => p -> LBS.ByteString -> CopyNote_args
decode_CopyNote_args iprot bs = to_CopyNote_args $ T.deserializeVal iprot (T.T_STRUCT typemap_CopyNote_args) bs
typemap_CopyNote_args :: T.TypeMap
typemap_CopyNote_args = Map.fromList [(1,("authenticationToken",T.T_STRING)),(2,("noteGuid",T.T_STRING)),(3,("toNotebookGuid",T.T_STRING))]
default_CopyNote_args :: CopyNote_args
default_CopyNote_args = CopyNote_args{
  copyNote_args_authenticationToken = "",
  copyNote_args_noteGuid = "",
  copyNote_args_toNotebookGuid = ""}
data CopyNote_result = CopyNote_result  { copyNote_result_success :: Types_Types.Note
  , copyNote_result_userException :: P.Maybe Errors_Types.EDAMUserException
  , copyNote_result_systemException :: P.Maybe Errors_Types.EDAMSystemException
  , copyNote_result_notFoundException :: P.Maybe Errors_Types.EDAMNotFoundException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable CopyNote_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` copyNote_result_success record   `H.hashWithSalt` copyNote_result_userException record   `H.hashWithSalt` copyNote_result_systemException record   `H.hashWithSalt` copyNote_result_notFoundException record  
instance QC.Arbitrary CopyNote_result where 
  arbitrary = M.liftM CopyNote_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_CopyNote_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_CopyNote_result{copyNote_result_success = copyNote_result_success obj} then P.Nothing else P.Just $ default_CopyNote_result{copyNote_result_success = copyNote_result_success obj}
    , if obj == default_CopyNote_result{copyNote_result_userException = copyNote_result_userException obj} then P.Nothing else P.Just $ default_CopyNote_result{copyNote_result_userException = copyNote_result_userException obj}
    , if obj == default_CopyNote_result{copyNote_result_systemException = copyNote_result_systemException obj} then P.Nothing else P.Just $ default_CopyNote_result{copyNote_result_systemException = copyNote_result_systemException obj}
    , if obj == default_CopyNote_result{copyNote_result_notFoundException = copyNote_result_notFoundException obj} then P.Nothing else P.Just $ default_CopyNote_result{copyNote_result_notFoundException = copyNote_result_notFoundException obj}
    ]
from_CopyNote_result :: CopyNote_result -> T.ThriftVal
from_CopyNote_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v1224 -> (1, ("userException",Errors_Types.from_EDAMUserException _v1224))) <$> copyNote_result_userException record, (\_v1224 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v1224))) <$> copyNote_result_systemException record, (\_v1224 -> (3, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v1224))) <$> copyNote_result_notFoundException record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v1224 -> P.Just (0, ("success",Types_Types.from_Note _v1224))) $ copyNote_result_success record
    , (\_v1224 -> (1, ("userException",Errors_Types.from_EDAMUserException _v1224))) <$> copyNote_result_userException record
    , (\_v1224 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v1224))) <$> copyNote_result_systemException record
    , (\_v1224 -> (3, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v1224))) <$> copyNote_result_notFoundException record
    ]
    )
write_CopyNote_result :: T.Protocol p => p -> CopyNote_result -> P.IO ()
write_CopyNote_result oprot record = T.writeVal oprot $ from_CopyNote_result record
encode_CopyNote_result :: T.StatelessProtocol p => p -> CopyNote_result -> LBS.ByteString
encode_CopyNote_result oprot record = T.serializeVal oprot $ from_CopyNote_result record
to_CopyNote_result :: T.ThriftVal -> CopyNote_result
to_CopyNote_result (T.TStruct fields) = CopyNote_result{
  copyNote_result_success = P.maybe (copyNote_result_success default_CopyNote_result) (\(_,_val1226) -> (case _val1226 of {T.TStruct _val1227 -> (Types_Types.to_Note (T.TStruct _val1227)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  copyNote_result_userException = P.maybe (P.Nothing) (\(_,_val1226) -> P.Just (case _val1226 of {T.TStruct _val1228 -> (Errors_Types.to_EDAMUserException (T.TStruct _val1228)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  copyNote_result_systemException = P.maybe (P.Nothing) (\(_,_val1226) -> P.Just (case _val1226 of {T.TStruct _val1229 -> (Errors_Types.to_EDAMSystemException (T.TStruct _val1229)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  copyNote_result_notFoundException = P.maybe (P.Nothing) (\(_,_val1226) -> P.Just (case _val1226 of {T.TStruct _val1230 -> (Errors_Types.to_EDAMNotFoundException (T.TStruct _val1230)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_CopyNote_result _ = P.error "not a struct"
read_CopyNote_result :: T.Protocol p => p -> P.IO CopyNote_result
read_CopyNote_result iprot = to_CopyNote_result <$> T.readVal iprot (T.T_STRUCT typemap_CopyNote_result)
decode_CopyNote_result :: T.StatelessProtocol p => p -> LBS.ByteString -> CopyNote_result
decode_CopyNote_result iprot bs = to_CopyNote_result $ T.deserializeVal iprot (T.T_STRUCT typemap_CopyNote_result) bs
typemap_CopyNote_result :: T.TypeMap
typemap_CopyNote_result = Map.fromList [(0,("success",(T.T_STRUCT Types_Types.typemap_Note))),(1,("userException",(T.T_STRUCT Errors_Types.typemap_EDAMUserException))),(2,("systemException",(T.T_STRUCT Errors_Types.typemap_EDAMSystemException))),(3,("notFoundException",(T.T_STRUCT Errors_Types.typemap_EDAMNotFoundException)))]
default_CopyNote_result :: CopyNote_result
default_CopyNote_result = CopyNote_result{
  copyNote_result_success = Types_Types.default_Note,
  copyNote_result_userException = P.Nothing,
  copyNote_result_systemException = P.Nothing,
  copyNote_result_notFoundException = P.Nothing}
data ListNoteVersions_args = ListNoteVersions_args  { listNoteVersions_args_authenticationToken :: LT.Text
  , listNoteVersions_args_noteGuid :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ListNoteVersions_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` listNoteVersions_args_authenticationToken record   `H.hashWithSalt` listNoteVersions_args_noteGuid record  
instance QC.Arbitrary ListNoteVersions_args where 
  arbitrary = M.liftM ListNoteVersions_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_ListNoteVersions_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ListNoteVersions_args{listNoteVersions_args_authenticationToken = listNoteVersions_args_authenticationToken obj} then P.Nothing else P.Just $ default_ListNoteVersions_args{listNoteVersions_args_authenticationToken = listNoteVersions_args_authenticationToken obj}
    , if obj == default_ListNoteVersions_args{listNoteVersions_args_noteGuid = listNoteVersions_args_noteGuid obj} then P.Nothing else P.Just $ default_ListNoteVersions_args{listNoteVersions_args_noteGuid = listNoteVersions_args_noteGuid obj}
    ]
from_ListNoteVersions_args :: ListNoteVersions_args -> T.ThriftVal
from_ListNoteVersions_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1233 -> P.Just (1, ("authenticationToken",T.TString $ E.encodeUtf8 _v1233))) $ listNoteVersions_args_authenticationToken record
  , (\_v1233 -> P.Just (2, ("noteGuid",T.TString $ E.encodeUtf8 _v1233))) $ listNoteVersions_args_noteGuid record
  ]
write_ListNoteVersions_args :: T.Protocol p => p -> ListNoteVersions_args -> P.IO ()
write_ListNoteVersions_args oprot record = T.writeVal oprot $ from_ListNoteVersions_args record
encode_ListNoteVersions_args :: T.StatelessProtocol p => p -> ListNoteVersions_args -> LBS.ByteString
encode_ListNoteVersions_args oprot record = T.serializeVal oprot $ from_ListNoteVersions_args record
to_ListNoteVersions_args :: T.ThriftVal -> ListNoteVersions_args
to_ListNoteVersions_args (T.TStruct fields) = ListNoteVersions_args{
  listNoteVersions_args_authenticationToken = P.maybe (listNoteVersions_args_authenticationToken default_ListNoteVersions_args) (\(_,_val1235) -> (case _val1235 of {T.TString _val1236 -> E.decodeUtf8 _val1236; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  listNoteVersions_args_noteGuid = P.maybe (listNoteVersions_args_noteGuid default_ListNoteVersions_args) (\(_,_val1235) -> (case _val1235 of {T.TString _val1237 -> E.decodeUtf8 _val1237; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_ListNoteVersions_args _ = P.error "not a struct"
read_ListNoteVersions_args :: T.Protocol p => p -> P.IO ListNoteVersions_args
read_ListNoteVersions_args iprot = to_ListNoteVersions_args <$> T.readVal iprot (T.T_STRUCT typemap_ListNoteVersions_args)
decode_ListNoteVersions_args :: T.StatelessProtocol p => p -> LBS.ByteString -> ListNoteVersions_args
decode_ListNoteVersions_args iprot bs = to_ListNoteVersions_args $ T.deserializeVal iprot (T.T_STRUCT typemap_ListNoteVersions_args) bs
typemap_ListNoteVersions_args :: T.TypeMap
typemap_ListNoteVersions_args = Map.fromList [(1,("authenticationToken",T.T_STRING)),(2,("noteGuid",T.T_STRING))]
default_ListNoteVersions_args :: ListNoteVersions_args
default_ListNoteVersions_args = ListNoteVersions_args{
  listNoteVersions_args_authenticationToken = "",
  listNoteVersions_args_noteGuid = ""}
data ListNoteVersions_result = ListNoteVersions_result  { listNoteVersions_result_success :: (Vector.Vector NoteVersionId)
  , listNoteVersions_result_userException :: P.Maybe Errors_Types.EDAMUserException
  , listNoteVersions_result_systemException :: P.Maybe Errors_Types.EDAMSystemException
  , listNoteVersions_result_notFoundException :: P.Maybe Errors_Types.EDAMNotFoundException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ListNoteVersions_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` listNoteVersions_result_success record   `H.hashWithSalt` listNoteVersions_result_userException record   `H.hashWithSalt` listNoteVersions_result_systemException record   `H.hashWithSalt` listNoteVersions_result_notFoundException record  
instance QC.Arbitrary ListNoteVersions_result where 
  arbitrary = M.liftM ListNoteVersions_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_ListNoteVersions_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ListNoteVersions_result{listNoteVersions_result_success = listNoteVersions_result_success obj} then P.Nothing else P.Just $ default_ListNoteVersions_result{listNoteVersions_result_success = listNoteVersions_result_success obj}
    , if obj == default_ListNoteVersions_result{listNoteVersions_result_userException = listNoteVersions_result_userException obj} then P.Nothing else P.Just $ default_ListNoteVersions_result{listNoteVersions_result_userException = listNoteVersions_result_userException obj}
    , if obj == default_ListNoteVersions_result{listNoteVersions_result_systemException = listNoteVersions_result_systemException obj} then P.Nothing else P.Just $ default_ListNoteVersions_result{listNoteVersions_result_systemException = listNoteVersions_result_systemException obj}
    , if obj == default_ListNoteVersions_result{listNoteVersions_result_notFoundException = listNoteVersions_result_notFoundException obj} then P.Nothing else P.Just $ default_ListNoteVersions_result{listNoteVersions_result_notFoundException = listNoteVersions_result_notFoundException obj}
    ]
from_ListNoteVersions_result :: ListNoteVersions_result -> T.ThriftVal
from_ListNoteVersions_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v1240 -> (1, ("userException",Errors_Types.from_EDAMUserException _v1240))) <$> listNoteVersions_result_userException record, (\_v1240 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v1240))) <$> listNoteVersions_result_systemException record, (\_v1240 -> (3, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v1240))) <$> listNoteVersions_result_notFoundException record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v1240 -> P.Just (0, ("success",T.TList (T.T_STRUCT typemap_NoteVersionId) $ P.map (\_v1242 -> from_NoteVersionId _v1242) $ Vector.toList _v1240))) $ listNoteVersions_result_success record
    , (\_v1240 -> (1, ("userException",Errors_Types.from_EDAMUserException _v1240))) <$> listNoteVersions_result_userException record
    , (\_v1240 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v1240))) <$> listNoteVersions_result_systemException record
    , (\_v1240 -> (3, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v1240))) <$> listNoteVersions_result_notFoundException record
    ]
    )
write_ListNoteVersions_result :: T.Protocol p => p -> ListNoteVersions_result -> P.IO ()
write_ListNoteVersions_result oprot record = T.writeVal oprot $ from_ListNoteVersions_result record
encode_ListNoteVersions_result :: T.StatelessProtocol p => p -> ListNoteVersions_result -> LBS.ByteString
encode_ListNoteVersions_result oprot record = T.serializeVal oprot $ from_ListNoteVersions_result record
to_ListNoteVersions_result :: T.ThriftVal -> ListNoteVersions_result
to_ListNoteVersions_result (T.TStruct fields) = ListNoteVersions_result{
  listNoteVersions_result_success = P.maybe (listNoteVersions_result_success default_ListNoteVersions_result) (\(_,_val1244) -> (case _val1244 of {T.TList _ _val1245 -> (Vector.fromList $ P.map (\_v1246 -> (case _v1246 of {T.TStruct _val1247 -> (to_NoteVersionId (T.TStruct _val1247)); _ -> P.error "wrong type"})) _val1245); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  listNoteVersions_result_userException = P.maybe (P.Nothing) (\(_,_val1244) -> P.Just (case _val1244 of {T.TStruct _val1248 -> (Errors_Types.to_EDAMUserException (T.TStruct _val1248)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  listNoteVersions_result_systemException = P.maybe (P.Nothing) (\(_,_val1244) -> P.Just (case _val1244 of {T.TStruct _val1249 -> (Errors_Types.to_EDAMSystemException (T.TStruct _val1249)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  listNoteVersions_result_notFoundException = P.maybe (P.Nothing) (\(_,_val1244) -> P.Just (case _val1244 of {T.TStruct _val1250 -> (Errors_Types.to_EDAMNotFoundException (T.TStruct _val1250)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_ListNoteVersions_result _ = P.error "not a struct"
read_ListNoteVersions_result :: T.Protocol p => p -> P.IO ListNoteVersions_result
read_ListNoteVersions_result iprot = to_ListNoteVersions_result <$> T.readVal iprot (T.T_STRUCT typemap_ListNoteVersions_result)
decode_ListNoteVersions_result :: T.StatelessProtocol p => p -> LBS.ByteString -> ListNoteVersions_result
decode_ListNoteVersions_result iprot bs = to_ListNoteVersions_result $ T.deserializeVal iprot (T.T_STRUCT typemap_ListNoteVersions_result) bs
typemap_ListNoteVersions_result :: T.TypeMap
typemap_ListNoteVersions_result = Map.fromList [(0,("success",(T.T_LIST (T.T_STRUCT typemap_NoteVersionId)))),(1,("userException",(T.T_STRUCT Errors_Types.typemap_EDAMUserException))),(2,("systemException",(T.T_STRUCT Errors_Types.typemap_EDAMSystemException))),(3,("notFoundException",(T.T_STRUCT Errors_Types.typemap_EDAMNotFoundException)))]
default_ListNoteVersions_result :: ListNoteVersions_result
default_ListNoteVersions_result = ListNoteVersions_result{
  listNoteVersions_result_success = Vector.empty,
  listNoteVersions_result_userException = P.Nothing,
  listNoteVersions_result_systemException = P.Nothing,
  listNoteVersions_result_notFoundException = P.Nothing}
data GetNoteVersion_args = GetNoteVersion_args  { getNoteVersion_args_authenticationToken :: LT.Text
  , getNoteVersion_args_noteGuid :: LT.Text
  , getNoteVersion_args_updateSequenceNum :: I.Int32
  , getNoteVersion_args_withResourcesData :: P.Bool
  , getNoteVersion_args_withResourcesRecognition :: P.Bool
  , getNoteVersion_args_withResourcesAlternateData :: P.Bool
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetNoteVersion_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getNoteVersion_args_authenticationToken record   `H.hashWithSalt` getNoteVersion_args_noteGuid record   `H.hashWithSalt` getNoteVersion_args_updateSequenceNum record   `H.hashWithSalt` getNoteVersion_args_withResourcesData record   `H.hashWithSalt` getNoteVersion_args_withResourcesRecognition record   `H.hashWithSalt` getNoteVersion_args_withResourcesAlternateData record  
instance QC.Arbitrary GetNoteVersion_args where 
  arbitrary = M.liftM GetNoteVersion_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GetNoteVersion_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetNoteVersion_args{getNoteVersion_args_authenticationToken = getNoteVersion_args_authenticationToken obj} then P.Nothing else P.Just $ default_GetNoteVersion_args{getNoteVersion_args_authenticationToken = getNoteVersion_args_authenticationToken obj}
    , if obj == default_GetNoteVersion_args{getNoteVersion_args_noteGuid = getNoteVersion_args_noteGuid obj} then P.Nothing else P.Just $ default_GetNoteVersion_args{getNoteVersion_args_noteGuid = getNoteVersion_args_noteGuid obj}
    , if obj == default_GetNoteVersion_args{getNoteVersion_args_updateSequenceNum = getNoteVersion_args_updateSequenceNum obj} then P.Nothing else P.Just $ default_GetNoteVersion_args{getNoteVersion_args_updateSequenceNum = getNoteVersion_args_updateSequenceNum obj}
    , if obj == default_GetNoteVersion_args{getNoteVersion_args_withResourcesData = getNoteVersion_args_withResourcesData obj} then P.Nothing else P.Just $ default_GetNoteVersion_args{getNoteVersion_args_withResourcesData = getNoteVersion_args_withResourcesData obj}
    , if obj == default_GetNoteVersion_args{getNoteVersion_args_withResourcesRecognition = getNoteVersion_args_withResourcesRecognition obj} then P.Nothing else P.Just $ default_GetNoteVersion_args{getNoteVersion_args_withResourcesRecognition = getNoteVersion_args_withResourcesRecognition obj}
    , if obj == default_GetNoteVersion_args{getNoteVersion_args_withResourcesAlternateData = getNoteVersion_args_withResourcesAlternateData obj} then P.Nothing else P.Just $ default_GetNoteVersion_args{getNoteVersion_args_withResourcesAlternateData = getNoteVersion_args_withResourcesAlternateData obj}
    ]
from_GetNoteVersion_args :: GetNoteVersion_args -> T.ThriftVal
from_GetNoteVersion_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1253 -> P.Just (1, ("authenticationToken",T.TString $ E.encodeUtf8 _v1253))) $ getNoteVersion_args_authenticationToken record
  , (\_v1253 -> P.Just (2, ("noteGuid",T.TString $ E.encodeUtf8 _v1253))) $ getNoteVersion_args_noteGuid record
  , (\_v1253 -> P.Just (3, ("updateSequenceNum",T.TI32 _v1253))) $ getNoteVersion_args_updateSequenceNum record
  , (\_v1253 -> P.Just (4, ("withResourcesData",T.TBool _v1253))) $ getNoteVersion_args_withResourcesData record
  , (\_v1253 -> P.Just (5, ("withResourcesRecognition",T.TBool _v1253))) $ getNoteVersion_args_withResourcesRecognition record
  , (\_v1253 -> P.Just (6, ("withResourcesAlternateData",T.TBool _v1253))) $ getNoteVersion_args_withResourcesAlternateData record
  ]
write_GetNoteVersion_args :: T.Protocol p => p -> GetNoteVersion_args -> P.IO ()
write_GetNoteVersion_args oprot record = T.writeVal oprot $ from_GetNoteVersion_args record
encode_GetNoteVersion_args :: T.StatelessProtocol p => p -> GetNoteVersion_args -> LBS.ByteString
encode_GetNoteVersion_args oprot record = T.serializeVal oprot $ from_GetNoteVersion_args record
to_GetNoteVersion_args :: T.ThriftVal -> GetNoteVersion_args
to_GetNoteVersion_args (T.TStruct fields) = GetNoteVersion_args{
  getNoteVersion_args_authenticationToken = P.maybe (getNoteVersion_args_authenticationToken default_GetNoteVersion_args) (\(_,_val1255) -> (case _val1255 of {T.TString _val1256 -> E.decodeUtf8 _val1256; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  getNoteVersion_args_noteGuid = P.maybe (getNoteVersion_args_noteGuid default_GetNoteVersion_args) (\(_,_val1255) -> (case _val1255 of {T.TString _val1257 -> E.decodeUtf8 _val1257; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  getNoteVersion_args_updateSequenceNum = P.maybe (getNoteVersion_args_updateSequenceNum default_GetNoteVersion_args) (\(_,_val1255) -> (case _val1255 of {T.TI32 _val1258 -> _val1258; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  getNoteVersion_args_withResourcesData = P.maybe (getNoteVersion_args_withResourcesData default_GetNoteVersion_args) (\(_,_val1255) -> (case _val1255 of {T.TBool _val1259 -> _val1259; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  getNoteVersion_args_withResourcesRecognition = P.maybe (getNoteVersion_args_withResourcesRecognition default_GetNoteVersion_args) (\(_,_val1255) -> (case _val1255 of {T.TBool _val1260 -> _val1260; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  getNoteVersion_args_withResourcesAlternateData = P.maybe (getNoteVersion_args_withResourcesAlternateData default_GetNoteVersion_args) (\(_,_val1255) -> (case _val1255 of {T.TBool _val1261 -> _val1261; _ -> P.error "wrong type"})) (Map.lookup (6) fields)
  }
to_GetNoteVersion_args _ = P.error "not a struct"
read_GetNoteVersion_args :: T.Protocol p => p -> P.IO GetNoteVersion_args
read_GetNoteVersion_args iprot = to_GetNoteVersion_args <$> T.readVal iprot (T.T_STRUCT typemap_GetNoteVersion_args)
decode_GetNoteVersion_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetNoteVersion_args
decode_GetNoteVersion_args iprot bs = to_GetNoteVersion_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetNoteVersion_args) bs
typemap_GetNoteVersion_args :: T.TypeMap
typemap_GetNoteVersion_args = Map.fromList [(1,("authenticationToken",T.T_STRING)),(2,("noteGuid",T.T_STRING)),(3,("updateSequenceNum",T.T_I32)),(4,("withResourcesData",T.T_BOOL)),(5,("withResourcesRecognition",T.T_BOOL)),(6,("withResourcesAlternateData",T.T_BOOL))]
default_GetNoteVersion_args :: GetNoteVersion_args
default_GetNoteVersion_args = GetNoteVersion_args{
  getNoteVersion_args_authenticationToken = "",
  getNoteVersion_args_noteGuid = "",
  getNoteVersion_args_updateSequenceNum = 0,
  getNoteVersion_args_withResourcesData = P.False,
  getNoteVersion_args_withResourcesRecognition = P.False,
  getNoteVersion_args_withResourcesAlternateData = P.False}
data GetNoteVersion_result = GetNoteVersion_result  { getNoteVersion_result_success :: Types_Types.Note
  , getNoteVersion_result_userException :: P.Maybe Errors_Types.EDAMUserException
  , getNoteVersion_result_systemException :: P.Maybe Errors_Types.EDAMSystemException
  , getNoteVersion_result_notFoundException :: P.Maybe Errors_Types.EDAMNotFoundException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetNoteVersion_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getNoteVersion_result_success record   `H.hashWithSalt` getNoteVersion_result_userException record   `H.hashWithSalt` getNoteVersion_result_systemException record   `H.hashWithSalt` getNoteVersion_result_notFoundException record  
instance QC.Arbitrary GetNoteVersion_result where 
  arbitrary = M.liftM GetNoteVersion_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetNoteVersion_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetNoteVersion_result{getNoteVersion_result_success = getNoteVersion_result_success obj} then P.Nothing else P.Just $ default_GetNoteVersion_result{getNoteVersion_result_success = getNoteVersion_result_success obj}
    , if obj == default_GetNoteVersion_result{getNoteVersion_result_userException = getNoteVersion_result_userException obj} then P.Nothing else P.Just $ default_GetNoteVersion_result{getNoteVersion_result_userException = getNoteVersion_result_userException obj}
    , if obj == default_GetNoteVersion_result{getNoteVersion_result_systemException = getNoteVersion_result_systemException obj} then P.Nothing else P.Just $ default_GetNoteVersion_result{getNoteVersion_result_systemException = getNoteVersion_result_systemException obj}
    , if obj == default_GetNoteVersion_result{getNoteVersion_result_notFoundException = getNoteVersion_result_notFoundException obj} then P.Nothing else P.Just $ default_GetNoteVersion_result{getNoteVersion_result_notFoundException = getNoteVersion_result_notFoundException obj}
    ]
from_GetNoteVersion_result :: GetNoteVersion_result -> T.ThriftVal
from_GetNoteVersion_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v1264 -> (1, ("userException",Errors_Types.from_EDAMUserException _v1264))) <$> getNoteVersion_result_userException record, (\_v1264 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v1264))) <$> getNoteVersion_result_systemException record, (\_v1264 -> (3, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v1264))) <$> getNoteVersion_result_notFoundException record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v1264 -> P.Just (0, ("success",Types_Types.from_Note _v1264))) $ getNoteVersion_result_success record
    , (\_v1264 -> (1, ("userException",Errors_Types.from_EDAMUserException _v1264))) <$> getNoteVersion_result_userException record
    , (\_v1264 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v1264))) <$> getNoteVersion_result_systemException record
    , (\_v1264 -> (3, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v1264))) <$> getNoteVersion_result_notFoundException record
    ]
    )
write_GetNoteVersion_result :: T.Protocol p => p -> GetNoteVersion_result -> P.IO ()
write_GetNoteVersion_result oprot record = T.writeVal oprot $ from_GetNoteVersion_result record
encode_GetNoteVersion_result :: T.StatelessProtocol p => p -> GetNoteVersion_result -> LBS.ByteString
encode_GetNoteVersion_result oprot record = T.serializeVal oprot $ from_GetNoteVersion_result record
to_GetNoteVersion_result :: T.ThriftVal -> GetNoteVersion_result
to_GetNoteVersion_result (T.TStruct fields) = GetNoteVersion_result{
  getNoteVersion_result_success = P.maybe (getNoteVersion_result_success default_GetNoteVersion_result) (\(_,_val1266) -> (case _val1266 of {T.TStruct _val1267 -> (Types_Types.to_Note (T.TStruct _val1267)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getNoteVersion_result_userException = P.maybe (P.Nothing) (\(_,_val1266) -> P.Just (case _val1266 of {T.TStruct _val1268 -> (Errors_Types.to_EDAMUserException (T.TStruct _val1268)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  getNoteVersion_result_systemException = P.maybe (P.Nothing) (\(_,_val1266) -> P.Just (case _val1266 of {T.TStruct _val1269 -> (Errors_Types.to_EDAMSystemException (T.TStruct _val1269)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  getNoteVersion_result_notFoundException = P.maybe (P.Nothing) (\(_,_val1266) -> P.Just (case _val1266 of {T.TStruct _val1270 -> (Errors_Types.to_EDAMNotFoundException (T.TStruct _val1270)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_GetNoteVersion_result _ = P.error "not a struct"
read_GetNoteVersion_result :: T.Protocol p => p -> P.IO GetNoteVersion_result
read_GetNoteVersion_result iprot = to_GetNoteVersion_result <$> T.readVal iprot (T.T_STRUCT typemap_GetNoteVersion_result)
decode_GetNoteVersion_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetNoteVersion_result
decode_GetNoteVersion_result iprot bs = to_GetNoteVersion_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetNoteVersion_result) bs
typemap_GetNoteVersion_result :: T.TypeMap
typemap_GetNoteVersion_result = Map.fromList [(0,("success",(T.T_STRUCT Types_Types.typemap_Note))),(1,("userException",(T.T_STRUCT Errors_Types.typemap_EDAMUserException))),(2,("systemException",(T.T_STRUCT Errors_Types.typemap_EDAMSystemException))),(3,("notFoundException",(T.T_STRUCT Errors_Types.typemap_EDAMNotFoundException)))]
default_GetNoteVersion_result :: GetNoteVersion_result
default_GetNoteVersion_result = GetNoteVersion_result{
  getNoteVersion_result_success = Types_Types.default_Note,
  getNoteVersion_result_userException = P.Nothing,
  getNoteVersion_result_systemException = P.Nothing,
  getNoteVersion_result_notFoundException = P.Nothing}
data GetResource_args = GetResource_args  { getResource_args_authenticationToken :: LT.Text
  , getResource_args_guid :: LT.Text
  , getResource_args_withData :: P.Bool
  , getResource_args_withRecognition :: P.Bool
  , getResource_args_withAttributes :: P.Bool
  , getResource_args_withAlternateData :: P.Bool
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetResource_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getResource_args_authenticationToken record   `H.hashWithSalt` getResource_args_guid record   `H.hashWithSalt` getResource_args_withData record   `H.hashWithSalt` getResource_args_withRecognition record   `H.hashWithSalt` getResource_args_withAttributes record   `H.hashWithSalt` getResource_args_withAlternateData record  
instance QC.Arbitrary GetResource_args where 
  arbitrary = M.liftM GetResource_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GetResource_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetResource_args{getResource_args_authenticationToken = getResource_args_authenticationToken obj} then P.Nothing else P.Just $ default_GetResource_args{getResource_args_authenticationToken = getResource_args_authenticationToken obj}
    , if obj == default_GetResource_args{getResource_args_guid = getResource_args_guid obj} then P.Nothing else P.Just $ default_GetResource_args{getResource_args_guid = getResource_args_guid obj}
    , if obj == default_GetResource_args{getResource_args_withData = getResource_args_withData obj} then P.Nothing else P.Just $ default_GetResource_args{getResource_args_withData = getResource_args_withData obj}
    , if obj == default_GetResource_args{getResource_args_withRecognition = getResource_args_withRecognition obj} then P.Nothing else P.Just $ default_GetResource_args{getResource_args_withRecognition = getResource_args_withRecognition obj}
    , if obj == default_GetResource_args{getResource_args_withAttributes = getResource_args_withAttributes obj} then P.Nothing else P.Just $ default_GetResource_args{getResource_args_withAttributes = getResource_args_withAttributes obj}
    , if obj == default_GetResource_args{getResource_args_withAlternateData = getResource_args_withAlternateData obj} then P.Nothing else P.Just $ default_GetResource_args{getResource_args_withAlternateData = getResource_args_withAlternateData obj}
    ]
from_GetResource_args :: GetResource_args -> T.ThriftVal
from_GetResource_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1273 -> P.Just (1, ("authenticationToken",T.TString $ E.encodeUtf8 _v1273))) $ getResource_args_authenticationToken record
  , (\_v1273 -> P.Just (2, ("guid",T.TString $ E.encodeUtf8 _v1273))) $ getResource_args_guid record
  , (\_v1273 -> P.Just (3, ("withData",T.TBool _v1273))) $ getResource_args_withData record
  , (\_v1273 -> P.Just (4, ("withRecognition",T.TBool _v1273))) $ getResource_args_withRecognition record
  , (\_v1273 -> P.Just (5, ("withAttributes",T.TBool _v1273))) $ getResource_args_withAttributes record
  , (\_v1273 -> P.Just (6, ("withAlternateData",T.TBool _v1273))) $ getResource_args_withAlternateData record
  ]
write_GetResource_args :: T.Protocol p => p -> GetResource_args -> P.IO ()
write_GetResource_args oprot record = T.writeVal oprot $ from_GetResource_args record
encode_GetResource_args :: T.StatelessProtocol p => p -> GetResource_args -> LBS.ByteString
encode_GetResource_args oprot record = T.serializeVal oprot $ from_GetResource_args record
to_GetResource_args :: T.ThriftVal -> GetResource_args
to_GetResource_args (T.TStruct fields) = GetResource_args{
  getResource_args_authenticationToken = P.maybe (getResource_args_authenticationToken default_GetResource_args) (\(_,_val1275) -> (case _val1275 of {T.TString _val1276 -> E.decodeUtf8 _val1276; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  getResource_args_guid = P.maybe (getResource_args_guid default_GetResource_args) (\(_,_val1275) -> (case _val1275 of {T.TString _val1277 -> E.decodeUtf8 _val1277; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  getResource_args_withData = P.maybe (getResource_args_withData default_GetResource_args) (\(_,_val1275) -> (case _val1275 of {T.TBool _val1278 -> _val1278; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  getResource_args_withRecognition = P.maybe (getResource_args_withRecognition default_GetResource_args) (\(_,_val1275) -> (case _val1275 of {T.TBool _val1279 -> _val1279; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  getResource_args_withAttributes = P.maybe (getResource_args_withAttributes default_GetResource_args) (\(_,_val1275) -> (case _val1275 of {T.TBool _val1280 -> _val1280; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  getResource_args_withAlternateData = P.maybe (getResource_args_withAlternateData default_GetResource_args) (\(_,_val1275) -> (case _val1275 of {T.TBool _val1281 -> _val1281; _ -> P.error "wrong type"})) (Map.lookup (6) fields)
  }
to_GetResource_args _ = P.error "not a struct"
read_GetResource_args :: T.Protocol p => p -> P.IO GetResource_args
read_GetResource_args iprot = to_GetResource_args <$> T.readVal iprot (T.T_STRUCT typemap_GetResource_args)
decode_GetResource_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetResource_args
decode_GetResource_args iprot bs = to_GetResource_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetResource_args) bs
typemap_GetResource_args :: T.TypeMap
typemap_GetResource_args = Map.fromList [(1,("authenticationToken",T.T_STRING)),(2,("guid",T.T_STRING)),(3,("withData",T.T_BOOL)),(4,("withRecognition",T.T_BOOL)),(5,("withAttributes",T.T_BOOL)),(6,("withAlternateData",T.T_BOOL))]
default_GetResource_args :: GetResource_args
default_GetResource_args = GetResource_args{
  getResource_args_authenticationToken = "",
  getResource_args_guid = "",
  getResource_args_withData = P.False,
  getResource_args_withRecognition = P.False,
  getResource_args_withAttributes = P.False,
  getResource_args_withAlternateData = P.False}
data GetResource_result = GetResource_result  { getResource_result_success :: Types_Types.Resource
  , getResource_result_userException :: P.Maybe Errors_Types.EDAMUserException
  , getResource_result_systemException :: P.Maybe Errors_Types.EDAMSystemException
  , getResource_result_notFoundException :: P.Maybe Errors_Types.EDAMNotFoundException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetResource_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getResource_result_success record   `H.hashWithSalt` getResource_result_userException record   `H.hashWithSalt` getResource_result_systemException record   `H.hashWithSalt` getResource_result_notFoundException record  
instance QC.Arbitrary GetResource_result where 
  arbitrary = M.liftM GetResource_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetResource_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetResource_result{getResource_result_success = getResource_result_success obj} then P.Nothing else P.Just $ default_GetResource_result{getResource_result_success = getResource_result_success obj}
    , if obj == default_GetResource_result{getResource_result_userException = getResource_result_userException obj} then P.Nothing else P.Just $ default_GetResource_result{getResource_result_userException = getResource_result_userException obj}
    , if obj == default_GetResource_result{getResource_result_systemException = getResource_result_systemException obj} then P.Nothing else P.Just $ default_GetResource_result{getResource_result_systemException = getResource_result_systemException obj}
    , if obj == default_GetResource_result{getResource_result_notFoundException = getResource_result_notFoundException obj} then P.Nothing else P.Just $ default_GetResource_result{getResource_result_notFoundException = getResource_result_notFoundException obj}
    ]
from_GetResource_result :: GetResource_result -> T.ThriftVal
from_GetResource_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v1284 -> (1, ("userException",Errors_Types.from_EDAMUserException _v1284))) <$> getResource_result_userException record, (\_v1284 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v1284))) <$> getResource_result_systemException record, (\_v1284 -> (3, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v1284))) <$> getResource_result_notFoundException record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v1284 -> P.Just (0, ("success",Types_Types.from_Resource _v1284))) $ getResource_result_success record
    , (\_v1284 -> (1, ("userException",Errors_Types.from_EDAMUserException _v1284))) <$> getResource_result_userException record
    , (\_v1284 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v1284))) <$> getResource_result_systemException record
    , (\_v1284 -> (3, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v1284))) <$> getResource_result_notFoundException record
    ]
    )
write_GetResource_result :: T.Protocol p => p -> GetResource_result -> P.IO ()
write_GetResource_result oprot record = T.writeVal oprot $ from_GetResource_result record
encode_GetResource_result :: T.StatelessProtocol p => p -> GetResource_result -> LBS.ByteString
encode_GetResource_result oprot record = T.serializeVal oprot $ from_GetResource_result record
to_GetResource_result :: T.ThriftVal -> GetResource_result
to_GetResource_result (T.TStruct fields) = GetResource_result{
  getResource_result_success = P.maybe (getResource_result_success default_GetResource_result) (\(_,_val1286) -> (case _val1286 of {T.TStruct _val1287 -> (Types_Types.to_Resource (T.TStruct _val1287)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getResource_result_userException = P.maybe (P.Nothing) (\(_,_val1286) -> P.Just (case _val1286 of {T.TStruct _val1288 -> (Errors_Types.to_EDAMUserException (T.TStruct _val1288)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  getResource_result_systemException = P.maybe (P.Nothing) (\(_,_val1286) -> P.Just (case _val1286 of {T.TStruct _val1289 -> (Errors_Types.to_EDAMSystemException (T.TStruct _val1289)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  getResource_result_notFoundException = P.maybe (P.Nothing) (\(_,_val1286) -> P.Just (case _val1286 of {T.TStruct _val1290 -> (Errors_Types.to_EDAMNotFoundException (T.TStruct _val1290)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_GetResource_result _ = P.error "not a struct"
read_GetResource_result :: T.Protocol p => p -> P.IO GetResource_result
read_GetResource_result iprot = to_GetResource_result <$> T.readVal iprot (T.T_STRUCT typemap_GetResource_result)
decode_GetResource_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetResource_result
decode_GetResource_result iprot bs = to_GetResource_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetResource_result) bs
typemap_GetResource_result :: T.TypeMap
typemap_GetResource_result = Map.fromList [(0,("success",(T.T_STRUCT Types_Types.typemap_Resource))),(1,("userException",(T.T_STRUCT Errors_Types.typemap_EDAMUserException))),(2,("systemException",(T.T_STRUCT Errors_Types.typemap_EDAMSystemException))),(3,("notFoundException",(T.T_STRUCT Errors_Types.typemap_EDAMNotFoundException)))]
default_GetResource_result :: GetResource_result
default_GetResource_result = GetResource_result{
  getResource_result_success = Types_Types.default_Resource,
  getResource_result_userException = P.Nothing,
  getResource_result_systemException = P.Nothing,
  getResource_result_notFoundException = P.Nothing}
data GetResourceApplicationData_args = GetResourceApplicationData_args  { getResourceApplicationData_args_authenticationToken :: LT.Text
  , getResourceApplicationData_args_guid :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetResourceApplicationData_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getResourceApplicationData_args_authenticationToken record   `H.hashWithSalt` getResourceApplicationData_args_guid record  
instance QC.Arbitrary GetResourceApplicationData_args where 
  arbitrary = M.liftM GetResourceApplicationData_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GetResourceApplicationData_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetResourceApplicationData_args{getResourceApplicationData_args_authenticationToken = getResourceApplicationData_args_authenticationToken obj} then P.Nothing else P.Just $ default_GetResourceApplicationData_args{getResourceApplicationData_args_authenticationToken = getResourceApplicationData_args_authenticationToken obj}
    , if obj == default_GetResourceApplicationData_args{getResourceApplicationData_args_guid = getResourceApplicationData_args_guid obj} then P.Nothing else P.Just $ default_GetResourceApplicationData_args{getResourceApplicationData_args_guid = getResourceApplicationData_args_guid obj}
    ]
from_GetResourceApplicationData_args :: GetResourceApplicationData_args -> T.ThriftVal
from_GetResourceApplicationData_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1293 -> P.Just (1, ("authenticationToken",T.TString $ E.encodeUtf8 _v1293))) $ getResourceApplicationData_args_authenticationToken record
  , (\_v1293 -> P.Just (2, ("guid",T.TString $ E.encodeUtf8 _v1293))) $ getResourceApplicationData_args_guid record
  ]
write_GetResourceApplicationData_args :: T.Protocol p => p -> GetResourceApplicationData_args -> P.IO ()
write_GetResourceApplicationData_args oprot record = T.writeVal oprot $ from_GetResourceApplicationData_args record
encode_GetResourceApplicationData_args :: T.StatelessProtocol p => p -> GetResourceApplicationData_args -> LBS.ByteString
encode_GetResourceApplicationData_args oprot record = T.serializeVal oprot $ from_GetResourceApplicationData_args record
to_GetResourceApplicationData_args :: T.ThriftVal -> GetResourceApplicationData_args
to_GetResourceApplicationData_args (T.TStruct fields) = GetResourceApplicationData_args{
  getResourceApplicationData_args_authenticationToken = P.maybe (getResourceApplicationData_args_authenticationToken default_GetResourceApplicationData_args) (\(_,_val1295) -> (case _val1295 of {T.TString _val1296 -> E.decodeUtf8 _val1296; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  getResourceApplicationData_args_guid = P.maybe (getResourceApplicationData_args_guid default_GetResourceApplicationData_args) (\(_,_val1295) -> (case _val1295 of {T.TString _val1297 -> E.decodeUtf8 _val1297; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_GetResourceApplicationData_args _ = P.error "not a struct"
read_GetResourceApplicationData_args :: T.Protocol p => p -> P.IO GetResourceApplicationData_args
read_GetResourceApplicationData_args iprot = to_GetResourceApplicationData_args <$> T.readVal iprot (T.T_STRUCT typemap_GetResourceApplicationData_args)
decode_GetResourceApplicationData_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetResourceApplicationData_args
decode_GetResourceApplicationData_args iprot bs = to_GetResourceApplicationData_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetResourceApplicationData_args) bs
typemap_GetResourceApplicationData_args :: T.TypeMap
typemap_GetResourceApplicationData_args = Map.fromList [(1,("authenticationToken",T.T_STRING)),(2,("guid",T.T_STRING))]
default_GetResourceApplicationData_args :: GetResourceApplicationData_args
default_GetResourceApplicationData_args = GetResourceApplicationData_args{
  getResourceApplicationData_args_authenticationToken = "",
  getResourceApplicationData_args_guid = ""}
data GetResourceApplicationData_result = GetResourceApplicationData_result  { getResourceApplicationData_result_success :: Types_Types.LazyMap
  , getResourceApplicationData_result_userException :: P.Maybe Errors_Types.EDAMUserException
  , getResourceApplicationData_result_systemException :: P.Maybe Errors_Types.EDAMSystemException
  , getResourceApplicationData_result_notFoundException :: P.Maybe Errors_Types.EDAMNotFoundException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetResourceApplicationData_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getResourceApplicationData_result_success record   `H.hashWithSalt` getResourceApplicationData_result_userException record   `H.hashWithSalt` getResourceApplicationData_result_systemException record   `H.hashWithSalt` getResourceApplicationData_result_notFoundException record  
instance QC.Arbitrary GetResourceApplicationData_result where 
  arbitrary = M.liftM GetResourceApplicationData_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetResourceApplicationData_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetResourceApplicationData_result{getResourceApplicationData_result_success = getResourceApplicationData_result_success obj} then P.Nothing else P.Just $ default_GetResourceApplicationData_result{getResourceApplicationData_result_success = getResourceApplicationData_result_success obj}
    , if obj == default_GetResourceApplicationData_result{getResourceApplicationData_result_userException = getResourceApplicationData_result_userException obj} then P.Nothing else P.Just $ default_GetResourceApplicationData_result{getResourceApplicationData_result_userException = getResourceApplicationData_result_userException obj}
    , if obj == default_GetResourceApplicationData_result{getResourceApplicationData_result_systemException = getResourceApplicationData_result_systemException obj} then P.Nothing else P.Just $ default_GetResourceApplicationData_result{getResourceApplicationData_result_systemException = getResourceApplicationData_result_systemException obj}
    , if obj == default_GetResourceApplicationData_result{getResourceApplicationData_result_notFoundException = getResourceApplicationData_result_notFoundException obj} then P.Nothing else P.Just $ default_GetResourceApplicationData_result{getResourceApplicationData_result_notFoundException = getResourceApplicationData_result_notFoundException obj}
    ]
from_GetResourceApplicationData_result :: GetResourceApplicationData_result -> T.ThriftVal
from_GetResourceApplicationData_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v1300 -> (1, ("userException",Errors_Types.from_EDAMUserException _v1300))) <$> getResourceApplicationData_result_userException record, (\_v1300 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v1300))) <$> getResourceApplicationData_result_systemException record, (\_v1300 -> (3, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v1300))) <$> getResourceApplicationData_result_notFoundException record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v1300 -> P.Just (0, ("success",Types_Types.from_LazyMap _v1300))) $ getResourceApplicationData_result_success record
    , (\_v1300 -> (1, ("userException",Errors_Types.from_EDAMUserException _v1300))) <$> getResourceApplicationData_result_userException record
    , (\_v1300 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v1300))) <$> getResourceApplicationData_result_systemException record
    , (\_v1300 -> (3, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v1300))) <$> getResourceApplicationData_result_notFoundException record
    ]
    )
write_GetResourceApplicationData_result :: T.Protocol p => p -> GetResourceApplicationData_result -> P.IO ()
write_GetResourceApplicationData_result oprot record = T.writeVal oprot $ from_GetResourceApplicationData_result record
encode_GetResourceApplicationData_result :: T.StatelessProtocol p => p -> GetResourceApplicationData_result -> LBS.ByteString
encode_GetResourceApplicationData_result oprot record = T.serializeVal oprot $ from_GetResourceApplicationData_result record
to_GetResourceApplicationData_result :: T.ThriftVal -> GetResourceApplicationData_result
to_GetResourceApplicationData_result (T.TStruct fields) = GetResourceApplicationData_result{
  getResourceApplicationData_result_success = P.maybe (getResourceApplicationData_result_success default_GetResourceApplicationData_result) (\(_,_val1302) -> (case _val1302 of {T.TStruct _val1303 -> (Types_Types.to_LazyMap (T.TStruct _val1303)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getResourceApplicationData_result_userException = P.maybe (P.Nothing) (\(_,_val1302) -> P.Just (case _val1302 of {T.TStruct _val1304 -> (Errors_Types.to_EDAMUserException (T.TStruct _val1304)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  getResourceApplicationData_result_systemException = P.maybe (P.Nothing) (\(_,_val1302) -> P.Just (case _val1302 of {T.TStruct _val1305 -> (Errors_Types.to_EDAMSystemException (T.TStruct _val1305)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  getResourceApplicationData_result_notFoundException = P.maybe (P.Nothing) (\(_,_val1302) -> P.Just (case _val1302 of {T.TStruct _val1306 -> (Errors_Types.to_EDAMNotFoundException (T.TStruct _val1306)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_GetResourceApplicationData_result _ = P.error "not a struct"
read_GetResourceApplicationData_result :: T.Protocol p => p -> P.IO GetResourceApplicationData_result
read_GetResourceApplicationData_result iprot = to_GetResourceApplicationData_result <$> T.readVal iprot (T.T_STRUCT typemap_GetResourceApplicationData_result)
decode_GetResourceApplicationData_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetResourceApplicationData_result
decode_GetResourceApplicationData_result iprot bs = to_GetResourceApplicationData_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetResourceApplicationData_result) bs
typemap_GetResourceApplicationData_result :: T.TypeMap
typemap_GetResourceApplicationData_result = Map.fromList [(0,("success",(T.T_STRUCT Types_Types.typemap_LazyMap))),(1,("userException",(T.T_STRUCT Errors_Types.typemap_EDAMUserException))),(2,("systemException",(T.T_STRUCT Errors_Types.typemap_EDAMSystemException))),(3,("notFoundException",(T.T_STRUCT Errors_Types.typemap_EDAMNotFoundException)))]
default_GetResourceApplicationData_result :: GetResourceApplicationData_result
default_GetResourceApplicationData_result = GetResourceApplicationData_result{
  getResourceApplicationData_result_success = Types_Types.default_LazyMap,
  getResourceApplicationData_result_userException = P.Nothing,
  getResourceApplicationData_result_systemException = P.Nothing,
  getResourceApplicationData_result_notFoundException = P.Nothing}
data GetResourceApplicationDataEntry_args = GetResourceApplicationDataEntry_args  { getResourceApplicationDataEntry_args_authenticationToken :: LT.Text
  , getResourceApplicationDataEntry_args_guid :: LT.Text
  , getResourceApplicationDataEntry_args_key :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetResourceApplicationDataEntry_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getResourceApplicationDataEntry_args_authenticationToken record   `H.hashWithSalt` getResourceApplicationDataEntry_args_guid record   `H.hashWithSalt` getResourceApplicationDataEntry_args_key record  
instance QC.Arbitrary GetResourceApplicationDataEntry_args where 
  arbitrary = M.liftM GetResourceApplicationDataEntry_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GetResourceApplicationDataEntry_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetResourceApplicationDataEntry_args{getResourceApplicationDataEntry_args_authenticationToken = getResourceApplicationDataEntry_args_authenticationToken obj} then P.Nothing else P.Just $ default_GetResourceApplicationDataEntry_args{getResourceApplicationDataEntry_args_authenticationToken = getResourceApplicationDataEntry_args_authenticationToken obj}
    , if obj == default_GetResourceApplicationDataEntry_args{getResourceApplicationDataEntry_args_guid = getResourceApplicationDataEntry_args_guid obj} then P.Nothing else P.Just $ default_GetResourceApplicationDataEntry_args{getResourceApplicationDataEntry_args_guid = getResourceApplicationDataEntry_args_guid obj}
    , if obj == default_GetResourceApplicationDataEntry_args{getResourceApplicationDataEntry_args_key = getResourceApplicationDataEntry_args_key obj} then P.Nothing else P.Just $ default_GetResourceApplicationDataEntry_args{getResourceApplicationDataEntry_args_key = getResourceApplicationDataEntry_args_key obj}
    ]
from_GetResourceApplicationDataEntry_args :: GetResourceApplicationDataEntry_args -> T.ThriftVal
from_GetResourceApplicationDataEntry_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1309 -> P.Just (1, ("authenticationToken",T.TString $ E.encodeUtf8 _v1309))) $ getResourceApplicationDataEntry_args_authenticationToken record
  , (\_v1309 -> P.Just (2, ("guid",T.TString $ E.encodeUtf8 _v1309))) $ getResourceApplicationDataEntry_args_guid record
  , (\_v1309 -> P.Just (3, ("key",T.TString $ E.encodeUtf8 _v1309))) $ getResourceApplicationDataEntry_args_key record
  ]
write_GetResourceApplicationDataEntry_args :: T.Protocol p => p -> GetResourceApplicationDataEntry_args -> P.IO ()
write_GetResourceApplicationDataEntry_args oprot record = T.writeVal oprot $ from_GetResourceApplicationDataEntry_args record
encode_GetResourceApplicationDataEntry_args :: T.StatelessProtocol p => p -> GetResourceApplicationDataEntry_args -> LBS.ByteString
encode_GetResourceApplicationDataEntry_args oprot record = T.serializeVal oprot $ from_GetResourceApplicationDataEntry_args record
to_GetResourceApplicationDataEntry_args :: T.ThriftVal -> GetResourceApplicationDataEntry_args
to_GetResourceApplicationDataEntry_args (T.TStruct fields) = GetResourceApplicationDataEntry_args{
  getResourceApplicationDataEntry_args_authenticationToken = P.maybe (getResourceApplicationDataEntry_args_authenticationToken default_GetResourceApplicationDataEntry_args) (\(_,_val1311) -> (case _val1311 of {T.TString _val1312 -> E.decodeUtf8 _val1312; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  getResourceApplicationDataEntry_args_guid = P.maybe (getResourceApplicationDataEntry_args_guid default_GetResourceApplicationDataEntry_args) (\(_,_val1311) -> (case _val1311 of {T.TString _val1313 -> E.decodeUtf8 _val1313; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  getResourceApplicationDataEntry_args_key = P.maybe (getResourceApplicationDataEntry_args_key default_GetResourceApplicationDataEntry_args) (\(_,_val1311) -> (case _val1311 of {T.TString _val1314 -> E.decodeUtf8 _val1314; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_GetResourceApplicationDataEntry_args _ = P.error "not a struct"
read_GetResourceApplicationDataEntry_args :: T.Protocol p => p -> P.IO GetResourceApplicationDataEntry_args
read_GetResourceApplicationDataEntry_args iprot = to_GetResourceApplicationDataEntry_args <$> T.readVal iprot (T.T_STRUCT typemap_GetResourceApplicationDataEntry_args)
decode_GetResourceApplicationDataEntry_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetResourceApplicationDataEntry_args
decode_GetResourceApplicationDataEntry_args iprot bs = to_GetResourceApplicationDataEntry_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetResourceApplicationDataEntry_args) bs
typemap_GetResourceApplicationDataEntry_args :: T.TypeMap
typemap_GetResourceApplicationDataEntry_args = Map.fromList [(1,("authenticationToken",T.T_STRING)),(2,("guid",T.T_STRING)),(3,("key",T.T_STRING))]
default_GetResourceApplicationDataEntry_args :: GetResourceApplicationDataEntry_args
default_GetResourceApplicationDataEntry_args = GetResourceApplicationDataEntry_args{
  getResourceApplicationDataEntry_args_authenticationToken = "",
  getResourceApplicationDataEntry_args_guid = "",
  getResourceApplicationDataEntry_args_key = ""}
data GetResourceApplicationDataEntry_result = GetResourceApplicationDataEntry_result  { getResourceApplicationDataEntry_result_success :: LT.Text
  , getResourceApplicationDataEntry_result_userException :: P.Maybe Errors_Types.EDAMUserException
  , getResourceApplicationDataEntry_result_systemException :: P.Maybe Errors_Types.EDAMSystemException
  , getResourceApplicationDataEntry_result_notFoundException :: P.Maybe Errors_Types.EDAMNotFoundException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetResourceApplicationDataEntry_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getResourceApplicationDataEntry_result_success record   `H.hashWithSalt` getResourceApplicationDataEntry_result_userException record   `H.hashWithSalt` getResourceApplicationDataEntry_result_systemException record   `H.hashWithSalt` getResourceApplicationDataEntry_result_notFoundException record  
instance QC.Arbitrary GetResourceApplicationDataEntry_result where 
  arbitrary = M.liftM GetResourceApplicationDataEntry_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetResourceApplicationDataEntry_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetResourceApplicationDataEntry_result{getResourceApplicationDataEntry_result_success = getResourceApplicationDataEntry_result_success obj} then P.Nothing else P.Just $ default_GetResourceApplicationDataEntry_result{getResourceApplicationDataEntry_result_success = getResourceApplicationDataEntry_result_success obj}
    , if obj == default_GetResourceApplicationDataEntry_result{getResourceApplicationDataEntry_result_userException = getResourceApplicationDataEntry_result_userException obj} then P.Nothing else P.Just $ default_GetResourceApplicationDataEntry_result{getResourceApplicationDataEntry_result_userException = getResourceApplicationDataEntry_result_userException obj}
    , if obj == default_GetResourceApplicationDataEntry_result{getResourceApplicationDataEntry_result_systemException = getResourceApplicationDataEntry_result_systemException obj} then P.Nothing else P.Just $ default_GetResourceApplicationDataEntry_result{getResourceApplicationDataEntry_result_systemException = getResourceApplicationDataEntry_result_systemException obj}
    , if obj == default_GetResourceApplicationDataEntry_result{getResourceApplicationDataEntry_result_notFoundException = getResourceApplicationDataEntry_result_notFoundException obj} then P.Nothing else P.Just $ default_GetResourceApplicationDataEntry_result{getResourceApplicationDataEntry_result_notFoundException = getResourceApplicationDataEntry_result_notFoundException obj}
    ]
from_GetResourceApplicationDataEntry_result :: GetResourceApplicationDataEntry_result -> T.ThriftVal
from_GetResourceApplicationDataEntry_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v1317 -> (1, ("userException",Errors_Types.from_EDAMUserException _v1317))) <$> getResourceApplicationDataEntry_result_userException record, (\_v1317 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v1317))) <$> getResourceApplicationDataEntry_result_systemException record, (\_v1317 -> (3, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v1317))) <$> getResourceApplicationDataEntry_result_notFoundException record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v1317 -> P.Just (0, ("success",T.TString $ E.encodeUtf8 _v1317))) $ getResourceApplicationDataEntry_result_success record
    , (\_v1317 -> (1, ("userException",Errors_Types.from_EDAMUserException _v1317))) <$> getResourceApplicationDataEntry_result_userException record
    , (\_v1317 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v1317))) <$> getResourceApplicationDataEntry_result_systemException record
    , (\_v1317 -> (3, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v1317))) <$> getResourceApplicationDataEntry_result_notFoundException record
    ]
    )
write_GetResourceApplicationDataEntry_result :: T.Protocol p => p -> GetResourceApplicationDataEntry_result -> P.IO ()
write_GetResourceApplicationDataEntry_result oprot record = T.writeVal oprot $ from_GetResourceApplicationDataEntry_result record
encode_GetResourceApplicationDataEntry_result :: T.StatelessProtocol p => p -> GetResourceApplicationDataEntry_result -> LBS.ByteString
encode_GetResourceApplicationDataEntry_result oprot record = T.serializeVal oprot $ from_GetResourceApplicationDataEntry_result record
to_GetResourceApplicationDataEntry_result :: T.ThriftVal -> GetResourceApplicationDataEntry_result
to_GetResourceApplicationDataEntry_result (T.TStruct fields) = GetResourceApplicationDataEntry_result{
  getResourceApplicationDataEntry_result_success = P.maybe (getResourceApplicationDataEntry_result_success default_GetResourceApplicationDataEntry_result) (\(_,_val1319) -> (case _val1319 of {T.TString _val1320 -> E.decodeUtf8 _val1320; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getResourceApplicationDataEntry_result_userException = P.maybe (P.Nothing) (\(_,_val1319) -> P.Just (case _val1319 of {T.TStruct _val1321 -> (Errors_Types.to_EDAMUserException (T.TStruct _val1321)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  getResourceApplicationDataEntry_result_systemException = P.maybe (P.Nothing) (\(_,_val1319) -> P.Just (case _val1319 of {T.TStruct _val1322 -> (Errors_Types.to_EDAMSystemException (T.TStruct _val1322)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  getResourceApplicationDataEntry_result_notFoundException = P.maybe (P.Nothing) (\(_,_val1319) -> P.Just (case _val1319 of {T.TStruct _val1323 -> (Errors_Types.to_EDAMNotFoundException (T.TStruct _val1323)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_GetResourceApplicationDataEntry_result _ = P.error "not a struct"
read_GetResourceApplicationDataEntry_result :: T.Protocol p => p -> P.IO GetResourceApplicationDataEntry_result
read_GetResourceApplicationDataEntry_result iprot = to_GetResourceApplicationDataEntry_result <$> T.readVal iprot (T.T_STRUCT typemap_GetResourceApplicationDataEntry_result)
decode_GetResourceApplicationDataEntry_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetResourceApplicationDataEntry_result
decode_GetResourceApplicationDataEntry_result iprot bs = to_GetResourceApplicationDataEntry_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetResourceApplicationDataEntry_result) bs
typemap_GetResourceApplicationDataEntry_result :: T.TypeMap
typemap_GetResourceApplicationDataEntry_result = Map.fromList [(0,("success",T.T_STRING)),(1,("userException",(T.T_STRUCT Errors_Types.typemap_EDAMUserException))),(2,("systemException",(T.T_STRUCT Errors_Types.typemap_EDAMSystemException))),(3,("notFoundException",(T.T_STRUCT Errors_Types.typemap_EDAMNotFoundException)))]
default_GetResourceApplicationDataEntry_result :: GetResourceApplicationDataEntry_result
default_GetResourceApplicationDataEntry_result = GetResourceApplicationDataEntry_result{
  getResourceApplicationDataEntry_result_success = "",
  getResourceApplicationDataEntry_result_userException = P.Nothing,
  getResourceApplicationDataEntry_result_systemException = P.Nothing,
  getResourceApplicationDataEntry_result_notFoundException = P.Nothing}
data SetResourceApplicationDataEntry_args = SetResourceApplicationDataEntry_args  { setResourceApplicationDataEntry_args_authenticationToken :: LT.Text
  , setResourceApplicationDataEntry_args_guid :: LT.Text
  , setResourceApplicationDataEntry_args_key :: LT.Text
  , setResourceApplicationDataEntry_args_value :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SetResourceApplicationDataEntry_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` setResourceApplicationDataEntry_args_authenticationToken record   `H.hashWithSalt` setResourceApplicationDataEntry_args_guid record   `H.hashWithSalt` setResourceApplicationDataEntry_args_key record   `H.hashWithSalt` setResourceApplicationDataEntry_args_value record  
instance QC.Arbitrary SetResourceApplicationDataEntry_args where 
  arbitrary = M.liftM SetResourceApplicationDataEntry_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SetResourceApplicationDataEntry_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SetResourceApplicationDataEntry_args{setResourceApplicationDataEntry_args_authenticationToken = setResourceApplicationDataEntry_args_authenticationToken obj} then P.Nothing else P.Just $ default_SetResourceApplicationDataEntry_args{setResourceApplicationDataEntry_args_authenticationToken = setResourceApplicationDataEntry_args_authenticationToken obj}
    , if obj == default_SetResourceApplicationDataEntry_args{setResourceApplicationDataEntry_args_guid = setResourceApplicationDataEntry_args_guid obj} then P.Nothing else P.Just $ default_SetResourceApplicationDataEntry_args{setResourceApplicationDataEntry_args_guid = setResourceApplicationDataEntry_args_guid obj}
    , if obj == default_SetResourceApplicationDataEntry_args{setResourceApplicationDataEntry_args_key = setResourceApplicationDataEntry_args_key obj} then P.Nothing else P.Just $ default_SetResourceApplicationDataEntry_args{setResourceApplicationDataEntry_args_key = setResourceApplicationDataEntry_args_key obj}
    , if obj == default_SetResourceApplicationDataEntry_args{setResourceApplicationDataEntry_args_value = setResourceApplicationDataEntry_args_value obj} then P.Nothing else P.Just $ default_SetResourceApplicationDataEntry_args{setResourceApplicationDataEntry_args_value = setResourceApplicationDataEntry_args_value obj}
    ]
from_SetResourceApplicationDataEntry_args :: SetResourceApplicationDataEntry_args -> T.ThriftVal
from_SetResourceApplicationDataEntry_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1326 -> P.Just (1, ("authenticationToken",T.TString $ E.encodeUtf8 _v1326))) $ setResourceApplicationDataEntry_args_authenticationToken record
  , (\_v1326 -> P.Just (2, ("guid",T.TString $ E.encodeUtf8 _v1326))) $ setResourceApplicationDataEntry_args_guid record
  , (\_v1326 -> P.Just (3, ("key",T.TString $ E.encodeUtf8 _v1326))) $ setResourceApplicationDataEntry_args_key record
  , (\_v1326 -> P.Just (4, ("value",T.TString $ E.encodeUtf8 _v1326))) $ setResourceApplicationDataEntry_args_value record
  ]
write_SetResourceApplicationDataEntry_args :: T.Protocol p => p -> SetResourceApplicationDataEntry_args -> P.IO ()
write_SetResourceApplicationDataEntry_args oprot record = T.writeVal oprot $ from_SetResourceApplicationDataEntry_args record
encode_SetResourceApplicationDataEntry_args :: T.StatelessProtocol p => p -> SetResourceApplicationDataEntry_args -> LBS.ByteString
encode_SetResourceApplicationDataEntry_args oprot record = T.serializeVal oprot $ from_SetResourceApplicationDataEntry_args record
to_SetResourceApplicationDataEntry_args :: T.ThriftVal -> SetResourceApplicationDataEntry_args
to_SetResourceApplicationDataEntry_args (T.TStruct fields) = SetResourceApplicationDataEntry_args{
  setResourceApplicationDataEntry_args_authenticationToken = P.maybe (setResourceApplicationDataEntry_args_authenticationToken default_SetResourceApplicationDataEntry_args) (\(_,_val1328) -> (case _val1328 of {T.TString _val1329 -> E.decodeUtf8 _val1329; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  setResourceApplicationDataEntry_args_guid = P.maybe (setResourceApplicationDataEntry_args_guid default_SetResourceApplicationDataEntry_args) (\(_,_val1328) -> (case _val1328 of {T.TString _val1330 -> E.decodeUtf8 _val1330; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  setResourceApplicationDataEntry_args_key = P.maybe (setResourceApplicationDataEntry_args_key default_SetResourceApplicationDataEntry_args) (\(_,_val1328) -> (case _val1328 of {T.TString _val1331 -> E.decodeUtf8 _val1331; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  setResourceApplicationDataEntry_args_value = P.maybe (setResourceApplicationDataEntry_args_value default_SetResourceApplicationDataEntry_args) (\(_,_val1328) -> (case _val1328 of {T.TString _val1332 -> E.decodeUtf8 _val1332; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_SetResourceApplicationDataEntry_args _ = P.error "not a struct"
read_SetResourceApplicationDataEntry_args :: T.Protocol p => p -> P.IO SetResourceApplicationDataEntry_args
read_SetResourceApplicationDataEntry_args iprot = to_SetResourceApplicationDataEntry_args <$> T.readVal iprot (T.T_STRUCT typemap_SetResourceApplicationDataEntry_args)
decode_SetResourceApplicationDataEntry_args :: T.StatelessProtocol p => p -> LBS.ByteString -> SetResourceApplicationDataEntry_args
decode_SetResourceApplicationDataEntry_args iprot bs = to_SetResourceApplicationDataEntry_args $ T.deserializeVal iprot (T.T_STRUCT typemap_SetResourceApplicationDataEntry_args) bs
typemap_SetResourceApplicationDataEntry_args :: T.TypeMap
typemap_SetResourceApplicationDataEntry_args = Map.fromList [(1,("authenticationToken",T.T_STRING)),(2,("guid",T.T_STRING)),(3,("key",T.T_STRING)),(4,("value",T.T_STRING))]
default_SetResourceApplicationDataEntry_args :: SetResourceApplicationDataEntry_args
default_SetResourceApplicationDataEntry_args = SetResourceApplicationDataEntry_args{
  setResourceApplicationDataEntry_args_authenticationToken = "",
  setResourceApplicationDataEntry_args_guid = "",
  setResourceApplicationDataEntry_args_key = "",
  setResourceApplicationDataEntry_args_value = ""}
data SetResourceApplicationDataEntry_result = SetResourceApplicationDataEntry_result  { setResourceApplicationDataEntry_result_success :: I.Int32
  , setResourceApplicationDataEntry_result_userException :: P.Maybe Errors_Types.EDAMUserException
  , setResourceApplicationDataEntry_result_systemException :: P.Maybe Errors_Types.EDAMSystemException
  , setResourceApplicationDataEntry_result_notFoundException :: P.Maybe Errors_Types.EDAMNotFoundException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SetResourceApplicationDataEntry_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` setResourceApplicationDataEntry_result_success record   `H.hashWithSalt` setResourceApplicationDataEntry_result_userException record   `H.hashWithSalt` setResourceApplicationDataEntry_result_systemException record   `H.hashWithSalt` setResourceApplicationDataEntry_result_notFoundException record  
instance QC.Arbitrary SetResourceApplicationDataEntry_result where 
  arbitrary = M.liftM SetResourceApplicationDataEntry_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_SetResourceApplicationDataEntry_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SetResourceApplicationDataEntry_result{setResourceApplicationDataEntry_result_success = setResourceApplicationDataEntry_result_success obj} then P.Nothing else P.Just $ default_SetResourceApplicationDataEntry_result{setResourceApplicationDataEntry_result_success = setResourceApplicationDataEntry_result_success obj}
    , if obj == default_SetResourceApplicationDataEntry_result{setResourceApplicationDataEntry_result_userException = setResourceApplicationDataEntry_result_userException obj} then P.Nothing else P.Just $ default_SetResourceApplicationDataEntry_result{setResourceApplicationDataEntry_result_userException = setResourceApplicationDataEntry_result_userException obj}
    , if obj == default_SetResourceApplicationDataEntry_result{setResourceApplicationDataEntry_result_systemException = setResourceApplicationDataEntry_result_systemException obj} then P.Nothing else P.Just $ default_SetResourceApplicationDataEntry_result{setResourceApplicationDataEntry_result_systemException = setResourceApplicationDataEntry_result_systemException obj}
    , if obj == default_SetResourceApplicationDataEntry_result{setResourceApplicationDataEntry_result_notFoundException = setResourceApplicationDataEntry_result_notFoundException obj} then P.Nothing else P.Just $ default_SetResourceApplicationDataEntry_result{setResourceApplicationDataEntry_result_notFoundException = setResourceApplicationDataEntry_result_notFoundException obj}
    ]
from_SetResourceApplicationDataEntry_result :: SetResourceApplicationDataEntry_result -> T.ThriftVal
from_SetResourceApplicationDataEntry_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v1335 -> (1, ("userException",Errors_Types.from_EDAMUserException _v1335))) <$> setResourceApplicationDataEntry_result_userException record, (\_v1335 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v1335))) <$> setResourceApplicationDataEntry_result_systemException record, (\_v1335 -> (3, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v1335))) <$> setResourceApplicationDataEntry_result_notFoundException record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v1335 -> P.Just (0, ("success",T.TI32 _v1335))) $ setResourceApplicationDataEntry_result_success record
    , (\_v1335 -> (1, ("userException",Errors_Types.from_EDAMUserException _v1335))) <$> setResourceApplicationDataEntry_result_userException record
    , (\_v1335 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v1335))) <$> setResourceApplicationDataEntry_result_systemException record
    , (\_v1335 -> (3, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v1335))) <$> setResourceApplicationDataEntry_result_notFoundException record
    ]
    )
write_SetResourceApplicationDataEntry_result :: T.Protocol p => p -> SetResourceApplicationDataEntry_result -> P.IO ()
write_SetResourceApplicationDataEntry_result oprot record = T.writeVal oprot $ from_SetResourceApplicationDataEntry_result record
encode_SetResourceApplicationDataEntry_result :: T.StatelessProtocol p => p -> SetResourceApplicationDataEntry_result -> LBS.ByteString
encode_SetResourceApplicationDataEntry_result oprot record = T.serializeVal oprot $ from_SetResourceApplicationDataEntry_result record
to_SetResourceApplicationDataEntry_result :: T.ThriftVal -> SetResourceApplicationDataEntry_result
to_SetResourceApplicationDataEntry_result (T.TStruct fields) = SetResourceApplicationDataEntry_result{
  setResourceApplicationDataEntry_result_success = P.maybe (setResourceApplicationDataEntry_result_success default_SetResourceApplicationDataEntry_result) (\(_,_val1337) -> (case _val1337 of {T.TI32 _val1338 -> _val1338; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  setResourceApplicationDataEntry_result_userException = P.maybe (P.Nothing) (\(_,_val1337) -> P.Just (case _val1337 of {T.TStruct _val1339 -> (Errors_Types.to_EDAMUserException (T.TStruct _val1339)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  setResourceApplicationDataEntry_result_systemException = P.maybe (P.Nothing) (\(_,_val1337) -> P.Just (case _val1337 of {T.TStruct _val1340 -> (Errors_Types.to_EDAMSystemException (T.TStruct _val1340)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  setResourceApplicationDataEntry_result_notFoundException = P.maybe (P.Nothing) (\(_,_val1337) -> P.Just (case _val1337 of {T.TStruct _val1341 -> (Errors_Types.to_EDAMNotFoundException (T.TStruct _val1341)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_SetResourceApplicationDataEntry_result _ = P.error "not a struct"
read_SetResourceApplicationDataEntry_result :: T.Protocol p => p -> P.IO SetResourceApplicationDataEntry_result
read_SetResourceApplicationDataEntry_result iprot = to_SetResourceApplicationDataEntry_result <$> T.readVal iprot (T.T_STRUCT typemap_SetResourceApplicationDataEntry_result)
decode_SetResourceApplicationDataEntry_result :: T.StatelessProtocol p => p -> LBS.ByteString -> SetResourceApplicationDataEntry_result
decode_SetResourceApplicationDataEntry_result iprot bs = to_SetResourceApplicationDataEntry_result $ T.deserializeVal iprot (T.T_STRUCT typemap_SetResourceApplicationDataEntry_result) bs
typemap_SetResourceApplicationDataEntry_result :: T.TypeMap
typemap_SetResourceApplicationDataEntry_result = Map.fromList [(0,("success",T.T_I32)),(1,("userException",(T.T_STRUCT Errors_Types.typemap_EDAMUserException))),(2,("systemException",(T.T_STRUCT Errors_Types.typemap_EDAMSystemException))),(3,("notFoundException",(T.T_STRUCT Errors_Types.typemap_EDAMNotFoundException)))]
default_SetResourceApplicationDataEntry_result :: SetResourceApplicationDataEntry_result
default_SetResourceApplicationDataEntry_result = SetResourceApplicationDataEntry_result{
  setResourceApplicationDataEntry_result_success = 0,
  setResourceApplicationDataEntry_result_userException = P.Nothing,
  setResourceApplicationDataEntry_result_systemException = P.Nothing,
  setResourceApplicationDataEntry_result_notFoundException = P.Nothing}
data UnsetResourceApplicationDataEntry_args = UnsetResourceApplicationDataEntry_args  { unsetResourceApplicationDataEntry_args_authenticationToken :: LT.Text
  , unsetResourceApplicationDataEntry_args_guid :: LT.Text
  , unsetResourceApplicationDataEntry_args_key :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UnsetResourceApplicationDataEntry_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` unsetResourceApplicationDataEntry_args_authenticationToken record   `H.hashWithSalt` unsetResourceApplicationDataEntry_args_guid record   `H.hashWithSalt` unsetResourceApplicationDataEntry_args_key record  
instance QC.Arbitrary UnsetResourceApplicationDataEntry_args where 
  arbitrary = M.liftM UnsetResourceApplicationDataEntry_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_UnsetResourceApplicationDataEntry_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UnsetResourceApplicationDataEntry_args{unsetResourceApplicationDataEntry_args_authenticationToken = unsetResourceApplicationDataEntry_args_authenticationToken obj} then P.Nothing else P.Just $ default_UnsetResourceApplicationDataEntry_args{unsetResourceApplicationDataEntry_args_authenticationToken = unsetResourceApplicationDataEntry_args_authenticationToken obj}
    , if obj == default_UnsetResourceApplicationDataEntry_args{unsetResourceApplicationDataEntry_args_guid = unsetResourceApplicationDataEntry_args_guid obj} then P.Nothing else P.Just $ default_UnsetResourceApplicationDataEntry_args{unsetResourceApplicationDataEntry_args_guid = unsetResourceApplicationDataEntry_args_guid obj}
    , if obj == default_UnsetResourceApplicationDataEntry_args{unsetResourceApplicationDataEntry_args_key = unsetResourceApplicationDataEntry_args_key obj} then P.Nothing else P.Just $ default_UnsetResourceApplicationDataEntry_args{unsetResourceApplicationDataEntry_args_key = unsetResourceApplicationDataEntry_args_key obj}
    ]
from_UnsetResourceApplicationDataEntry_args :: UnsetResourceApplicationDataEntry_args -> T.ThriftVal
from_UnsetResourceApplicationDataEntry_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1344 -> P.Just (1, ("authenticationToken",T.TString $ E.encodeUtf8 _v1344))) $ unsetResourceApplicationDataEntry_args_authenticationToken record
  , (\_v1344 -> P.Just (2, ("guid",T.TString $ E.encodeUtf8 _v1344))) $ unsetResourceApplicationDataEntry_args_guid record
  , (\_v1344 -> P.Just (3, ("key",T.TString $ E.encodeUtf8 _v1344))) $ unsetResourceApplicationDataEntry_args_key record
  ]
write_UnsetResourceApplicationDataEntry_args :: T.Protocol p => p -> UnsetResourceApplicationDataEntry_args -> P.IO ()
write_UnsetResourceApplicationDataEntry_args oprot record = T.writeVal oprot $ from_UnsetResourceApplicationDataEntry_args record
encode_UnsetResourceApplicationDataEntry_args :: T.StatelessProtocol p => p -> UnsetResourceApplicationDataEntry_args -> LBS.ByteString
encode_UnsetResourceApplicationDataEntry_args oprot record = T.serializeVal oprot $ from_UnsetResourceApplicationDataEntry_args record
to_UnsetResourceApplicationDataEntry_args :: T.ThriftVal -> UnsetResourceApplicationDataEntry_args
to_UnsetResourceApplicationDataEntry_args (T.TStruct fields) = UnsetResourceApplicationDataEntry_args{
  unsetResourceApplicationDataEntry_args_authenticationToken = P.maybe (unsetResourceApplicationDataEntry_args_authenticationToken default_UnsetResourceApplicationDataEntry_args) (\(_,_val1346) -> (case _val1346 of {T.TString _val1347 -> E.decodeUtf8 _val1347; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  unsetResourceApplicationDataEntry_args_guid = P.maybe (unsetResourceApplicationDataEntry_args_guid default_UnsetResourceApplicationDataEntry_args) (\(_,_val1346) -> (case _val1346 of {T.TString _val1348 -> E.decodeUtf8 _val1348; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  unsetResourceApplicationDataEntry_args_key = P.maybe (unsetResourceApplicationDataEntry_args_key default_UnsetResourceApplicationDataEntry_args) (\(_,_val1346) -> (case _val1346 of {T.TString _val1349 -> E.decodeUtf8 _val1349; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_UnsetResourceApplicationDataEntry_args _ = P.error "not a struct"
read_UnsetResourceApplicationDataEntry_args :: T.Protocol p => p -> P.IO UnsetResourceApplicationDataEntry_args
read_UnsetResourceApplicationDataEntry_args iprot = to_UnsetResourceApplicationDataEntry_args <$> T.readVal iprot (T.T_STRUCT typemap_UnsetResourceApplicationDataEntry_args)
decode_UnsetResourceApplicationDataEntry_args :: T.StatelessProtocol p => p -> LBS.ByteString -> UnsetResourceApplicationDataEntry_args
decode_UnsetResourceApplicationDataEntry_args iprot bs = to_UnsetResourceApplicationDataEntry_args $ T.deserializeVal iprot (T.T_STRUCT typemap_UnsetResourceApplicationDataEntry_args) bs
typemap_UnsetResourceApplicationDataEntry_args :: T.TypeMap
typemap_UnsetResourceApplicationDataEntry_args = Map.fromList [(1,("authenticationToken",T.T_STRING)),(2,("guid",T.T_STRING)),(3,("key",T.T_STRING))]
default_UnsetResourceApplicationDataEntry_args :: UnsetResourceApplicationDataEntry_args
default_UnsetResourceApplicationDataEntry_args = UnsetResourceApplicationDataEntry_args{
  unsetResourceApplicationDataEntry_args_authenticationToken = "",
  unsetResourceApplicationDataEntry_args_guid = "",
  unsetResourceApplicationDataEntry_args_key = ""}
data UnsetResourceApplicationDataEntry_result = UnsetResourceApplicationDataEntry_result  { unsetResourceApplicationDataEntry_result_success :: I.Int32
  , unsetResourceApplicationDataEntry_result_userException :: P.Maybe Errors_Types.EDAMUserException
  , unsetResourceApplicationDataEntry_result_systemException :: P.Maybe Errors_Types.EDAMSystemException
  , unsetResourceApplicationDataEntry_result_notFoundException :: P.Maybe Errors_Types.EDAMNotFoundException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UnsetResourceApplicationDataEntry_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` unsetResourceApplicationDataEntry_result_success record   `H.hashWithSalt` unsetResourceApplicationDataEntry_result_userException record   `H.hashWithSalt` unsetResourceApplicationDataEntry_result_systemException record   `H.hashWithSalt` unsetResourceApplicationDataEntry_result_notFoundException record  
instance QC.Arbitrary UnsetResourceApplicationDataEntry_result where 
  arbitrary = M.liftM UnsetResourceApplicationDataEntry_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_UnsetResourceApplicationDataEntry_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UnsetResourceApplicationDataEntry_result{unsetResourceApplicationDataEntry_result_success = unsetResourceApplicationDataEntry_result_success obj} then P.Nothing else P.Just $ default_UnsetResourceApplicationDataEntry_result{unsetResourceApplicationDataEntry_result_success = unsetResourceApplicationDataEntry_result_success obj}
    , if obj == default_UnsetResourceApplicationDataEntry_result{unsetResourceApplicationDataEntry_result_userException = unsetResourceApplicationDataEntry_result_userException obj} then P.Nothing else P.Just $ default_UnsetResourceApplicationDataEntry_result{unsetResourceApplicationDataEntry_result_userException = unsetResourceApplicationDataEntry_result_userException obj}
    , if obj == default_UnsetResourceApplicationDataEntry_result{unsetResourceApplicationDataEntry_result_systemException = unsetResourceApplicationDataEntry_result_systemException obj} then P.Nothing else P.Just $ default_UnsetResourceApplicationDataEntry_result{unsetResourceApplicationDataEntry_result_systemException = unsetResourceApplicationDataEntry_result_systemException obj}
    , if obj == default_UnsetResourceApplicationDataEntry_result{unsetResourceApplicationDataEntry_result_notFoundException = unsetResourceApplicationDataEntry_result_notFoundException obj} then P.Nothing else P.Just $ default_UnsetResourceApplicationDataEntry_result{unsetResourceApplicationDataEntry_result_notFoundException = unsetResourceApplicationDataEntry_result_notFoundException obj}
    ]
from_UnsetResourceApplicationDataEntry_result :: UnsetResourceApplicationDataEntry_result -> T.ThriftVal
from_UnsetResourceApplicationDataEntry_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v1352 -> (1, ("userException",Errors_Types.from_EDAMUserException _v1352))) <$> unsetResourceApplicationDataEntry_result_userException record, (\_v1352 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v1352))) <$> unsetResourceApplicationDataEntry_result_systemException record, (\_v1352 -> (3, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v1352))) <$> unsetResourceApplicationDataEntry_result_notFoundException record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v1352 -> P.Just (0, ("success",T.TI32 _v1352))) $ unsetResourceApplicationDataEntry_result_success record
    , (\_v1352 -> (1, ("userException",Errors_Types.from_EDAMUserException _v1352))) <$> unsetResourceApplicationDataEntry_result_userException record
    , (\_v1352 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v1352))) <$> unsetResourceApplicationDataEntry_result_systemException record
    , (\_v1352 -> (3, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v1352))) <$> unsetResourceApplicationDataEntry_result_notFoundException record
    ]
    )
write_UnsetResourceApplicationDataEntry_result :: T.Protocol p => p -> UnsetResourceApplicationDataEntry_result -> P.IO ()
write_UnsetResourceApplicationDataEntry_result oprot record = T.writeVal oprot $ from_UnsetResourceApplicationDataEntry_result record
encode_UnsetResourceApplicationDataEntry_result :: T.StatelessProtocol p => p -> UnsetResourceApplicationDataEntry_result -> LBS.ByteString
encode_UnsetResourceApplicationDataEntry_result oprot record = T.serializeVal oprot $ from_UnsetResourceApplicationDataEntry_result record
to_UnsetResourceApplicationDataEntry_result :: T.ThriftVal -> UnsetResourceApplicationDataEntry_result
to_UnsetResourceApplicationDataEntry_result (T.TStruct fields) = UnsetResourceApplicationDataEntry_result{
  unsetResourceApplicationDataEntry_result_success = P.maybe (unsetResourceApplicationDataEntry_result_success default_UnsetResourceApplicationDataEntry_result) (\(_,_val1354) -> (case _val1354 of {T.TI32 _val1355 -> _val1355; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  unsetResourceApplicationDataEntry_result_userException = P.maybe (P.Nothing) (\(_,_val1354) -> P.Just (case _val1354 of {T.TStruct _val1356 -> (Errors_Types.to_EDAMUserException (T.TStruct _val1356)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  unsetResourceApplicationDataEntry_result_systemException = P.maybe (P.Nothing) (\(_,_val1354) -> P.Just (case _val1354 of {T.TStruct _val1357 -> (Errors_Types.to_EDAMSystemException (T.TStruct _val1357)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  unsetResourceApplicationDataEntry_result_notFoundException = P.maybe (P.Nothing) (\(_,_val1354) -> P.Just (case _val1354 of {T.TStruct _val1358 -> (Errors_Types.to_EDAMNotFoundException (T.TStruct _val1358)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_UnsetResourceApplicationDataEntry_result _ = P.error "not a struct"
read_UnsetResourceApplicationDataEntry_result :: T.Protocol p => p -> P.IO UnsetResourceApplicationDataEntry_result
read_UnsetResourceApplicationDataEntry_result iprot = to_UnsetResourceApplicationDataEntry_result <$> T.readVal iprot (T.T_STRUCT typemap_UnsetResourceApplicationDataEntry_result)
decode_UnsetResourceApplicationDataEntry_result :: T.StatelessProtocol p => p -> LBS.ByteString -> UnsetResourceApplicationDataEntry_result
decode_UnsetResourceApplicationDataEntry_result iprot bs = to_UnsetResourceApplicationDataEntry_result $ T.deserializeVal iprot (T.T_STRUCT typemap_UnsetResourceApplicationDataEntry_result) bs
typemap_UnsetResourceApplicationDataEntry_result :: T.TypeMap
typemap_UnsetResourceApplicationDataEntry_result = Map.fromList [(0,("success",T.T_I32)),(1,("userException",(T.T_STRUCT Errors_Types.typemap_EDAMUserException))),(2,("systemException",(T.T_STRUCT Errors_Types.typemap_EDAMSystemException))),(3,("notFoundException",(T.T_STRUCT Errors_Types.typemap_EDAMNotFoundException)))]
default_UnsetResourceApplicationDataEntry_result :: UnsetResourceApplicationDataEntry_result
default_UnsetResourceApplicationDataEntry_result = UnsetResourceApplicationDataEntry_result{
  unsetResourceApplicationDataEntry_result_success = 0,
  unsetResourceApplicationDataEntry_result_userException = P.Nothing,
  unsetResourceApplicationDataEntry_result_systemException = P.Nothing,
  unsetResourceApplicationDataEntry_result_notFoundException = P.Nothing}
data UpdateResource_args = UpdateResource_args  { updateResource_args_authenticationToken :: LT.Text
  , updateResource_args_resource :: Types_Types.Resource
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateResource_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateResource_args_authenticationToken record   `H.hashWithSalt` updateResource_args_resource record  
instance QC.Arbitrary UpdateResource_args where 
  arbitrary = M.liftM UpdateResource_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_UpdateResource_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateResource_args{updateResource_args_authenticationToken = updateResource_args_authenticationToken obj} then P.Nothing else P.Just $ default_UpdateResource_args{updateResource_args_authenticationToken = updateResource_args_authenticationToken obj}
    , if obj == default_UpdateResource_args{updateResource_args_resource = updateResource_args_resource obj} then P.Nothing else P.Just $ default_UpdateResource_args{updateResource_args_resource = updateResource_args_resource obj}
    ]
from_UpdateResource_args :: UpdateResource_args -> T.ThriftVal
from_UpdateResource_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1361 -> P.Just (1, ("authenticationToken",T.TString $ E.encodeUtf8 _v1361))) $ updateResource_args_authenticationToken record
  , (\_v1361 -> P.Just (2, ("resource",Types_Types.from_Resource _v1361))) $ updateResource_args_resource record
  ]
write_UpdateResource_args :: T.Protocol p => p -> UpdateResource_args -> P.IO ()
write_UpdateResource_args oprot record = T.writeVal oprot $ from_UpdateResource_args record
encode_UpdateResource_args :: T.StatelessProtocol p => p -> UpdateResource_args -> LBS.ByteString
encode_UpdateResource_args oprot record = T.serializeVal oprot $ from_UpdateResource_args record
to_UpdateResource_args :: T.ThriftVal -> UpdateResource_args
to_UpdateResource_args (T.TStruct fields) = UpdateResource_args{
  updateResource_args_authenticationToken = P.maybe (updateResource_args_authenticationToken default_UpdateResource_args) (\(_,_val1363) -> (case _val1363 of {T.TString _val1364 -> E.decodeUtf8 _val1364; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  updateResource_args_resource = P.maybe (updateResource_args_resource default_UpdateResource_args) (\(_,_val1363) -> (case _val1363 of {T.TStruct _val1365 -> (Types_Types.to_Resource (T.TStruct _val1365)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_UpdateResource_args _ = P.error "not a struct"
read_UpdateResource_args :: T.Protocol p => p -> P.IO UpdateResource_args
read_UpdateResource_args iprot = to_UpdateResource_args <$> T.readVal iprot (T.T_STRUCT typemap_UpdateResource_args)
decode_UpdateResource_args :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateResource_args
decode_UpdateResource_args iprot bs = to_UpdateResource_args $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateResource_args) bs
typemap_UpdateResource_args :: T.TypeMap
typemap_UpdateResource_args = Map.fromList [(1,("authenticationToken",T.T_STRING)),(2,("resource",(T.T_STRUCT Types_Types.typemap_Resource)))]
default_UpdateResource_args :: UpdateResource_args
default_UpdateResource_args = UpdateResource_args{
  updateResource_args_authenticationToken = "",
  updateResource_args_resource = Types_Types.default_Resource}
data UpdateResource_result = UpdateResource_result  { updateResource_result_success :: I.Int32
  , updateResource_result_userException :: P.Maybe Errors_Types.EDAMUserException
  , updateResource_result_systemException :: P.Maybe Errors_Types.EDAMSystemException
  , updateResource_result_notFoundException :: P.Maybe Errors_Types.EDAMNotFoundException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateResource_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateResource_result_success record   `H.hashWithSalt` updateResource_result_userException record   `H.hashWithSalt` updateResource_result_systemException record   `H.hashWithSalt` updateResource_result_notFoundException record  
instance QC.Arbitrary UpdateResource_result where 
  arbitrary = M.liftM UpdateResource_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_UpdateResource_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateResource_result{updateResource_result_success = updateResource_result_success obj} then P.Nothing else P.Just $ default_UpdateResource_result{updateResource_result_success = updateResource_result_success obj}
    , if obj == default_UpdateResource_result{updateResource_result_userException = updateResource_result_userException obj} then P.Nothing else P.Just $ default_UpdateResource_result{updateResource_result_userException = updateResource_result_userException obj}
    , if obj == default_UpdateResource_result{updateResource_result_systemException = updateResource_result_systemException obj} then P.Nothing else P.Just $ default_UpdateResource_result{updateResource_result_systemException = updateResource_result_systemException obj}
    , if obj == default_UpdateResource_result{updateResource_result_notFoundException = updateResource_result_notFoundException obj} then P.Nothing else P.Just $ default_UpdateResource_result{updateResource_result_notFoundException = updateResource_result_notFoundException obj}
    ]
from_UpdateResource_result :: UpdateResource_result -> T.ThriftVal
from_UpdateResource_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v1368 -> (1, ("userException",Errors_Types.from_EDAMUserException _v1368))) <$> updateResource_result_userException record, (\_v1368 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v1368))) <$> updateResource_result_systemException record, (\_v1368 -> (3, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v1368))) <$> updateResource_result_notFoundException record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v1368 -> P.Just (0, ("success",T.TI32 _v1368))) $ updateResource_result_success record
    , (\_v1368 -> (1, ("userException",Errors_Types.from_EDAMUserException _v1368))) <$> updateResource_result_userException record
    , (\_v1368 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v1368))) <$> updateResource_result_systemException record
    , (\_v1368 -> (3, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v1368))) <$> updateResource_result_notFoundException record
    ]
    )
write_UpdateResource_result :: T.Protocol p => p -> UpdateResource_result -> P.IO ()
write_UpdateResource_result oprot record = T.writeVal oprot $ from_UpdateResource_result record
encode_UpdateResource_result :: T.StatelessProtocol p => p -> UpdateResource_result -> LBS.ByteString
encode_UpdateResource_result oprot record = T.serializeVal oprot $ from_UpdateResource_result record
to_UpdateResource_result :: T.ThriftVal -> UpdateResource_result
to_UpdateResource_result (T.TStruct fields) = UpdateResource_result{
  updateResource_result_success = P.maybe (updateResource_result_success default_UpdateResource_result) (\(_,_val1370) -> (case _val1370 of {T.TI32 _val1371 -> _val1371; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  updateResource_result_userException = P.maybe (P.Nothing) (\(_,_val1370) -> P.Just (case _val1370 of {T.TStruct _val1372 -> (Errors_Types.to_EDAMUserException (T.TStruct _val1372)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  updateResource_result_systemException = P.maybe (P.Nothing) (\(_,_val1370) -> P.Just (case _val1370 of {T.TStruct _val1373 -> (Errors_Types.to_EDAMSystemException (T.TStruct _val1373)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  updateResource_result_notFoundException = P.maybe (P.Nothing) (\(_,_val1370) -> P.Just (case _val1370 of {T.TStruct _val1374 -> (Errors_Types.to_EDAMNotFoundException (T.TStruct _val1374)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_UpdateResource_result _ = P.error "not a struct"
read_UpdateResource_result :: T.Protocol p => p -> P.IO UpdateResource_result
read_UpdateResource_result iprot = to_UpdateResource_result <$> T.readVal iprot (T.T_STRUCT typemap_UpdateResource_result)
decode_UpdateResource_result :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateResource_result
decode_UpdateResource_result iprot bs = to_UpdateResource_result $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateResource_result) bs
typemap_UpdateResource_result :: T.TypeMap
typemap_UpdateResource_result = Map.fromList [(0,("success",T.T_I32)),(1,("userException",(T.T_STRUCT Errors_Types.typemap_EDAMUserException))),(2,("systemException",(T.T_STRUCT Errors_Types.typemap_EDAMSystemException))),(3,("notFoundException",(T.T_STRUCT Errors_Types.typemap_EDAMNotFoundException)))]
default_UpdateResource_result :: UpdateResource_result
default_UpdateResource_result = UpdateResource_result{
  updateResource_result_success = 0,
  updateResource_result_userException = P.Nothing,
  updateResource_result_systemException = P.Nothing,
  updateResource_result_notFoundException = P.Nothing}
data GetResourceData_args = GetResourceData_args  { getResourceData_args_authenticationToken :: LT.Text
  , getResourceData_args_guid :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetResourceData_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getResourceData_args_authenticationToken record   `H.hashWithSalt` getResourceData_args_guid record  
instance QC.Arbitrary GetResourceData_args where 
  arbitrary = M.liftM GetResourceData_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GetResourceData_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetResourceData_args{getResourceData_args_authenticationToken = getResourceData_args_authenticationToken obj} then P.Nothing else P.Just $ default_GetResourceData_args{getResourceData_args_authenticationToken = getResourceData_args_authenticationToken obj}
    , if obj == default_GetResourceData_args{getResourceData_args_guid = getResourceData_args_guid obj} then P.Nothing else P.Just $ default_GetResourceData_args{getResourceData_args_guid = getResourceData_args_guid obj}
    ]
from_GetResourceData_args :: GetResourceData_args -> T.ThriftVal
from_GetResourceData_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1377 -> P.Just (1, ("authenticationToken",T.TString $ E.encodeUtf8 _v1377))) $ getResourceData_args_authenticationToken record
  , (\_v1377 -> P.Just (2, ("guid",T.TString $ E.encodeUtf8 _v1377))) $ getResourceData_args_guid record
  ]
write_GetResourceData_args :: T.Protocol p => p -> GetResourceData_args -> P.IO ()
write_GetResourceData_args oprot record = T.writeVal oprot $ from_GetResourceData_args record
encode_GetResourceData_args :: T.StatelessProtocol p => p -> GetResourceData_args -> LBS.ByteString
encode_GetResourceData_args oprot record = T.serializeVal oprot $ from_GetResourceData_args record
to_GetResourceData_args :: T.ThriftVal -> GetResourceData_args
to_GetResourceData_args (T.TStruct fields) = GetResourceData_args{
  getResourceData_args_authenticationToken = P.maybe (getResourceData_args_authenticationToken default_GetResourceData_args) (\(_,_val1379) -> (case _val1379 of {T.TString _val1380 -> E.decodeUtf8 _val1380; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  getResourceData_args_guid = P.maybe (getResourceData_args_guid default_GetResourceData_args) (\(_,_val1379) -> (case _val1379 of {T.TString _val1381 -> E.decodeUtf8 _val1381; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_GetResourceData_args _ = P.error "not a struct"
read_GetResourceData_args :: T.Protocol p => p -> P.IO GetResourceData_args
read_GetResourceData_args iprot = to_GetResourceData_args <$> T.readVal iprot (T.T_STRUCT typemap_GetResourceData_args)
decode_GetResourceData_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetResourceData_args
decode_GetResourceData_args iprot bs = to_GetResourceData_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetResourceData_args) bs
typemap_GetResourceData_args :: T.TypeMap
typemap_GetResourceData_args = Map.fromList [(1,("authenticationToken",T.T_STRING)),(2,("guid",T.T_STRING))]
default_GetResourceData_args :: GetResourceData_args
default_GetResourceData_args = GetResourceData_args{
  getResourceData_args_authenticationToken = "",
  getResourceData_args_guid = ""}
data GetResourceData_result = GetResourceData_result  { getResourceData_result_success :: LBS.ByteString
  , getResourceData_result_userException :: P.Maybe Errors_Types.EDAMUserException
  , getResourceData_result_systemException :: P.Maybe Errors_Types.EDAMSystemException
  , getResourceData_result_notFoundException :: P.Maybe Errors_Types.EDAMNotFoundException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetResourceData_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getResourceData_result_success record   `H.hashWithSalt` getResourceData_result_userException record   `H.hashWithSalt` getResourceData_result_systemException record   `H.hashWithSalt` getResourceData_result_notFoundException record  
instance QC.Arbitrary GetResourceData_result where 
  arbitrary = M.liftM GetResourceData_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetResourceData_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetResourceData_result{getResourceData_result_success = getResourceData_result_success obj} then P.Nothing else P.Just $ default_GetResourceData_result{getResourceData_result_success = getResourceData_result_success obj}
    , if obj == default_GetResourceData_result{getResourceData_result_userException = getResourceData_result_userException obj} then P.Nothing else P.Just $ default_GetResourceData_result{getResourceData_result_userException = getResourceData_result_userException obj}
    , if obj == default_GetResourceData_result{getResourceData_result_systemException = getResourceData_result_systemException obj} then P.Nothing else P.Just $ default_GetResourceData_result{getResourceData_result_systemException = getResourceData_result_systemException obj}
    , if obj == default_GetResourceData_result{getResourceData_result_notFoundException = getResourceData_result_notFoundException obj} then P.Nothing else P.Just $ default_GetResourceData_result{getResourceData_result_notFoundException = getResourceData_result_notFoundException obj}
    ]
from_GetResourceData_result :: GetResourceData_result -> T.ThriftVal
from_GetResourceData_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v1384 -> (1, ("userException",Errors_Types.from_EDAMUserException _v1384))) <$> getResourceData_result_userException record, (\_v1384 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v1384))) <$> getResourceData_result_systemException record, (\_v1384 -> (3, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v1384))) <$> getResourceData_result_notFoundException record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v1384 -> P.Just (0, ("success",T.TBinary _v1384))) $ getResourceData_result_success record
    , (\_v1384 -> (1, ("userException",Errors_Types.from_EDAMUserException _v1384))) <$> getResourceData_result_userException record
    , (\_v1384 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v1384))) <$> getResourceData_result_systemException record
    , (\_v1384 -> (3, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v1384))) <$> getResourceData_result_notFoundException record
    ]
    )
write_GetResourceData_result :: T.Protocol p => p -> GetResourceData_result -> P.IO ()
write_GetResourceData_result oprot record = T.writeVal oprot $ from_GetResourceData_result record
encode_GetResourceData_result :: T.StatelessProtocol p => p -> GetResourceData_result -> LBS.ByteString
encode_GetResourceData_result oprot record = T.serializeVal oprot $ from_GetResourceData_result record
to_GetResourceData_result :: T.ThriftVal -> GetResourceData_result
to_GetResourceData_result (T.TStruct fields) = GetResourceData_result{
  getResourceData_result_success = P.maybe (getResourceData_result_success default_GetResourceData_result) (\(_,_val1386) -> (case _val1386 of {T.TBinary _val1387 -> _val1387; T.TString _val1387 -> _val1387; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getResourceData_result_userException = P.maybe (P.Nothing) (\(_,_val1386) -> P.Just (case _val1386 of {T.TStruct _val1388 -> (Errors_Types.to_EDAMUserException (T.TStruct _val1388)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  getResourceData_result_systemException = P.maybe (P.Nothing) (\(_,_val1386) -> P.Just (case _val1386 of {T.TStruct _val1389 -> (Errors_Types.to_EDAMSystemException (T.TStruct _val1389)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  getResourceData_result_notFoundException = P.maybe (P.Nothing) (\(_,_val1386) -> P.Just (case _val1386 of {T.TStruct _val1390 -> (Errors_Types.to_EDAMNotFoundException (T.TStruct _val1390)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_GetResourceData_result _ = P.error "not a struct"
read_GetResourceData_result :: T.Protocol p => p -> P.IO GetResourceData_result
read_GetResourceData_result iprot = to_GetResourceData_result <$> T.readVal iprot (T.T_STRUCT typemap_GetResourceData_result)
decode_GetResourceData_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetResourceData_result
decode_GetResourceData_result iprot bs = to_GetResourceData_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetResourceData_result) bs
typemap_GetResourceData_result :: T.TypeMap
typemap_GetResourceData_result = Map.fromList [(0,("success",T.T_BINARY)),(1,("userException",(T.T_STRUCT Errors_Types.typemap_EDAMUserException))),(2,("systemException",(T.T_STRUCT Errors_Types.typemap_EDAMSystemException))),(3,("notFoundException",(T.T_STRUCT Errors_Types.typemap_EDAMNotFoundException)))]
default_GetResourceData_result :: GetResourceData_result
default_GetResourceData_result = GetResourceData_result{
  getResourceData_result_success = "",
  getResourceData_result_userException = P.Nothing,
  getResourceData_result_systemException = P.Nothing,
  getResourceData_result_notFoundException = P.Nothing}
data GetResourceByHash_args = GetResourceByHash_args  { getResourceByHash_args_authenticationToken :: LT.Text
  , getResourceByHash_args_noteGuid :: LT.Text
  , getResourceByHash_args_contentHash :: LBS.ByteString
  , getResourceByHash_args_withData :: P.Bool
  , getResourceByHash_args_withRecognition :: P.Bool
  , getResourceByHash_args_withAlternateData :: P.Bool
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetResourceByHash_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getResourceByHash_args_authenticationToken record   `H.hashWithSalt` getResourceByHash_args_noteGuid record   `H.hashWithSalt` getResourceByHash_args_contentHash record   `H.hashWithSalt` getResourceByHash_args_withData record   `H.hashWithSalt` getResourceByHash_args_withRecognition record   `H.hashWithSalt` getResourceByHash_args_withAlternateData record  
instance QC.Arbitrary GetResourceByHash_args where 
  arbitrary = M.liftM GetResourceByHash_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GetResourceByHash_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetResourceByHash_args{getResourceByHash_args_authenticationToken = getResourceByHash_args_authenticationToken obj} then P.Nothing else P.Just $ default_GetResourceByHash_args{getResourceByHash_args_authenticationToken = getResourceByHash_args_authenticationToken obj}
    , if obj == default_GetResourceByHash_args{getResourceByHash_args_noteGuid = getResourceByHash_args_noteGuid obj} then P.Nothing else P.Just $ default_GetResourceByHash_args{getResourceByHash_args_noteGuid = getResourceByHash_args_noteGuid obj}
    , if obj == default_GetResourceByHash_args{getResourceByHash_args_contentHash = getResourceByHash_args_contentHash obj} then P.Nothing else P.Just $ default_GetResourceByHash_args{getResourceByHash_args_contentHash = getResourceByHash_args_contentHash obj}
    , if obj == default_GetResourceByHash_args{getResourceByHash_args_withData = getResourceByHash_args_withData obj} then P.Nothing else P.Just $ default_GetResourceByHash_args{getResourceByHash_args_withData = getResourceByHash_args_withData obj}
    , if obj == default_GetResourceByHash_args{getResourceByHash_args_withRecognition = getResourceByHash_args_withRecognition obj} then P.Nothing else P.Just $ default_GetResourceByHash_args{getResourceByHash_args_withRecognition = getResourceByHash_args_withRecognition obj}
    , if obj == default_GetResourceByHash_args{getResourceByHash_args_withAlternateData = getResourceByHash_args_withAlternateData obj} then P.Nothing else P.Just $ default_GetResourceByHash_args{getResourceByHash_args_withAlternateData = getResourceByHash_args_withAlternateData obj}
    ]
from_GetResourceByHash_args :: GetResourceByHash_args -> T.ThriftVal
from_GetResourceByHash_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1393 -> P.Just (1, ("authenticationToken",T.TString $ E.encodeUtf8 _v1393))) $ getResourceByHash_args_authenticationToken record
  , (\_v1393 -> P.Just (2, ("noteGuid",T.TString $ E.encodeUtf8 _v1393))) $ getResourceByHash_args_noteGuid record
  , (\_v1393 -> P.Just (3, ("contentHash",T.TBinary _v1393))) $ getResourceByHash_args_contentHash record
  , (\_v1393 -> P.Just (4, ("withData",T.TBool _v1393))) $ getResourceByHash_args_withData record
  , (\_v1393 -> P.Just (5, ("withRecognition",T.TBool _v1393))) $ getResourceByHash_args_withRecognition record
  , (\_v1393 -> P.Just (6, ("withAlternateData",T.TBool _v1393))) $ getResourceByHash_args_withAlternateData record
  ]
write_GetResourceByHash_args :: T.Protocol p => p -> GetResourceByHash_args -> P.IO ()
write_GetResourceByHash_args oprot record = T.writeVal oprot $ from_GetResourceByHash_args record
encode_GetResourceByHash_args :: T.StatelessProtocol p => p -> GetResourceByHash_args -> LBS.ByteString
encode_GetResourceByHash_args oprot record = T.serializeVal oprot $ from_GetResourceByHash_args record
to_GetResourceByHash_args :: T.ThriftVal -> GetResourceByHash_args
to_GetResourceByHash_args (T.TStruct fields) = GetResourceByHash_args{
  getResourceByHash_args_authenticationToken = P.maybe (getResourceByHash_args_authenticationToken default_GetResourceByHash_args) (\(_,_val1395) -> (case _val1395 of {T.TString _val1396 -> E.decodeUtf8 _val1396; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  getResourceByHash_args_noteGuid = P.maybe (getResourceByHash_args_noteGuid default_GetResourceByHash_args) (\(_,_val1395) -> (case _val1395 of {T.TString _val1397 -> E.decodeUtf8 _val1397; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  getResourceByHash_args_contentHash = P.maybe (getResourceByHash_args_contentHash default_GetResourceByHash_args) (\(_,_val1395) -> (case _val1395 of {T.TBinary _val1398 -> _val1398; T.TString _val1398 -> _val1398; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  getResourceByHash_args_withData = P.maybe (getResourceByHash_args_withData default_GetResourceByHash_args) (\(_,_val1395) -> (case _val1395 of {T.TBool _val1399 -> _val1399; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  getResourceByHash_args_withRecognition = P.maybe (getResourceByHash_args_withRecognition default_GetResourceByHash_args) (\(_,_val1395) -> (case _val1395 of {T.TBool _val1400 -> _val1400; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  getResourceByHash_args_withAlternateData = P.maybe (getResourceByHash_args_withAlternateData default_GetResourceByHash_args) (\(_,_val1395) -> (case _val1395 of {T.TBool _val1401 -> _val1401; _ -> P.error "wrong type"})) (Map.lookup (6) fields)
  }
to_GetResourceByHash_args _ = P.error "not a struct"
read_GetResourceByHash_args :: T.Protocol p => p -> P.IO GetResourceByHash_args
read_GetResourceByHash_args iprot = to_GetResourceByHash_args <$> T.readVal iprot (T.T_STRUCT typemap_GetResourceByHash_args)
decode_GetResourceByHash_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetResourceByHash_args
decode_GetResourceByHash_args iprot bs = to_GetResourceByHash_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetResourceByHash_args) bs
typemap_GetResourceByHash_args :: T.TypeMap
typemap_GetResourceByHash_args = Map.fromList [(1,("authenticationToken",T.T_STRING)),(2,("noteGuid",T.T_STRING)),(3,("contentHash",T.T_BINARY)),(4,("withData",T.T_BOOL)),(5,("withRecognition",T.T_BOOL)),(6,("withAlternateData",T.T_BOOL))]
default_GetResourceByHash_args :: GetResourceByHash_args
default_GetResourceByHash_args = GetResourceByHash_args{
  getResourceByHash_args_authenticationToken = "",
  getResourceByHash_args_noteGuid = "",
  getResourceByHash_args_contentHash = "",
  getResourceByHash_args_withData = P.False,
  getResourceByHash_args_withRecognition = P.False,
  getResourceByHash_args_withAlternateData = P.False}
data GetResourceByHash_result = GetResourceByHash_result  { getResourceByHash_result_success :: Types_Types.Resource
  , getResourceByHash_result_userException :: P.Maybe Errors_Types.EDAMUserException
  , getResourceByHash_result_systemException :: P.Maybe Errors_Types.EDAMSystemException
  , getResourceByHash_result_notFoundException :: P.Maybe Errors_Types.EDAMNotFoundException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetResourceByHash_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getResourceByHash_result_success record   `H.hashWithSalt` getResourceByHash_result_userException record   `H.hashWithSalt` getResourceByHash_result_systemException record   `H.hashWithSalt` getResourceByHash_result_notFoundException record  
instance QC.Arbitrary GetResourceByHash_result where 
  arbitrary = M.liftM GetResourceByHash_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetResourceByHash_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetResourceByHash_result{getResourceByHash_result_success = getResourceByHash_result_success obj} then P.Nothing else P.Just $ default_GetResourceByHash_result{getResourceByHash_result_success = getResourceByHash_result_success obj}
    , if obj == default_GetResourceByHash_result{getResourceByHash_result_userException = getResourceByHash_result_userException obj} then P.Nothing else P.Just $ default_GetResourceByHash_result{getResourceByHash_result_userException = getResourceByHash_result_userException obj}
    , if obj == default_GetResourceByHash_result{getResourceByHash_result_systemException = getResourceByHash_result_systemException obj} then P.Nothing else P.Just $ default_GetResourceByHash_result{getResourceByHash_result_systemException = getResourceByHash_result_systemException obj}
    , if obj == default_GetResourceByHash_result{getResourceByHash_result_notFoundException = getResourceByHash_result_notFoundException obj} then P.Nothing else P.Just $ default_GetResourceByHash_result{getResourceByHash_result_notFoundException = getResourceByHash_result_notFoundException obj}
    ]
from_GetResourceByHash_result :: GetResourceByHash_result -> T.ThriftVal
from_GetResourceByHash_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v1404 -> (1, ("userException",Errors_Types.from_EDAMUserException _v1404))) <$> getResourceByHash_result_userException record, (\_v1404 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v1404))) <$> getResourceByHash_result_systemException record, (\_v1404 -> (3, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v1404))) <$> getResourceByHash_result_notFoundException record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v1404 -> P.Just (0, ("success",Types_Types.from_Resource _v1404))) $ getResourceByHash_result_success record
    , (\_v1404 -> (1, ("userException",Errors_Types.from_EDAMUserException _v1404))) <$> getResourceByHash_result_userException record
    , (\_v1404 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v1404))) <$> getResourceByHash_result_systemException record
    , (\_v1404 -> (3, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v1404))) <$> getResourceByHash_result_notFoundException record
    ]
    )
write_GetResourceByHash_result :: T.Protocol p => p -> GetResourceByHash_result -> P.IO ()
write_GetResourceByHash_result oprot record = T.writeVal oprot $ from_GetResourceByHash_result record
encode_GetResourceByHash_result :: T.StatelessProtocol p => p -> GetResourceByHash_result -> LBS.ByteString
encode_GetResourceByHash_result oprot record = T.serializeVal oprot $ from_GetResourceByHash_result record
to_GetResourceByHash_result :: T.ThriftVal -> GetResourceByHash_result
to_GetResourceByHash_result (T.TStruct fields) = GetResourceByHash_result{
  getResourceByHash_result_success = P.maybe (getResourceByHash_result_success default_GetResourceByHash_result) (\(_,_val1406) -> (case _val1406 of {T.TStruct _val1407 -> (Types_Types.to_Resource (T.TStruct _val1407)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getResourceByHash_result_userException = P.maybe (P.Nothing) (\(_,_val1406) -> P.Just (case _val1406 of {T.TStruct _val1408 -> (Errors_Types.to_EDAMUserException (T.TStruct _val1408)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  getResourceByHash_result_systemException = P.maybe (P.Nothing) (\(_,_val1406) -> P.Just (case _val1406 of {T.TStruct _val1409 -> (Errors_Types.to_EDAMSystemException (T.TStruct _val1409)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  getResourceByHash_result_notFoundException = P.maybe (P.Nothing) (\(_,_val1406) -> P.Just (case _val1406 of {T.TStruct _val1410 -> (Errors_Types.to_EDAMNotFoundException (T.TStruct _val1410)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_GetResourceByHash_result _ = P.error "not a struct"
read_GetResourceByHash_result :: T.Protocol p => p -> P.IO GetResourceByHash_result
read_GetResourceByHash_result iprot = to_GetResourceByHash_result <$> T.readVal iprot (T.T_STRUCT typemap_GetResourceByHash_result)
decode_GetResourceByHash_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetResourceByHash_result
decode_GetResourceByHash_result iprot bs = to_GetResourceByHash_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetResourceByHash_result) bs
typemap_GetResourceByHash_result :: T.TypeMap
typemap_GetResourceByHash_result = Map.fromList [(0,("success",(T.T_STRUCT Types_Types.typemap_Resource))),(1,("userException",(T.T_STRUCT Errors_Types.typemap_EDAMUserException))),(2,("systemException",(T.T_STRUCT Errors_Types.typemap_EDAMSystemException))),(3,("notFoundException",(T.T_STRUCT Errors_Types.typemap_EDAMNotFoundException)))]
default_GetResourceByHash_result :: GetResourceByHash_result
default_GetResourceByHash_result = GetResourceByHash_result{
  getResourceByHash_result_success = Types_Types.default_Resource,
  getResourceByHash_result_userException = P.Nothing,
  getResourceByHash_result_systemException = P.Nothing,
  getResourceByHash_result_notFoundException = P.Nothing}
data GetResourceRecognition_args = GetResourceRecognition_args  { getResourceRecognition_args_authenticationToken :: LT.Text
  , getResourceRecognition_args_guid :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetResourceRecognition_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getResourceRecognition_args_authenticationToken record   `H.hashWithSalt` getResourceRecognition_args_guid record  
instance QC.Arbitrary GetResourceRecognition_args where 
  arbitrary = M.liftM GetResourceRecognition_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GetResourceRecognition_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetResourceRecognition_args{getResourceRecognition_args_authenticationToken = getResourceRecognition_args_authenticationToken obj} then P.Nothing else P.Just $ default_GetResourceRecognition_args{getResourceRecognition_args_authenticationToken = getResourceRecognition_args_authenticationToken obj}
    , if obj == default_GetResourceRecognition_args{getResourceRecognition_args_guid = getResourceRecognition_args_guid obj} then P.Nothing else P.Just $ default_GetResourceRecognition_args{getResourceRecognition_args_guid = getResourceRecognition_args_guid obj}
    ]
from_GetResourceRecognition_args :: GetResourceRecognition_args -> T.ThriftVal
from_GetResourceRecognition_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1413 -> P.Just (1, ("authenticationToken",T.TString $ E.encodeUtf8 _v1413))) $ getResourceRecognition_args_authenticationToken record
  , (\_v1413 -> P.Just (2, ("guid",T.TString $ E.encodeUtf8 _v1413))) $ getResourceRecognition_args_guid record
  ]
write_GetResourceRecognition_args :: T.Protocol p => p -> GetResourceRecognition_args -> P.IO ()
write_GetResourceRecognition_args oprot record = T.writeVal oprot $ from_GetResourceRecognition_args record
encode_GetResourceRecognition_args :: T.StatelessProtocol p => p -> GetResourceRecognition_args -> LBS.ByteString
encode_GetResourceRecognition_args oprot record = T.serializeVal oprot $ from_GetResourceRecognition_args record
to_GetResourceRecognition_args :: T.ThriftVal -> GetResourceRecognition_args
to_GetResourceRecognition_args (T.TStruct fields) = GetResourceRecognition_args{
  getResourceRecognition_args_authenticationToken = P.maybe (getResourceRecognition_args_authenticationToken default_GetResourceRecognition_args) (\(_,_val1415) -> (case _val1415 of {T.TString _val1416 -> E.decodeUtf8 _val1416; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  getResourceRecognition_args_guid = P.maybe (getResourceRecognition_args_guid default_GetResourceRecognition_args) (\(_,_val1415) -> (case _val1415 of {T.TString _val1417 -> E.decodeUtf8 _val1417; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_GetResourceRecognition_args _ = P.error "not a struct"
read_GetResourceRecognition_args :: T.Protocol p => p -> P.IO GetResourceRecognition_args
read_GetResourceRecognition_args iprot = to_GetResourceRecognition_args <$> T.readVal iprot (T.T_STRUCT typemap_GetResourceRecognition_args)
decode_GetResourceRecognition_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetResourceRecognition_args
decode_GetResourceRecognition_args iprot bs = to_GetResourceRecognition_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetResourceRecognition_args) bs
typemap_GetResourceRecognition_args :: T.TypeMap
typemap_GetResourceRecognition_args = Map.fromList [(1,("authenticationToken",T.T_STRING)),(2,("guid",T.T_STRING))]
default_GetResourceRecognition_args :: GetResourceRecognition_args
default_GetResourceRecognition_args = GetResourceRecognition_args{
  getResourceRecognition_args_authenticationToken = "",
  getResourceRecognition_args_guid = ""}
data GetResourceRecognition_result = GetResourceRecognition_result  { getResourceRecognition_result_success :: LBS.ByteString
  , getResourceRecognition_result_userException :: P.Maybe Errors_Types.EDAMUserException
  , getResourceRecognition_result_systemException :: P.Maybe Errors_Types.EDAMSystemException
  , getResourceRecognition_result_notFoundException :: P.Maybe Errors_Types.EDAMNotFoundException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetResourceRecognition_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getResourceRecognition_result_success record   `H.hashWithSalt` getResourceRecognition_result_userException record   `H.hashWithSalt` getResourceRecognition_result_systemException record   `H.hashWithSalt` getResourceRecognition_result_notFoundException record  
instance QC.Arbitrary GetResourceRecognition_result where 
  arbitrary = M.liftM GetResourceRecognition_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetResourceRecognition_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetResourceRecognition_result{getResourceRecognition_result_success = getResourceRecognition_result_success obj} then P.Nothing else P.Just $ default_GetResourceRecognition_result{getResourceRecognition_result_success = getResourceRecognition_result_success obj}
    , if obj == default_GetResourceRecognition_result{getResourceRecognition_result_userException = getResourceRecognition_result_userException obj} then P.Nothing else P.Just $ default_GetResourceRecognition_result{getResourceRecognition_result_userException = getResourceRecognition_result_userException obj}
    , if obj == default_GetResourceRecognition_result{getResourceRecognition_result_systemException = getResourceRecognition_result_systemException obj} then P.Nothing else P.Just $ default_GetResourceRecognition_result{getResourceRecognition_result_systemException = getResourceRecognition_result_systemException obj}
    , if obj == default_GetResourceRecognition_result{getResourceRecognition_result_notFoundException = getResourceRecognition_result_notFoundException obj} then P.Nothing else P.Just $ default_GetResourceRecognition_result{getResourceRecognition_result_notFoundException = getResourceRecognition_result_notFoundException obj}
    ]
from_GetResourceRecognition_result :: GetResourceRecognition_result -> T.ThriftVal
from_GetResourceRecognition_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v1420 -> (1, ("userException",Errors_Types.from_EDAMUserException _v1420))) <$> getResourceRecognition_result_userException record, (\_v1420 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v1420))) <$> getResourceRecognition_result_systemException record, (\_v1420 -> (3, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v1420))) <$> getResourceRecognition_result_notFoundException record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v1420 -> P.Just (0, ("success",T.TBinary _v1420))) $ getResourceRecognition_result_success record
    , (\_v1420 -> (1, ("userException",Errors_Types.from_EDAMUserException _v1420))) <$> getResourceRecognition_result_userException record
    , (\_v1420 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v1420))) <$> getResourceRecognition_result_systemException record
    , (\_v1420 -> (3, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v1420))) <$> getResourceRecognition_result_notFoundException record
    ]
    )
write_GetResourceRecognition_result :: T.Protocol p => p -> GetResourceRecognition_result -> P.IO ()
write_GetResourceRecognition_result oprot record = T.writeVal oprot $ from_GetResourceRecognition_result record
encode_GetResourceRecognition_result :: T.StatelessProtocol p => p -> GetResourceRecognition_result -> LBS.ByteString
encode_GetResourceRecognition_result oprot record = T.serializeVal oprot $ from_GetResourceRecognition_result record
to_GetResourceRecognition_result :: T.ThriftVal -> GetResourceRecognition_result
to_GetResourceRecognition_result (T.TStruct fields) = GetResourceRecognition_result{
  getResourceRecognition_result_success = P.maybe (getResourceRecognition_result_success default_GetResourceRecognition_result) (\(_,_val1422) -> (case _val1422 of {T.TBinary _val1423 -> _val1423; T.TString _val1423 -> _val1423; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getResourceRecognition_result_userException = P.maybe (P.Nothing) (\(_,_val1422) -> P.Just (case _val1422 of {T.TStruct _val1424 -> (Errors_Types.to_EDAMUserException (T.TStruct _val1424)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  getResourceRecognition_result_systemException = P.maybe (P.Nothing) (\(_,_val1422) -> P.Just (case _val1422 of {T.TStruct _val1425 -> (Errors_Types.to_EDAMSystemException (T.TStruct _val1425)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  getResourceRecognition_result_notFoundException = P.maybe (P.Nothing) (\(_,_val1422) -> P.Just (case _val1422 of {T.TStruct _val1426 -> (Errors_Types.to_EDAMNotFoundException (T.TStruct _val1426)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_GetResourceRecognition_result _ = P.error "not a struct"
read_GetResourceRecognition_result :: T.Protocol p => p -> P.IO GetResourceRecognition_result
read_GetResourceRecognition_result iprot = to_GetResourceRecognition_result <$> T.readVal iprot (T.T_STRUCT typemap_GetResourceRecognition_result)
decode_GetResourceRecognition_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetResourceRecognition_result
decode_GetResourceRecognition_result iprot bs = to_GetResourceRecognition_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetResourceRecognition_result) bs
typemap_GetResourceRecognition_result :: T.TypeMap
typemap_GetResourceRecognition_result = Map.fromList [(0,("success",T.T_BINARY)),(1,("userException",(T.T_STRUCT Errors_Types.typemap_EDAMUserException))),(2,("systemException",(T.T_STRUCT Errors_Types.typemap_EDAMSystemException))),(3,("notFoundException",(T.T_STRUCT Errors_Types.typemap_EDAMNotFoundException)))]
default_GetResourceRecognition_result :: GetResourceRecognition_result
default_GetResourceRecognition_result = GetResourceRecognition_result{
  getResourceRecognition_result_success = "",
  getResourceRecognition_result_userException = P.Nothing,
  getResourceRecognition_result_systemException = P.Nothing,
  getResourceRecognition_result_notFoundException = P.Nothing}
data GetResourceAlternateData_args = GetResourceAlternateData_args  { getResourceAlternateData_args_authenticationToken :: LT.Text
  , getResourceAlternateData_args_guid :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetResourceAlternateData_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getResourceAlternateData_args_authenticationToken record   `H.hashWithSalt` getResourceAlternateData_args_guid record  
instance QC.Arbitrary GetResourceAlternateData_args where 
  arbitrary = M.liftM GetResourceAlternateData_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GetResourceAlternateData_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetResourceAlternateData_args{getResourceAlternateData_args_authenticationToken = getResourceAlternateData_args_authenticationToken obj} then P.Nothing else P.Just $ default_GetResourceAlternateData_args{getResourceAlternateData_args_authenticationToken = getResourceAlternateData_args_authenticationToken obj}
    , if obj == default_GetResourceAlternateData_args{getResourceAlternateData_args_guid = getResourceAlternateData_args_guid obj} then P.Nothing else P.Just $ default_GetResourceAlternateData_args{getResourceAlternateData_args_guid = getResourceAlternateData_args_guid obj}
    ]
from_GetResourceAlternateData_args :: GetResourceAlternateData_args -> T.ThriftVal
from_GetResourceAlternateData_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1429 -> P.Just (1, ("authenticationToken",T.TString $ E.encodeUtf8 _v1429))) $ getResourceAlternateData_args_authenticationToken record
  , (\_v1429 -> P.Just (2, ("guid",T.TString $ E.encodeUtf8 _v1429))) $ getResourceAlternateData_args_guid record
  ]
write_GetResourceAlternateData_args :: T.Protocol p => p -> GetResourceAlternateData_args -> P.IO ()
write_GetResourceAlternateData_args oprot record = T.writeVal oprot $ from_GetResourceAlternateData_args record
encode_GetResourceAlternateData_args :: T.StatelessProtocol p => p -> GetResourceAlternateData_args -> LBS.ByteString
encode_GetResourceAlternateData_args oprot record = T.serializeVal oprot $ from_GetResourceAlternateData_args record
to_GetResourceAlternateData_args :: T.ThriftVal -> GetResourceAlternateData_args
to_GetResourceAlternateData_args (T.TStruct fields) = GetResourceAlternateData_args{
  getResourceAlternateData_args_authenticationToken = P.maybe (getResourceAlternateData_args_authenticationToken default_GetResourceAlternateData_args) (\(_,_val1431) -> (case _val1431 of {T.TString _val1432 -> E.decodeUtf8 _val1432; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  getResourceAlternateData_args_guid = P.maybe (getResourceAlternateData_args_guid default_GetResourceAlternateData_args) (\(_,_val1431) -> (case _val1431 of {T.TString _val1433 -> E.decodeUtf8 _val1433; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_GetResourceAlternateData_args _ = P.error "not a struct"
read_GetResourceAlternateData_args :: T.Protocol p => p -> P.IO GetResourceAlternateData_args
read_GetResourceAlternateData_args iprot = to_GetResourceAlternateData_args <$> T.readVal iprot (T.T_STRUCT typemap_GetResourceAlternateData_args)
decode_GetResourceAlternateData_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetResourceAlternateData_args
decode_GetResourceAlternateData_args iprot bs = to_GetResourceAlternateData_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetResourceAlternateData_args) bs
typemap_GetResourceAlternateData_args :: T.TypeMap
typemap_GetResourceAlternateData_args = Map.fromList [(1,("authenticationToken",T.T_STRING)),(2,("guid",T.T_STRING))]
default_GetResourceAlternateData_args :: GetResourceAlternateData_args
default_GetResourceAlternateData_args = GetResourceAlternateData_args{
  getResourceAlternateData_args_authenticationToken = "",
  getResourceAlternateData_args_guid = ""}
data GetResourceAlternateData_result = GetResourceAlternateData_result  { getResourceAlternateData_result_success :: LBS.ByteString
  , getResourceAlternateData_result_userException :: P.Maybe Errors_Types.EDAMUserException
  , getResourceAlternateData_result_systemException :: P.Maybe Errors_Types.EDAMSystemException
  , getResourceAlternateData_result_notFoundException :: P.Maybe Errors_Types.EDAMNotFoundException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetResourceAlternateData_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getResourceAlternateData_result_success record   `H.hashWithSalt` getResourceAlternateData_result_userException record   `H.hashWithSalt` getResourceAlternateData_result_systemException record   `H.hashWithSalt` getResourceAlternateData_result_notFoundException record  
instance QC.Arbitrary GetResourceAlternateData_result where 
  arbitrary = M.liftM GetResourceAlternateData_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetResourceAlternateData_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetResourceAlternateData_result{getResourceAlternateData_result_success = getResourceAlternateData_result_success obj} then P.Nothing else P.Just $ default_GetResourceAlternateData_result{getResourceAlternateData_result_success = getResourceAlternateData_result_success obj}
    , if obj == default_GetResourceAlternateData_result{getResourceAlternateData_result_userException = getResourceAlternateData_result_userException obj} then P.Nothing else P.Just $ default_GetResourceAlternateData_result{getResourceAlternateData_result_userException = getResourceAlternateData_result_userException obj}
    , if obj == default_GetResourceAlternateData_result{getResourceAlternateData_result_systemException = getResourceAlternateData_result_systemException obj} then P.Nothing else P.Just $ default_GetResourceAlternateData_result{getResourceAlternateData_result_systemException = getResourceAlternateData_result_systemException obj}
    , if obj == default_GetResourceAlternateData_result{getResourceAlternateData_result_notFoundException = getResourceAlternateData_result_notFoundException obj} then P.Nothing else P.Just $ default_GetResourceAlternateData_result{getResourceAlternateData_result_notFoundException = getResourceAlternateData_result_notFoundException obj}
    ]
from_GetResourceAlternateData_result :: GetResourceAlternateData_result -> T.ThriftVal
from_GetResourceAlternateData_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v1436 -> (1, ("userException",Errors_Types.from_EDAMUserException _v1436))) <$> getResourceAlternateData_result_userException record, (\_v1436 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v1436))) <$> getResourceAlternateData_result_systemException record, (\_v1436 -> (3, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v1436))) <$> getResourceAlternateData_result_notFoundException record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v1436 -> P.Just (0, ("success",T.TBinary _v1436))) $ getResourceAlternateData_result_success record
    , (\_v1436 -> (1, ("userException",Errors_Types.from_EDAMUserException _v1436))) <$> getResourceAlternateData_result_userException record
    , (\_v1436 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v1436))) <$> getResourceAlternateData_result_systemException record
    , (\_v1436 -> (3, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v1436))) <$> getResourceAlternateData_result_notFoundException record
    ]
    )
write_GetResourceAlternateData_result :: T.Protocol p => p -> GetResourceAlternateData_result -> P.IO ()
write_GetResourceAlternateData_result oprot record = T.writeVal oprot $ from_GetResourceAlternateData_result record
encode_GetResourceAlternateData_result :: T.StatelessProtocol p => p -> GetResourceAlternateData_result -> LBS.ByteString
encode_GetResourceAlternateData_result oprot record = T.serializeVal oprot $ from_GetResourceAlternateData_result record
to_GetResourceAlternateData_result :: T.ThriftVal -> GetResourceAlternateData_result
to_GetResourceAlternateData_result (T.TStruct fields) = GetResourceAlternateData_result{
  getResourceAlternateData_result_success = P.maybe (getResourceAlternateData_result_success default_GetResourceAlternateData_result) (\(_,_val1438) -> (case _val1438 of {T.TBinary _val1439 -> _val1439; T.TString _val1439 -> _val1439; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getResourceAlternateData_result_userException = P.maybe (P.Nothing) (\(_,_val1438) -> P.Just (case _val1438 of {T.TStruct _val1440 -> (Errors_Types.to_EDAMUserException (T.TStruct _val1440)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  getResourceAlternateData_result_systemException = P.maybe (P.Nothing) (\(_,_val1438) -> P.Just (case _val1438 of {T.TStruct _val1441 -> (Errors_Types.to_EDAMSystemException (T.TStruct _val1441)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  getResourceAlternateData_result_notFoundException = P.maybe (P.Nothing) (\(_,_val1438) -> P.Just (case _val1438 of {T.TStruct _val1442 -> (Errors_Types.to_EDAMNotFoundException (T.TStruct _val1442)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_GetResourceAlternateData_result _ = P.error "not a struct"
read_GetResourceAlternateData_result :: T.Protocol p => p -> P.IO GetResourceAlternateData_result
read_GetResourceAlternateData_result iprot = to_GetResourceAlternateData_result <$> T.readVal iprot (T.T_STRUCT typemap_GetResourceAlternateData_result)
decode_GetResourceAlternateData_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetResourceAlternateData_result
decode_GetResourceAlternateData_result iprot bs = to_GetResourceAlternateData_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetResourceAlternateData_result) bs
typemap_GetResourceAlternateData_result :: T.TypeMap
typemap_GetResourceAlternateData_result = Map.fromList [(0,("success",T.T_BINARY)),(1,("userException",(T.T_STRUCT Errors_Types.typemap_EDAMUserException))),(2,("systemException",(T.T_STRUCT Errors_Types.typemap_EDAMSystemException))),(3,("notFoundException",(T.T_STRUCT Errors_Types.typemap_EDAMNotFoundException)))]
default_GetResourceAlternateData_result :: GetResourceAlternateData_result
default_GetResourceAlternateData_result = GetResourceAlternateData_result{
  getResourceAlternateData_result_success = "",
  getResourceAlternateData_result_userException = P.Nothing,
  getResourceAlternateData_result_systemException = P.Nothing,
  getResourceAlternateData_result_notFoundException = P.Nothing}
data GetResourceAttributes_args = GetResourceAttributes_args  { getResourceAttributes_args_authenticationToken :: LT.Text
  , getResourceAttributes_args_guid :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetResourceAttributes_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getResourceAttributes_args_authenticationToken record   `H.hashWithSalt` getResourceAttributes_args_guid record  
instance QC.Arbitrary GetResourceAttributes_args where 
  arbitrary = M.liftM GetResourceAttributes_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GetResourceAttributes_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetResourceAttributes_args{getResourceAttributes_args_authenticationToken = getResourceAttributes_args_authenticationToken obj} then P.Nothing else P.Just $ default_GetResourceAttributes_args{getResourceAttributes_args_authenticationToken = getResourceAttributes_args_authenticationToken obj}
    , if obj == default_GetResourceAttributes_args{getResourceAttributes_args_guid = getResourceAttributes_args_guid obj} then P.Nothing else P.Just $ default_GetResourceAttributes_args{getResourceAttributes_args_guid = getResourceAttributes_args_guid obj}
    ]
from_GetResourceAttributes_args :: GetResourceAttributes_args -> T.ThriftVal
from_GetResourceAttributes_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1445 -> P.Just (1, ("authenticationToken",T.TString $ E.encodeUtf8 _v1445))) $ getResourceAttributes_args_authenticationToken record
  , (\_v1445 -> P.Just (2, ("guid",T.TString $ E.encodeUtf8 _v1445))) $ getResourceAttributes_args_guid record
  ]
write_GetResourceAttributes_args :: T.Protocol p => p -> GetResourceAttributes_args -> P.IO ()
write_GetResourceAttributes_args oprot record = T.writeVal oprot $ from_GetResourceAttributes_args record
encode_GetResourceAttributes_args :: T.StatelessProtocol p => p -> GetResourceAttributes_args -> LBS.ByteString
encode_GetResourceAttributes_args oprot record = T.serializeVal oprot $ from_GetResourceAttributes_args record
to_GetResourceAttributes_args :: T.ThriftVal -> GetResourceAttributes_args
to_GetResourceAttributes_args (T.TStruct fields) = GetResourceAttributes_args{
  getResourceAttributes_args_authenticationToken = P.maybe (getResourceAttributes_args_authenticationToken default_GetResourceAttributes_args) (\(_,_val1447) -> (case _val1447 of {T.TString _val1448 -> E.decodeUtf8 _val1448; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  getResourceAttributes_args_guid = P.maybe (getResourceAttributes_args_guid default_GetResourceAttributes_args) (\(_,_val1447) -> (case _val1447 of {T.TString _val1449 -> E.decodeUtf8 _val1449; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_GetResourceAttributes_args _ = P.error "not a struct"
read_GetResourceAttributes_args :: T.Protocol p => p -> P.IO GetResourceAttributes_args
read_GetResourceAttributes_args iprot = to_GetResourceAttributes_args <$> T.readVal iprot (T.T_STRUCT typemap_GetResourceAttributes_args)
decode_GetResourceAttributes_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetResourceAttributes_args
decode_GetResourceAttributes_args iprot bs = to_GetResourceAttributes_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetResourceAttributes_args) bs
typemap_GetResourceAttributes_args :: T.TypeMap
typemap_GetResourceAttributes_args = Map.fromList [(1,("authenticationToken",T.T_STRING)),(2,("guid",T.T_STRING))]
default_GetResourceAttributes_args :: GetResourceAttributes_args
default_GetResourceAttributes_args = GetResourceAttributes_args{
  getResourceAttributes_args_authenticationToken = "",
  getResourceAttributes_args_guid = ""}
data GetResourceAttributes_result = GetResourceAttributes_result  { getResourceAttributes_result_success :: Types_Types.ResourceAttributes
  , getResourceAttributes_result_userException :: P.Maybe Errors_Types.EDAMUserException
  , getResourceAttributes_result_systemException :: P.Maybe Errors_Types.EDAMSystemException
  , getResourceAttributes_result_notFoundException :: P.Maybe Errors_Types.EDAMNotFoundException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetResourceAttributes_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getResourceAttributes_result_success record   `H.hashWithSalt` getResourceAttributes_result_userException record   `H.hashWithSalt` getResourceAttributes_result_systemException record   `H.hashWithSalt` getResourceAttributes_result_notFoundException record  
instance QC.Arbitrary GetResourceAttributes_result where 
  arbitrary = M.liftM GetResourceAttributes_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetResourceAttributes_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetResourceAttributes_result{getResourceAttributes_result_success = getResourceAttributes_result_success obj} then P.Nothing else P.Just $ default_GetResourceAttributes_result{getResourceAttributes_result_success = getResourceAttributes_result_success obj}
    , if obj == default_GetResourceAttributes_result{getResourceAttributes_result_userException = getResourceAttributes_result_userException obj} then P.Nothing else P.Just $ default_GetResourceAttributes_result{getResourceAttributes_result_userException = getResourceAttributes_result_userException obj}
    , if obj == default_GetResourceAttributes_result{getResourceAttributes_result_systemException = getResourceAttributes_result_systemException obj} then P.Nothing else P.Just $ default_GetResourceAttributes_result{getResourceAttributes_result_systemException = getResourceAttributes_result_systemException obj}
    , if obj == default_GetResourceAttributes_result{getResourceAttributes_result_notFoundException = getResourceAttributes_result_notFoundException obj} then P.Nothing else P.Just $ default_GetResourceAttributes_result{getResourceAttributes_result_notFoundException = getResourceAttributes_result_notFoundException obj}
    ]
from_GetResourceAttributes_result :: GetResourceAttributes_result -> T.ThriftVal
from_GetResourceAttributes_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v1452 -> (1, ("userException",Errors_Types.from_EDAMUserException _v1452))) <$> getResourceAttributes_result_userException record, (\_v1452 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v1452))) <$> getResourceAttributes_result_systemException record, (\_v1452 -> (3, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v1452))) <$> getResourceAttributes_result_notFoundException record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v1452 -> P.Just (0, ("success",Types_Types.from_ResourceAttributes _v1452))) $ getResourceAttributes_result_success record
    , (\_v1452 -> (1, ("userException",Errors_Types.from_EDAMUserException _v1452))) <$> getResourceAttributes_result_userException record
    , (\_v1452 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v1452))) <$> getResourceAttributes_result_systemException record
    , (\_v1452 -> (3, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v1452))) <$> getResourceAttributes_result_notFoundException record
    ]
    )
write_GetResourceAttributes_result :: T.Protocol p => p -> GetResourceAttributes_result -> P.IO ()
write_GetResourceAttributes_result oprot record = T.writeVal oprot $ from_GetResourceAttributes_result record
encode_GetResourceAttributes_result :: T.StatelessProtocol p => p -> GetResourceAttributes_result -> LBS.ByteString
encode_GetResourceAttributes_result oprot record = T.serializeVal oprot $ from_GetResourceAttributes_result record
to_GetResourceAttributes_result :: T.ThriftVal -> GetResourceAttributes_result
to_GetResourceAttributes_result (T.TStruct fields) = GetResourceAttributes_result{
  getResourceAttributes_result_success = P.maybe (getResourceAttributes_result_success default_GetResourceAttributes_result) (\(_,_val1454) -> (case _val1454 of {T.TStruct _val1455 -> (Types_Types.to_ResourceAttributes (T.TStruct _val1455)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getResourceAttributes_result_userException = P.maybe (P.Nothing) (\(_,_val1454) -> P.Just (case _val1454 of {T.TStruct _val1456 -> (Errors_Types.to_EDAMUserException (T.TStruct _val1456)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  getResourceAttributes_result_systemException = P.maybe (P.Nothing) (\(_,_val1454) -> P.Just (case _val1454 of {T.TStruct _val1457 -> (Errors_Types.to_EDAMSystemException (T.TStruct _val1457)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  getResourceAttributes_result_notFoundException = P.maybe (P.Nothing) (\(_,_val1454) -> P.Just (case _val1454 of {T.TStruct _val1458 -> (Errors_Types.to_EDAMNotFoundException (T.TStruct _val1458)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_GetResourceAttributes_result _ = P.error "not a struct"
read_GetResourceAttributes_result :: T.Protocol p => p -> P.IO GetResourceAttributes_result
read_GetResourceAttributes_result iprot = to_GetResourceAttributes_result <$> T.readVal iprot (T.T_STRUCT typemap_GetResourceAttributes_result)
decode_GetResourceAttributes_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetResourceAttributes_result
decode_GetResourceAttributes_result iprot bs = to_GetResourceAttributes_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetResourceAttributes_result) bs
typemap_GetResourceAttributes_result :: T.TypeMap
typemap_GetResourceAttributes_result = Map.fromList [(0,("success",(T.T_STRUCT Types_Types.typemap_ResourceAttributes))),(1,("userException",(T.T_STRUCT Errors_Types.typemap_EDAMUserException))),(2,("systemException",(T.T_STRUCT Errors_Types.typemap_EDAMSystemException))),(3,("notFoundException",(T.T_STRUCT Errors_Types.typemap_EDAMNotFoundException)))]
default_GetResourceAttributes_result :: GetResourceAttributes_result
default_GetResourceAttributes_result = GetResourceAttributes_result{
  getResourceAttributes_result_success = Types_Types.default_ResourceAttributes,
  getResourceAttributes_result_userException = P.Nothing,
  getResourceAttributes_result_systemException = P.Nothing,
  getResourceAttributes_result_notFoundException = P.Nothing}
data GetPublicNotebook_args = GetPublicNotebook_args  { getPublicNotebook_args_userId :: I.Int32
  , getPublicNotebook_args_publicUri :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetPublicNotebook_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getPublicNotebook_args_userId record   `H.hashWithSalt` getPublicNotebook_args_publicUri record  
instance QC.Arbitrary GetPublicNotebook_args where 
  arbitrary = M.liftM GetPublicNotebook_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GetPublicNotebook_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetPublicNotebook_args{getPublicNotebook_args_userId = getPublicNotebook_args_userId obj} then P.Nothing else P.Just $ default_GetPublicNotebook_args{getPublicNotebook_args_userId = getPublicNotebook_args_userId obj}
    , if obj == default_GetPublicNotebook_args{getPublicNotebook_args_publicUri = getPublicNotebook_args_publicUri obj} then P.Nothing else P.Just $ default_GetPublicNotebook_args{getPublicNotebook_args_publicUri = getPublicNotebook_args_publicUri obj}
    ]
from_GetPublicNotebook_args :: GetPublicNotebook_args -> T.ThriftVal
from_GetPublicNotebook_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1461 -> P.Just (1, ("userId",T.TI32 _v1461))) $ getPublicNotebook_args_userId record
  , (\_v1461 -> P.Just (2, ("publicUri",T.TString $ E.encodeUtf8 _v1461))) $ getPublicNotebook_args_publicUri record
  ]
write_GetPublicNotebook_args :: T.Protocol p => p -> GetPublicNotebook_args -> P.IO ()
write_GetPublicNotebook_args oprot record = T.writeVal oprot $ from_GetPublicNotebook_args record
encode_GetPublicNotebook_args :: T.StatelessProtocol p => p -> GetPublicNotebook_args -> LBS.ByteString
encode_GetPublicNotebook_args oprot record = T.serializeVal oprot $ from_GetPublicNotebook_args record
to_GetPublicNotebook_args :: T.ThriftVal -> GetPublicNotebook_args
to_GetPublicNotebook_args (T.TStruct fields) = GetPublicNotebook_args{
  getPublicNotebook_args_userId = P.maybe (getPublicNotebook_args_userId default_GetPublicNotebook_args) (\(_,_val1463) -> (case _val1463 of {T.TI32 _val1464 -> _val1464; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  getPublicNotebook_args_publicUri = P.maybe (getPublicNotebook_args_publicUri default_GetPublicNotebook_args) (\(_,_val1463) -> (case _val1463 of {T.TString _val1465 -> E.decodeUtf8 _val1465; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_GetPublicNotebook_args _ = P.error "not a struct"
read_GetPublicNotebook_args :: T.Protocol p => p -> P.IO GetPublicNotebook_args
read_GetPublicNotebook_args iprot = to_GetPublicNotebook_args <$> T.readVal iprot (T.T_STRUCT typemap_GetPublicNotebook_args)
decode_GetPublicNotebook_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetPublicNotebook_args
decode_GetPublicNotebook_args iprot bs = to_GetPublicNotebook_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetPublicNotebook_args) bs
typemap_GetPublicNotebook_args :: T.TypeMap
typemap_GetPublicNotebook_args = Map.fromList [(1,("userId",T.T_I32)),(2,("publicUri",T.T_STRING))]
default_GetPublicNotebook_args :: GetPublicNotebook_args
default_GetPublicNotebook_args = GetPublicNotebook_args{
  getPublicNotebook_args_userId = 0,
  getPublicNotebook_args_publicUri = ""}
data GetPublicNotebook_result = GetPublicNotebook_result  { getPublicNotebook_result_success :: Types_Types.Notebook
  , getPublicNotebook_result_systemException :: P.Maybe Errors_Types.EDAMSystemException
  , getPublicNotebook_result_notFoundException :: P.Maybe Errors_Types.EDAMNotFoundException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetPublicNotebook_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getPublicNotebook_result_success record   `H.hashWithSalt` getPublicNotebook_result_systemException record   `H.hashWithSalt` getPublicNotebook_result_notFoundException record  
instance QC.Arbitrary GetPublicNotebook_result where 
  arbitrary = M.liftM GetPublicNotebook_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetPublicNotebook_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetPublicNotebook_result{getPublicNotebook_result_success = getPublicNotebook_result_success obj} then P.Nothing else P.Just $ default_GetPublicNotebook_result{getPublicNotebook_result_success = getPublicNotebook_result_success obj}
    , if obj == default_GetPublicNotebook_result{getPublicNotebook_result_systemException = getPublicNotebook_result_systemException obj} then P.Nothing else P.Just $ default_GetPublicNotebook_result{getPublicNotebook_result_systemException = getPublicNotebook_result_systemException obj}
    , if obj == default_GetPublicNotebook_result{getPublicNotebook_result_notFoundException = getPublicNotebook_result_notFoundException obj} then P.Nothing else P.Just $ default_GetPublicNotebook_result{getPublicNotebook_result_notFoundException = getPublicNotebook_result_notFoundException obj}
    ]
from_GetPublicNotebook_result :: GetPublicNotebook_result -> T.ThriftVal
from_GetPublicNotebook_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v1468 -> (1, ("systemException",Errors_Types.from_EDAMSystemException _v1468))) <$> getPublicNotebook_result_systemException record, (\_v1468 -> (2, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v1468))) <$> getPublicNotebook_result_notFoundException record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v1468 -> P.Just (0, ("success",Types_Types.from_Notebook _v1468))) $ getPublicNotebook_result_success record
    , (\_v1468 -> (1, ("systemException",Errors_Types.from_EDAMSystemException _v1468))) <$> getPublicNotebook_result_systemException record
    , (\_v1468 -> (2, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v1468))) <$> getPublicNotebook_result_notFoundException record
    ]
    )
write_GetPublicNotebook_result :: T.Protocol p => p -> GetPublicNotebook_result -> P.IO ()
write_GetPublicNotebook_result oprot record = T.writeVal oprot $ from_GetPublicNotebook_result record
encode_GetPublicNotebook_result :: T.StatelessProtocol p => p -> GetPublicNotebook_result -> LBS.ByteString
encode_GetPublicNotebook_result oprot record = T.serializeVal oprot $ from_GetPublicNotebook_result record
to_GetPublicNotebook_result :: T.ThriftVal -> GetPublicNotebook_result
to_GetPublicNotebook_result (T.TStruct fields) = GetPublicNotebook_result{
  getPublicNotebook_result_success = P.maybe (getPublicNotebook_result_success default_GetPublicNotebook_result) (\(_,_val1470) -> (case _val1470 of {T.TStruct _val1471 -> (Types_Types.to_Notebook (T.TStruct _val1471)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getPublicNotebook_result_systemException = P.maybe (P.Nothing) (\(_,_val1470) -> P.Just (case _val1470 of {T.TStruct _val1472 -> (Errors_Types.to_EDAMSystemException (T.TStruct _val1472)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  getPublicNotebook_result_notFoundException = P.maybe (P.Nothing) (\(_,_val1470) -> P.Just (case _val1470 of {T.TStruct _val1473 -> (Errors_Types.to_EDAMNotFoundException (T.TStruct _val1473)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_GetPublicNotebook_result _ = P.error "not a struct"
read_GetPublicNotebook_result :: T.Protocol p => p -> P.IO GetPublicNotebook_result
read_GetPublicNotebook_result iprot = to_GetPublicNotebook_result <$> T.readVal iprot (T.T_STRUCT typemap_GetPublicNotebook_result)
decode_GetPublicNotebook_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetPublicNotebook_result
decode_GetPublicNotebook_result iprot bs = to_GetPublicNotebook_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetPublicNotebook_result) bs
typemap_GetPublicNotebook_result :: T.TypeMap
typemap_GetPublicNotebook_result = Map.fromList [(0,("success",(T.T_STRUCT Types_Types.typemap_Notebook))),(1,("systemException",(T.T_STRUCT Errors_Types.typemap_EDAMSystemException))),(2,("notFoundException",(T.T_STRUCT Errors_Types.typemap_EDAMNotFoundException)))]
default_GetPublicNotebook_result :: GetPublicNotebook_result
default_GetPublicNotebook_result = GetPublicNotebook_result{
  getPublicNotebook_result_success = Types_Types.default_Notebook,
  getPublicNotebook_result_systemException = P.Nothing,
  getPublicNotebook_result_notFoundException = P.Nothing}
data ShareNotebook_args = ShareNotebook_args  { shareNotebook_args_authenticationToken :: LT.Text
  , shareNotebook_args_sharedNotebook :: Types_Types.SharedNotebook
  , shareNotebook_args_message :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ShareNotebook_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` shareNotebook_args_authenticationToken record   `H.hashWithSalt` shareNotebook_args_sharedNotebook record   `H.hashWithSalt` shareNotebook_args_message record  
instance QC.Arbitrary ShareNotebook_args where 
  arbitrary = M.liftM ShareNotebook_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_ShareNotebook_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ShareNotebook_args{shareNotebook_args_authenticationToken = shareNotebook_args_authenticationToken obj} then P.Nothing else P.Just $ default_ShareNotebook_args{shareNotebook_args_authenticationToken = shareNotebook_args_authenticationToken obj}
    , if obj == default_ShareNotebook_args{shareNotebook_args_sharedNotebook = shareNotebook_args_sharedNotebook obj} then P.Nothing else P.Just $ default_ShareNotebook_args{shareNotebook_args_sharedNotebook = shareNotebook_args_sharedNotebook obj}
    , if obj == default_ShareNotebook_args{shareNotebook_args_message = shareNotebook_args_message obj} then P.Nothing else P.Just $ default_ShareNotebook_args{shareNotebook_args_message = shareNotebook_args_message obj}
    ]
from_ShareNotebook_args :: ShareNotebook_args -> T.ThriftVal
from_ShareNotebook_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1476 -> P.Just (1, ("authenticationToken",T.TString $ E.encodeUtf8 _v1476))) $ shareNotebook_args_authenticationToken record
  , (\_v1476 -> P.Just (2, ("sharedNotebook",Types_Types.from_SharedNotebook _v1476))) $ shareNotebook_args_sharedNotebook record
  , (\_v1476 -> P.Just (3, ("message",T.TString $ E.encodeUtf8 _v1476))) $ shareNotebook_args_message record
  ]
write_ShareNotebook_args :: T.Protocol p => p -> ShareNotebook_args -> P.IO ()
write_ShareNotebook_args oprot record = T.writeVal oprot $ from_ShareNotebook_args record
encode_ShareNotebook_args :: T.StatelessProtocol p => p -> ShareNotebook_args -> LBS.ByteString
encode_ShareNotebook_args oprot record = T.serializeVal oprot $ from_ShareNotebook_args record
to_ShareNotebook_args :: T.ThriftVal -> ShareNotebook_args
to_ShareNotebook_args (T.TStruct fields) = ShareNotebook_args{
  shareNotebook_args_authenticationToken = P.maybe (shareNotebook_args_authenticationToken default_ShareNotebook_args) (\(_,_val1478) -> (case _val1478 of {T.TString _val1479 -> E.decodeUtf8 _val1479; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  shareNotebook_args_sharedNotebook = P.maybe (shareNotebook_args_sharedNotebook default_ShareNotebook_args) (\(_,_val1478) -> (case _val1478 of {T.TStruct _val1480 -> (Types_Types.to_SharedNotebook (T.TStruct _val1480)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  shareNotebook_args_message = P.maybe (shareNotebook_args_message default_ShareNotebook_args) (\(_,_val1478) -> (case _val1478 of {T.TString _val1481 -> E.decodeUtf8 _val1481; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_ShareNotebook_args _ = P.error "not a struct"
read_ShareNotebook_args :: T.Protocol p => p -> P.IO ShareNotebook_args
read_ShareNotebook_args iprot = to_ShareNotebook_args <$> T.readVal iprot (T.T_STRUCT typemap_ShareNotebook_args)
decode_ShareNotebook_args :: T.StatelessProtocol p => p -> LBS.ByteString -> ShareNotebook_args
decode_ShareNotebook_args iprot bs = to_ShareNotebook_args $ T.deserializeVal iprot (T.T_STRUCT typemap_ShareNotebook_args) bs
typemap_ShareNotebook_args :: T.TypeMap
typemap_ShareNotebook_args = Map.fromList [(1,("authenticationToken",T.T_STRING)),(2,("sharedNotebook",(T.T_STRUCT Types_Types.typemap_SharedNotebook))),(3,("message",T.T_STRING))]
default_ShareNotebook_args :: ShareNotebook_args
default_ShareNotebook_args = ShareNotebook_args{
  shareNotebook_args_authenticationToken = "",
  shareNotebook_args_sharedNotebook = Types_Types.default_SharedNotebook,
  shareNotebook_args_message = ""}
data ShareNotebook_result = ShareNotebook_result  { shareNotebook_result_success :: Types_Types.SharedNotebook
  , shareNotebook_result_userException :: P.Maybe Errors_Types.EDAMUserException
  , shareNotebook_result_notFoundException :: P.Maybe Errors_Types.EDAMNotFoundException
  , shareNotebook_result_systemException :: P.Maybe Errors_Types.EDAMSystemException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ShareNotebook_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` shareNotebook_result_success record   `H.hashWithSalt` shareNotebook_result_userException record   `H.hashWithSalt` shareNotebook_result_notFoundException record   `H.hashWithSalt` shareNotebook_result_systemException record  
instance QC.Arbitrary ShareNotebook_result where 
  arbitrary = M.liftM ShareNotebook_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_ShareNotebook_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ShareNotebook_result{shareNotebook_result_success = shareNotebook_result_success obj} then P.Nothing else P.Just $ default_ShareNotebook_result{shareNotebook_result_success = shareNotebook_result_success obj}
    , if obj == default_ShareNotebook_result{shareNotebook_result_userException = shareNotebook_result_userException obj} then P.Nothing else P.Just $ default_ShareNotebook_result{shareNotebook_result_userException = shareNotebook_result_userException obj}
    , if obj == default_ShareNotebook_result{shareNotebook_result_notFoundException = shareNotebook_result_notFoundException obj} then P.Nothing else P.Just $ default_ShareNotebook_result{shareNotebook_result_notFoundException = shareNotebook_result_notFoundException obj}
    , if obj == default_ShareNotebook_result{shareNotebook_result_systemException = shareNotebook_result_systemException obj} then P.Nothing else P.Just $ default_ShareNotebook_result{shareNotebook_result_systemException = shareNotebook_result_systemException obj}
    ]
from_ShareNotebook_result :: ShareNotebook_result -> T.ThriftVal
from_ShareNotebook_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v1484 -> (1, ("userException",Errors_Types.from_EDAMUserException _v1484))) <$> shareNotebook_result_userException record, (\_v1484 -> (2, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v1484))) <$> shareNotebook_result_notFoundException record, (\_v1484 -> (3, ("systemException",Errors_Types.from_EDAMSystemException _v1484))) <$> shareNotebook_result_systemException record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v1484 -> P.Just (0, ("success",Types_Types.from_SharedNotebook _v1484))) $ shareNotebook_result_success record
    , (\_v1484 -> (1, ("userException",Errors_Types.from_EDAMUserException _v1484))) <$> shareNotebook_result_userException record
    , (\_v1484 -> (2, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v1484))) <$> shareNotebook_result_notFoundException record
    , (\_v1484 -> (3, ("systemException",Errors_Types.from_EDAMSystemException _v1484))) <$> shareNotebook_result_systemException record
    ]
    )
write_ShareNotebook_result :: T.Protocol p => p -> ShareNotebook_result -> P.IO ()
write_ShareNotebook_result oprot record = T.writeVal oprot $ from_ShareNotebook_result record
encode_ShareNotebook_result :: T.StatelessProtocol p => p -> ShareNotebook_result -> LBS.ByteString
encode_ShareNotebook_result oprot record = T.serializeVal oprot $ from_ShareNotebook_result record
to_ShareNotebook_result :: T.ThriftVal -> ShareNotebook_result
to_ShareNotebook_result (T.TStruct fields) = ShareNotebook_result{
  shareNotebook_result_success = P.maybe (shareNotebook_result_success default_ShareNotebook_result) (\(_,_val1486) -> (case _val1486 of {T.TStruct _val1487 -> (Types_Types.to_SharedNotebook (T.TStruct _val1487)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  shareNotebook_result_userException = P.maybe (P.Nothing) (\(_,_val1486) -> P.Just (case _val1486 of {T.TStruct _val1488 -> (Errors_Types.to_EDAMUserException (T.TStruct _val1488)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  shareNotebook_result_notFoundException = P.maybe (P.Nothing) (\(_,_val1486) -> P.Just (case _val1486 of {T.TStruct _val1489 -> (Errors_Types.to_EDAMNotFoundException (T.TStruct _val1489)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  shareNotebook_result_systemException = P.maybe (P.Nothing) (\(_,_val1486) -> P.Just (case _val1486 of {T.TStruct _val1490 -> (Errors_Types.to_EDAMSystemException (T.TStruct _val1490)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_ShareNotebook_result _ = P.error "not a struct"
read_ShareNotebook_result :: T.Protocol p => p -> P.IO ShareNotebook_result
read_ShareNotebook_result iprot = to_ShareNotebook_result <$> T.readVal iprot (T.T_STRUCT typemap_ShareNotebook_result)
decode_ShareNotebook_result :: T.StatelessProtocol p => p -> LBS.ByteString -> ShareNotebook_result
decode_ShareNotebook_result iprot bs = to_ShareNotebook_result $ T.deserializeVal iprot (T.T_STRUCT typemap_ShareNotebook_result) bs
typemap_ShareNotebook_result :: T.TypeMap
typemap_ShareNotebook_result = Map.fromList [(0,("success",(T.T_STRUCT Types_Types.typemap_SharedNotebook))),(1,("userException",(T.T_STRUCT Errors_Types.typemap_EDAMUserException))),(2,("notFoundException",(T.T_STRUCT Errors_Types.typemap_EDAMNotFoundException))),(3,("systemException",(T.T_STRUCT Errors_Types.typemap_EDAMSystemException)))]
default_ShareNotebook_result :: ShareNotebook_result
default_ShareNotebook_result = ShareNotebook_result{
  shareNotebook_result_success = Types_Types.default_SharedNotebook,
  shareNotebook_result_userException = P.Nothing,
  shareNotebook_result_notFoundException = P.Nothing,
  shareNotebook_result_systemException = P.Nothing}
data CreateOrUpdateNotebookShares_args = CreateOrUpdateNotebookShares_args  { createOrUpdateNotebookShares_args_authenticationToken :: LT.Text
  , createOrUpdateNotebookShares_args_shareTemplate :: NotebookShareTemplate
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable CreateOrUpdateNotebookShares_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` createOrUpdateNotebookShares_args_authenticationToken record   `H.hashWithSalt` createOrUpdateNotebookShares_args_shareTemplate record  
instance QC.Arbitrary CreateOrUpdateNotebookShares_args where 
  arbitrary = M.liftM CreateOrUpdateNotebookShares_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_CreateOrUpdateNotebookShares_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_CreateOrUpdateNotebookShares_args{createOrUpdateNotebookShares_args_authenticationToken = createOrUpdateNotebookShares_args_authenticationToken obj} then P.Nothing else P.Just $ default_CreateOrUpdateNotebookShares_args{createOrUpdateNotebookShares_args_authenticationToken = createOrUpdateNotebookShares_args_authenticationToken obj}
    , if obj == default_CreateOrUpdateNotebookShares_args{createOrUpdateNotebookShares_args_shareTemplate = createOrUpdateNotebookShares_args_shareTemplate obj} then P.Nothing else P.Just $ default_CreateOrUpdateNotebookShares_args{createOrUpdateNotebookShares_args_shareTemplate = createOrUpdateNotebookShares_args_shareTemplate obj}
    ]
from_CreateOrUpdateNotebookShares_args :: CreateOrUpdateNotebookShares_args -> T.ThriftVal
from_CreateOrUpdateNotebookShares_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1493 -> P.Just (1, ("authenticationToken",T.TString $ E.encodeUtf8 _v1493))) $ createOrUpdateNotebookShares_args_authenticationToken record
  , (\_v1493 -> P.Just (2, ("shareTemplate",from_NotebookShareTemplate _v1493))) $ createOrUpdateNotebookShares_args_shareTemplate record
  ]
write_CreateOrUpdateNotebookShares_args :: T.Protocol p => p -> CreateOrUpdateNotebookShares_args -> P.IO ()
write_CreateOrUpdateNotebookShares_args oprot record = T.writeVal oprot $ from_CreateOrUpdateNotebookShares_args record
encode_CreateOrUpdateNotebookShares_args :: T.StatelessProtocol p => p -> CreateOrUpdateNotebookShares_args -> LBS.ByteString
encode_CreateOrUpdateNotebookShares_args oprot record = T.serializeVal oprot $ from_CreateOrUpdateNotebookShares_args record
to_CreateOrUpdateNotebookShares_args :: T.ThriftVal -> CreateOrUpdateNotebookShares_args
to_CreateOrUpdateNotebookShares_args (T.TStruct fields) = CreateOrUpdateNotebookShares_args{
  createOrUpdateNotebookShares_args_authenticationToken = P.maybe (createOrUpdateNotebookShares_args_authenticationToken default_CreateOrUpdateNotebookShares_args) (\(_,_val1495) -> (case _val1495 of {T.TString _val1496 -> E.decodeUtf8 _val1496; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  createOrUpdateNotebookShares_args_shareTemplate = P.maybe (createOrUpdateNotebookShares_args_shareTemplate default_CreateOrUpdateNotebookShares_args) (\(_,_val1495) -> (case _val1495 of {T.TStruct _val1497 -> (to_NotebookShareTemplate (T.TStruct _val1497)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_CreateOrUpdateNotebookShares_args _ = P.error "not a struct"
read_CreateOrUpdateNotebookShares_args :: T.Protocol p => p -> P.IO CreateOrUpdateNotebookShares_args
read_CreateOrUpdateNotebookShares_args iprot = to_CreateOrUpdateNotebookShares_args <$> T.readVal iprot (T.T_STRUCT typemap_CreateOrUpdateNotebookShares_args)
decode_CreateOrUpdateNotebookShares_args :: T.StatelessProtocol p => p -> LBS.ByteString -> CreateOrUpdateNotebookShares_args
decode_CreateOrUpdateNotebookShares_args iprot bs = to_CreateOrUpdateNotebookShares_args $ T.deserializeVal iprot (T.T_STRUCT typemap_CreateOrUpdateNotebookShares_args) bs
typemap_CreateOrUpdateNotebookShares_args :: T.TypeMap
typemap_CreateOrUpdateNotebookShares_args = Map.fromList [(1,("authenticationToken",T.T_STRING)),(2,("shareTemplate",(T.T_STRUCT typemap_NotebookShareTemplate)))]
default_CreateOrUpdateNotebookShares_args :: CreateOrUpdateNotebookShares_args
default_CreateOrUpdateNotebookShares_args = CreateOrUpdateNotebookShares_args{
  createOrUpdateNotebookShares_args_authenticationToken = "",
  createOrUpdateNotebookShares_args_shareTemplate = default_NotebookShareTemplate}
data CreateOrUpdateNotebookShares_result = CreateOrUpdateNotebookShares_result  { createOrUpdateNotebookShares_result_success :: CreateOrUpdateNotebookSharesResult
  , createOrUpdateNotebookShares_result_userException :: P.Maybe Errors_Types.EDAMUserException
  , createOrUpdateNotebookShares_result_notFoundException :: P.Maybe Errors_Types.EDAMNotFoundException
  , createOrUpdateNotebookShares_result_systemException :: P.Maybe Errors_Types.EDAMSystemException
  , createOrUpdateNotebookShares_result_invalidContactsException :: P.Maybe Errors_Types.EDAMInvalidContactsException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable CreateOrUpdateNotebookShares_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` createOrUpdateNotebookShares_result_success record   `H.hashWithSalt` createOrUpdateNotebookShares_result_userException record   `H.hashWithSalt` createOrUpdateNotebookShares_result_notFoundException record   `H.hashWithSalt` createOrUpdateNotebookShares_result_systemException record   `H.hashWithSalt` createOrUpdateNotebookShares_result_invalidContactsException record  
instance QC.Arbitrary CreateOrUpdateNotebookShares_result where 
  arbitrary = M.liftM CreateOrUpdateNotebookShares_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_CreateOrUpdateNotebookShares_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_CreateOrUpdateNotebookShares_result{createOrUpdateNotebookShares_result_success = createOrUpdateNotebookShares_result_success obj} then P.Nothing else P.Just $ default_CreateOrUpdateNotebookShares_result{createOrUpdateNotebookShares_result_success = createOrUpdateNotebookShares_result_success obj}
    , if obj == default_CreateOrUpdateNotebookShares_result{createOrUpdateNotebookShares_result_userException = createOrUpdateNotebookShares_result_userException obj} then P.Nothing else P.Just $ default_CreateOrUpdateNotebookShares_result{createOrUpdateNotebookShares_result_userException = createOrUpdateNotebookShares_result_userException obj}
    , if obj == default_CreateOrUpdateNotebookShares_result{createOrUpdateNotebookShares_result_notFoundException = createOrUpdateNotebookShares_result_notFoundException obj} then P.Nothing else P.Just $ default_CreateOrUpdateNotebookShares_result{createOrUpdateNotebookShares_result_notFoundException = createOrUpdateNotebookShares_result_notFoundException obj}
    , if obj == default_CreateOrUpdateNotebookShares_result{createOrUpdateNotebookShares_result_systemException = createOrUpdateNotebookShares_result_systemException obj} then P.Nothing else P.Just $ default_CreateOrUpdateNotebookShares_result{createOrUpdateNotebookShares_result_systemException = createOrUpdateNotebookShares_result_systemException obj}
    , if obj == default_CreateOrUpdateNotebookShares_result{createOrUpdateNotebookShares_result_invalidContactsException = createOrUpdateNotebookShares_result_invalidContactsException obj} then P.Nothing else P.Just $ default_CreateOrUpdateNotebookShares_result{createOrUpdateNotebookShares_result_invalidContactsException = createOrUpdateNotebookShares_result_invalidContactsException obj}
    ]
from_CreateOrUpdateNotebookShares_result :: CreateOrUpdateNotebookShares_result -> T.ThriftVal
from_CreateOrUpdateNotebookShares_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v1500 -> (1, ("userException",Errors_Types.from_EDAMUserException _v1500))) <$> createOrUpdateNotebookShares_result_userException record, (\_v1500 -> (2, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v1500))) <$> createOrUpdateNotebookShares_result_notFoundException record, (\_v1500 -> (3, ("systemException",Errors_Types.from_EDAMSystemException _v1500))) <$> createOrUpdateNotebookShares_result_systemException record, (\_v1500 -> (4, ("invalidContactsException",Errors_Types.from_EDAMInvalidContactsException _v1500))) <$> createOrUpdateNotebookShares_result_invalidContactsException record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v1500 -> P.Just (0, ("success",from_CreateOrUpdateNotebookSharesResult _v1500))) $ createOrUpdateNotebookShares_result_success record
    , (\_v1500 -> (1, ("userException",Errors_Types.from_EDAMUserException _v1500))) <$> createOrUpdateNotebookShares_result_userException record
    , (\_v1500 -> (2, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v1500))) <$> createOrUpdateNotebookShares_result_notFoundException record
    , (\_v1500 -> (3, ("systemException",Errors_Types.from_EDAMSystemException _v1500))) <$> createOrUpdateNotebookShares_result_systemException record
    , (\_v1500 -> (4, ("invalidContactsException",Errors_Types.from_EDAMInvalidContactsException _v1500))) <$> createOrUpdateNotebookShares_result_invalidContactsException record
    ]
    )
write_CreateOrUpdateNotebookShares_result :: T.Protocol p => p -> CreateOrUpdateNotebookShares_result -> P.IO ()
write_CreateOrUpdateNotebookShares_result oprot record = T.writeVal oprot $ from_CreateOrUpdateNotebookShares_result record
encode_CreateOrUpdateNotebookShares_result :: T.StatelessProtocol p => p -> CreateOrUpdateNotebookShares_result -> LBS.ByteString
encode_CreateOrUpdateNotebookShares_result oprot record = T.serializeVal oprot $ from_CreateOrUpdateNotebookShares_result record
to_CreateOrUpdateNotebookShares_result :: T.ThriftVal -> CreateOrUpdateNotebookShares_result
to_CreateOrUpdateNotebookShares_result (T.TStruct fields) = CreateOrUpdateNotebookShares_result{
  createOrUpdateNotebookShares_result_success = P.maybe (createOrUpdateNotebookShares_result_success default_CreateOrUpdateNotebookShares_result) (\(_,_val1502) -> (case _val1502 of {T.TStruct _val1503 -> (to_CreateOrUpdateNotebookSharesResult (T.TStruct _val1503)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  createOrUpdateNotebookShares_result_userException = P.maybe (P.Nothing) (\(_,_val1502) -> P.Just (case _val1502 of {T.TStruct _val1504 -> (Errors_Types.to_EDAMUserException (T.TStruct _val1504)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  createOrUpdateNotebookShares_result_notFoundException = P.maybe (P.Nothing) (\(_,_val1502) -> P.Just (case _val1502 of {T.TStruct _val1505 -> (Errors_Types.to_EDAMNotFoundException (T.TStruct _val1505)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  createOrUpdateNotebookShares_result_systemException = P.maybe (P.Nothing) (\(_,_val1502) -> P.Just (case _val1502 of {T.TStruct _val1506 -> (Errors_Types.to_EDAMSystemException (T.TStruct _val1506)); _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  createOrUpdateNotebookShares_result_invalidContactsException = P.maybe (P.Nothing) (\(_,_val1502) -> P.Just (case _val1502 of {T.TStruct _val1507 -> (Errors_Types.to_EDAMInvalidContactsException (T.TStruct _val1507)); _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_CreateOrUpdateNotebookShares_result _ = P.error "not a struct"
read_CreateOrUpdateNotebookShares_result :: T.Protocol p => p -> P.IO CreateOrUpdateNotebookShares_result
read_CreateOrUpdateNotebookShares_result iprot = to_CreateOrUpdateNotebookShares_result <$> T.readVal iprot (T.T_STRUCT typemap_CreateOrUpdateNotebookShares_result)
decode_CreateOrUpdateNotebookShares_result :: T.StatelessProtocol p => p -> LBS.ByteString -> CreateOrUpdateNotebookShares_result
decode_CreateOrUpdateNotebookShares_result iprot bs = to_CreateOrUpdateNotebookShares_result $ T.deserializeVal iprot (T.T_STRUCT typemap_CreateOrUpdateNotebookShares_result) bs
typemap_CreateOrUpdateNotebookShares_result :: T.TypeMap
typemap_CreateOrUpdateNotebookShares_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_CreateOrUpdateNotebookSharesResult))),(1,("userException",(T.T_STRUCT Errors_Types.typemap_EDAMUserException))),(2,("notFoundException",(T.T_STRUCT Errors_Types.typemap_EDAMNotFoundException))),(3,("systemException",(T.T_STRUCT Errors_Types.typemap_EDAMSystemException))),(4,("invalidContactsException",(T.T_STRUCT Errors_Types.typemap_EDAMInvalidContactsException)))]
default_CreateOrUpdateNotebookShares_result :: CreateOrUpdateNotebookShares_result
default_CreateOrUpdateNotebookShares_result = CreateOrUpdateNotebookShares_result{
  createOrUpdateNotebookShares_result_success = default_CreateOrUpdateNotebookSharesResult,
  createOrUpdateNotebookShares_result_userException = P.Nothing,
  createOrUpdateNotebookShares_result_notFoundException = P.Nothing,
  createOrUpdateNotebookShares_result_systemException = P.Nothing,
  createOrUpdateNotebookShares_result_invalidContactsException = P.Nothing}
data UpdateSharedNotebook_args = UpdateSharedNotebook_args  { updateSharedNotebook_args_authenticationToken :: LT.Text
  , updateSharedNotebook_args_sharedNotebook :: Types_Types.SharedNotebook
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateSharedNotebook_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateSharedNotebook_args_authenticationToken record   `H.hashWithSalt` updateSharedNotebook_args_sharedNotebook record  
instance QC.Arbitrary UpdateSharedNotebook_args where 
  arbitrary = M.liftM UpdateSharedNotebook_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_UpdateSharedNotebook_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateSharedNotebook_args{updateSharedNotebook_args_authenticationToken = updateSharedNotebook_args_authenticationToken obj} then P.Nothing else P.Just $ default_UpdateSharedNotebook_args{updateSharedNotebook_args_authenticationToken = updateSharedNotebook_args_authenticationToken obj}
    , if obj == default_UpdateSharedNotebook_args{updateSharedNotebook_args_sharedNotebook = updateSharedNotebook_args_sharedNotebook obj} then P.Nothing else P.Just $ default_UpdateSharedNotebook_args{updateSharedNotebook_args_sharedNotebook = updateSharedNotebook_args_sharedNotebook obj}
    ]
from_UpdateSharedNotebook_args :: UpdateSharedNotebook_args -> T.ThriftVal
from_UpdateSharedNotebook_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1510 -> P.Just (1, ("authenticationToken",T.TString $ E.encodeUtf8 _v1510))) $ updateSharedNotebook_args_authenticationToken record
  , (\_v1510 -> P.Just (2, ("sharedNotebook",Types_Types.from_SharedNotebook _v1510))) $ updateSharedNotebook_args_sharedNotebook record
  ]
write_UpdateSharedNotebook_args :: T.Protocol p => p -> UpdateSharedNotebook_args -> P.IO ()
write_UpdateSharedNotebook_args oprot record = T.writeVal oprot $ from_UpdateSharedNotebook_args record
encode_UpdateSharedNotebook_args :: T.StatelessProtocol p => p -> UpdateSharedNotebook_args -> LBS.ByteString
encode_UpdateSharedNotebook_args oprot record = T.serializeVal oprot $ from_UpdateSharedNotebook_args record
to_UpdateSharedNotebook_args :: T.ThriftVal -> UpdateSharedNotebook_args
to_UpdateSharedNotebook_args (T.TStruct fields) = UpdateSharedNotebook_args{
  updateSharedNotebook_args_authenticationToken = P.maybe (updateSharedNotebook_args_authenticationToken default_UpdateSharedNotebook_args) (\(_,_val1512) -> (case _val1512 of {T.TString _val1513 -> E.decodeUtf8 _val1513; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  updateSharedNotebook_args_sharedNotebook = P.maybe (updateSharedNotebook_args_sharedNotebook default_UpdateSharedNotebook_args) (\(_,_val1512) -> (case _val1512 of {T.TStruct _val1514 -> (Types_Types.to_SharedNotebook (T.TStruct _val1514)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_UpdateSharedNotebook_args _ = P.error "not a struct"
read_UpdateSharedNotebook_args :: T.Protocol p => p -> P.IO UpdateSharedNotebook_args
read_UpdateSharedNotebook_args iprot = to_UpdateSharedNotebook_args <$> T.readVal iprot (T.T_STRUCT typemap_UpdateSharedNotebook_args)
decode_UpdateSharedNotebook_args :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateSharedNotebook_args
decode_UpdateSharedNotebook_args iprot bs = to_UpdateSharedNotebook_args $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateSharedNotebook_args) bs
typemap_UpdateSharedNotebook_args :: T.TypeMap
typemap_UpdateSharedNotebook_args = Map.fromList [(1,("authenticationToken",T.T_STRING)),(2,("sharedNotebook",(T.T_STRUCT Types_Types.typemap_SharedNotebook)))]
default_UpdateSharedNotebook_args :: UpdateSharedNotebook_args
default_UpdateSharedNotebook_args = UpdateSharedNotebook_args{
  updateSharedNotebook_args_authenticationToken = "",
  updateSharedNotebook_args_sharedNotebook = Types_Types.default_SharedNotebook}
data UpdateSharedNotebook_result = UpdateSharedNotebook_result  { updateSharedNotebook_result_success :: I.Int32
  , updateSharedNotebook_result_userException :: P.Maybe Errors_Types.EDAMUserException
  , updateSharedNotebook_result_notFoundException :: P.Maybe Errors_Types.EDAMNotFoundException
  , updateSharedNotebook_result_systemException :: P.Maybe Errors_Types.EDAMSystemException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateSharedNotebook_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateSharedNotebook_result_success record   `H.hashWithSalt` updateSharedNotebook_result_userException record   `H.hashWithSalt` updateSharedNotebook_result_notFoundException record   `H.hashWithSalt` updateSharedNotebook_result_systemException record  
instance QC.Arbitrary UpdateSharedNotebook_result where 
  arbitrary = M.liftM UpdateSharedNotebook_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_UpdateSharedNotebook_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateSharedNotebook_result{updateSharedNotebook_result_success = updateSharedNotebook_result_success obj} then P.Nothing else P.Just $ default_UpdateSharedNotebook_result{updateSharedNotebook_result_success = updateSharedNotebook_result_success obj}
    , if obj == default_UpdateSharedNotebook_result{updateSharedNotebook_result_userException = updateSharedNotebook_result_userException obj} then P.Nothing else P.Just $ default_UpdateSharedNotebook_result{updateSharedNotebook_result_userException = updateSharedNotebook_result_userException obj}
    , if obj == default_UpdateSharedNotebook_result{updateSharedNotebook_result_notFoundException = updateSharedNotebook_result_notFoundException obj} then P.Nothing else P.Just $ default_UpdateSharedNotebook_result{updateSharedNotebook_result_notFoundException = updateSharedNotebook_result_notFoundException obj}
    , if obj == default_UpdateSharedNotebook_result{updateSharedNotebook_result_systemException = updateSharedNotebook_result_systemException obj} then P.Nothing else P.Just $ default_UpdateSharedNotebook_result{updateSharedNotebook_result_systemException = updateSharedNotebook_result_systemException obj}
    ]
from_UpdateSharedNotebook_result :: UpdateSharedNotebook_result -> T.ThriftVal
from_UpdateSharedNotebook_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v1517 -> (1, ("userException",Errors_Types.from_EDAMUserException _v1517))) <$> updateSharedNotebook_result_userException record, (\_v1517 -> (2, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v1517))) <$> updateSharedNotebook_result_notFoundException record, (\_v1517 -> (3, ("systemException",Errors_Types.from_EDAMSystemException _v1517))) <$> updateSharedNotebook_result_systemException record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v1517 -> P.Just (0, ("success",T.TI32 _v1517))) $ updateSharedNotebook_result_success record
    , (\_v1517 -> (1, ("userException",Errors_Types.from_EDAMUserException _v1517))) <$> updateSharedNotebook_result_userException record
    , (\_v1517 -> (2, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v1517))) <$> updateSharedNotebook_result_notFoundException record
    , (\_v1517 -> (3, ("systemException",Errors_Types.from_EDAMSystemException _v1517))) <$> updateSharedNotebook_result_systemException record
    ]
    )
write_UpdateSharedNotebook_result :: T.Protocol p => p -> UpdateSharedNotebook_result -> P.IO ()
write_UpdateSharedNotebook_result oprot record = T.writeVal oprot $ from_UpdateSharedNotebook_result record
encode_UpdateSharedNotebook_result :: T.StatelessProtocol p => p -> UpdateSharedNotebook_result -> LBS.ByteString
encode_UpdateSharedNotebook_result oprot record = T.serializeVal oprot $ from_UpdateSharedNotebook_result record
to_UpdateSharedNotebook_result :: T.ThriftVal -> UpdateSharedNotebook_result
to_UpdateSharedNotebook_result (T.TStruct fields) = UpdateSharedNotebook_result{
  updateSharedNotebook_result_success = P.maybe (updateSharedNotebook_result_success default_UpdateSharedNotebook_result) (\(_,_val1519) -> (case _val1519 of {T.TI32 _val1520 -> _val1520; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  updateSharedNotebook_result_userException = P.maybe (P.Nothing) (\(_,_val1519) -> P.Just (case _val1519 of {T.TStruct _val1521 -> (Errors_Types.to_EDAMUserException (T.TStruct _val1521)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  updateSharedNotebook_result_notFoundException = P.maybe (P.Nothing) (\(_,_val1519) -> P.Just (case _val1519 of {T.TStruct _val1522 -> (Errors_Types.to_EDAMNotFoundException (T.TStruct _val1522)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  updateSharedNotebook_result_systemException = P.maybe (P.Nothing) (\(_,_val1519) -> P.Just (case _val1519 of {T.TStruct _val1523 -> (Errors_Types.to_EDAMSystemException (T.TStruct _val1523)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_UpdateSharedNotebook_result _ = P.error "not a struct"
read_UpdateSharedNotebook_result :: T.Protocol p => p -> P.IO UpdateSharedNotebook_result
read_UpdateSharedNotebook_result iprot = to_UpdateSharedNotebook_result <$> T.readVal iprot (T.T_STRUCT typemap_UpdateSharedNotebook_result)
decode_UpdateSharedNotebook_result :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateSharedNotebook_result
decode_UpdateSharedNotebook_result iprot bs = to_UpdateSharedNotebook_result $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateSharedNotebook_result) bs
typemap_UpdateSharedNotebook_result :: T.TypeMap
typemap_UpdateSharedNotebook_result = Map.fromList [(0,("success",T.T_I32)),(1,("userException",(T.T_STRUCT Errors_Types.typemap_EDAMUserException))),(2,("notFoundException",(T.T_STRUCT Errors_Types.typemap_EDAMNotFoundException))),(3,("systemException",(T.T_STRUCT Errors_Types.typemap_EDAMSystemException)))]
default_UpdateSharedNotebook_result :: UpdateSharedNotebook_result
default_UpdateSharedNotebook_result = UpdateSharedNotebook_result{
  updateSharedNotebook_result_success = 0,
  updateSharedNotebook_result_userException = P.Nothing,
  updateSharedNotebook_result_notFoundException = P.Nothing,
  updateSharedNotebook_result_systemException = P.Nothing}
data SetNotebookRecipientSettings_args = SetNotebookRecipientSettings_args  { setNotebookRecipientSettings_args_authenticationToken :: LT.Text
  , setNotebookRecipientSettings_args_notebookGuid :: LT.Text
  , setNotebookRecipientSettings_args_recipientSettings :: Types_Types.NotebookRecipientSettings
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SetNotebookRecipientSettings_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` setNotebookRecipientSettings_args_authenticationToken record   `H.hashWithSalt` setNotebookRecipientSettings_args_notebookGuid record   `H.hashWithSalt` setNotebookRecipientSettings_args_recipientSettings record  
instance QC.Arbitrary SetNotebookRecipientSettings_args where 
  arbitrary = M.liftM SetNotebookRecipientSettings_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_SetNotebookRecipientSettings_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SetNotebookRecipientSettings_args{setNotebookRecipientSettings_args_authenticationToken = setNotebookRecipientSettings_args_authenticationToken obj} then P.Nothing else P.Just $ default_SetNotebookRecipientSettings_args{setNotebookRecipientSettings_args_authenticationToken = setNotebookRecipientSettings_args_authenticationToken obj}
    , if obj == default_SetNotebookRecipientSettings_args{setNotebookRecipientSettings_args_notebookGuid = setNotebookRecipientSettings_args_notebookGuid obj} then P.Nothing else P.Just $ default_SetNotebookRecipientSettings_args{setNotebookRecipientSettings_args_notebookGuid = setNotebookRecipientSettings_args_notebookGuid obj}
    , if obj == default_SetNotebookRecipientSettings_args{setNotebookRecipientSettings_args_recipientSettings = setNotebookRecipientSettings_args_recipientSettings obj} then P.Nothing else P.Just $ default_SetNotebookRecipientSettings_args{setNotebookRecipientSettings_args_recipientSettings = setNotebookRecipientSettings_args_recipientSettings obj}
    ]
from_SetNotebookRecipientSettings_args :: SetNotebookRecipientSettings_args -> T.ThriftVal
from_SetNotebookRecipientSettings_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1526 -> P.Just (1, ("authenticationToken",T.TString $ E.encodeUtf8 _v1526))) $ setNotebookRecipientSettings_args_authenticationToken record
  , (\_v1526 -> P.Just (2, ("notebookGuid",T.TString $ E.encodeUtf8 _v1526))) $ setNotebookRecipientSettings_args_notebookGuid record
  , (\_v1526 -> P.Just (3, ("recipientSettings",Types_Types.from_NotebookRecipientSettings _v1526))) $ setNotebookRecipientSettings_args_recipientSettings record
  ]
write_SetNotebookRecipientSettings_args :: T.Protocol p => p -> SetNotebookRecipientSettings_args -> P.IO ()
write_SetNotebookRecipientSettings_args oprot record = T.writeVal oprot $ from_SetNotebookRecipientSettings_args record
encode_SetNotebookRecipientSettings_args :: T.StatelessProtocol p => p -> SetNotebookRecipientSettings_args -> LBS.ByteString
encode_SetNotebookRecipientSettings_args oprot record = T.serializeVal oprot $ from_SetNotebookRecipientSettings_args record
to_SetNotebookRecipientSettings_args :: T.ThriftVal -> SetNotebookRecipientSettings_args
to_SetNotebookRecipientSettings_args (T.TStruct fields) = SetNotebookRecipientSettings_args{
  setNotebookRecipientSettings_args_authenticationToken = P.maybe (setNotebookRecipientSettings_args_authenticationToken default_SetNotebookRecipientSettings_args) (\(_,_val1528) -> (case _val1528 of {T.TString _val1529 -> E.decodeUtf8 _val1529; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  setNotebookRecipientSettings_args_notebookGuid = P.maybe (setNotebookRecipientSettings_args_notebookGuid default_SetNotebookRecipientSettings_args) (\(_,_val1528) -> (case _val1528 of {T.TString _val1530 -> E.decodeUtf8 _val1530; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  setNotebookRecipientSettings_args_recipientSettings = P.maybe (setNotebookRecipientSettings_args_recipientSettings default_SetNotebookRecipientSettings_args) (\(_,_val1528) -> (case _val1528 of {T.TStruct _val1531 -> (Types_Types.to_NotebookRecipientSettings (T.TStruct _val1531)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_SetNotebookRecipientSettings_args _ = P.error "not a struct"
read_SetNotebookRecipientSettings_args :: T.Protocol p => p -> P.IO SetNotebookRecipientSettings_args
read_SetNotebookRecipientSettings_args iprot = to_SetNotebookRecipientSettings_args <$> T.readVal iprot (T.T_STRUCT typemap_SetNotebookRecipientSettings_args)
decode_SetNotebookRecipientSettings_args :: T.StatelessProtocol p => p -> LBS.ByteString -> SetNotebookRecipientSettings_args
decode_SetNotebookRecipientSettings_args iprot bs = to_SetNotebookRecipientSettings_args $ T.deserializeVal iprot (T.T_STRUCT typemap_SetNotebookRecipientSettings_args) bs
typemap_SetNotebookRecipientSettings_args :: T.TypeMap
typemap_SetNotebookRecipientSettings_args = Map.fromList [(1,("authenticationToken",T.T_STRING)),(2,("notebookGuid",T.T_STRING)),(3,("recipientSettings",(T.T_STRUCT Types_Types.typemap_NotebookRecipientSettings)))]
default_SetNotebookRecipientSettings_args :: SetNotebookRecipientSettings_args
default_SetNotebookRecipientSettings_args = SetNotebookRecipientSettings_args{
  setNotebookRecipientSettings_args_authenticationToken = "",
  setNotebookRecipientSettings_args_notebookGuid = "",
  setNotebookRecipientSettings_args_recipientSettings = Types_Types.default_NotebookRecipientSettings}
data SetNotebookRecipientSettings_result = SetNotebookRecipientSettings_result  { setNotebookRecipientSettings_result_success :: Types_Types.Notebook
  , setNotebookRecipientSettings_result_userException :: P.Maybe Errors_Types.EDAMUserException
  , setNotebookRecipientSettings_result_notFoundException :: P.Maybe Errors_Types.EDAMNotFoundException
  , setNotebookRecipientSettings_result_systemException :: P.Maybe Errors_Types.EDAMSystemException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SetNotebookRecipientSettings_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` setNotebookRecipientSettings_result_success record   `H.hashWithSalt` setNotebookRecipientSettings_result_userException record   `H.hashWithSalt` setNotebookRecipientSettings_result_notFoundException record   `H.hashWithSalt` setNotebookRecipientSettings_result_systemException record  
instance QC.Arbitrary SetNotebookRecipientSettings_result where 
  arbitrary = M.liftM SetNotebookRecipientSettings_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_SetNotebookRecipientSettings_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SetNotebookRecipientSettings_result{setNotebookRecipientSettings_result_success = setNotebookRecipientSettings_result_success obj} then P.Nothing else P.Just $ default_SetNotebookRecipientSettings_result{setNotebookRecipientSettings_result_success = setNotebookRecipientSettings_result_success obj}
    , if obj == default_SetNotebookRecipientSettings_result{setNotebookRecipientSettings_result_userException = setNotebookRecipientSettings_result_userException obj} then P.Nothing else P.Just $ default_SetNotebookRecipientSettings_result{setNotebookRecipientSettings_result_userException = setNotebookRecipientSettings_result_userException obj}
    , if obj == default_SetNotebookRecipientSettings_result{setNotebookRecipientSettings_result_notFoundException = setNotebookRecipientSettings_result_notFoundException obj} then P.Nothing else P.Just $ default_SetNotebookRecipientSettings_result{setNotebookRecipientSettings_result_notFoundException = setNotebookRecipientSettings_result_notFoundException obj}
    , if obj == default_SetNotebookRecipientSettings_result{setNotebookRecipientSettings_result_systemException = setNotebookRecipientSettings_result_systemException obj} then P.Nothing else P.Just $ default_SetNotebookRecipientSettings_result{setNotebookRecipientSettings_result_systemException = setNotebookRecipientSettings_result_systemException obj}
    ]
from_SetNotebookRecipientSettings_result :: SetNotebookRecipientSettings_result -> T.ThriftVal
from_SetNotebookRecipientSettings_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v1534 -> (1, ("userException",Errors_Types.from_EDAMUserException _v1534))) <$> setNotebookRecipientSettings_result_userException record, (\_v1534 -> (2, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v1534))) <$> setNotebookRecipientSettings_result_notFoundException record, (\_v1534 -> (3, ("systemException",Errors_Types.from_EDAMSystemException _v1534))) <$> setNotebookRecipientSettings_result_systemException record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v1534 -> P.Just (0, ("success",Types_Types.from_Notebook _v1534))) $ setNotebookRecipientSettings_result_success record
    , (\_v1534 -> (1, ("userException",Errors_Types.from_EDAMUserException _v1534))) <$> setNotebookRecipientSettings_result_userException record
    , (\_v1534 -> (2, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v1534))) <$> setNotebookRecipientSettings_result_notFoundException record
    , (\_v1534 -> (3, ("systemException",Errors_Types.from_EDAMSystemException _v1534))) <$> setNotebookRecipientSettings_result_systemException record
    ]
    )
write_SetNotebookRecipientSettings_result :: T.Protocol p => p -> SetNotebookRecipientSettings_result -> P.IO ()
write_SetNotebookRecipientSettings_result oprot record = T.writeVal oprot $ from_SetNotebookRecipientSettings_result record
encode_SetNotebookRecipientSettings_result :: T.StatelessProtocol p => p -> SetNotebookRecipientSettings_result -> LBS.ByteString
encode_SetNotebookRecipientSettings_result oprot record = T.serializeVal oprot $ from_SetNotebookRecipientSettings_result record
to_SetNotebookRecipientSettings_result :: T.ThriftVal -> SetNotebookRecipientSettings_result
to_SetNotebookRecipientSettings_result (T.TStruct fields) = SetNotebookRecipientSettings_result{
  setNotebookRecipientSettings_result_success = P.maybe (setNotebookRecipientSettings_result_success default_SetNotebookRecipientSettings_result) (\(_,_val1536) -> (case _val1536 of {T.TStruct _val1537 -> (Types_Types.to_Notebook (T.TStruct _val1537)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  setNotebookRecipientSettings_result_userException = P.maybe (P.Nothing) (\(_,_val1536) -> P.Just (case _val1536 of {T.TStruct _val1538 -> (Errors_Types.to_EDAMUserException (T.TStruct _val1538)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  setNotebookRecipientSettings_result_notFoundException = P.maybe (P.Nothing) (\(_,_val1536) -> P.Just (case _val1536 of {T.TStruct _val1539 -> (Errors_Types.to_EDAMNotFoundException (T.TStruct _val1539)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  setNotebookRecipientSettings_result_systemException = P.maybe (P.Nothing) (\(_,_val1536) -> P.Just (case _val1536 of {T.TStruct _val1540 -> (Errors_Types.to_EDAMSystemException (T.TStruct _val1540)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_SetNotebookRecipientSettings_result _ = P.error "not a struct"
read_SetNotebookRecipientSettings_result :: T.Protocol p => p -> P.IO SetNotebookRecipientSettings_result
read_SetNotebookRecipientSettings_result iprot = to_SetNotebookRecipientSettings_result <$> T.readVal iprot (T.T_STRUCT typemap_SetNotebookRecipientSettings_result)
decode_SetNotebookRecipientSettings_result :: T.StatelessProtocol p => p -> LBS.ByteString -> SetNotebookRecipientSettings_result
decode_SetNotebookRecipientSettings_result iprot bs = to_SetNotebookRecipientSettings_result $ T.deserializeVal iprot (T.T_STRUCT typemap_SetNotebookRecipientSettings_result) bs
typemap_SetNotebookRecipientSettings_result :: T.TypeMap
typemap_SetNotebookRecipientSettings_result = Map.fromList [(0,("success",(T.T_STRUCT Types_Types.typemap_Notebook))),(1,("userException",(T.T_STRUCT Errors_Types.typemap_EDAMUserException))),(2,("notFoundException",(T.T_STRUCT Errors_Types.typemap_EDAMNotFoundException))),(3,("systemException",(T.T_STRUCT Errors_Types.typemap_EDAMSystemException)))]
default_SetNotebookRecipientSettings_result :: SetNotebookRecipientSettings_result
default_SetNotebookRecipientSettings_result = SetNotebookRecipientSettings_result{
  setNotebookRecipientSettings_result_success = Types_Types.default_Notebook,
  setNotebookRecipientSettings_result_userException = P.Nothing,
  setNotebookRecipientSettings_result_notFoundException = P.Nothing,
  setNotebookRecipientSettings_result_systemException = P.Nothing}
data ListSharedNotebooks_args = ListSharedNotebooks_args  { listSharedNotebooks_args_authenticationToken :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ListSharedNotebooks_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` listSharedNotebooks_args_authenticationToken record  
instance QC.Arbitrary ListSharedNotebooks_args where 
  arbitrary = M.liftM ListSharedNotebooks_args (QC.arbitrary)
  shrink obj | obj == default_ListSharedNotebooks_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ListSharedNotebooks_args{listSharedNotebooks_args_authenticationToken = listSharedNotebooks_args_authenticationToken obj} then P.Nothing else P.Just $ default_ListSharedNotebooks_args{listSharedNotebooks_args_authenticationToken = listSharedNotebooks_args_authenticationToken obj}
    ]
from_ListSharedNotebooks_args :: ListSharedNotebooks_args -> T.ThriftVal
from_ListSharedNotebooks_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1543 -> P.Just (1, ("authenticationToken",T.TString $ E.encodeUtf8 _v1543))) $ listSharedNotebooks_args_authenticationToken record
  ]
write_ListSharedNotebooks_args :: T.Protocol p => p -> ListSharedNotebooks_args -> P.IO ()
write_ListSharedNotebooks_args oprot record = T.writeVal oprot $ from_ListSharedNotebooks_args record
encode_ListSharedNotebooks_args :: T.StatelessProtocol p => p -> ListSharedNotebooks_args -> LBS.ByteString
encode_ListSharedNotebooks_args oprot record = T.serializeVal oprot $ from_ListSharedNotebooks_args record
to_ListSharedNotebooks_args :: T.ThriftVal -> ListSharedNotebooks_args
to_ListSharedNotebooks_args (T.TStruct fields) = ListSharedNotebooks_args{
  listSharedNotebooks_args_authenticationToken = P.maybe (listSharedNotebooks_args_authenticationToken default_ListSharedNotebooks_args) (\(_,_val1545) -> (case _val1545 of {T.TString _val1546 -> E.decodeUtf8 _val1546; _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_ListSharedNotebooks_args _ = P.error "not a struct"
read_ListSharedNotebooks_args :: T.Protocol p => p -> P.IO ListSharedNotebooks_args
read_ListSharedNotebooks_args iprot = to_ListSharedNotebooks_args <$> T.readVal iprot (T.T_STRUCT typemap_ListSharedNotebooks_args)
decode_ListSharedNotebooks_args :: T.StatelessProtocol p => p -> LBS.ByteString -> ListSharedNotebooks_args
decode_ListSharedNotebooks_args iprot bs = to_ListSharedNotebooks_args $ T.deserializeVal iprot (T.T_STRUCT typemap_ListSharedNotebooks_args) bs
typemap_ListSharedNotebooks_args :: T.TypeMap
typemap_ListSharedNotebooks_args = Map.fromList [(1,("authenticationToken",T.T_STRING))]
default_ListSharedNotebooks_args :: ListSharedNotebooks_args
default_ListSharedNotebooks_args = ListSharedNotebooks_args{
  listSharedNotebooks_args_authenticationToken = ""}
data ListSharedNotebooks_result = ListSharedNotebooks_result  { listSharedNotebooks_result_success :: (Vector.Vector Types_Types.SharedNotebook)
  , listSharedNotebooks_result_userException :: P.Maybe Errors_Types.EDAMUserException
  , listSharedNotebooks_result_notFoundException :: P.Maybe Errors_Types.EDAMNotFoundException
  , listSharedNotebooks_result_systemException :: P.Maybe Errors_Types.EDAMSystemException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ListSharedNotebooks_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` listSharedNotebooks_result_success record   `H.hashWithSalt` listSharedNotebooks_result_userException record   `H.hashWithSalt` listSharedNotebooks_result_notFoundException record   `H.hashWithSalt` listSharedNotebooks_result_systemException record  
instance QC.Arbitrary ListSharedNotebooks_result where 
  arbitrary = M.liftM ListSharedNotebooks_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_ListSharedNotebooks_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ListSharedNotebooks_result{listSharedNotebooks_result_success = listSharedNotebooks_result_success obj} then P.Nothing else P.Just $ default_ListSharedNotebooks_result{listSharedNotebooks_result_success = listSharedNotebooks_result_success obj}
    , if obj == default_ListSharedNotebooks_result{listSharedNotebooks_result_userException = listSharedNotebooks_result_userException obj} then P.Nothing else P.Just $ default_ListSharedNotebooks_result{listSharedNotebooks_result_userException = listSharedNotebooks_result_userException obj}
    , if obj == default_ListSharedNotebooks_result{listSharedNotebooks_result_notFoundException = listSharedNotebooks_result_notFoundException obj} then P.Nothing else P.Just $ default_ListSharedNotebooks_result{listSharedNotebooks_result_notFoundException = listSharedNotebooks_result_notFoundException obj}
    , if obj == default_ListSharedNotebooks_result{listSharedNotebooks_result_systemException = listSharedNotebooks_result_systemException obj} then P.Nothing else P.Just $ default_ListSharedNotebooks_result{listSharedNotebooks_result_systemException = listSharedNotebooks_result_systemException obj}
    ]
from_ListSharedNotebooks_result :: ListSharedNotebooks_result -> T.ThriftVal
from_ListSharedNotebooks_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v1549 -> (1, ("userException",Errors_Types.from_EDAMUserException _v1549))) <$> listSharedNotebooks_result_userException record, (\_v1549 -> (2, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v1549))) <$> listSharedNotebooks_result_notFoundException record, (\_v1549 -> (3, ("systemException",Errors_Types.from_EDAMSystemException _v1549))) <$> listSharedNotebooks_result_systemException record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v1549 -> P.Just (0, ("success",T.TList (T.T_STRUCT Types_Types.typemap_SharedNotebook) $ P.map (\_v1551 -> Types_Types.from_SharedNotebook _v1551) $ Vector.toList _v1549))) $ listSharedNotebooks_result_success record
    , (\_v1549 -> (1, ("userException",Errors_Types.from_EDAMUserException _v1549))) <$> listSharedNotebooks_result_userException record
    , (\_v1549 -> (2, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v1549))) <$> listSharedNotebooks_result_notFoundException record
    , (\_v1549 -> (3, ("systemException",Errors_Types.from_EDAMSystemException _v1549))) <$> listSharedNotebooks_result_systemException record
    ]
    )
write_ListSharedNotebooks_result :: T.Protocol p => p -> ListSharedNotebooks_result -> P.IO ()
write_ListSharedNotebooks_result oprot record = T.writeVal oprot $ from_ListSharedNotebooks_result record
encode_ListSharedNotebooks_result :: T.StatelessProtocol p => p -> ListSharedNotebooks_result -> LBS.ByteString
encode_ListSharedNotebooks_result oprot record = T.serializeVal oprot $ from_ListSharedNotebooks_result record
to_ListSharedNotebooks_result :: T.ThriftVal -> ListSharedNotebooks_result
to_ListSharedNotebooks_result (T.TStruct fields) = ListSharedNotebooks_result{
  listSharedNotebooks_result_success = P.maybe (listSharedNotebooks_result_success default_ListSharedNotebooks_result) (\(_,_val1553) -> (case _val1553 of {T.TList _ _val1554 -> (Vector.fromList $ P.map (\_v1555 -> (case _v1555 of {T.TStruct _val1556 -> (Types_Types.to_SharedNotebook (T.TStruct _val1556)); _ -> P.error "wrong type"})) _val1554); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  listSharedNotebooks_result_userException = P.maybe (P.Nothing) (\(_,_val1553) -> P.Just (case _val1553 of {T.TStruct _val1557 -> (Errors_Types.to_EDAMUserException (T.TStruct _val1557)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  listSharedNotebooks_result_notFoundException = P.maybe (P.Nothing) (\(_,_val1553) -> P.Just (case _val1553 of {T.TStruct _val1558 -> (Errors_Types.to_EDAMNotFoundException (T.TStruct _val1558)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  listSharedNotebooks_result_systemException = P.maybe (P.Nothing) (\(_,_val1553) -> P.Just (case _val1553 of {T.TStruct _val1559 -> (Errors_Types.to_EDAMSystemException (T.TStruct _val1559)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_ListSharedNotebooks_result _ = P.error "not a struct"
read_ListSharedNotebooks_result :: T.Protocol p => p -> P.IO ListSharedNotebooks_result
read_ListSharedNotebooks_result iprot = to_ListSharedNotebooks_result <$> T.readVal iprot (T.T_STRUCT typemap_ListSharedNotebooks_result)
decode_ListSharedNotebooks_result :: T.StatelessProtocol p => p -> LBS.ByteString -> ListSharedNotebooks_result
decode_ListSharedNotebooks_result iprot bs = to_ListSharedNotebooks_result $ T.deserializeVal iprot (T.T_STRUCT typemap_ListSharedNotebooks_result) bs
typemap_ListSharedNotebooks_result :: T.TypeMap
typemap_ListSharedNotebooks_result = Map.fromList [(0,("success",(T.T_LIST (T.T_STRUCT Types_Types.typemap_SharedNotebook)))),(1,("userException",(T.T_STRUCT Errors_Types.typemap_EDAMUserException))),(2,("notFoundException",(T.T_STRUCT Errors_Types.typemap_EDAMNotFoundException))),(3,("systemException",(T.T_STRUCT Errors_Types.typemap_EDAMSystemException)))]
default_ListSharedNotebooks_result :: ListSharedNotebooks_result
default_ListSharedNotebooks_result = ListSharedNotebooks_result{
  listSharedNotebooks_result_success = Vector.empty,
  listSharedNotebooks_result_userException = P.Nothing,
  listSharedNotebooks_result_notFoundException = P.Nothing,
  listSharedNotebooks_result_systemException = P.Nothing}
data CreateLinkedNotebook_args = CreateLinkedNotebook_args  { createLinkedNotebook_args_authenticationToken :: LT.Text
  , createLinkedNotebook_args_linkedNotebook :: Types_Types.LinkedNotebook
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable CreateLinkedNotebook_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` createLinkedNotebook_args_authenticationToken record   `H.hashWithSalt` createLinkedNotebook_args_linkedNotebook record  
instance QC.Arbitrary CreateLinkedNotebook_args where 
  arbitrary = M.liftM CreateLinkedNotebook_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_CreateLinkedNotebook_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_CreateLinkedNotebook_args{createLinkedNotebook_args_authenticationToken = createLinkedNotebook_args_authenticationToken obj} then P.Nothing else P.Just $ default_CreateLinkedNotebook_args{createLinkedNotebook_args_authenticationToken = createLinkedNotebook_args_authenticationToken obj}
    , if obj == default_CreateLinkedNotebook_args{createLinkedNotebook_args_linkedNotebook = createLinkedNotebook_args_linkedNotebook obj} then P.Nothing else P.Just $ default_CreateLinkedNotebook_args{createLinkedNotebook_args_linkedNotebook = createLinkedNotebook_args_linkedNotebook obj}
    ]
from_CreateLinkedNotebook_args :: CreateLinkedNotebook_args -> T.ThriftVal
from_CreateLinkedNotebook_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1562 -> P.Just (1, ("authenticationToken",T.TString $ E.encodeUtf8 _v1562))) $ createLinkedNotebook_args_authenticationToken record
  , (\_v1562 -> P.Just (2, ("linkedNotebook",Types_Types.from_LinkedNotebook _v1562))) $ createLinkedNotebook_args_linkedNotebook record
  ]
write_CreateLinkedNotebook_args :: T.Protocol p => p -> CreateLinkedNotebook_args -> P.IO ()
write_CreateLinkedNotebook_args oprot record = T.writeVal oprot $ from_CreateLinkedNotebook_args record
encode_CreateLinkedNotebook_args :: T.StatelessProtocol p => p -> CreateLinkedNotebook_args -> LBS.ByteString
encode_CreateLinkedNotebook_args oprot record = T.serializeVal oprot $ from_CreateLinkedNotebook_args record
to_CreateLinkedNotebook_args :: T.ThriftVal -> CreateLinkedNotebook_args
to_CreateLinkedNotebook_args (T.TStruct fields) = CreateLinkedNotebook_args{
  createLinkedNotebook_args_authenticationToken = P.maybe (createLinkedNotebook_args_authenticationToken default_CreateLinkedNotebook_args) (\(_,_val1564) -> (case _val1564 of {T.TString _val1565 -> E.decodeUtf8 _val1565; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  createLinkedNotebook_args_linkedNotebook = P.maybe (createLinkedNotebook_args_linkedNotebook default_CreateLinkedNotebook_args) (\(_,_val1564) -> (case _val1564 of {T.TStruct _val1566 -> (Types_Types.to_LinkedNotebook (T.TStruct _val1566)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_CreateLinkedNotebook_args _ = P.error "not a struct"
read_CreateLinkedNotebook_args :: T.Protocol p => p -> P.IO CreateLinkedNotebook_args
read_CreateLinkedNotebook_args iprot = to_CreateLinkedNotebook_args <$> T.readVal iprot (T.T_STRUCT typemap_CreateLinkedNotebook_args)
decode_CreateLinkedNotebook_args :: T.StatelessProtocol p => p -> LBS.ByteString -> CreateLinkedNotebook_args
decode_CreateLinkedNotebook_args iprot bs = to_CreateLinkedNotebook_args $ T.deserializeVal iprot (T.T_STRUCT typemap_CreateLinkedNotebook_args) bs
typemap_CreateLinkedNotebook_args :: T.TypeMap
typemap_CreateLinkedNotebook_args = Map.fromList [(1,("authenticationToken",T.T_STRING)),(2,("linkedNotebook",(T.T_STRUCT Types_Types.typemap_LinkedNotebook)))]
default_CreateLinkedNotebook_args :: CreateLinkedNotebook_args
default_CreateLinkedNotebook_args = CreateLinkedNotebook_args{
  createLinkedNotebook_args_authenticationToken = "",
  createLinkedNotebook_args_linkedNotebook = Types_Types.default_LinkedNotebook}
data CreateLinkedNotebook_result = CreateLinkedNotebook_result  { createLinkedNotebook_result_success :: Types_Types.LinkedNotebook
  , createLinkedNotebook_result_userException :: P.Maybe Errors_Types.EDAMUserException
  , createLinkedNotebook_result_notFoundException :: P.Maybe Errors_Types.EDAMNotFoundException
  , createLinkedNotebook_result_systemException :: P.Maybe Errors_Types.EDAMSystemException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable CreateLinkedNotebook_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` createLinkedNotebook_result_success record   `H.hashWithSalt` createLinkedNotebook_result_userException record   `H.hashWithSalt` createLinkedNotebook_result_notFoundException record   `H.hashWithSalt` createLinkedNotebook_result_systemException record  
instance QC.Arbitrary CreateLinkedNotebook_result where 
  arbitrary = M.liftM CreateLinkedNotebook_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_CreateLinkedNotebook_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_CreateLinkedNotebook_result{createLinkedNotebook_result_success = createLinkedNotebook_result_success obj} then P.Nothing else P.Just $ default_CreateLinkedNotebook_result{createLinkedNotebook_result_success = createLinkedNotebook_result_success obj}
    , if obj == default_CreateLinkedNotebook_result{createLinkedNotebook_result_userException = createLinkedNotebook_result_userException obj} then P.Nothing else P.Just $ default_CreateLinkedNotebook_result{createLinkedNotebook_result_userException = createLinkedNotebook_result_userException obj}
    , if obj == default_CreateLinkedNotebook_result{createLinkedNotebook_result_notFoundException = createLinkedNotebook_result_notFoundException obj} then P.Nothing else P.Just $ default_CreateLinkedNotebook_result{createLinkedNotebook_result_notFoundException = createLinkedNotebook_result_notFoundException obj}
    , if obj == default_CreateLinkedNotebook_result{createLinkedNotebook_result_systemException = createLinkedNotebook_result_systemException obj} then P.Nothing else P.Just $ default_CreateLinkedNotebook_result{createLinkedNotebook_result_systemException = createLinkedNotebook_result_systemException obj}
    ]
from_CreateLinkedNotebook_result :: CreateLinkedNotebook_result -> T.ThriftVal
from_CreateLinkedNotebook_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v1569 -> (1, ("userException",Errors_Types.from_EDAMUserException _v1569))) <$> createLinkedNotebook_result_userException record, (\_v1569 -> (2, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v1569))) <$> createLinkedNotebook_result_notFoundException record, (\_v1569 -> (3, ("systemException",Errors_Types.from_EDAMSystemException _v1569))) <$> createLinkedNotebook_result_systemException record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v1569 -> P.Just (0, ("success",Types_Types.from_LinkedNotebook _v1569))) $ createLinkedNotebook_result_success record
    , (\_v1569 -> (1, ("userException",Errors_Types.from_EDAMUserException _v1569))) <$> createLinkedNotebook_result_userException record
    , (\_v1569 -> (2, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v1569))) <$> createLinkedNotebook_result_notFoundException record
    , (\_v1569 -> (3, ("systemException",Errors_Types.from_EDAMSystemException _v1569))) <$> createLinkedNotebook_result_systemException record
    ]
    )
write_CreateLinkedNotebook_result :: T.Protocol p => p -> CreateLinkedNotebook_result -> P.IO ()
write_CreateLinkedNotebook_result oprot record = T.writeVal oprot $ from_CreateLinkedNotebook_result record
encode_CreateLinkedNotebook_result :: T.StatelessProtocol p => p -> CreateLinkedNotebook_result -> LBS.ByteString
encode_CreateLinkedNotebook_result oprot record = T.serializeVal oprot $ from_CreateLinkedNotebook_result record
to_CreateLinkedNotebook_result :: T.ThriftVal -> CreateLinkedNotebook_result
to_CreateLinkedNotebook_result (T.TStruct fields) = CreateLinkedNotebook_result{
  createLinkedNotebook_result_success = P.maybe (createLinkedNotebook_result_success default_CreateLinkedNotebook_result) (\(_,_val1571) -> (case _val1571 of {T.TStruct _val1572 -> (Types_Types.to_LinkedNotebook (T.TStruct _val1572)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  createLinkedNotebook_result_userException = P.maybe (P.Nothing) (\(_,_val1571) -> P.Just (case _val1571 of {T.TStruct _val1573 -> (Errors_Types.to_EDAMUserException (T.TStruct _val1573)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  createLinkedNotebook_result_notFoundException = P.maybe (P.Nothing) (\(_,_val1571) -> P.Just (case _val1571 of {T.TStruct _val1574 -> (Errors_Types.to_EDAMNotFoundException (T.TStruct _val1574)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  createLinkedNotebook_result_systemException = P.maybe (P.Nothing) (\(_,_val1571) -> P.Just (case _val1571 of {T.TStruct _val1575 -> (Errors_Types.to_EDAMSystemException (T.TStruct _val1575)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_CreateLinkedNotebook_result _ = P.error "not a struct"
read_CreateLinkedNotebook_result :: T.Protocol p => p -> P.IO CreateLinkedNotebook_result
read_CreateLinkedNotebook_result iprot = to_CreateLinkedNotebook_result <$> T.readVal iprot (T.T_STRUCT typemap_CreateLinkedNotebook_result)
decode_CreateLinkedNotebook_result :: T.StatelessProtocol p => p -> LBS.ByteString -> CreateLinkedNotebook_result
decode_CreateLinkedNotebook_result iprot bs = to_CreateLinkedNotebook_result $ T.deserializeVal iprot (T.T_STRUCT typemap_CreateLinkedNotebook_result) bs
typemap_CreateLinkedNotebook_result :: T.TypeMap
typemap_CreateLinkedNotebook_result = Map.fromList [(0,("success",(T.T_STRUCT Types_Types.typemap_LinkedNotebook))),(1,("userException",(T.T_STRUCT Errors_Types.typemap_EDAMUserException))),(2,("notFoundException",(T.T_STRUCT Errors_Types.typemap_EDAMNotFoundException))),(3,("systemException",(T.T_STRUCT Errors_Types.typemap_EDAMSystemException)))]
default_CreateLinkedNotebook_result :: CreateLinkedNotebook_result
default_CreateLinkedNotebook_result = CreateLinkedNotebook_result{
  createLinkedNotebook_result_success = Types_Types.default_LinkedNotebook,
  createLinkedNotebook_result_userException = P.Nothing,
  createLinkedNotebook_result_notFoundException = P.Nothing,
  createLinkedNotebook_result_systemException = P.Nothing}
data UpdateLinkedNotebook_args = UpdateLinkedNotebook_args  { updateLinkedNotebook_args_authenticationToken :: LT.Text
  , updateLinkedNotebook_args_linkedNotebook :: Types_Types.LinkedNotebook
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateLinkedNotebook_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateLinkedNotebook_args_authenticationToken record   `H.hashWithSalt` updateLinkedNotebook_args_linkedNotebook record  
instance QC.Arbitrary UpdateLinkedNotebook_args where 
  arbitrary = M.liftM UpdateLinkedNotebook_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_UpdateLinkedNotebook_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateLinkedNotebook_args{updateLinkedNotebook_args_authenticationToken = updateLinkedNotebook_args_authenticationToken obj} then P.Nothing else P.Just $ default_UpdateLinkedNotebook_args{updateLinkedNotebook_args_authenticationToken = updateLinkedNotebook_args_authenticationToken obj}
    , if obj == default_UpdateLinkedNotebook_args{updateLinkedNotebook_args_linkedNotebook = updateLinkedNotebook_args_linkedNotebook obj} then P.Nothing else P.Just $ default_UpdateLinkedNotebook_args{updateLinkedNotebook_args_linkedNotebook = updateLinkedNotebook_args_linkedNotebook obj}
    ]
from_UpdateLinkedNotebook_args :: UpdateLinkedNotebook_args -> T.ThriftVal
from_UpdateLinkedNotebook_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1578 -> P.Just (1, ("authenticationToken",T.TString $ E.encodeUtf8 _v1578))) $ updateLinkedNotebook_args_authenticationToken record
  , (\_v1578 -> P.Just (2, ("linkedNotebook",Types_Types.from_LinkedNotebook _v1578))) $ updateLinkedNotebook_args_linkedNotebook record
  ]
write_UpdateLinkedNotebook_args :: T.Protocol p => p -> UpdateLinkedNotebook_args -> P.IO ()
write_UpdateLinkedNotebook_args oprot record = T.writeVal oprot $ from_UpdateLinkedNotebook_args record
encode_UpdateLinkedNotebook_args :: T.StatelessProtocol p => p -> UpdateLinkedNotebook_args -> LBS.ByteString
encode_UpdateLinkedNotebook_args oprot record = T.serializeVal oprot $ from_UpdateLinkedNotebook_args record
to_UpdateLinkedNotebook_args :: T.ThriftVal -> UpdateLinkedNotebook_args
to_UpdateLinkedNotebook_args (T.TStruct fields) = UpdateLinkedNotebook_args{
  updateLinkedNotebook_args_authenticationToken = P.maybe (updateLinkedNotebook_args_authenticationToken default_UpdateLinkedNotebook_args) (\(_,_val1580) -> (case _val1580 of {T.TString _val1581 -> E.decodeUtf8 _val1581; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  updateLinkedNotebook_args_linkedNotebook = P.maybe (updateLinkedNotebook_args_linkedNotebook default_UpdateLinkedNotebook_args) (\(_,_val1580) -> (case _val1580 of {T.TStruct _val1582 -> (Types_Types.to_LinkedNotebook (T.TStruct _val1582)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_UpdateLinkedNotebook_args _ = P.error "not a struct"
read_UpdateLinkedNotebook_args :: T.Protocol p => p -> P.IO UpdateLinkedNotebook_args
read_UpdateLinkedNotebook_args iprot = to_UpdateLinkedNotebook_args <$> T.readVal iprot (T.T_STRUCT typemap_UpdateLinkedNotebook_args)
decode_UpdateLinkedNotebook_args :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateLinkedNotebook_args
decode_UpdateLinkedNotebook_args iprot bs = to_UpdateLinkedNotebook_args $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateLinkedNotebook_args) bs
typemap_UpdateLinkedNotebook_args :: T.TypeMap
typemap_UpdateLinkedNotebook_args = Map.fromList [(1,("authenticationToken",T.T_STRING)),(2,("linkedNotebook",(T.T_STRUCT Types_Types.typemap_LinkedNotebook)))]
default_UpdateLinkedNotebook_args :: UpdateLinkedNotebook_args
default_UpdateLinkedNotebook_args = UpdateLinkedNotebook_args{
  updateLinkedNotebook_args_authenticationToken = "",
  updateLinkedNotebook_args_linkedNotebook = Types_Types.default_LinkedNotebook}
data UpdateLinkedNotebook_result = UpdateLinkedNotebook_result  { updateLinkedNotebook_result_success :: I.Int32
  , updateLinkedNotebook_result_userException :: P.Maybe Errors_Types.EDAMUserException
  , updateLinkedNotebook_result_notFoundException :: P.Maybe Errors_Types.EDAMNotFoundException
  , updateLinkedNotebook_result_systemException :: P.Maybe Errors_Types.EDAMSystemException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateLinkedNotebook_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateLinkedNotebook_result_success record   `H.hashWithSalt` updateLinkedNotebook_result_userException record   `H.hashWithSalt` updateLinkedNotebook_result_notFoundException record   `H.hashWithSalt` updateLinkedNotebook_result_systemException record  
instance QC.Arbitrary UpdateLinkedNotebook_result where 
  arbitrary = M.liftM UpdateLinkedNotebook_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_UpdateLinkedNotebook_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateLinkedNotebook_result{updateLinkedNotebook_result_success = updateLinkedNotebook_result_success obj} then P.Nothing else P.Just $ default_UpdateLinkedNotebook_result{updateLinkedNotebook_result_success = updateLinkedNotebook_result_success obj}
    , if obj == default_UpdateLinkedNotebook_result{updateLinkedNotebook_result_userException = updateLinkedNotebook_result_userException obj} then P.Nothing else P.Just $ default_UpdateLinkedNotebook_result{updateLinkedNotebook_result_userException = updateLinkedNotebook_result_userException obj}
    , if obj == default_UpdateLinkedNotebook_result{updateLinkedNotebook_result_notFoundException = updateLinkedNotebook_result_notFoundException obj} then P.Nothing else P.Just $ default_UpdateLinkedNotebook_result{updateLinkedNotebook_result_notFoundException = updateLinkedNotebook_result_notFoundException obj}
    , if obj == default_UpdateLinkedNotebook_result{updateLinkedNotebook_result_systemException = updateLinkedNotebook_result_systemException obj} then P.Nothing else P.Just $ default_UpdateLinkedNotebook_result{updateLinkedNotebook_result_systemException = updateLinkedNotebook_result_systemException obj}
    ]
from_UpdateLinkedNotebook_result :: UpdateLinkedNotebook_result -> T.ThriftVal
from_UpdateLinkedNotebook_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v1585 -> (1, ("userException",Errors_Types.from_EDAMUserException _v1585))) <$> updateLinkedNotebook_result_userException record, (\_v1585 -> (2, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v1585))) <$> updateLinkedNotebook_result_notFoundException record, (\_v1585 -> (3, ("systemException",Errors_Types.from_EDAMSystemException _v1585))) <$> updateLinkedNotebook_result_systemException record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v1585 -> P.Just (0, ("success",T.TI32 _v1585))) $ updateLinkedNotebook_result_success record
    , (\_v1585 -> (1, ("userException",Errors_Types.from_EDAMUserException _v1585))) <$> updateLinkedNotebook_result_userException record
    , (\_v1585 -> (2, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v1585))) <$> updateLinkedNotebook_result_notFoundException record
    , (\_v1585 -> (3, ("systemException",Errors_Types.from_EDAMSystemException _v1585))) <$> updateLinkedNotebook_result_systemException record
    ]
    )
write_UpdateLinkedNotebook_result :: T.Protocol p => p -> UpdateLinkedNotebook_result -> P.IO ()
write_UpdateLinkedNotebook_result oprot record = T.writeVal oprot $ from_UpdateLinkedNotebook_result record
encode_UpdateLinkedNotebook_result :: T.StatelessProtocol p => p -> UpdateLinkedNotebook_result -> LBS.ByteString
encode_UpdateLinkedNotebook_result oprot record = T.serializeVal oprot $ from_UpdateLinkedNotebook_result record
to_UpdateLinkedNotebook_result :: T.ThriftVal -> UpdateLinkedNotebook_result
to_UpdateLinkedNotebook_result (T.TStruct fields) = UpdateLinkedNotebook_result{
  updateLinkedNotebook_result_success = P.maybe (updateLinkedNotebook_result_success default_UpdateLinkedNotebook_result) (\(_,_val1587) -> (case _val1587 of {T.TI32 _val1588 -> _val1588; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  updateLinkedNotebook_result_userException = P.maybe (P.Nothing) (\(_,_val1587) -> P.Just (case _val1587 of {T.TStruct _val1589 -> (Errors_Types.to_EDAMUserException (T.TStruct _val1589)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  updateLinkedNotebook_result_notFoundException = P.maybe (P.Nothing) (\(_,_val1587) -> P.Just (case _val1587 of {T.TStruct _val1590 -> (Errors_Types.to_EDAMNotFoundException (T.TStruct _val1590)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  updateLinkedNotebook_result_systemException = P.maybe (P.Nothing) (\(_,_val1587) -> P.Just (case _val1587 of {T.TStruct _val1591 -> (Errors_Types.to_EDAMSystemException (T.TStruct _val1591)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_UpdateLinkedNotebook_result _ = P.error "not a struct"
read_UpdateLinkedNotebook_result :: T.Protocol p => p -> P.IO UpdateLinkedNotebook_result
read_UpdateLinkedNotebook_result iprot = to_UpdateLinkedNotebook_result <$> T.readVal iprot (T.T_STRUCT typemap_UpdateLinkedNotebook_result)
decode_UpdateLinkedNotebook_result :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateLinkedNotebook_result
decode_UpdateLinkedNotebook_result iprot bs = to_UpdateLinkedNotebook_result $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateLinkedNotebook_result) bs
typemap_UpdateLinkedNotebook_result :: T.TypeMap
typemap_UpdateLinkedNotebook_result = Map.fromList [(0,("success",T.T_I32)),(1,("userException",(T.T_STRUCT Errors_Types.typemap_EDAMUserException))),(2,("notFoundException",(T.T_STRUCT Errors_Types.typemap_EDAMNotFoundException))),(3,("systemException",(T.T_STRUCT Errors_Types.typemap_EDAMSystemException)))]
default_UpdateLinkedNotebook_result :: UpdateLinkedNotebook_result
default_UpdateLinkedNotebook_result = UpdateLinkedNotebook_result{
  updateLinkedNotebook_result_success = 0,
  updateLinkedNotebook_result_userException = P.Nothing,
  updateLinkedNotebook_result_notFoundException = P.Nothing,
  updateLinkedNotebook_result_systemException = P.Nothing}
data ListLinkedNotebooks_args = ListLinkedNotebooks_args  { listLinkedNotebooks_args_authenticationToken :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ListLinkedNotebooks_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` listLinkedNotebooks_args_authenticationToken record  
instance QC.Arbitrary ListLinkedNotebooks_args where 
  arbitrary = M.liftM ListLinkedNotebooks_args (QC.arbitrary)
  shrink obj | obj == default_ListLinkedNotebooks_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ListLinkedNotebooks_args{listLinkedNotebooks_args_authenticationToken = listLinkedNotebooks_args_authenticationToken obj} then P.Nothing else P.Just $ default_ListLinkedNotebooks_args{listLinkedNotebooks_args_authenticationToken = listLinkedNotebooks_args_authenticationToken obj}
    ]
from_ListLinkedNotebooks_args :: ListLinkedNotebooks_args -> T.ThriftVal
from_ListLinkedNotebooks_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1594 -> P.Just (1, ("authenticationToken",T.TString $ E.encodeUtf8 _v1594))) $ listLinkedNotebooks_args_authenticationToken record
  ]
write_ListLinkedNotebooks_args :: T.Protocol p => p -> ListLinkedNotebooks_args -> P.IO ()
write_ListLinkedNotebooks_args oprot record = T.writeVal oprot $ from_ListLinkedNotebooks_args record
encode_ListLinkedNotebooks_args :: T.StatelessProtocol p => p -> ListLinkedNotebooks_args -> LBS.ByteString
encode_ListLinkedNotebooks_args oprot record = T.serializeVal oprot $ from_ListLinkedNotebooks_args record
to_ListLinkedNotebooks_args :: T.ThriftVal -> ListLinkedNotebooks_args
to_ListLinkedNotebooks_args (T.TStruct fields) = ListLinkedNotebooks_args{
  listLinkedNotebooks_args_authenticationToken = P.maybe (listLinkedNotebooks_args_authenticationToken default_ListLinkedNotebooks_args) (\(_,_val1596) -> (case _val1596 of {T.TString _val1597 -> E.decodeUtf8 _val1597; _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_ListLinkedNotebooks_args _ = P.error "not a struct"
read_ListLinkedNotebooks_args :: T.Protocol p => p -> P.IO ListLinkedNotebooks_args
read_ListLinkedNotebooks_args iprot = to_ListLinkedNotebooks_args <$> T.readVal iprot (T.T_STRUCT typemap_ListLinkedNotebooks_args)
decode_ListLinkedNotebooks_args :: T.StatelessProtocol p => p -> LBS.ByteString -> ListLinkedNotebooks_args
decode_ListLinkedNotebooks_args iprot bs = to_ListLinkedNotebooks_args $ T.deserializeVal iprot (T.T_STRUCT typemap_ListLinkedNotebooks_args) bs
typemap_ListLinkedNotebooks_args :: T.TypeMap
typemap_ListLinkedNotebooks_args = Map.fromList [(1,("authenticationToken",T.T_STRING))]
default_ListLinkedNotebooks_args :: ListLinkedNotebooks_args
default_ListLinkedNotebooks_args = ListLinkedNotebooks_args{
  listLinkedNotebooks_args_authenticationToken = ""}
data ListLinkedNotebooks_result = ListLinkedNotebooks_result  { listLinkedNotebooks_result_success :: (Vector.Vector Types_Types.LinkedNotebook)
  , listLinkedNotebooks_result_userException :: P.Maybe Errors_Types.EDAMUserException
  , listLinkedNotebooks_result_notFoundException :: P.Maybe Errors_Types.EDAMNotFoundException
  , listLinkedNotebooks_result_systemException :: P.Maybe Errors_Types.EDAMSystemException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ListLinkedNotebooks_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` listLinkedNotebooks_result_success record   `H.hashWithSalt` listLinkedNotebooks_result_userException record   `H.hashWithSalt` listLinkedNotebooks_result_notFoundException record   `H.hashWithSalt` listLinkedNotebooks_result_systemException record  
instance QC.Arbitrary ListLinkedNotebooks_result where 
  arbitrary = M.liftM ListLinkedNotebooks_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_ListLinkedNotebooks_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ListLinkedNotebooks_result{listLinkedNotebooks_result_success = listLinkedNotebooks_result_success obj} then P.Nothing else P.Just $ default_ListLinkedNotebooks_result{listLinkedNotebooks_result_success = listLinkedNotebooks_result_success obj}
    , if obj == default_ListLinkedNotebooks_result{listLinkedNotebooks_result_userException = listLinkedNotebooks_result_userException obj} then P.Nothing else P.Just $ default_ListLinkedNotebooks_result{listLinkedNotebooks_result_userException = listLinkedNotebooks_result_userException obj}
    , if obj == default_ListLinkedNotebooks_result{listLinkedNotebooks_result_notFoundException = listLinkedNotebooks_result_notFoundException obj} then P.Nothing else P.Just $ default_ListLinkedNotebooks_result{listLinkedNotebooks_result_notFoundException = listLinkedNotebooks_result_notFoundException obj}
    , if obj == default_ListLinkedNotebooks_result{listLinkedNotebooks_result_systemException = listLinkedNotebooks_result_systemException obj} then P.Nothing else P.Just $ default_ListLinkedNotebooks_result{listLinkedNotebooks_result_systemException = listLinkedNotebooks_result_systemException obj}
    ]
from_ListLinkedNotebooks_result :: ListLinkedNotebooks_result -> T.ThriftVal
from_ListLinkedNotebooks_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v1600 -> (1, ("userException",Errors_Types.from_EDAMUserException _v1600))) <$> listLinkedNotebooks_result_userException record, (\_v1600 -> (2, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v1600))) <$> listLinkedNotebooks_result_notFoundException record, (\_v1600 -> (3, ("systemException",Errors_Types.from_EDAMSystemException _v1600))) <$> listLinkedNotebooks_result_systemException record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v1600 -> P.Just (0, ("success",T.TList (T.T_STRUCT Types_Types.typemap_LinkedNotebook) $ P.map (\_v1602 -> Types_Types.from_LinkedNotebook _v1602) $ Vector.toList _v1600))) $ listLinkedNotebooks_result_success record
    , (\_v1600 -> (1, ("userException",Errors_Types.from_EDAMUserException _v1600))) <$> listLinkedNotebooks_result_userException record
    , (\_v1600 -> (2, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v1600))) <$> listLinkedNotebooks_result_notFoundException record
    , (\_v1600 -> (3, ("systemException",Errors_Types.from_EDAMSystemException _v1600))) <$> listLinkedNotebooks_result_systemException record
    ]
    )
write_ListLinkedNotebooks_result :: T.Protocol p => p -> ListLinkedNotebooks_result -> P.IO ()
write_ListLinkedNotebooks_result oprot record = T.writeVal oprot $ from_ListLinkedNotebooks_result record
encode_ListLinkedNotebooks_result :: T.StatelessProtocol p => p -> ListLinkedNotebooks_result -> LBS.ByteString
encode_ListLinkedNotebooks_result oprot record = T.serializeVal oprot $ from_ListLinkedNotebooks_result record
to_ListLinkedNotebooks_result :: T.ThriftVal -> ListLinkedNotebooks_result
to_ListLinkedNotebooks_result (T.TStruct fields) = ListLinkedNotebooks_result{
  listLinkedNotebooks_result_success = P.maybe (listLinkedNotebooks_result_success default_ListLinkedNotebooks_result) (\(_,_val1604) -> (case _val1604 of {T.TList _ _val1605 -> (Vector.fromList $ P.map (\_v1606 -> (case _v1606 of {T.TStruct _val1607 -> (Types_Types.to_LinkedNotebook (T.TStruct _val1607)); _ -> P.error "wrong type"})) _val1605); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  listLinkedNotebooks_result_userException = P.maybe (P.Nothing) (\(_,_val1604) -> P.Just (case _val1604 of {T.TStruct _val1608 -> (Errors_Types.to_EDAMUserException (T.TStruct _val1608)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  listLinkedNotebooks_result_notFoundException = P.maybe (P.Nothing) (\(_,_val1604) -> P.Just (case _val1604 of {T.TStruct _val1609 -> (Errors_Types.to_EDAMNotFoundException (T.TStruct _val1609)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  listLinkedNotebooks_result_systemException = P.maybe (P.Nothing) (\(_,_val1604) -> P.Just (case _val1604 of {T.TStruct _val1610 -> (Errors_Types.to_EDAMSystemException (T.TStruct _val1610)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_ListLinkedNotebooks_result _ = P.error "not a struct"
read_ListLinkedNotebooks_result :: T.Protocol p => p -> P.IO ListLinkedNotebooks_result
read_ListLinkedNotebooks_result iprot = to_ListLinkedNotebooks_result <$> T.readVal iprot (T.T_STRUCT typemap_ListLinkedNotebooks_result)
decode_ListLinkedNotebooks_result :: T.StatelessProtocol p => p -> LBS.ByteString -> ListLinkedNotebooks_result
decode_ListLinkedNotebooks_result iprot bs = to_ListLinkedNotebooks_result $ T.deserializeVal iprot (T.T_STRUCT typemap_ListLinkedNotebooks_result) bs
typemap_ListLinkedNotebooks_result :: T.TypeMap
typemap_ListLinkedNotebooks_result = Map.fromList [(0,("success",(T.T_LIST (T.T_STRUCT Types_Types.typemap_LinkedNotebook)))),(1,("userException",(T.T_STRUCT Errors_Types.typemap_EDAMUserException))),(2,("notFoundException",(T.T_STRUCT Errors_Types.typemap_EDAMNotFoundException))),(3,("systemException",(T.T_STRUCT Errors_Types.typemap_EDAMSystemException)))]
default_ListLinkedNotebooks_result :: ListLinkedNotebooks_result
default_ListLinkedNotebooks_result = ListLinkedNotebooks_result{
  listLinkedNotebooks_result_success = Vector.empty,
  listLinkedNotebooks_result_userException = P.Nothing,
  listLinkedNotebooks_result_notFoundException = P.Nothing,
  listLinkedNotebooks_result_systemException = P.Nothing}
data ExpungeLinkedNotebook_args = ExpungeLinkedNotebook_args  { expungeLinkedNotebook_args_authenticationToken :: LT.Text
  , expungeLinkedNotebook_args_guid :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ExpungeLinkedNotebook_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` expungeLinkedNotebook_args_authenticationToken record   `H.hashWithSalt` expungeLinkedNotebook_args_guid record  
instance QC.Arbitrary ExpungeLinkedNotebook_args where 
  arbitrary = M.liftM ExpungeLinkedNotebook_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_ExpungeLinkedNotebook_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ExpungeLinkedNotebook_args{expungeLinkedNotebook_args_authenticationToken = expungeLinkedNotebook_args_authenticationToken obj} then P.Nothing else P.Just $ default_ExpungeLinkedNotebook_args{expungeLinkedNotebook_args_authenticationToken = expungeLinkedNotebook_args_authenticationToken obj}
    , if obj == default_ExpungeLinkedNotebook_args{expungeLinkedNotebook_args_guid = expungeLinkedNotebook_args_guid obj} then P.Nothing else P.Just $ default_ExpungeLinkedNotebook_args{expungeLinkedNotebook_args_guid = expungeLinkedNotebook_args_guid obj}
    ]
from_ExpungeLinkedNotebook_args :: ExpungeLinkedNotebook_args -> T.ThriftVal
from_ExpungeLinkedNotebook_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1613 -> P.Just (1, ("authenticationToken",T.TString $ E.encodeUtf8 _v1613))) $ expungeLinkedNotebook_args_authenticationToken record
  , (\_v1613 -> P.Just (2, ("guid",T.TString $ E.encodeUtf8 _v1613))) $ expungeLinkedNotebook_args_guid record
  ]
write_ExpungeLinkedNotebook_args :: T.Protocol p => p -> ExpungeLinkedNotebook_args -> P.IO ()
write_ExpungeLinkedNotebook_args oprot record = T.writeVal oprot $ from_ExpungeLinkedNotebook_args record
encode_ExpungeLinkedNotebook_args :: T.StatelessProtocol p => p -> ExpungeLinkedNotebook_args -> LBS.ByteString
encode_ExpungeLinkedNotebook_args oprot record = T.serializeVal oprot $ from_ExpungeLinkedNotebook_args record
to_ExpungeLinkedNotebook_args :: T.ThriftVal -> ExpungeLinkedNotebook_args
to_ExpungeLinkedNotebook_args (T.TStruct fields) = ExpungeLinkedNotebook_args{
  expungeLinkedNotebook_args_authenticationToken = P.maybe (expungeLinkedNotebook_args_authenticationToken default_ExpungeLinkedNotebook_args) (\(_,_val1615) -> (case _val1615 of {T.TString _val1616 -> E.decodeUtf8 _val1616; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  expungeLinkedNotebook_args_guid = P.maybe (expungeLinkedNotebook_args_guid default_ExpungeLinkedNotebook_args) (\(_,_val1615) -> (case _val1615 of {T.TString _val1617 -> E.decodeUtf8 _val1617; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_ExpungeLinkedNotebook_args _ = P.error "not a struct"
read_ExpungeLinkedNotebook_args :: T.Protocol p => p -> P.IO ExpungeLinkedNotebook_args
read_ExpungeLinkedNotebook_args iprot = to_ExpungeLinkedNotebook_args <$> T.readVal iprot (T.T_STRUCT typemap_ExpungeLinkedNotebook_args)
decode_ExpungeLinkedNotebook_args :: T.StatelessProtocol p => p -> LBS.ByteString -> ExpungeLinkedNotebook_args
decode_ExpungeLinkedNotebook_args iprot bs = to_ExpungeLinkedNotebook_args $ T.deserializeVal iprot (T.T_STRUCT typemap_ExpungeLinkedNotebook_args) bs
typemap_ExpungeLinkedNotebook_args :: T.TypeMap
typemap_ExpungeLinkedNotebook_args = Map.fromList [(1,("authenticationToken",T.T_STRING)),(2,("guid",T.T_STRING))]
default_ExpungeLinkedNotebook_args :: ExpungeLinkedNotebook_args
default_ExpungeLinkedNotebook_args = ExpungeLinkedNotebook_args{
  expungeLinkedNotebook_args_authenticationToken = "",
  expungeLinkedNotebook_args_guid = ""}
data ExpungeLinkedNotebook_result = ExpungeLinkedNotebook_result  { expungeLinkedNotebook_result_success :: I.Int32
  , expungeLinkedNotebook_result_userException :: P.Maybe Errors_Types.EDAMUserException
  , expungeLinkedNotebook_result_notFoundException :: P.Maybe Errors_Types.EDAMNotFoundException
  , expungeLinkedNotebook_result_systemException :: P.Maybe Errors_Types.EDAMSystemException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ExpungeLinkedNotebook_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` expungeLinkedNotebook_result_success record   `H.hashWithSalt` expungeLinkedNotebook_result_userException record   `H.hashWithSalt` expungeLinkedNotebook_result_notFoundException record   `H.hashWithSalt` expungeLinkedNotebook_result_systemException record  
instance QC.Arbitrary ExpungeLinkedNotebook_result where 
  arbitrary = M.liftM ExpungeLinkedNotebook_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_ExpungeLinkedNotebook_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ExpungeLinkedNotebook_result{expungeLinkedNotebook_result_success = expungeLinkedNotebook_result_success obj} then P.Nothing else P.Just $ default_ExpungeLinkedNotebook_result{expungeLinkedNotebook_result_success = expungeLinkedNotebook_result_success obj}
    , if obj == default_ExpungeLinkedNotebook_result{expungeLinkedNotebook_result_userException = expungeLinkedNotebook_result_userException obj} then P.Nothing else P.Just $ default_ExpungeLinkedNotebook_result{expungeLinkedNotebook_result_userException = expungeLinkedNotebook_result_userException obj}
    , if obj == default_ExpungeLinkedNotebook_result{expungeLinkedNotebook_result_notFoundException = expungeLinkedNotebook_result_notFoundException obj} then P.Nothing else P.Just $ default_ExpungeLinkedNotebook_result{expungeLinkedNotebook_result_notFoundException = expungeLinkedNotebook_result_notFoundException obj}
    , if obj == default_ExpungeLinkedNotebook_result{expungeLinkedNotebook_result_systemException = expungeLinkedNotebook_result_systemException obj} then P.Nothing else P.Just $ default_ExpungeLinkedNotebook_result{expungeLinkedNotebook_result_systemException = expungeLinkedNotebook_result_systemException obj}
    ]
from_ExpungeLinkedNotebook_result :: ExpungeLinkedNotebook_result -> T.ThriftVal
from_ExpungeLinkedNotebook_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v1620 -> (1, ("userException",Errors_Types.from_EDAMUserException _v1620))) <$> expungeLinkedNotebook_result_userException record, (\_v1620 -> (2, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v1620))) <$> expungeLinkedNotebook_result_notFoundException record, (\_v1620 -> (3, ("systemException",Errors_Types.from_EDAMSystemException _v1620))) <$> expungeLinkedNotebook_result_systemException record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v1620 -> P.Just (0, ("success",T.TI32 _v1620))) $ expungeLinkedNotebook_result_success record
    , (\_v1620 -> (1, ("userException",Errors_Types.from_EDAMUserException _v1620))) <$> expungeLinkedNotebook_result_userException record
    , (\_v1620 -> (2, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v1620))) <$> expungeLinkedNotebook_result_notFoundException record
    , (\_v1620 -> (3, ("systemException",Errors_Types.from_EDAMSystemException _v1620))) <$> expungeLinkedNotebook_result_systemException record
    ]
    )
write_ExpungeLinkedNotebook_result :: T.Protocol p => p -> ExpungeLinkedNotebook_result -> P.IO ()
write_ExpungeLinkedNotebook_result oprot record = T.writeVal oprot $ from_ExpungeLinkedNotebook_result record
encode_ExpungeLinkedNotebook_result :: T.StatelessProtocol p => p -> ExpungeLinkedNotebook_result -> LBS.ByteString
encode_ExpungeLinkedNotebook_result oprot record = T.serializeVal oprot $ from_ExpungeLinkedNotebook_result record
to_ExpungeLinkedNotebook_result :: T.ThriftVal -> ExpungeLinkedNotebook_result
to_ExpungeLinkedNotebook_result (T.TStruct fields) = ExpungeLinkedNotebook_result{
  expungeLinkedNotebook_result_success = P.maybe (expungeLinkedNotebook_result_success default_ExpungeLinkedNotebook_result) (\(_,_val1622) -> (case _val1622 of {T.TI32 _val1623 -> _val1623; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  expungeLinkedNotebook_result_userException = P.maybe (P.Nothing) (\(_,_val1622) -> P.Just (case _val1622 of {T.TStruct _val1624 -> (Errors_Types.to_EDAMUserException (T.TStruct _val1624)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  expungeLinkedNotebook_result_notFoundException = P.maybe (P.Nothing) (\(_,_val1622) -> P.Just (case _val1622 of {T.TStruct _val1625 -> (Errors_Types.to_EDAMNotFoundException (T.TStruct _val1625)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  expungeLinkedNotebook_result_systemException = P.maybe (P.Nothing) (\(_,_val1622) -> P.Just (case _val1622 of {T.TStruct _val1626 -> (Errors_Types.to_EDAMSystemException (T.TStruct _val1626)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_ExpungeLinkedNotebook_result _ = P.error "not a struct"
read_ExpungeLinkedNotebook_result :: T.Protocol p => p -> P.IO ExpungeLinkedNotebook_result
read_ExpungeLinkedNotebook_result iprot = to_ExpungeLinkedNotebook_result <$> T.readVal iprot (T.T_STRUCT typemap_ExpungeLinkedNotebook_result)
decode_ExpungeLinkedNotebook_result :: T.StatelessProtocol p => p -> LBS.ByteString -> ExpungeLinkedNotebook_result
decode_ExpungeLinkedNotebook_result iprot bs = to_ExpungeLinkedNotebook_result $ T.deserializeVal iprot (T.T_STRUCT typemap_ExpungeLinkedNotebook_result) bs
typemap_ExpungeLinkedNotebook_result :: T.TypeMap
typemap_ExpungeLinkedNotebook_result = Map.fromList [(0,("success",T.T_I32)),(1,("userException",(T.T_STRUCT Errors_Types.typemap_EDAMUserException))),(2,("notFoundException",(T.T_STRUCT Errors_Types.typemap_EDAMNotFoundException))),(3,("systemException",(T.T_STRUCT Errors_Types.typemap_EDAMSystemException)))]
default_ExpungeLinkedNotebook_result :: ExpungeLinkedNotebook_result
default_ExpungeLinkedNotebook_result = ExpungeLinkedNotebook_result{
  expungeLinkedNotebook_result_success = 0,
  expungeLinkedNotebook_result_userException = P.Nothing,
  expungeLinkedNotebook_result_notFoundException = P.Nothing,
  expungeLinkedNotebook_result_systemException = P.Nothing}
data AuthenticateToSharedNotebook_args = AuthenticateToSharedNotebook_args  { authenticateToSharedNotebook_args_shareKeyOrGlobalId :: LT.Text
  , authenticateToSharedNotebook_args_authenticationToken :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable AuthenticateToSharedNotebook_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` authenticateToSharedNotebook_args_shareKeyOrGlobalId record   `H.hashWithSalt` authenticateToSharedNotebook_args_authenticationToken record  
instance QC.Arbitrary AuthenticateToSharedNotebook_args where 
  arbitrary = M.liftM AuthenticateToSharedNotebook_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_AuthenticateToSharedNotebook_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_AuthenticateToSharedNotebook_args{authenticateToSharedNotebook_args_shareKeyOrGlobalId = authenticateToSharedNotebook_args_shareKeyOrGlobalId obj} then P.Nothing else P.Just $ default_AuthenticateToSharedNotebook_args{authenticateToSharedNotebook_args_shareKeyOrGlobalId = authenticateToSharedNotebook_args_shareKeyOrGlobalId obj}
    , if obj == default_AuthenticateToSharedNotebook_args{authenticateToSharedNotebook_args_authenticationToken = authenticateToSharedNotebook_args_authenticationToken obj} then P.Nothing else P.Just $ default_AuthenticateToSharedNotebook_args{authenticateToSharedNotebook_args_authenticationToken = authenticateToSharedNotebook_args_authenticationToken obj}
    ]
from_AuthenticateToSharedNotebook_args :: AuthenticateToSharedNotebook_args -> T.ThriftVal
from_AuthenticateToSharedNotebook_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1629 -> P.Just (1, ("shareKeyOrGlobalId",T.TString $ E.encodeUtf8 _v1629))) $ authenticateToSharedNotebook_args_shareKeyOrGlobalId record
  , (\_v1629 -> P.Just (2, ("authenticationToken",T.TString $ E.encodeUtf8 _v1629))) $ authenticateToSharedNotebook_args_authenticationToken record
  ]
write_AuthenticateToSharedNotebook_args :: T.Protocol p => p -> AuthenticateToSharedNotebook_args -> P.IO ()
write_AuthenticateToSharedNotebook_args oprot record = T.writeVal oprot $ from_AuthenticateToSharedNotebook_args record
encode_AuthenticateToSharedNotebook_args :: T.StatelessProtocol p => p -> AuthenticateToSharedNotebook_args -> LBS.ByteString
encode_AuthenticateToSharedNotebook_args oprot record = T.serializeVal oprot $ from_AuthenticateToSharedNotebook_args record
to_AuthenticateToSharedNotebook_args :: T.ThriftVal -> AuthenticateToSharedNotebook_args
to_AuthenticateToSharedNotebook_args (T.TStruct fields) = AuthenticateToSharedNotebook_args{
  authenticateToSharedNotebook_args_shareKeyOrGlobalId = P.maybe (authenticateToSharedNotebook_args_shareKeyOrGlobalId default_AuthenticateToSharedNotebook_args) (\(_,_val1631) -> (case _val1631 of {T.TString _val1632 -> E.decodeUtf8 _val1632; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  authenticateToSharedNotebook_args_authenticationToken = P.maybe (authenticateToSharedNotebook_args_authenticationToken default_AuthenticateToSharedNotebook_args) (\(_,_val1631) -> (case _val1631 of {T.TString _val1633 -> E.decodeUtf8 _val1633; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_AuthenticateToSharedNotebook_args _ = P.error "not a struct"
read_AuthenticateToSharedNotebook_args :: T.Protocol p => p -> P.IO AuthenticateToSharedNotebook_args
read_AuthenticateToSharedNotebook_args iprot = to_AuthenticateToSharedNotebook_args <$> T.readVal iprot (T.T_STRUCT typemap_AuthenticateToSharedNotebook_args)
decode_AuthenticateToSharedNotebook_args :: T.StatelessProtocol p => p -> LBS.ByteString -> AuthenticateToSharedNotebook_args
decode_AuthenticateToSharedNotebook_args iprot bs = to_AuthenticateToSharedNotebook_args $ T.deserializeVal iprot (T.T_STRUCT typemap_AuthenticateToSharedNotebook_args) bs
typemap_AuthenticateToSharedNotebook_args :: T.TypeMap
typemap_AuthenticateToSharedNotebook_args = Map.fromList [(1,("shareKeyOrGlobalId",T.T_STRING)),(2,("authenticationToken",T.T_STRING))]
default_AuthenticateToSharedNotebook_args :: AuthenticateToSharedNotebook_args
default_AuthenticateToSharedNotebook_args = AuthenticateToSharedNotebook_args{
  authenticateToSharedNotebook_args_shareKeyOrGlobalId = "",
  authenticateToSharedNotebook_args_authenticationToken = ""}
data AuthenticateToSharedNotebook_result = AuthenticateToSharedNotebook_result  { authenticateToSharedNotebook_result_success :: UserStore_Types.AuthenticationResult
  , authenticateToSharedNotebook_result_userException :: P.Maybe Errors_Types.EDAMUserException
  , authenticateToSharedNotebook_result_notFoundException :: P.Maybe Errors_Types.EDAMNotFoundException
  , authenticateToSharedNotebook_result_systemException :: P.Maybe Errors_Types.EDAMSystemException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable AuthenticateToSharedNotebook_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` authenticateToSharedNotebook_result_success record   `H.hashWithSalt` authenticateToSharedNotebook_result_userException record   `H.hashWithSalt` authenticateToSharedNotebook_result_notFoundException record   `H.hashWithSalt` authenticateToSharedNotebook_result_systemException record  
instance QC.Arbitrary AuthenticateToSharedNotebook_result where 
  arbitrary = M.liftM AuthenticateToSharedNotebook_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_AuthenticateToSharedNotebook_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_AuthenticateToSharedNotebook_result{authenticateToSharedNotebook_result_success = authenticateToSharedNotebook_result_success obj} then P.Nothing else P.Just $ default_AuthenticateToSharedNotebook_result{authenticateToSharedNotebook_result_success = authenticateToSharedNotebook_result_success obj}
    , if obj == default_AuthenticateToSharedNotebook_result{authenticateToSharedNotebook_result_userException = authenticateToSharedNotebook_result_userException obj} then P.Nothing else P.Just $ default_AuthenticateToSharedNotebook_result{authenticateToSharedNotebook_result_userException = authenticateToSharedNotebook_result_userException obj}
    , if obj == default_AuthenticateToSharedNotebook_result{authenticateToSharedNotebook_result_notFoundException = authenticateToSharedNotebook_result_notFoundException obj} then P.Nothing else P.Just $ default_AuthenticateToSharedNotebook_result{authenticateToSharedNotebook_result_notFoundException = authenticateToSharedNotebook_result_notFoundException obj}
    , if obj == default_AuthenticateToSharedNotebook_result{authenticateToSharedNotebook_result_systemException = authenticateToSharedNotebook_result_systemException obj} then P.Nothing else P.Just $ default_AuthenticateToSharedNotebook_result{authenticateToSharedNotebook_result_systemException = authenticateToSharedNotebook_result_systemException obj}
    ]
from_AuthenticateToSharedNotebook_result :: AuthenticateToSharedNotebook_result -> T.ThriftVal
from_AuthenticateToSharedNotebook_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v1636 -> (1, ("userException",Errors_Types.from_EDAMUserException _v1636))) <$> authenticateToSharedNotebook_result_userException record, (\_v1636 -> (2, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v1636))) <$> authenticateToSharedNotebook_result_notFoundException record, (\_v1636 -> (3, ("systemException",Errors_Types.from_EDAMSystemException _v1636))) <$> authenticateToSharedNotebook_result_systemException record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v1636 -> P.Just (0, ("success",UserStore_Types.from_AuthenticationResult _v1636))) $ authenticateToSharedNotebook_result_success record
    , (\_v1636 -> (1, ("userException",Errors_Types.from_EDAMUserException _v1636))) <$> authenticateToSharedNotebook_result_userException record
    , (\_v1636 -> (2, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v1636))) <$> authenticateToSharedNotebook_result_notFoundException record
    , (\_v1636 -> (3, ("systemException",Errors_Types.from_EDAMSystemException _v1636))) <$> authenticateToSharedNotebook_result_systemException record
    ]
    )
write_AuthenticateToSharedNotebook_result :: T.Protocol p => p -> AuthenticateToSharedNotebook_result -> P.IO ()
write_AuthenticateToSharedNotebook_result oprot record = T.writeVal oprot $ from_AuthenticateToSharedNotebook_result record
encode_AuthenticateToSharedNotebook_result :: T.StatelessProtocol p => p -> AuthenticateToSharedNotebook_result -> LBS.ByteString
encode_AuthenticateToSharedNotebook_result oprot record = T.serializeVal oprot $ from_AuthenticateToSharedNotebook_result record
to_AuthenticateToSharedNotebook_result :: T.ThriftVal -> AuthenticateToSharedNotebook_result
to_AuthenticateToSharedNotebook_result (T.TStruct fields) = AuthenticateToSharedNotebook_result{
  authenticateToSharedNotebook_result_success = P.maybe (authenticateToSharedNotebook_result_success default_AuthenticateToSharedNotebook_result) (\(_,_val1638) -> (case _val1638 of {T.TStruct _val1639 -> (UserStore_Types.to_AuthenticationResult (T.TStruct _val1639)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  authenticateToSharedNotebook_result_userException = P.maybe (P.Nothing) (\(_,_val1638) -> P.Just (case _val1638 of {T.TStruct _val1640 -> (Errors_Types.to_EDAMUserException (T.TStruct _val1640)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  authenticateToSharedNotebook_result_notFoundException = P.maybe (P.Nothing) (\(_,_val1638) -> P.Just (case _val1638 of {T.TStruct _val1641 -> (Errors_Types.to_EDAMNotFoundException (T.TStruct _val1641)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  authenticateToSharedNotebook_result_systemException = P.maybe (P.Nothing) (\(_,_val1638) -> P.Just (case _val1638 of {T.TStruct _val1642 -> (Errors_Types.to_EDAMSystemException (T.TStruct _val1642)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_AuthenticateToSharedNotebook_result _ = P.error "not a struct"
read_AuthenticateToSharedNotebook_result :: T.Protocol p => p -> P.IO AuthenticateToSharedNotebook_result
read_AuthenticateToSharedNotebook_result iprot = to_AuthenticateToSharedNotebook_result <$> T.readVal iprot (T.T_STRUCT typemap_AuthenticateToSharedNotebook_result)
decode_AuthenticateToSharedNotebook_result :: T.StatelessProtocol p => p -> LBS.ByteString -> AuthenticateToSharedNotebook_result
decode_AuthenticateToSharedNotebook_result iprot bs = to_AuthenticateToSharedNotebook_result $ T.deserializeVal iprot (T.T_STRUCT typemap_AuthenticateToSharedNotebook_result) bs
typemap_AuthenticateToSharedNotebook_result :: T.TypeMap
typemap_AuthenticateToSharedNotebook_result = Map.fromList [(0,("success",(T.T_STRUCT UserStore_Types.typemap_AuthenticationResult))),(1,("userException",(T.T_STRUCT Errors_Types.typemap_EDAMUserException))),(2,("notFoundException",(T.T_STRUCT Errors_Types.typemap_EDAMNotFoundException))),(3,("systemException",(T.T_STRUCT Errors_Types.typemap_EDAMSystemException)))]
default_AuthenticateToSharedNotebook_result :: AuthenticateToSharedNotebook_result
default_AuthenticateToSharedNotebook_result = AuthenticateToSharedNotebook_result{
  authenticateToSharedNotebook_result_success = UserStore_Types.default_AuthenticationResult,
  authenticateToSharedNotebook_result_userException = P.Nothing,
  authenticateToSharedNotebook_result_notFoundException = P.Nothing,
  authenticateToSharedNotebook_result_systemException = P.Nothing}
data GetSharedNotebookByAuth_args = GetSharedNotebookByAuth_args  { getSharedNotebookByAuth_args_authenticationToken :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetSharedNotebookByAuth_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getSharedNotebookByAuth_args_authenticationToken record  
instance QC.Arbitrary GetSharedNotebookByAuth_args where 
  arbitrary = M.liftM GetSharedNotebookByAuth_args (QC.arbitrary)
  shrink obj | obj == default_GetSharedNotebookByAuth_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetSharedNotebookByAuth_args{getSharedNotebookByAuth_args_authenticationToken = getSharedNotebookByAuth_args_authenticationToken obj} then P.Nothing else P.Just $ default_GetSharedNotebookByAuth_args{getSharedNotebookByAuth_args_authenticationToken = getSharedNotebookByAuth_args_authenticationToken obj}
    ]
from_GetSharedNotebookByAuth_args :: GetSharedNotebookByAuth_args -> T.ThriftVal
from_GetSharedNotebookByAuth_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1645 -> P.Just (1, ("authenticationToken",T.TString $ E.encodeUtf8 _v1645))) $ getSharedNotebookByAuth_args_authenticationToken record
  ]
write_GetSharedNotebookByAuth_args :: T.Protocol p => p -> GetSharedNotebookByAuth_args -> P.IO ()
write_GetSharedNotebookByAuth_args oprot record = T.writeVal oprot $ from_GetSharedNotebookByAuth_args record
encode_GetSharedNotebookByAuth_args :: T.StatelessProtocol p => p -> GetSharedNotebookByAuth_args -> LBS.ByteString
encode_GetSharedNotebookByAuth_args oprot record = T.serializeVal oprot $ from_GetSharedNotebookByAuth_args record
to_GetSharedNotebookByAuth_args :: T.ThriftVal -> GetSharedNotebookByAuth_args
to_GetSharedNotebookByAuth_args (T.TStruct fields) = GetSharedNotebookByAuth_args{
  getSharedNotebookByAuth_args_authenticationToken = P.maybe (getSharedNotebookByAuth_args_authenticationToken default_GetSharedNotebookByAuth_args) (\(_,_val1647) -> (case _val1647 of {T.TString _val1648 -> E.decodeUtf8 _val1648; _ -> P.error "wrong type"})) (Map.lookup (1) fields)
  }
to_GetSharedNotebookByAuth_args _ = P.error "not a struct"
read_GetSharedNotebookByAuth_args :: T.Protocol p => p -> P.IO GetSharedNotebookByAuth_args
read_GetSharedNotebookByAuth_args iprot = to_GetSharedNotebookByAuth_args <$> T.readVal iprot (T.T_STRUCT typemap_GetSharedNotebookByAuth_args)
decode_GetSharedNotebookByAuth_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetSharedNotebookByAuth_args
decode_GetSharedNotebookByAuth_args iprot bs = to_GetSharedNotebookByAuth_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetSharedNotebookByAuth_args) bs
typemap_GetSharedNotebookByAuth_args :: T.TypeMap
typemap_GetSharedNotebookByAuth_args = Map.fromList [(1,("authenticationToken",T.T_STRING))]
default_GetSharedNotebookByAuth_args :: GetSharedNotebookByAuth_args
default_GetSharedNotebookByAuth_args = GetSharedNotebookByAuth_args{
  getSharedNotebookByAuth_args_authenticationToken = ""}
data GetSharedNotebookByAuth_result = GetSharedNotebookByAuth_result  { getSharedNotebookByAuth_result_success :: Types_Types.SharedNotebook
  , getSharedNotebookByAuth_result_userException :: P.Maybe Errors_Types.EDAMUserException
  , getSharedNotebookByAuth_result_notFoundException :: P.Maybe Errors_Types.EDAMNotFoundException
  , getSharedNotebookByAuth_result_systemException :: P.Maybe Errors_Types.EDAMSystemException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetSharedNotebookByAuth_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getSharedNotebookByAuth_result_success record   `H.hashWithSalt` getSharedNotebookByAuth_result_userException record   `H.hashWithSalt` getSharedNotebookByAuth_result_notFoundException record   `H.hashWithSalt` getSharedNotebookByAuth_result_systemException record  
instance QC.Arbitrary GetSharedNotebookByAuth_result where 
  arbitrary = M.liftM GetSharedNotebookByAuth_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetSharedNotebookByAuth_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetSharedNotebookByAuth_result{getSharedNotebookByAuth_result_success = getSharedNotebookByAuth_result_success obj} then P.Nothing else P.Just $ default_GetSharedNotebookByAuth_result{getSharedNotebookByAuth_result_success = getSharedNotebookByAuth_result_success obj}
    , if obj == default_GetSharedNotebookByAuth_result{getSharedNotebookByAuth_result_userException = getSharedNotebookByAuth_result_userException obj} then P.Nothing else P.Just $ default_GetSharedNotebookByAuth_result{getSharedNotebookByAuth_result_userException = getSharedNotebookByAuth_result_userException obj}
    , if obj == default_GetSharedNotebookByAuth_result{getSharedNotebookByAuth_result_notFoundException = getSharedNotebookByAuth_result_notFoundException obj} then P.Nothing else P.Just $ default_GetSharedNotebookByAuth_result{getSharedNotebookByAuth_result_notFoundException = getSharedNotebookByAuth_result_notFoundException obj}
    , if obj == default_GetSharedNotebookByAuth_result{getSharedNotebookByAuth_result_systemException = getSharedNotebookByAuth_result_systemException obj} then P.Nothing else P.Just $ default_GetSharedNotebookByAuth_result{getSharedNotebookByAuth_result_systemException = getSharedNotebookByAuth_result_systemException obj}
    ]
from_GetSharedNotebookByAuth_result :: GetSharedNotebookByAuth_result -> T.ThriftVal
from_GetSharedNotebookByAuth_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v1651 -> (1, ("userException",Errors_Types.from_EDAMUserException _v1651))) <$> getSharedNotebookByAuth_result_userException record, (\_v1651 -> (2, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v1651))) <$> getSharedNotebookByAuth_result_notFoundException record, (\_v1651 -> (3, ("systemException",Errors_Types.from_EDAMSystemException _v1651))) <$> getSharedNotebookByAuth_result_systemException record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v1651 -> P.Just (0, ("success",Types_Types.from_SharedNotebook _v1651))) $ getSharedNotebookByAuth_result_success record
    , (\_v1651 -> (1, ("userException",Errors_Types.from_EDAMUserException _v1651))) <$> getSharedNotebookByAuth_result_userException record
    , (\_v1651 -> (2, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v1651))) <$> getSharedNotebookByAuth_result_notFoundException record
    , (\_v1651 -> (3, ("systemException",Errors_Types.from_EDAMSystemException _v1651))) <$> getSharedNotebookByAuth_result_systemException record
    ]
    )
write_GetSharedNotebookByAuth_result :: T.Protocol p => p -> GetSharedNotebookByAuth_result -> P.IO ()
write_GetSharedNotebookByAuth_result oprot record = T.writeVal oprot $ from_GetSharedNotebookByAuth_result record
encode_GetSharedNotebookByAuth_result :: T.StatelessProtocol p => p -> GetSharedNotebookByAuth_result -> LBS.ByteString
encode_GetSharedNotebookByAuth_result oprot record = T.serializeVal oprot $ from_GetSharedNotebookByAuth_result record
to_GetSharedNotebookByAuth_result :: T.ThriftVal -> GetSharedNotebookByAuth_result
to_GetSharedNotebookByAuth_result (T.TStruct fields) = GetSharedNotebookByAuth_result{
  getSharedNotebookByAuth_result_success = P.maybe (getSharedNotebookByAuth_result_success default_GetSharedNotebookByAuth_result) (\(_,_val1653) -> (case _val1653 of {T.TStruct _val1654 -> (Types_Types.to_SharedNotebook (T.TStruct _val1654)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getSharedNotebookByAuth_result_userException = P.maybe (P.Nothing) (\(_,_val1653) -> P.Just (case _val1653 of {T.TStruct _val1655 -> (Errors_Types.to_EDAMUserException (T.TStruct _val1655)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  getSharedNotebookByAuth_result_notFoundException = P.maybe (P.Nothing) (\(_,_val1653) -> P.Just (case _val1653 of {T.TStruct _val1656 -> (Errors_Types.to_EDAMNotFoundException (T.TStruct _val1656)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  getSharedNotebookByAuth_result_systemException = P.maybe (P.Nothing) (\(_,_val1653) -> P.Just (case _val1653 of {T.TStruct _val1657 -> (Errors_Types.to_EDAMSystemException (T.TStruct _val1657)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_GetSharedNotebookByAuth_result _ = P.error "not a struct"
read_GetSharedNotebookByAuth_result :: T.Protocol p => p -> P.IO GetSharedNotebookByAuth_result
read_GetSharedNotebookByAuth_result iprot = to_GetSharedNotebookByAuth_result <$> T.readVal iprot (T.T_STRUCT typemap_GetSharedNotebookByAuth_result)
decode_GetSharedNotebookByAuth_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetSharedNotebookByAuth_result
decode_GetSharedNotebookByAuth_result iprot bs = to_GetSharedNotebookByAuth_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetSharedNotebookByAuth_result) bs
typemap_GetSharedNotebookByAuth_result :: T.TypeMap
typemap_GetSharedNotebookByAuth_result = Map.fromList [(0,("success",(T.T_STRUCT Types_Types.typemap_SharedNotebook))),(1,("userException",(T.T_STRUCT Errors_Types.typemap_EDAMUserException))),(2,("notFoundException",(T.T_STRUCT Errors_Types.typemap_EDAMNotFoundException))),(3,("systemException",(T.T_STRUCT Errors_Types.typemap_EDAMSystemException)))]
default_GetSharedNotebookByAuth_result :: GetSharedNotebookByAuth_result
default_GetSharedNotebookByAuth_result = GetSharedNotebookByAuth_result{
  getSharedNotebookByAuth_result_success = Types_Types.default_SharedNotebook,
  getSharedNotebookByAuth_result_userException = P.Nothing,
  getSharedNotebookByAuth_result_notFoundException = P.Nothing,
  getSharedNotebookByAuth_result_systemException = P.Nothing}
data EmailNote_args = EmailNote_args  { emailNote_args_authenticationToken :: LT.Text
  , emailNote_args_parameters :: NoteEmailParameters
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable EmailNote_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` emailNote_args_authenticationToken record   `H.hashWithSalt` emailNote_args_parameters record  
instance QC.Arbitrary EmailNote_args where 
  arbitrary = M.liftM EmailNote_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_EmailNote_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_EmailNote_args{emailNote_args_authenticationToken = emailNote_args_authenticationToken obj} then P.Nothing else P.Just $ default_EmailNote_args{emailNote_args_authenticationToken = emailNote_args_authenticationToken obj}
    , if obj == default_EmailNote_args{emailNote_args_parameters = emailNote_args_parameters obj} then P.Nothing else P.Just $ default_EmailNote_args{emailNote_args_parameters = emailNote_args_parameters obj}
    ]
from_EmailNote_args :: EmailNote_args -> T.ThriftVal
from_EmailNote_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1660 -> P.Just (1, ("authenticationToken",T.TString $ E.encodeUtf8 _v1660))) $ emailNote_args_authenticationToken record
  , (\_v1660 -> P.Just (2, ("parameters",from_NoteEmailParameters _v1660))) $ emailNote_args_parameters record
  ]
write_EmailNote_args :: T.Protocol p => p -> EmailNote_args -> P.IO ()
write_EmailNote_args oprot record = T.writeVal oprot $ from_EmailNote_args record
encode_EmailNote_args :: T.StatelessProtocol p => p -> EmailNote_args -> LBS.ByteString
encode_EmailNote_args oprot record = T.serializeVal oprot $ from_EmailNote_args record
to_EmailNote_args :: T.ThriftVal -> EmailNote_args
to_EmailNote_args (T.TStruct fields) = EmailNote_args{
  emailNote_args_authenticationToken = P.maybe (emailNote_args_authenticationToken default_EmailNote_args) (\(_,_val1662) -> (case _val1662 of {T.TString _val1663 -> E.decodeUtf8 _val1663; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  emailNote_args_parameters = P.maybe (emailNote_args_parameters default_EmailNote_args) (\(_,_val1662) -> (case _val1662 of {T.TStruct _val1664 -> (to_NoteEmailParameters (T.TStruct _val1664)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_EmailNote_args _ = P.error "not a struct"
read_EmailNote_args :: T.Protocol p => p -> P.IO EmailNote_args
read_EmailNote_args iprot = to_EmailNote_args <$> T.readVal iprot (T.T_STRUCT typemap_EmailNote_args)
decode_EmailNote_args :: T.StatelessProtocol p => p -> LBS.ByteString -> EmailNote_args
decode_EmailNote_args iprot bs = to_EmailNote_args $ T.deserializeVal iprot (T.T_STRUCT typemap_EmailNote_args) bs
typemap_EmailNote_args :: T.TypeMap
typemap_EmailNote_args = Map.fromList [(1,("authenticationToken",T.T_STRING)),(2,("parameters",(T.T_STRUCT typemap_NoteEmailParameters)))]
default_EmailNote_args :: EmailNote_args
default_EmailNote_args = EmailNote_args{
  emailNote_args_authenticationToken = "",
  emailNote_args_parameters = default_NoteEmailParameters}
data EmailNote_result = EmailNote_result  { emailNote_result_userException :: P.Maybe Errors_Types.EDAMUserException
  , emailNote_result_notFoundException :: P.Maybe Errors_Types.EDAMNotFoundException
  , emailNote_result_systemException :: P.Maybe Errors_Types.EDAMSystemException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable EmailNote_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` emailNote_result_userException record   `H.hashWithSalt` emailNote_result_notFoundException record   `H.hashWithSalt` emailNote_result_systemException record  
instance QC.Arbitrary EmailNote_result where 
  arbitrary = M.liftM EmailNote_result (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_EmailNote_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_EmailNote_result{emailNote_result_userException = emailNote_result_userException obj} then P.Nothing else P.Just $ default_EmailNote_result{emailNote_result_userException = emailNote_result_userException obj}
    , if obj == default_EmailNote_result{emailNote_result_notFoundException = emailNote_result_notFoundException obj} then P.Nothing else P.Just $ default_EmailNote_result{emailNote_result_notFoundException = emailNote_result_notFoundException obj}
    , if obj == default_EmailNote_result{emailNote_result_systemException = emailNote_result_systemException obj} then P.Nothing else P.Just $ default_EmailNote_result{emailNote_result_systemException = emailNote_result_systemException obj}
    ]
from_EmailNote_result :: EmailNote_result -> T.ThriftVal
from_EmailNote_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v1667 -> (1, ("userException",Errors_Types.from_EDAMUserException _v1667))) <$> emailNote_result_userException record, (\_v1667 -> (2, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v1667))) <$> emailNote_result_notFoundException record, (\_v1667 -> (3, ("systemException",Errors_Types.from_EDAMSystemException _v1667))) <$> emailNote_result_systemException record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v1667 -> (1, ("userException",Errors_Types.from_EDAMUserException _v1667))) <$> emailNote_result_userException record
    , (\_v1667 -> (2, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v1667))) <$> emailNote_result_notFoundException record
    , (\_v1667 -> (3, ("systemException",Errors_Types.from_EDAMSystemException _v1667))) <$> emailNote_result_systemException record
    ]
    )
write_EmailNote_result :: T.Protocol p => p -> EmailNote_result -> P.IO ()
write_EmailNote_result oprot record = T.writeVal oprot $ from_EmailNote_result record
encode_EmailNote_result :: T.StatelessProtocol p => p -> EmailNote_result -> LBS.ByteString
encode_EmailNote_result oprot record = T.serializeVal oprot $ from_EmailNote_result record
to_EmailNote_result :: T.ThriftVal -> EmailNote_result
to_EmailNote_result (T.TStruct fields) = EmailNote_result{
  emailNote_result_userException = P.maybe (P.Nothing) (\(_,_val1669) -> P.Just (case _val1669 of {T.TStruct _val1670 -> (Errors_Types.to_EDAMUserException (T.TStruct _val1670)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  emailNote_result_notFoundException = P.maybe (P.Nothing) (\(_,_val1669) -> P.Just (case _val1669 of {T.TStruct _val1671 -> (Errors_Types.to_EDAMNotFoundException (T.TStruct _val1671)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  emailNote_result_systemException = P.maybe (P.Nothing) (\(_,_val1669) -> P.Just (case _val1669 of {T.TStruct _val1672 -> (Errors_Types.to_EDAMSystemException (T.TStruct _val1672)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_EmailNote_result _ = P.error "not a struct"
read_EmailNote_result :: T.Protocol p => p -> P.IO EmailNote_result
read_EmailNote_result iprot = to_EmailNote_result <$> T.readVal iprot (T.T_STRUCT typemap_EmailNote_result)
decode_EmailNote_result :: T.StatelessProtocol p => p -> LBS.ByteString -> EmailNote_result
decode_EmailNote_result iprot bs = to_EmailNote_result $ T.deserializeVal iprot (T.T_STRUCT typemap_EmailNote_result) bs
typemap_EmailNote_result :: T.TypeMap
typemap_EmailNote_result = Map.fromList [(1,("userException",(T.T_STRUCT Errors_Types.typemap_EDAMUserException))),(2,("notFoundException",(T.T_STRUCT Errors_Types.typemap_EDAMNotFoundException))),(3,("systemException",(T.T_STRUCT Errors_Types.typemap_EDAMSystemException)))]
default_EmailNote_result :: EmailNote_result
default_EmailNote_result = EmailNote_result{
  emailNote_result_userException = P.Nothing,
  emailNote_result_notFoundException = P.Nothing,
  emailNote_result_systemException = P.Nothing}
data ShareNote_args = ShareNote_args  { shareNote_args_authenticationToken :: LT.Text
  , shareNote_args_guid :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ShareNote_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` shareNote_args_authenticationToken record   `H.hashWithSalt` shareNote_args_guid record  
instance QC.Arbitrary ShareNote_args where 
  arbitrary = M.liftM ShareNote_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_ShareNote_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ShareNote_args{shareNote_args_authenticationToken = shareNote_args_authenticationToken obj} then P.Nothing else P.Just $ default_ShareNote_args{shareNote_args_authenticationToken = shareNote_args_authenticationToken obj}
    , if obj == default_ShareNote_args{shareNote_args_guid = shareNote_args_guid obj} then P.Nothing else P.Just $ default_ShareNote_args{shareNote_args_guid = shareNote_args_guid obj}
    ]
from_ShareNote_args :: ShareNote_args -> T.ThriftVal
from_ShareNote_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1675 -> P.Just (1, ("authenticationToken",T.TString $ E.encodeUtf8 _v1675))) $ shareNote_args_authenticationToken record
  , (\_v1675 -> P.Just (2, ("guid",T.TString $ E.encodeUtf8 _v1675))) $ shareNote_args_guid record
  ]
write_ShareNote_args :: T.Protocol p => p -> ShareNote_args -> P.IO ()
write_ShareNote_args oprot record = T.writeVal oprot $ from_ShareNote_args record
encode_ShareNote_args :: T.StatelessProtocol p => p -> ShareNote_args -> LBS.ByteString
encode_ShareNote_args oprot record = T.serializeVal oprot $ from_ShareNote_args record
to_ShareNote_args :: T.ThriftVal -> ShareNote_args
to_ShareNote_args (T.TStruct fields) = ShareNote_args{
  shareNote_args_authenticationToken = P.maybe (shareNote_args_authenticationToken default_ShareNote_args) (\(_,_val1677) -> (case _val1677 of {T.TString _val1678 -> E.decodeUtf8 _val1678; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  shareNote_args_guid = P.maybe (shareNote_args_guid default_ShareNote_args) (\(_,_val1677) -> (case _val1677 of {T.TString _val1679 -> E.decodeUtf8 _val1679; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_ShareNote_args _ = P.error "not a struct"
read_ShareNote_args :: T.Protocol p => p -> P.IO ShareNote_args
read_ShareNote_args iprot = to_ShareNote_args <$> T.readVal iprot (T.T_STRUCT typemap_ShareNote_args)
decode_ShareNote_args :: T.StatelessProtocol p => p -> LBS.ByteString -> ShareNote_args
decode_ShareNote_args iprot bs = to_ShareNote_args $ T.deserializeVal iprot (T.T_STRUCT typemap_ShareNote_args) bs
typemap_ShareNote_args :: T.TypeMap
typemap_ShareNote_args = Map.fromList [(1,("authenticationToken",T.T_STRING)),(2,("guid",T.T_STRING))]
default_ShareNote_args :: ShareNote_args
default_ShareNote_args = ShareNote_args{
  shareNote_args_authenticationToken = "",
  shareNote_args_guid = ""}
data ShareNote_result = ShareNote_result  { shareNote_result_success :: LT.Text
  , shareNote_result_userException :: P.Maybe Errors_Types.EDAMUserException
  , shareNote_result_notFoundException :: P.Maybe Errors_Types.EDAMNotFoundException
  , shareNote_result_systemException :: P.Maybe Errors_Types.EDAMSystemException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ShareNote_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` shareNote_result_success record   `H.hashWithSalt` shareNote_result_userException record   `H.hashWithSalt` shareNote_result_notFoundException record   `H.hashWithSalt` shareNote_result_systemException record  
instance QC.Arbitrary ShareNote_result where 
  arbitrary = M.liftM ShareNote_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_ShareNote_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ShareNote_result{shareNote_result_success = shareNote_result_success obj} then P.Nothing else P.Just $ default_ShareNote_result{shareNote_result_success = shareNote_result_success obj}
    , if obj == default_ShareNote_result{shareNote_result_userException = shareNote_result_userException obj} then P.Nothing else P.Just $ default_ShareNote_result{shareNote_result_userException = shareNote_result_userException obj}
    , if obj == default_ShareNote_result{shareNote_result_notFoundException = shareNote_result_notFoundException obj} then P.Nothing else P.Just $ default_ShareNote_result{shareNote_result_notFoundException = shareNote_result_notFoundException obj}
    , if obj == default_ShareNote_result{shareNote_result_systemException = shareNote_result_systemException obj} then P.Nothing else P.Just $ default_ShareNote_result{shareNote_result_systemException = shareNote_result_systemException obj}
    ]
from_ShareNote_result :: ShareNote_result -> T.ThriftVal
from_ShareNote_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v1682 -> (1, ("userException",Errors_Types.from_EDAMUserException _v1682))) <$> shareNote_result_userException record, (\_v1682 -> (2, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v1682))) <$> shareNote_result_notFoundException record, (\_v1682 -> (3, ("systemException",Errors_Types.from_EDAMSystemException _v1682))) <$> shareNote_result_systemException record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v1682 -> P.Just (0, ("success",T.TString $ E.encodeUtf8 _v1682))) $ shareNote_result_success record
    , (\_v1682 -> (1, ("userException",Errors_Types.from_EDAMUserException _v1682))) <$> shareNote_result_userException record
    , (\_v1682 -> (2, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v1682))) <$> shareNote_result_notFoundException record
    , (\_v1682 -> (3, ("systemException",Errors_Types.from_EDAMSystemException _v1682))) <$> shareNote_result_systemException record
    ]
    )
write_ShareNote_result :: T.Protocol p => p -> ShareNote_result -> P.IO ()
write_ShareNote_result oprot record = T.writeVal oprot $ from_ShareNote_result record
encode_ShareNote_result :: T.StatelessProtocol p => p -> ShareNote_result -> LBS.ByteString
encode_ShareNote_result oprot record = T.serializeVal oprot $ from_ShareNote_result record
to_ShareNote_result :: T.ThriftVal -> ShareNote_result
to_ShareNote_result (T.TStruct fields) = ShareNote_result{
  shareNote_result_success = P.maybe (shareNote_result_success default_ShareNote_result) (\(_,_val1684) -> (case _val1684 of {T.TString _val1685 -> E.decodeUtf8 _val1685; _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  shareNote_result_userException = P.maybe (P.Nothing) (\(_,_val1684) -> P.Just (case _val1684 of {T.TStruct _val1686 -> (Errors_Types.to_EDAMUserException (T.TStruct _val1686)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  shareNote_result_notFoundException = P.maybe (P.Nothing) (\(_,_val1684) -> P.Just (case _val1684 of {T.TStruct _val1687 -> (Errors_Types.to_EDAMNotFoundException (T.TStruct _val1687)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  shareNote_result_systemException = P.maybe (P.Nothing) (\(_,_val1684) -> P.Just (case _val1684 of {T.TStruct _val1688 -> (Errors_Types.to_EDAMSystemException (T.TStruct _val1688)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_ShareNote_result _ = P.error "not a struct"
read_ShareNote_result :: T.Protocol p => p -> P.IO ShareNote_result
read_ShareNote_result iprot = to_ShareNote_result <$> T.readVal iprot (T.T_STRUCT typemap_ShareNote_result)
decode_ShareNote_result :: T.StatelessProtocol p => p -> LBS.ByteString -> ShareNote_result
decode_ShareNote_result iprot bs = to_ShareNote_result $ T.deserializeVal iprot (T.T_STRUCT typemap_ShareNote_result) bs
typemap_ShareNote_result :: T.TypeMap
typemap_ShareNote_result = Map.fromList [(0,("success",T.T_STRING)),(1,("userException",(T.T_STRUCT Errors_Types.typemap_EDAMUserException))),(2,("notFoundException",(T.T_STRUCT Errors_Types.typemap_EDAMNotFoundException))),(3,("systemException",(T.T_STRUCT Errors_Types.typemap_EDAMSystemException)))]
default_ShareNote_result :: ShareNote_result
default_ShareNote_result = ShareNote_result{
  shareNote_result_success = "",
  shareNote_result_userException = P.Nothing,
  shareNote_result_notFoundException = P.Nothing,
  shareNote_result_systemException = P.Nothing}
data StopSharingNote_args = StopSharingNote_args  { stopSharingNote_args_authenticationToken :: LT.Text
  , stopSharingNote_args_guid :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable StopSharingNote_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` stopSharingNote_args_authenticationToken record   `H.hashWithSalt` stopSharingNote_args_guid record  
instance QC.Arbitrary StopSharingNote_args where 
  arbitrary = M.liftM StopSharingNote_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_StopSharingNote_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_StopSharingNote_args{stopSharingNote_args_authenticationToken = stopSharingNote_args_authenticationToken obj} then P.Nothing else P.Just $ default_StopSharingNote_args{stopSharingNote_args_authenticationToken = stopSharingNote_args_authenticationToken obj}
    , if obj == default_StopSharingNote_args{stopSharingNote_args_guid = stopSharingNote_args_guid obj} then P.Nothing else P.Just $ default_StopSharingNote_args{stopSharingNote_args_guid = stopSharingNote_args_guid obj}
    ]
from_StopSharingNote_args :: StopSharingNote_args -> T.ThriftVal
from_StopSharingNote_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1691 -> P.Just (1, ("authenticationToken",T.TString $ E.encodeUtf8 _v1691))) $ stopSharingNote_args_authenticationToken record
  , (\_v1691 -> P.Just (2, ("guid",T.TString $ E.encodeUtf8 _v1691))) $ stopSharingNote_args_guid record
  ]
write_StopSharingNote_args :: T.Protocol p => p -> StopSharingNote_args -> P.IO ()
write_StopSharingNote_args oprot record = T.writeVal oprot $ from_StopSharingNote_args record
encode_StopSharingNote_args :: T.StatelessProtocol p => p -> StopSharingNote_args -> LBS.ByteString
encode_StopSharingNote_args oprot record = T.serializeVal oprot $ from_StopSharingNote_args record
to_StopSharingNote_args :: T.ThriftVal -> StopSharingNote_args
to_StopSharingNote_args (T.TStruct fields) = StopSharingNote_args{
  stopSharingNote_args_authenticationToken = P.maybe (stopSharingNote_args_authenticationToken default_StopSharingNote_args) (\(_,_val1693) -> (case _val1693 of {T.TString _val1694 -> E.decodeUtf8 _val1694; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  stopSharingNote_args_guid = P.maybe (stopSharingNote_args_guid default_StopSharingNote_args) (\(_,_val1693) -> (case _val1693 of {T.TString _val1695 -> E.decodeUtf8 _val1695; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_StopSharingNote_args _ = P.error "not a struct"
read_StopSharingNote_args :: T.Protocol p => p -> P.IO StopSharingNote_args
read_StopSharingNote_args iprot = to_StopSharingNote_args <$> T.readVal iprot (T.T_STRUCT typemap_StopSharingNote_args)
decode_StopSharingNote_args :: T.StatelessProtocol p => p -> LBS.ByteString -> StopSharingNote_args
decode_StopSharingNote_args iprot bs = to_StopSharingNote_args $ T.deserializeVal iprot (T.T_STRUCT typemap_StopSharingNote_args) bs
typemap_StopSharingNote_args :: T.TypeMap
typemap_StopSharingNote_args = Map.fromList [(1,("authenticationToken",T.T_STRING)),(2,("guid",T.T_STRING))]
default_StopSharingNote_args :: StopSharingNote_args
default_StopSharingNote_args = StopSharingNote_args{
  stopSharingNote_args_authenticationToken = "",
  stopSharingNote_args_guid = ""}
data StopSharingNote_result = StopSharingNote_result  { stopSharingNote_result_userException :: P.Maybe Errors_Types.EDAMUserException
  , stopSharingNote_result_notFoundException :: P.Maybe Errors_Types.EDAMNotFoundException
  , stopSharingNote_result_systemException :: P.Maybe Errors_Types.EDAMSystemException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable StopSharingNote_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` stopSharingNote_result_userException record   `H.hashWithSalt` stopSharingNote_result_notFoundException record   `H.hashWithSalt` stopSharingNote_result_systemException record  
instance QC.Arbitrary StopSharingNote_result where 
  arbitrary = M.liftM StopSharingNote_result (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_StopSharingNote_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_StopSharingNote_result{stopSharingNote_result_userException = stopSharingNote_result_userException obj} then P.Nothing else P.Just $ default_StopSharingNote_result{stopSharingNote_result_userException = stopSharingNote_result_userException obj}
    , if obj == default_StopSharingNote_result{stopSharingNote_result_notFoundException = stopSharingNote_result_notFoundException obj} then P.Nothing else P.Just $ default_StopSharingNote_result{stopSharingNote_result_notFoundException = stopSharingNote_result_notFoundException obj}
    , if obj == default_StopSharingNote_result{stopSharingNote_result_systemException = stopSharingNote_result_systemException obj} then P.Nothing else P.Just $ default_StopSharingNote_result{stopSharingNote_result_systemException = stopSharingNote_result_systemException obj}
    ]
from_StopSharingNote_result :: StopSharingNote_result -> T.ThriftVal
from_StopSharingNote_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v1698 -> (1, ("userException",Errors_Types.from_EDAMUserException _v1698))) <$> stopSharingNote_result_userException record, (\_v1698 -> (2, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v1698))) <$> stopSharingNote_result_notFoundException record, (\_v1698 -> (3, ("systemException",Errors_Types.from_EDAMSystemException _v1698))) <$> stopSharingNote_result_systemException record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v1698 -> (1, ("userException",Errors_Types.from_EDAMUserException _v1698))) <$> stopSharingNote_result_userException record
    , (\_v1698 -> (2, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v1698))) <$> stopSharingNote_result_notFoundException record
    , (\_v1698 -> (3, ("systemException",Errors_Types.from_EDAMSystemException _v1698))) <$> stopSharingNote_result_systemException record
    ]
    )
write_StopSharingNote_result :: T.Protocol p => p -> StopSharingNote_result -> P.IO ()
write_StopSharingNote_result oprot record = T.writeVal oprot $ from_StopSharingNote_result record
encode_StopSharingNote_result :: T.StatelessProtocol p => p -> StopSharingNote_result -> LBS.ByteString
encode_StopSharingNote_result oprot record = T.serializeVal oprot $ from_StopSharingNote_result record
to_StopSharingNote_result :: T.ThriftVal -> StopSharingNote_result
to_StopSharingNote_result (T.TStruct fields) = StopSharingNote_result{
  stopSharingNote_result_userException = P.maybe (P.Nothing) (\(_,_val1700) -> P.Just (case _val1700 of {T.TStruct _val1701 -> (Errors_Types.to_EDAMUserException (T.TStruct _val1701)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  stopSharingNote_result_notFoundException = P.maybe (P.Nothing) (\(_,_val1700) -> P.Just (case _val1700 of {T.TStruct _val1702 -> (Errors_Types.to_EDAMNotFoundException (T.TStruct _val1702)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  stopSharingNote_result_systemException = P.maybe (P.Nothing) (\(_,_val1700) -> P.Just (case _val1700 of {T.TStruct _val1703 -> (Errors_Types.to_EDAMSystemException (T.TStruct _val1703)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_StopSharingNote_result _ = P.error "not a struct"
read_StopSharingNote_result :: T.Protocol p => p -> P.IO StopSharingNote_result
read_StopSharingNote_result iprot = to_StopSharingNote_result <$> T.readVal iprot (T.T_STRUCT typemap_StopSharingNote_result)
decode_StopSharingNote_result :: T.StatelessProtocol p => p -> LBS.ByteString -> StopSharingNote_result
decode_StopSharingNote_result iprot bs = to_StopSharingNote_result $ T.deserializeVal iprot (T.T_STRUCT typemap_StopSharingNote_result) bs
typemap_StopSharingNote_result :: T.TypeMap
typemap_StopSharingNote_result = Map.fromList [(1,("userException",(T.T_STRUCT Errors_Types.typemap_EDAMUserException))),(2,("notFoundException",(T.T_STRUCT Errors_Types.typemap_EDAMNotFoundException))),(3,("systemException",(T.T_STRUCT Errors_Types.typemap_EDAMSystemException)))]
default_StopSharingNote_result :: StopSharingNote_result
default_StopSharingNote_result = StopSharingNote_result{
  stopSharingNote_result_userException = P.Nothing,
  stopSharingNote_result_notFoundException = P.Nothing,
  stopSharingNote_result_systemException = P.Nothing}
data AuthenticateToSharedNote_args = AuthenticateToSharedNote_args  { authenticateToSharedNote_args_guid :: LT.Text
  , authenticateToSharedNote_args_noteKey :: LT.Text
  , authenticateToSharedNote_args_authenticationToken :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable AuthenticateToSharedNote_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` authenticateToSharedNote_args_guid record   `H.hashWithSalt` authenticateToSharedNote_args_noteKey record   `H.hashWithSalt` authenticateToSharedNote_args_authenticationToken record  
instance QC.Arbitrary AuthenticateToSharedNote_args where 
  arbitrary = M.liftM AuthenticateToSharedNote_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_AuthenticateToSharedNote_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_AuthenticateToSharedNote_args{authenticateToSharedNote_args_guid = authenticateToSharedNote_args_guid obj} then P.Nothing else P.Just $ default_AuthenticateToSharedNote_args{authenticateToSharedNote_args_guid = authenticateToSharedNote_args_guid obj}
    , if obj == default_AuthenticateToSharedNote_args{authenticateToSharedNote_args_noteKey = authenticateToSharedNote_args_noteKey obj} then P.Nothing else P.Just $ default_AuthenticateToSharedNote_args{authenticateToSharedNote_args_noteKey = authenticateToSharedNote_args_noteKey obj}
    , if obj == default_AuthenticateToSharedNote_args{authenticateToSharedNote_args_authenticationToken = authenticateToSharedNote_args_authenticationToken obj} then P.Nothing else P.Just $ default_AuthenticateToSharedNote_args{authenticateToSharedNote_args_authenticationToken = authenticateToSharedNote_args_authenticationToken obj}
    ]
from_AuthenticateToSharedNote_args :: AuthenticateToSharedNote_args -> T.ThriftVal
from_AuthenticateToSharedNote_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1706 -> P.Just (1, ("guid",T.TString $ E.encodeUtf8 _v1706))) $ authenticateToSharedNote_args_guid record
  , (\_v1706 -> P.Just (2, ("noteKey",T.TString $ E.encodeUtf8 _v1706))) $ authenticateToSharedNote_args_noteKey record
  , (\_v1706 -> P.Just (3, ("authenticationToken",T.TString $ E.encodeUtf8 _v1706))) $ authenticateToSharedNote_args_authenticationToken record
  ]
write_AuthenticateToSharedNote_args :: T.Protocol p => p -> AuthenticateToSharedNote_args -> P.IO ()
write_AuthenticateToSharedNote_args oprot record = T.writeVal oprot $ from_AuthenticateToSharedNote_args record
encode_AuthenticateToSharedNote_args :: T.StatelessProtocol p => p -> AuthenticateToSharedNote_args -> LBS.ByteString
encode_AuthenticateToSharedNote_args oprot record = T.serializeVal oprot $ from_AuthenticateToSharedNote_args record
to_AuthenticateToSharedNote_args :: T.ThriftVal -> AuthenticateToSharedNote_args
to_AuthenticateToSharedNote_args (T.TStruct fields) = AuthenticateToSharedNote_args{
  authenticateToSharedNote_args_guid = P.maybe (authenticateToSharedNote_args_guid default_AuthenticateToSharedNote_args) (\(_,_val1708) -> (case _val1708 of {T.TString _val1709 -> E.decodeUtf8 _val1709; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  authenticateToSharedNote_args_noteKey = P.maybe (authenticateToSharedNote_args_noteKey default_AuthenticateToSharedNote_args) (\(_,_val1708) -> (case _val1708 of {T.TString _val1710 -> E.decodeUtf8 _val1710; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  authenticateToSharedNote_args_authenticationToken = P.maybe (authenticateToSharedNote_args_authenticationToken default_AuthenticateToSharedNote_args) (\(_,_val1708) -> (case _val1708 of {T.TString _val1711 -> E.decodeUtf8 _val1711; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_AuthenticateToSharedNote_args _ = P.error "not a struct"
read_AuthenticateToSharedNote_args :: T.Protocol p => p -> P.IO AuthenticateToSharedNote_args
read_AuthenticateToSharedNote_args iprot = to_AuthenticateToSharedNote_args <$> T.readVal iprot (T.T_STRUCT typemap_AuthenticateToSharedNote_args)
decode_AuthenticateToSharedNote_args :: T.StatelessProtocol p => p -> LBS.ByteString -> AuthenticateToSharedNote_args
decode_AuthenticateToSharedNote_args iprot bs = to_AuthenticateToSharedNote_args $ T.deserializeVal iprot (T.T_STRUCT typemap_AuthenticateToSharedNote_args) bs
typemap_AuthenticateToSharedNote_args :: T.TypeMap
typemap_AuthenticateToSharedNote_args = Map.fromList [(1,("guid",T.T_STRING)),(2,("noteKey",T.T_STRING)),(3,("authenticationToken",T.T_STRING))]
default_AuthenticateToSharedNote_args :: AuthenticateToSharedNote_args
default_AuthenticateToSharedNote_args = AuthenticateToSharedNote_args{
  authenticateToSharedNote_args_guid = "",
  authenticateToSharedNote_args_noteKey = "",
  authenticateToSharedNote_args_authenticationToken = ""}
data AuthenticateToSharedNote_result = AuthenticateToSharedNote_result  { authenticateToSharedNote_result_success :: UserStore_Types.AuthenticationResult
  , authenticateToSharedNote_result_userException :: P.Maybe Errors_Types.EDAMUserException
  , authenticateToSharedNote_result_notFoundException :: P.Maybe Errors_Types.EDAMNotFoundException
  , authenticateToSharedNote_result_systemException :: P.Maybe Errors_Types.EDAMSystemException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable AuthenticateToSharedNote_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` authenticateToSharedNote_result_success record   `H.hashWithSalt` authenticateToSharedNote_result_userException record   `H.hashWithSalt` authenticateToSharedNote_result_notFoundException record   `H.hashWithSalt` authenticateToSharedNote_result_systemException record  
instance QC.Arbitrary AuthenticateToSharedNote_result where 
  arbitrary = M.liftM AuthenticateToSharedNote_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_AuthenticateToSharedNote_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_AuthenticateToSharedNote_result{authenticateToSharedNote_result_success = authenticateToSharedNote_result_success obj} then P.Nothing else P.Just $ default_AuthenticateToSharedNote_result{authenticateToSharedNote_result_success = authenticateToSharedNote_result_success obj}
    , if obj == default_AuthenticateToSharedNote_result{authenticateToSharedNote_result_userException = authenticateToSharedNote_result_userException obj} then P.Nothing else P.Just $ default_AuthenticateToSharedNote_result{authenticateToSharedNote_result_userException = authenticateToSharedNote_result_userException obj}
    , if obj == default_AuthenticateToSharedNote_result{authenticateToSharedNote_result_notFoundException = authenticateToSharedNote_result_notFoundException obj} then P.Nothing else P.Just $ default_AuthenticateToSharedNote_result{authenticateToSharedNote_result_notFoundException = authenticateToSharedNote_result_notFoundException obj}
    , if obj == default_AuthenticateToSharedNote_result{authenticateToSharedNote_result_systemException = authenticateToSharedNote_result_systemException obj} then P.Nothing else P.Just $ default_AuthenticateToSharedNote_result{authenticateToSharedNote_result_systemException = authenticateToSharedNote_result_systemException obj}
    ]
from_AuthenticateToSharedNote_result :: AuthenticateToSharedNote_result -> T.ThriftVal
from_AuthenticateToSharedNote_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v1714 -> (1, ("userException",Errors_Types.from_EDAMUserException _v1714))) <$> authenticateToSharedNote_result_userException record, (\_v1714 -> (2, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v1714))) <$> authenticateToSharedNote_result_notFoundException record, (\_v1714 -> (3, ("systemException",Errors_Types.from_EDAMSystemException _v1714))) <$> authenticateToSharedNote_result_systemException record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v1714 -> P.Just (0, ("success",UserStore_Types.from_AuthenticationResult _v1714))) $ authenticateToSharedNote_result_success record
    , (\_v1714 -> (1, ("userException",Errors_Types.from_EDAMUserException _v1714))) <$> authenticateToSharedNote_result_userException record
    , (\_v1714 -> (2, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v1714))) <$> authenticateToSharedNote_result_notFoundException record
    , (\_v1714 -> (3, ("systemException",Errors_Types.from_EDAMSystemException _v1714))) <$> authenticateToSharedNote_result_systemException record
    ]
    )
write_AuthenticateToSharedNote_result :: T.Protocol p => p -> AuthenticateToSharedNote_result -> P.IO ()
write_AuthenticateToSharedNote_result oprot record = T.writeVal oprot $ from_AuthenticateToSharedNote_result record
encode_AuthenticateToSharedNote_result :: T.StatelessProtocol p => p -> AuthenticateToSharedNote_result -> LBS.ByteString
encode_AuthenticateToSharedNote_result oprot record = T.serializeVal oprot $ from_AuthenticateToSharedNote_result record
to_AuthenticateToSharedNote_result :: T.ThriftVal -> AuthenticateToSharedNote_result
to_AuthenticateToSharedNote_result (T.TStruct fields) = AuthenticateToSharedNote_result{
  authenticateToSharedNote_result_success = P.maybe (authenticateToSharedNote_result_success default_AuthenticateToSharedNote_result) (\(_,_val1716) -> (case _val1716 of {T.TStruct _val1717 -> (UserStore_Types.to_AuthenticationResult (T.TStruct _val1717)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  authenticateToSharedNote_result_userException = P.maybe (P.Nothing) (\(_,_val1716) -> P.Just (case _val1716 of {T.TStruct _val1718 -> (Errors_Types.to_EDAMUserException (T.TStruct _val1718)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  authenticateToSharedNote_result_notFoundException = P.maybe (P.Nothing) (\(_,_val1716) -> P.Just (case _val1716 of {T.TStruct _val1719 -> (Errors_Types.to_EDAMNotFoundException (T.TStruct _val1719)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  authenticateToSharedNote_result_systemException = P.maybe (P.Nothing) (\(_,_val1716) -> P.Just (case _val1716 of {T.TStruct _val1720 -> (Errors_Types.to_EDAMSystemException (T.TStruct _val1720)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_AuthenticateToSharedNote_result _ = P.error "not a struct"
read_AuthenticateToSharedNote_result :: T.Protocol p => p -> P.IO AuthenticateToSharedNote_result
read_AuthenticateToSharedNote_result iprot = to_AuthenticateToSharedNote_result <$> T.readVal iprot (T.T_STRUCT typemap_AuthenticateToSharedNote_result)
decode_AuthenticateToSharedNote_result :: T.StatelessProtocol p => p -> LBS.ByteString -> AuthenticateToSharedNote_result
decode_AuthenticateToSharedNote_result iprot bs = to_AuthenticateToSharedNote_result $ T.deserializeVal iprot (T.T_STRUCT typemap_AuthenticateToSharedNote_result) bs
typemap_AuthenticateToSharedNote_result :: T.TypeMap
typemap_AuthenticateToSharedNote_result = Map.fromList [(0,("success",(T.T_STRUCT UserStore_Types.typemap_AuthenticationResult))),(1,("userException",(T.T_STRUCT Errors_Types.typemap_EDAMUserException))),(2,("notFoundException",(T.T_STRUCT Errors_Types.typemap_EDAMNotFoundException))),(3,("systemException",(T.T_STRUCT Errors_Types.typemap_EDAMSystemException)))]
default_AuthenticateToSharedNote_result :: AuthenticateToSharedNote_result
default_AuthenticateToSharedNote_result = AuthenticateToSharedNote_result{
  authenticateToSharedNote_result_success = UserStore_Types.default_AuthenticationResult,
  authenticateToSharedNote_result_userException = P.Nothing,
  authenticateToSharedNote_result_notFoundException = P.Nothing,
  authenticateToSharedNote_result_systemException = P.Nothing}
data FindRelated_args = FindRelated_args  { findRelated_args_authenticationToken :: LT.Text
  , findRelated_args_query :: RelatedQuery
  , findRelated_args_resultSpec :: RelatedResultSpec
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable FindRelated_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` findRelated_args_authenticationToken record   `H.hashWithSalt` findRelated_args_query record   `H.hashWithSalt` findRelated_args_resultSpec record  
instance QC.Arbitrary FindRelated_args where 
  arbitrary = M.liftM FindRelated_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_FindRelated_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_FindRelated_args{findRelated_args_authenticationToken = findRelated_args_authenticationToken obj} then P.Nothing else P.Just $ default_FindRelated_args{findRelated_args_authenticationToken = findRelated_args_authenticationToken obj}
    , if obj == default_FindRelated_args{findRelated_args_query = findRelated_args_query obj} then P.Nothing else P.Just $ default_FindRelated_args{findRelated_args_query = findRelated_args_query obj}
    , if obj == default_FindRelated_args{findRelated_args_resultSpec = findRelated_args_resultSpec obj} then P.Nothing else P.Just $ default_FindRelated_args{findRelated_args_resultSpec = findRelated_args_resultSpec obj}
    ]
from_FindRelated_args :: FindRelated_args -> T.ThriftVal
from_FindRelated_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1723 -> P.Just (1, ("authenticationToken",T.TString $ E.encodeUtf8 _v1723))) $ findRelated_args_authenticationToken record
  , (\_v1723 -> P.Just (2, ("query",from_RelatedQuery _v1723))) $ findRelated_args_query record
  , (\_v1723 -> P.Just (3, ("resultSpec",from_RelatedResultSpec _v1723))) $ findRelated_args_resultSpec record
  ]
write_FindRelated_args :: T.Protocol p => p -> FindRelated_args -> P.IO ()
write_FindRelated_args oprot record = T.writeVal oprot $ from_FindRelated_args record
encode_FindRelated_args :: T.StatelessProtocol p => p -> FindRelated_args -> LBS.ByteString
encode_FindRelated_args oprot record = T.serializeVal oprot $ from_FindRelated_args record
to_FindRelated_args :: T.ThriftVal -> FindRelated_args
to_FindRelated_args (T.TStruct fields) = FindRelated_args{
  findRelated_args_authenticationToken = P.maybe (findRelated_args_authenticationToken default_FindRelated_args) (\(_,_val1725) -> (case _val1725 of {T.TString _val1726 -> E.decodeUtf8 _val1726; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  findRelated_args_query = P.maybe (findRelated_args_query default_FindRelated_args) (\(_,_val1725) -> (case _val1725 of {T.TStruct _val1727 -> (to_RelatedQuery (T.TStruct _val1727)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  findRelated_args_resultSpec = P.maybe (findRelated_args_resultSpec default_FindRelated_args) (\(_,_val1725) -> (case _val1725 of {T.TStruct _val1728 -> (to_RelatedResultSpec (T.TStruct _val1728)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_FindRelated_args _ = P.error "not a struct"
read_FindRelated_args :: T.Protocol p => p -> P.IO FindRelated_args
read_FindRelated_args iprot = to_FindRelated_args <$> T.readVal iprot (T.T_STRUCT typemap_FindRelated_args)
decode_FindRelated_args :: T.StatelessProtocol p => p -> LBS.ByteString -> FindRelated_args
decode_FindRelated_args iprot bs = to_FindRelated_args $ T.deserializeVal iprot (T.T_STRUCT typemap_FindRelated_args) bs
typemap_FindRelated_args :: T.TypeMap
typemap_FindRelated_args = Map.fromList [(1,("authenticationToken",T.T_STRING)),(2,("query",(T.T_STRUCT typemap_RelatedQuery))),(3,("resultSpec",(T.T_STRUCT typemap_RelatedResultSpec)))]
default_FindRelated_args :: FindRelated_args
default_FindRelated_args = FindRelated_args{
  findRelated_args_authenticationToken = "",
  findRelated_args_query = default_RelatedQuery,
  findRelated_args_resultSpec = default_RelatedResultSpec}
data FindRelated_result = FindRelated_result  { findRelated_result_success :: RelatedResult
  , findRelated_result_userException :: P.Maybe Errors_Types.EDAMUserException
  , findRelated_result_systemException :: P.Maybe Errors_Types.EDAMSystemException
  , findRelated_result_notFoundException :: P.Maybe Errors_Types.EDAMNotFoundException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable FindRelated_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` findRelated_result_success record   `H.hashWithSalt` findRelated_result_userException record   `H.hashWithSalt` findRelated_result_systemException record   `H.hashWithSalt` findRelated_result_notFoundException record  
instance QC.Arbitrary FindRelated_result where 
  arbitrary = M.liftM FindRelated_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_FindRelated_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_FindRelated_result{findRelated_result_success = findRelated_result_success obj} then P.Nothing else P.Just $ default_FindRelated_result{findRelated_result_success = findRelated_result_success obj}
    , if obj == default_FindRelated_result{findRelated_result_userException = findRelated_result_userException obj} then P.Nothing else P.Just $ default_FindRelated_result{findRelated_result_userException = findRelated_result_userException obj}
    , if obj == default_FindRelated_result{findRelated_result_systemException = findRelated_result_systemException obj} then P.Nothing else P.Just $ default_FindRelated_result{findRelated_result_systemException = findRelated_result_systemException obj}
    , if obj == default_FindRelated_result{findRelated_result_notFoundException = findRelated_result_notFoundException obj} then P.Nothing else P.Just $ default_FindRelated_result{findRelated_result_notFoundException = findRelated_result_notFoundException obj}
    ]
from_FindRelated_result :: FindRelated_result -> T.ThriftVal
from_FindRelated_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v1731 -> (1, ("userException",Errors_Types.from_EDAMUserException _v1731))) <$> findRelated_result_userException record, (\_v1731 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v1731))) <$> findRelated_result_systemException record, (\_v1731 -> (3, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v1731))) <$> findRelated_result_notFoundException record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v1731 -> P.Just (0, ("success",from_RelatedResult _v1731))) $ findRelated_result_success record
    , (\_v1731 -> (1, ("userException",Errors_Types.from_EDAMUserException _v1731))) <$> findRelated_result_userException record
    , (\_v1731 -> (2, ("systemException",Errors_Types.from_EDAMSystemException _v1731))) <$> findRelated_result_systemException record
    , (\_v1731 -> (3, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v1731))) <$> findRelated_result_notFoundException record
    ]
    )
write_FindRelated_result :: T.Protocol p => p -> FindRelated_result -> P.IO ()
write_FindRelated_result oprot record = T.writeVal oprot $ from_FindRelated_result record
encode_FindRelated_result :: T.StatelessProtocol p => p -> FindRelated_result -> LBS.ByteString
encode_FindRelated_result oprot record = T.serializeVal oprot $ from_FindRelated_result record
to_FindRelated_result :: T.ThriftVal -> FindRelated_result
to_FindRelated_result (T.TStruct fields) = FindRelated_result{
  findRelated_result_success = P.maybe (findRelated_result_success default_FindRelated_result) (\(_,_val1733) -> (case _val1733 of {T.TStruct _val1734 -> (to_RelatedResult (T.TStruct _val1734)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  findRelated_result_userException = P.maybe (P.Nothing) (\(_,_val1733) -> P.Just (case _val1733 of {T.TStruct _val1735 -> (Errors_Types.to_EDAMUserException (T.TStruct _val1735)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  findRelated_result_systemException = P.maybe (P.Nothing) (\(_,_val1733) -> P.Just (case _val1733 of {T.TStruct _val1736 -> (Errors_Types.to_EDAMSystemException (T.TStruct _val1736)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  findRelated_result_notFoundException = P.maybe (P.Nothing) (\(_,_val1733) -> P.Just (case _val1733 of {T.TStruct _val1737 -> (Errors_Types.to_EDAMNotFoundException (T.TStruct _val1737)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_FindRelated_result _ = P.error "not a struct"
read_FindRelated_result :: T.Protocol p => p -> P.IO FindRelated_result
read_FindRelated_result iprot = to_FindRelated_result <$> T.readVal iprot (T.T_STRUCT typemap_FindRelated_result)
decode_FindRelated_result :: T.StatelessProtocol p => p -> LBS.ByteString -> FindRelated_result
decode_FindRelated_result iprot bs = to_FindRelated_result $ T.deserializeVal iprot (T.T_STRUCT typemap_FindRelated_result) bs
typemap_FindRelated_result :: T.TypeMap
typemap_FindRelated_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_RelatedResult))),(1,("userException",(T.T_STRUCT Errors_Types.typemap_EDAMUserException))),(2,("systemException",(T.T_STRUCT Errors_Types.typemap_EDAMSystemException))),(3,("notFoundException",(T.T_STRUCT Errors_Types.typemap_EDAMNotFoundException)))]
default_FindRelated_result :: FindRelated_result
default_FindRelated_result = FindRelated_result{
  findRelated_result_success = default_RelatedResult,
  findRelated_result_userException = P.Nothing,
  findRelated_result_systemException = P.Nothing,
  findRelated_result_notFoundException = P.Nothing}
data UpdateNoteIfUsnMatches_args = UpdateNoteIfUsnMatches_args  { updateNoteIfUsnMatches_args_authenticationToken :: LT.Text
  , updateNoteIfUsnMatches_args_note :: Types_Types.Note
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateNoteIfUsnMatches_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateNoteIfUsnMatches_args_authenticationToken record   `H.hashWithSalt` updateNoteIfUsnMatches_args_note record  
instance QC.Arbitrary UpdateNoteIfUsnMatches_args where 
  arbitrary = M.liftM UpdateNoteIfUsnMatches_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_UpdateNoteIfUsnMatches_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateNoteIfUsnMatches_args{updateNoteIfUsnMatches_args_authenticationToken = updateNoteIfUsnMatches_args_authenticationToken obj} then P.Nothing else P.Just $ default_UpdateNoteIfUsnMatches_args{updateNoteIfUsnMatches_args_authenticationToken = updateNoteIfUsnMatches_args_authenticationToken obj}
    , if obj == default_UpdateNoteIfUsnMatches_args{updateNoteIfUsnMatches_args_note = updateNoteIfUsnMatches_args_note obj} then P.Nothing else P.Just $ default_UpdateNoteIfUsnMatches_args{updateNoteIfUsnMatches_args_note = updateNoteIfUsnMatches_args_note obj}
    ]
from_UpdateNoteIfUsnMatches_args :: UpdateNoteIfUsnMatches_args -> T.ThriftVal
from_UpdateNoteIfUsnMatches_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1740 -> P.Just (1, ("authenticationToken",T.TString $ E.encodeUtf8 _v1740))) $ updateNoteIfUsnMatches_args_authenticationToken record
  , (\_v1740 -> P.Just (2, ("note",Types_Types.from_Note _v1740))) $ updateNoteIfUsnMatches_args_note record
  ]
write_UpdateNoteIfUsnMatches_args :: T.Protocol p => p -> UpdateNoteIfUsnMatches_args -> P.IO ()
write_UpdateNoteIfUsnMatches_args oprot record = T.writeVal oprot $ from_UpdateNoteIfUsnMatches_args record
encode_UpdateNoteIfUsnMatches_args :: T.StatelessProtocol p => p -> UpdateNoteIfUsnMatches_args -> LBS.ByteString
encode_UpdateNoteIfUsnMatches_args oprot record = T.serializeVal oprot $ from_UpdateNoteIfUsnMatches_args record
to_UpdateNoteIfUsnMatches_args :: T.ThriftVal -> UpdateNoteIfUsnMatches_args
to_UpdateNoteIfUsnMatches_args (T.TStruct fields) = UpdateNoteIfUsnMatches_args{
  updateNoteIfUsnMatches_args_authenticationToken = P.maybe (updateNoteIfUsnMatches_args_authenticationToken default_UpdateNoteIfUsnMatches_args) (\(_,_val1742) -> (case _val1742 of {T.TString _val1743 -> E.decodeUtf8 _val1743; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  updateNoteIfUsnMatches_args_note = P.maybe (updateNoteIfUsnMatches_args_note default_UpdateNoteIfUsnMatches_args) (\(_,_val1742) -> (case _val1742 of {T.TStruct _val1744 -> (Types_Types.to_Note (T.TStruct _val1744)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_UpdateNoteIfUsnMatches_args _ = P.error "not a struct"
read_UpdateNoteIfUsnMatches_args :: T.Protocol p => p -> P.IO UpdateNoteIfUsnMatches_args
read_UpdateNoteIfUsnMatches_args iprot = to_UpdateNoteIfUsnMatches_args <$> T.readVal iprot (T.T_STRUCT typemap_UpdateNoteIfUsnMatches_args)
decode_UpdateNoteIfUsnMatches_args :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateNoteIfUsnMatches_args
decode_UpdateNoteIfUsnMatches_args iprot bs = to_UpdateNoteIfUsnMatches_args $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateNoteIfUsnMatches_args) bs
typemap_UpdateNoteIfUsnMatches_args :: T.TypeMap
typemap_UpdateNoteIfUsnMatches_args = Map.fromList [(1,("authenticationToken",T.T_STRING)),(2,("note",(T.T_STRUCT Types_Types.typemap_Note)))]
default_UpdateNoteIfUsnMatches_args :: UpdateNoteIfUsnMatches_args
default_UpdateNoteIfUsnMatches_args = UpdateNoteIfUsnMatches_args{
  updateNoteIfUsnMatches_args_authenticationToken = "",
  updateNoteIfUsnMatches_args_note = Types_Types.default_Note}
data UpdateNoteIfUsnMatches_result = UpdateNoteIfUsnMatches_result  { updateNoteIfUsnMatches_result_success :: UpdateNoteIfUsnMatchesResult
  , updateNoteIfUsnMatches_result_userException :: P.Maybe Errors_Types.EDAMUserException
  , updateNoteIfUsnMatches_result_notFoundException :: P.Maybe Errors_Types.EDAMNotFoundException
  , updateNoteIfUsnMatches_result_systemException :: P.Maybe Errors_Types.EDAMSystemException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UpdateNoteIfUsnMatches_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` updateNoteIfUsnMatches_result_success record   `H.hashWithSalt` updateNoteIfUsnMatches_result_userException record   `H.hashWithSalt` updateNoteIfUsnMatches_result_notFoundException record   `H.hashWithSalt` updateNoteIfUsnMatches_result_systemException record  
instance QC.Arbitrary UpdateNoteIfUsnMatches_result where 
  arbitrary = M.liftM UpdateNoteIfUsnMatches_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_UpdateNoteIfUsnMatches_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UpdateNoteIfUsnMatches_result{updateNoteIfUsnMatches_result_success = updateNoteIfUsnMatches_result_success obj} then P.Nothing else P.Just $ default_UpdateNoteIfUsnMatches_result{updateNoteIfUsnMatches_result_success = updateNoteIfUsnMatches_result_success obj}
    , if obj == default_UpdateNoteIfUsnMatches_result{updateNoteIfUsnMatches_result_userException = updateNoteIfUsnMatches_result_userException obj} then P.Nothing else P.Just $ default_UpdateNoteIfUsnMatches_result{updateNoteIfUsnMatches_result_userException = updateNoteIfUsnMatches_result_userException obj}
    , if obj == default_UpdateNoteIfUsnMatches_result{updateNoteIfUsnMatches_result_notFoundException = updateNoteIfUsnMatches_result_notFoundException obj} then P.Nothing else P.Just $ default_UpdateNoteIfUsnMatches_result{updateNoteIfUsnMatches_result_notFoundException = updateNoteIfUsnMatches_result_notFoundException obj}
    , if obj == default_UpdateNoteIfUsnMatches_result{updateNoteIfUsnMatches_result_systemException = updateNoteIfUsnMatches_result_systemException obj} then P.Nothing else P.Just $ default_UpdateNoteIfUsnMatches_result{updateNoteIfUsnMatches_result_systemException = updateNoteIfUsnMatches_result_systemException obj}
    ]
from_UpdateNoteIfUsnMatches_result :: UpdateNoteIfUsnMatches_result -> T.ThriftVal
from_UpdateNoteIfUsnMatches_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v1747 -> (1, ("userException",Errors_Types.from_EDAMUserException _v1747))) <$> updateNoteIfUsnMatches_result_userException record, (\_v1747 -> (2, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v1747))) <$> updateNoteIfUsnMatches_result_notFoundException record, (\_v1747 -> (3, ("systemException",Errors_Types.from_EDAMSystemException _v1747))) <$> updateNoteIfUsnMatches_result_systemException record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v1747 -> P.Just (0, ("success",from_UpdateNoteIfUsnMatchesResult _v1747))) $ updateNoteIfUsnMatches_result_success record
    , (\_v1747 -> (1, ("userException",Errors_Types.from_EDAMUserException _v1747))) <$> updateNoteIfUsnMatches_result_userException record
    , (\_v1747 -> (2, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v1747))) <$> updateNoteIfUsnMatches_result_notFoundException record
    , (\_v1747 -> (3, ("systemException",Errors_Types.from_EDAMSystemException _v1747))) <$> updateNoteIfUsnMatches_result_systemException record
    ]
    )
write_UpdateNoteIfUsnMatches_result :: T.Protocol p => p -> UpdateNoteIfUsnMatches_result -> P.IO ()
write_UpdateNoteIfUsnMatches_result oprot record = T.writeVal oprot $ from_UpdateNoteIfUsnMatches_result record
encode_UpdateNoteIfUsnMatches_result :: T.StatelessProtocol p => p -> UpdateNoteIfUsnMatches_result -> LBS.ByteString
encode_UpdateNoteIfUsnMatches_result oprot record = T.serializeVal oprot $ from_UpdateNoteIfUsnMatches_result record
to_UpdateNoteIfUsnMatches_result :: T.ThriftVal -> UpdateNoteIfUsnMatches_result
to_UpdateNoteIfUsnMatches_result (T.TStruct fields) = UpdateNoteIfUsnMatches_result{
  updateNoteIfUsnMatches_result_success = P.maybe (updateNoteIfUsnMatches_result_success default_UpdateNoteIfUsnMatches_result) (\(_,_val1749) -> (case _val1749 of {T.TStruct _val1750 -> (to_UpdateNoteIfUsnMatchesResult (T.TStruct _val1750)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  updateNoteIfUsnMatches_result_userException = P.maybe (P.Nothing) (\(_,_val1749) -> P.Just (case _val1749 of {T.TStruct _val1751 -> (Errors_Types.to_EDAMUserException (T.TStruct _val1751)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  updateNoteIfUsnMatches_result_notFoundException = P.maybe (P.Nothing) (\(_,_val1749) -> P.Just (case _val1749 of {T.TStruct _val1752 -> (Errors_Types.to_EDAMNotFoundException (T.TStruct _val1752)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  updateNoteIfUsnMatches_result_systemException = P.maybe (P.Nothing) (\(_,_val1749) -> P.Just (case _val1749 of {T.TStruct _val1753 -> (Errors_Types.to_EDAMSystemException (T.TStruct _val1753)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_UpdateNoteIfUsnMatches_result _ = P.error "not a struct"
read_UpdateNoteIfUsnMatches_result :: T.Protocol p => p -> P.IO UpdateNoteIfUsnMatches_result
read_UpdateNoteIfUsnMatches_result iprot = to_UpdateNoteIfUsnMatches_result <$> T.readVal iprot (T.T_STRUCT typemap_UpdateNoteIfUsnMatches_result)
decode_UpdateNoteIfUsnMatches_result :: T.StatelessProtocol p => p -> LBS.ByteString -> UpdateNoteIfUsnMatches_result
decode_UpdateNoteIfUsnMatches_result iprot bs = to_UpdateNoteIfUsnMatches_result $ T.deserializeVal iprot (T.T_STRUCT typemap_UpdateNoteIfUsnMatches_result) bs
typemap_UpdateNoteIfUsnMatches_result :: T.TypeMap
typemap_UpdateNoteIfUsnMatches_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_UpdateNoteIfUsnMatchesResult))),(1,("userException",(T.T_STRUCT Errors_Types.typemap_EDAMUserException))),(2,("notFoundException",(T.T_STRUCT Errors_Types.typemap_EDAMNotFoundException))),(3,("systemException",(T.T_STRUCT Errors_Types.typemap_EDAMSystemException)))]
default_UpdateNoteIfUsnMatches_result :: UpdateNoteIfUsnMatches_result
default_UpdateNoteIfUsnMatches_result = UpdateNoteIfUsnMatches_result{
  updateNoteIfUsnMatches_result_success = default_UpdateNoteIfUsnMatchesResult,
  updateNoteIfUsnMatches_result_userException = P.Nothing,
  updateNoteIfUsnMatches_result_notFoundException = P.Nothing,
  updateNoteIfUsnMatches_result_systemException = P.Nothing}
data ManageNotebookShares_args = ManageNotebookShares_args  { manageNotebookShares_args_authenticationToken :: LT.Text
  , manageNotebookShares_args_parameters :: ManageNotebookSharesParameters
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ManageNotebookShares_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` manageNotebookShares_args_authenticationToken record   `H.hashWithSalt` manageNotebookShares_args_parameters record  
instance QC.Arbitrary ManageNotebookShares_args where 
  arbitrary = M.liftM ManageNotebookShares_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_ManageNotebookShares_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ManageNotebookShares_args{manageNotebookShares_args_authenticationToken = manageNotebookShares_args_authenticationToken obj} then P.Nothing else P.Just $ default_ManageNotebookShares_args{manageNotebookShares_args_authenticationToken = manageNotebookShares_args_authenticationToken obj}
    , if obj == default_ManageNotebookShares_args{manageNotebookShares_args_parameters = manageNotebookShares_args_parameters obj} then P.Nothing else P.Just $ default_ManageNotebookShares_args{manageNotebookShares_args_parameters = manageNotebookShares_args_parameters obj}
    ]
from_ManageNotebookShares_args :: ManageNotebookShares_args -> T.ThriftVal
from_ManageNotebookShares_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1756 -> P.Just (1, ("authenticationToken",T.TString $ E.encodeUtf8 _v1756))) $ manageNotebookShares_args_authenticationToken record
  , (\_v1756 -> P.Just (2, ("parameters",from_ManageNotebookSharesParameters _v1756))) $ manageNotebookShares_args_parameters record
  ]
write_ManageNotebookShares_args :: T.Protocol p => p -> ManageNotebookShares_args -> P.IO ()
write_ManageNotebookShares_args oprot record = T.writeVal oprot $ from_ManageNotebookShares_args record
encode_ManageNotebookShares_args :: T.StatelessProtocol p => p -> ManageNotebookShares_args -> LBS.ByteString
encode_ManageNotebookShares_args oprot record = T.serializeVal oprot $ from_ManageNotebookShares_args record
to_ManageNotebookShares_args :: T.ThriftVal -> ManageNotebookShares_args
to_ManageNotebookShares_args (T.TStruct fields) = ManageNotebookShares_args{
  manageNotebookShares_args_authenticationToken = P.maybe (manageNotebookShares_args_authenticationToken default_ManageNotebookShares_args) (\(_,_val1758) -> (case _val1758 of {T.TString _val1759 -> E.decodeUtf8 _val1759; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  manageNotebookShares_args_parameters = P.maybe (manageNotebookShares_args_parameters default_ManageNotebookShares_args) (\(_,_val1758) -> (case _val1758 of {T.TStruct _val1760 -> (to_ManageNotebookSharesParameters (T.TStruct _val1760)); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_ManageNotebookShares_args _ = P.error "not a struct"
read_ManageNotebookShares_args :: T.Protocol p => p -> P.IO ManageNotebookShares_args
read_ManageNotebookShares_args iprot = to_ManageNotebookShares_args <$> T.readVal iprot (T.T_STRUCT typemap_ManageNotebookShares_args)
decode_ManageNotebookShares_args :: T.StatelessProtocol p => p -> LBS.ByteString -> ManageNotebookShares_args
decode_ManageNotebookShares_args iprot bs = to_ManageNotebookShares_args $ T.deserializeVal iprot (T.T_STRUCT typemap_ManageNotebookShares_args) bs
typemap_ManageNotebookShares_args :: T.TypeMap
typemap_ManageNotebookShares_args = Map.fromList [(1,("authenticationToken",T.T_STRING)),(2,("parameters",(T.T_STRUCT typemap_ManageNotebookSharesParameters)))]
default_ManageNotebookShares_args :: ManageNotebookShares_args
default_ManageNotebookShares_args = ManageNotebookShares_args{
  manageNotebookShares_args_authenticationToken = "",
  manageNotebookShares_args_parameters = default_ManageNotebookSharesParameters}
data ManageNotebookShares_result = ManageNotebookShares_result  { manageNotebookShares_result_success :: ManageNotebookSharesResult
  , manageNotebookShares_result_userException :: P.Maybe Errors_Types.EDAMUserException
  , manageNotebookShares_result_notFoundException :: P.Maybe Errors_Types.EDAMNotFoundException
  , manageNotebookShares_result_systemException :: P.Maybe Errors_Types.EDAMSystemException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ManageNotebookShares_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` manageNotebookShares_result_success record   `H.hashWithSalt` manageNotebookShares_result_userException record   `H.hashWithSalt` manageNotebookShares_result_notFoundException record   `H.hashWithSalt` manageNotebookShares_result_systemException record  
instance QC.Arbitrary ManageNotebookShares_result where 
  arbitrary = M.liftM ManageNotebookShares_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_ManageNotebookShares_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ManageNotebookShares_result{manageNotebookShares_result_success = manageNotebookShares_result_success obj} then P.Nothing else P.Just $ default_ManageNotebookShares_result{manageNotebookShares_result_success = manageNotebookShares_result_success obj}
    , if obj == default_ManageNotebookShares_result{manageNotebookShares_result_userException = manageNotebookShares_result_userException obj} then P.Nothing else P.Just $ default_ManageNotebookShares_result{manageNotebookShares_result_userException = manageNotebookShares_result_userException obj}
    , if obj == default_ManageNotebookShares_result{manageNotebookShares_result_notFoundException = manageNotebookShares_result_notFoundException obj} then P.Nothing else P.Just $ default_ManageNotebookShares_result{manageNotebookShares_result_notFoundException = manageNotebookShares_result_notFoundException obj}
    , if obj == default_ManageNotebookShares_result{manageNotebookShares_result_systemException = manageNotebookShares_result_systemException obj} then P.Nothing else P.Just $ default_ManageNotebookShares_result{manageNotebookShares_result_systemException = manageNotebookShares_result_systemException obj}
    ]
from_ManageNotebookShares_result :: ManageNotebookShares_result -> T.ThriftVal
from_ManageNotebookShares_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v1763 -> (1, ("userException",Errors_Types.from_EDAMUserException _v1763))) <$> manageNotebookShares_result_userException record, (\_v1763 -> (2, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v1763))) <$> manageNotebookShares_result_notFoundException record, (\_v1763 -> (3, ("systemException",Errors_Types.from_EDAMSystemException _v1763))) <$> manageNotebookShares_result_systemException record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v1763 -> P.Just (0, ("success",from_ManageNotebookSharesResult _v1763))) $ manageNotebookShares_result_success record
    , (\_v1763 -> (1, ("userException",Errors_Types.from_EDAMUserException _v1763))) <$> manageNotebookShares_result_userException record
    , (\_v1763 -> (2, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v1763))) <$> manageNotebookShares_result_notFoundException record
    , (\_v1763 -> (3, ("systemException",Errors_Types.from_EDAMSystemException _v1763))) <$> manageNotebookShares_result_systemException record
    ]
    )
write_ManageNotebookShares_result :: T.Protocol p => p -> ManageNotebookShares_result -> P.IO ()
write_ManageNotebookShares_result oprot record = T.writeVal oprot $ from_ManageNotebookShares_result record
encode_ManageNotebookShares_result :: T.StatelessProtocol p => p -> ManageNotebookShares_result -> LBS.ByteString
encode_ManageNotebookShares_result oprot record = T.serializeVal oprot $ from_ManageNotebookShares_result record
to_ManageNotebookShares_result :: T.ThriftVal -> ManageNotebookShares_result
to_ManageNotebookShares_result (T.TStruct fields) = ManageNotebookShares_result{
  manageNotebookShares_result_success = P.maybe (manageNotebookShares_result_success default_ManageNotebookShares_result) (\(_,_val1765) -> (case _val1765 of {T.TStruct _val1766 -> (to_ManageNotebookSharesResult (T.TStruct _val1766)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  manageNotebookShares_result_userException = P.maybe (P.Nothing) (\(_,_val1765) -> P.Just (case _val1765 of {T.TStruct _val1767 -> (Errors_Types.to_EDAMUserException (T.TStruct _val1767)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  manageNotebookShares_result_notFoundException = P.maybe (P.Nothing) (\(_,_val1765) -> P.Just (case _val1765 of {T.TStruct _val1768 -> (Errors_Types.to_EDAMNotFoundException (T.TStruct _val1768)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  manageNotebookShares_result_systemException = P.maybe (P.Nothing) (\(_,_val1765) -> P.Just (case _val1765 of {T.TStruct _val1769 -> (Errors_Types.to_EDAMSystemException (T.TStruct _val1769)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_ManageNotebookShares_result _ = P.error "not a struct"
read_ManageNotebookShares_result :: T.Protocol p => p -> P.IO ManageNotebookShares_result
read_ManageNotebookShares_result iprot = to_ManageNotebookShares_result <$> T.readVal iprot (T.T_STRUCT typemap_ManageNotebookShares_result)
decode_ManageNotebookShares_result :: T.StatelessProtocol p => p -> LBS.ByteString -> ManageNotebookShares_result
decode_ManageNotebookShares_result iprot bs = to_ManageNotebookShares_result $ T.deserializeVal iprot (T.T_STRUCT typemap_ManageNotebookShares_result) bs
typemap_ManageNotebookShares_result :: T.TypeMap
typemap_ManageNotebookShares_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_ManageNotebookSharesResult))),(1,("userException",(T.T_STRUCT Errors_Types.typemap_EDAMUserException))),(2,("notFoundException",(T.T_STRUCT Errors_Types.typemap_EDAMNotFoundException))),(3,("systemException",(T.T_STRUCT Errors_Types.typemap_EDAMSystemException)))]
default_ManageNotebookShares_result :: ManageNotebookShares_result
default_ManageNotebookShares_result = ManageNotebookShares_result{
  manageNotebookShares_result_success = default_ManageNotebookSharesResult,
  manageNotebookShares_result_userException = P.Nothing,
  manageNotebookShares_result_notFoundException = P.Nothing,
  manageNotebookShares_result_systemException = P.Nothing}
data GetNotebookShares_args = GetNotebookShares_args  { getNotebookShares_args_authenticationToken :: LT.Text
  , getNotebookShares_args_notebookGuid :: LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetNotebookShares_args where
  hashWithSalt salt record = salt   `H.hashWithSalt` getNotebookShares_args_authenticationToken record   `H.hashWithSalt` getNotebookShares_args_notebookGuid record  
instance QC.Arbitrary GetNotebookShares_args where 
  arbitrary = M.liftM GetNotebookShares_args (QC.arbitrary)
          `M.ap`(QC.arbitrary)
  shrink obj | obj == default_GetNotebookShares_args = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetNotebookShares_args{getNotebookShares_args_authenticationToken = getNotebookShares_args_authenticationToken obj} then P.Nothing else P.Just $ default_GetNotebookShares_args{getNotebookShares_args_authenticationToken = getNotebookShares_args_authenticationToken obj}
    , if obj == default_GetNotebookShares_args{getNotebookShares_args_notebookGuid = getNotebookShares_args_notebookGuid obj} then P.Nothing else P.Just $ default_GetNotebookShares_args{getNotebookShares_args_notebookGuid = getNotebookShares_args_notebookGuid obj}
    ]
from_GetNotebookShares_args :: GetNotebookShares_args -> T.ThriftVal
from_GetNotebookShares_args record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v1772 -> P.Just (1, ("authenticationToken",T.TString $ E.encodeUtf8 _v1772))) $ getNotebookShares_args_authenticationToken record
  , (\_v1772 -> P.Just (2, ("notebookGuid",T.TString $ E.encodeUtf8 _v1772))) $ getNotebookShares_args_notebookGuid record
  ]
write_GetNotebookShares_args :: T.Protocol p => p -> GetNotebookShares_args -> P.IO ()
write_GetNotebookShares_args oprot record = T.writeVal oprot $ from_GetNotebookShares_args record
encode_GetNotebookShares_args :: T.StatelessProtocol p => p -> GetNotebookShares_args -> LBS.ByteString
encode_GetNotebookShares_args oprot record = T.serializeVal oprot $ from_GetNotebookShares_args record
to_GetNotebookShares_args :: T.ThriftVal -> GetNotebookShares_args
to_GetNotebookShares_args (T.TStruct fields) = GetNotebookShares_args{
  getNotebookShares_args_authenticationToken = P.maybe (getNotebookShares_args_authenticationToken default_GetNotebookShares_args) (\(_,_val1774) -> (case _val1774 of {T.TString _val1775 -> E.decodeUtf8 _val1775; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  getNotebookShares_args_notebookGuid = P.maybe (getNotebookShares_args_notebookGuid default_GetNotebookShares_args) (\(_,_val1774) -> (case _val1774 of {T.TString _val1776 -> E.decodeUtf8 _val1776; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_GetNotebookShares_args _ = P.error "not a struct"
read_GetNotebookShares_args :: T.Protocol p => p -> P.IO GetNotebookShares_args
read_GetNotebookShares_args iprot = to_GetNotebookShares_args <$> T.readVal iprot (T.T_STRUCT typemap_GetNotebookShares_args)
decode_GetNotebookShares_args :: T.StatelessProtocol p => p -> LBS.ByteString -> GetNotebookShares_args
decode_GetNotebookShares_args iprot bs = to_GetNotebookShares_args $ T.deserializeVal iprot (T.T_STRUCT typemap_GetNotebookShares_args) bs
typemap_GetNotebookShares_args :: T.TypeMap
typemap_GetNotebookShares_args = Map.fromList [(1,("authenticationToken",T.T_STRING)),(2,("notebookGuid",T.T_STRING))]
default_GetNotebookShares_args :: GetNotebookShares_args
default_GetNotebookShares_args = GetNotebookShares_args{
  getNotebookShares_args_authenticationToken = "",
  getNotebookShares_args_notebookGuid = ""}
data GetNotebookShares_result = GetNotebookShares_result  { getNotebookShares_result_success :: ShareRelationships
  , getNotebookShares_result_userException :: P.Maybe Errors_Types.EDAMUserException
  , getNotebookShares_result_notFoundException :: P.Maybe Errors_Types.EDAMNotFoundException
  , getNotebookShares_result_systemException :: P.Maybe Errors_Types.EDAMSystemException
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable GetNotebookShares_result where
  hashWithSalt salt record = salt   `H.hashWithSalt` getNotebookShares_result_success record   `H.hashWithSalt` getNotebookShares_result_userException record   `H.hashWithSalt` getNotebookShares_result_notFoundException record   `H.hashWithSalt` getNotebookShares_result_systemException record  
instance QC.Arbitrary GetNotebookShares_result where 
  arbitrary = M.liftM GetNotebookShares_result (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_GetNotebookShares_result = []
             | P.otherwise = M.catMaybes
    [ if obj == default_GetNotebookShares_result{getNotebookShares_result_success = getNotebookShares_result_success obj} then P.Nothing else P.Just $ default_GetNotebookShares_result{getNotebookShares_result_success = getNotebookShares_result_success obj}
    , if obj == default_GetNotebookShares_result{getNotebookShares_result_userException = getNotebookShares_result_userException obj} then P.Nothing else P.Just $ default_GetNotebookShares_result{getNotebookShares_result_userException = getNotebookShares_result_userException obj}
    , if obj == default_GetNotebookShares_result{getNotebookShares_result_notFoundException = getNotebookShares_result_notFoundException obj} then P.Nothing else P.Just $ default_GetNotebookShares_result{getNotebookShares_result_notFoundException = getNotebookShares_result_notFoundException obj}
    , if obj == default_GetNotebookShares_result{getNotebookShares_result_systemException = getNotebookShares_result_systemException obj} then P.Nothing else P.Just $ default_GetNotebookShares_result{getNotebookShares_result_systemException = getNotebookShares_result_systemException obj}
    ]
from_GetNotebookShares_result :: GetNotebookShares_result -> T.ThriftVal
from_GetNotebookShares_result record = T.TStruct $ Map.fromList 
  (let exns = M.catMaybes [ (\_v1779 -> (1, ("userException",Errors_Types.from_EDAMUserException _v1779))) <$> getNotebookShares_result_userException record, (\_v1779 -> (2, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v1779))) <$> getNotebookShares_result_notFoundException record, (\_v1779 -> (3, ("systemException",Errors_Types.from_EDAMSystemException _v1779))) <$> getNotebookShares_result_systemException record]
  in if P.not (P.null exns) then exns else M.catMaybes
    [ (\_v1779 -> P.Just (0, ("success",from_ShareRelationships _v1779))) $ getNotebookShares_result_success record
    , (\_v1779 -> (1, ("userException",Errors_Types.from_EDAMUserException _v1779))) <$> getNotebookShares_result_userException record
    , (\_v1779 -> (2, ("notFoundException",Errors_Types.from_EDAMNotFoundException _v1779))) <$> getNotebookShares_result_notFoundException record
    , (\_v1779 -> (3, ("systemException",Errors_Types.from_EDAMSystemException _v1779))) <$> getNotebookShares_result_systemException record
    ]
    )
write_GetNotebookShares_result :: T.Protocol p => p -> GetNotebookShares_result -> P.IO ()
write_GetNotebookShares_result oprot record = T.writeVal oprot $ from_GetNotebookShares_result record
encode_GetNotebookShares_result :: T.StatelessProtocol p => p -> GetNotebookShares_result -> LBS.ByteString
encode_GetNotebookShares_result oprot record = T.serializeVal oprot $ from_GetNotebookShares_result record
to_GetNotebookShares_result :: T.ThriftVal -> GetNotebookShares_result
to_GetNotebookShares_result (T.TStruct fields) = GetNotebookShares_result{
  getNotebookShares_result_success = P.maybe (getNotebookShares_result_success default_GetNotebookShares_result) (\(_,_val1781) -> (case _val1781 of {T.TStruct _val1782 -> (to_ShareRelationships (T.TStruct _val1782)); _ -> P.error "wrong type"})) (Map.lookup (0) fields),
  getNotebookShares_result_userException = P.maybe (P.Nothing) (\(_,_val1781) -> P.Just (case _val1781 of {T.TStruct _val1783 -> (Errors_Types.to_EDAMUserException (T.TStruct _val1783)); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  getNotebookShares_result_notFoundException = P.maybe (P.Nothing) (\(_,_val1781) -> P.Just (case _val1781 of {T.TStruct _val1784 -> (Errors_Types.to_EDAMNotFoundException (T.TStruct _val1784)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  getNotebookShares_result_systemException = P.maybe (P.Nothing) (\(_,_val1781) -> P.Just (case _val1781 of {T.TStruct _val1785 -> (Errors_Types.to_EDAMSystemException (T.TStruct _val1785)); _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_GetNotebookShares_result _ = P.error "not a struct"
read_GetNotebookShares_result :: T.Protocol p => p -> P.IO GetNotebookShares_result
read_GetNotebookShares_result iprot = to_GetNotebookShares_result <$> T.readVal iprot (T.T_STRUCT typemap_GetNotebookShares_result)
decode_GetNotebookShares_result :: T.StatelessProtocol p => p -> LBS.ByteString -> GetNotebookShares_result
decode_GetNotebookShares_result iprot bs = to_GetNotebookShares_result $ T.deserializeVal iprot (T.T_STRUCT typemap_GetNotebookShares_result) bs
typemap_GetNotebookShares_result :: T.TypeMap
typemap_GetNotebookShares_result = Map.fromList [(0,("success",(T.T_STRUCT typemap_ShareRelationships))),(1,("userException",(T.T_STRUCT Errors_Types.typemap_EDAMUserException))),(2,("notFoundException",(T.T_STRUCT Errors_Types.typemap_EDAMNotFoundException))),(3,("systemException",(T.T_STRUCT Errors_Types.typemap_EDAMSystemException)))]
default_GetNotebookShares_result :: GetNotebookShares_result
default_GetNotebookShares_result = GetNotebookShares_result{
  getNotebookShares_result_success = default_ShareRelationships,
  getNotebookShares_result_userException = P.Nothing,
  getNotebookShares_result_notFoundException = P.Nothing,
  getNotebookShares_result_systemException = P.Nothing}
process_getSyncState (seqid, iprot, oprot, handler) = do
  args <- read_GetSyncState_args iprot
  (X.catch
    (X.catch
      (X.catch
        (do
          val <- Iface.getSyncState handler (getSyncState_args_authenticationToken args)
          let res = default_GetSyncState_result{getSyncState_result_success = val}
          T.writeMessage oprot ("getSyncState", T.M_REPLY, seqid) $
            write_GetSyncState_result oprot res)
        (\e  -> do
          let res = default_GetSyncState_result{getSyncState_result_userException = P.Just e}
          T.writeMessage oprot ("getSyncState", T.M_REPLY, seqid) $
            write_GetSyncState_result oprot res))
      (\e  -> do
        let res = default_GetSyncState_result{getSyncState_result_systemException = P.Just e}
        T.writeMessage oprot ("getSyncState", T.M_REPLY, seqid) $
          write_GetSyncState_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getSyncState", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getFilteredSyncChunk (seqid, iprot, oprot, handler) = do
  args <- read_GetFilteredSyncChunk_args iprot
  (X.catch
    (X.catch
      (X.catch
        (do
          val <- Iface.getFilteredSyncChunk handler (getFilteredSyncChunk_args_authenticationToken args) (getFilteredSyncChunk_args_afterUSN args) (getFilteredSyncChunk_args_maxEntries args) (getFilteredSyncChunk_args_filter args)
          let res = default_GetFilteredSyncChunk_result{getFilteredSyncChunk_result_success = val}
          T.writeMessage oprot ("getFilteredSyncChunk", T.M_REPLY, seqid) $
            write_GetFilteredSyncChunk_result oprot res)
        (\e  -> do
          let res = default_GetFilteredSyncChunk_result{getFilteredSyncChunk_result_userException = P.Just e}
          T.writeMessage oprot ("getFilteredSyncChunk", T.M_REPLY, seqid) $
            write_GetFilteredSyncChunk_result oprot res))
      (\e  -> do
        let res = default_GetFilteredSyncChunk_result{getFilteredSyncChunk_result_systemException = P.Just e}
        T.writeMessage oprot ("getFilteredSyncChunk", T.M_REPLY, seqid) $
          write_GetFilteredSyncChunk_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getFilteredSyncChunk", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getLinkedNotebookSyncState (seqid, iprot, oprot, handler) = do
  args <- read_GetLinkedNotebookSyncState_args iprot
  (X.catch
    (X.catch
      (X.catch
        (X.catch
          (do
            val <- Iface.getLinkedNotebookSyncState handler (getLinkedNotebookSyncState_args_authenticationToken args) (getLinkedNotebookSyncState_args_linkedNotebook args)
            let res = default_GetLinkedNotebookSyncState_result{getLinkedNotebookSyncState_result_success = val}
            T.writeMessage oprot ("getLinkedNotebookSyncState", T.M_REPLY, seqid) $
              write_GetLinkedNotebookSyncState_result oprot res)
          (\e  -> do
            let res = default_GetLinkedNotebookSyncState_result{getLinkedNotebookSyncState_result_userException = P.Just e}
            T.writeMessage oprot ("getLinkedNotebookSyncState", T.M_REPLY, seqid) $
              write_GetLinkedNotebookSyncState_result oprot res))
        (\e  -> do
          let res = default_GetLinkedNotebookSyncState_result{getLinkedNotebookSyncState_result_systemException = P.Just e}
          T.writeMessage oprot ("getLinkedNotebookSyncState", T.M_REPLY, seqid) $
            write_GetLinkedNotebookSyncState_result oprot res))
      (\e  -> do
        let res = default_GetLinkedNotebookSyncState_result{getLinkedNotebookSyncState_result_notFoundException = P.Just e}
        T.writeMessage oprot ("getLinkedNotebookSyncState", T.M_REPLY, seqid) $
          write_GetLinkedNotebookSyncState_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getLinkedNotebookSyncState", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getLinkedNotebookSyncChunk (seqid, iprot, oprot, handler) = do
  args <- read_GetLinkedNotebookSyncChunk_args iprot
  (X.catch
    (X.catch
      (X.catch
        (X.catch
          (do
            val <- Iface.getLinkedNotebookSyncChunk handler (getLinkedNotebookSyncChunk_args_authenticationToken args) (getLinkedNotebookSyncChunk_args_linkedNotebook args) (getLinkedNotebookSyncChunk_args_afterUSN args) (getLinkedNotebookSyncChunk_args_maxEntries args) (getLinkedNotebookSyncChunk_args_fullSyncOnly args)
            let res = default_GetLinkedNotebookSyncChunk_result{getLinkedNotebookSyncChunk_result_success = val}
            T.writeMessage oprot ("getLinkedNotebookSyncChunk", T.M_REPLY, seqid) $
              write_GetLinkedNotebookSyncChunk_result oprot res)
          (\e  -> do
            let res = default_GetLinkedNotebookSyncChunk_result{getLinkedNotebookSyncChunk_result_userException = P.Just e}
            T.writeMessage oprot ("getLinkedNotebookSyncChunk", T.M_REPLY, seqid) $
              write_GetLinkedNotebookSyncChunk_result oprot res))
        (\e  -> do
          let res = default_GetLinkedNotebookSyncChunk_result{getLinkedNotebookSyncChunk_result_systemException = P.Just e}
          T.writeMessage oprot ("getLinkedNotebookSyncChunk", T.M_REPLY, seqid) $
            write_GetLinkedNotebookSyncChunk_result oprot res))
      (\e  -> do
        let res = default_GetLinkedNotebookSyncChunk_result{getLinkedNotebookSyncChunk_result_notFoundException = P.Just e}
        T.writeMessage oprot ("getLinkedNotebookSyncChunk", T.M_REPLY, seqid) $
          write_GetLinkedNotebookSyncChunk_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getLinkedNotebookSyncChunk", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_listNotebooks (seqid, iprot, oprot, handler) = do
  args <- read_ListNotebooks_args iprot
  (X.catch
    (X.catch
      (X.catch
        (do
          val <- Iface.listNotebooks handler (listNotebooks_args_authenticationToken args)
          let res = default_ListNotebooks_result{listNotebooks_result_success = val}
          T.writeMessage oprot ("listNotebooks", T.M_REPLY, seqid) $
            write_ListNotebooks_result oprot res)
        (\e  -> do
          let res = default_ListNotebooks_result{listNotebooks_result_userException = P.Just e}
          T.writeMessage oprot ("listNotebooks", T.M_REPLY, seqid) $
            write_ListNotebooks_result oprot res))
      (\e  -> do
        let res = default_ListNotebooks_result{listNotebooks_result_systemException = P.Just e}
        T.writeMessage oprot ("listNotebooks", T.M_REPLY, seqid) $
          write_ListNotebooks_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("listNotebooks", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_listAccessibleBusinessNotebooks (seqid, iprot, oprot, handler) = do
  args <- read_ListAccessibleBusinessNotebooks_args iprot
  (X.catch
    (X.catch
      (X.catch
        (do
          val <- Iface.listAccessibleBusinessNotebooks handler (listAccessibleBusinessNotebooks_args_authenticationToken args)
          let res = default_ListAccessibleBusinessNotebooks_result{listAccessibleBusinessNotebooks_result_success = val}
          T.writeMessage oprot ("listAccessibleBusinessNotebooks", T.M_REPLY, seqid) $
            write_ListAccessibleBusinessNotebooks_result oprot res)
        (\e  -> do
          let res = default_ListAccessibleBusinessNotebooks_result{listAccessibleBusinessNotebooks_result_userException = P.Just e}
          T.writeMessage oprot ("listAccessibleBusinessNotebooks", T.M_REPLY, seqid) $
            write_ListAccessibleBusinessNotebooks_result oprot res))
      (\e  -> do
        let res = default_ListAccessibleBusinessNotebooks_result{listAccessibleBusinessNotebooks_result_systemException = P.Just e}
        T.writeMessage oprot ("listAccessibleBusinessNotebooks", T.M_REPLY, seqid) $
          write_ListAccessibleBusinessNotebooks_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("listAccessibleBusinessNotebooks", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getNotebook (seqid, iprot, oprot, handler) = do
  args <- read_GetNotebook_args iprot
  (X.catch
    (X.catch
      (X.catch
        (X.catch
          (do
            val <- Iface.getNotebook handler (getNotebook_args_authenticationToken args) (getNotebook_args_guid args)
            let res = default_GetNotebook_result{getNotebook_result_success = val}
            T.writeMessage oprot ("getNotebook", T.M_REPLY, seqid) $
              write_GetNotebook_result oprot res)
          (\e  -> do
            let res = default_GetNotebook_result{getNotebook_result_userException = P.Just e}
            T.writeMessage oprot ("getNotebook", T.M_REPLY, seqid) $
              write_GetNotebook_result oprot res))
        (\e  -> do
          let res = default_GetNotebook_result{getNotebook_result_systemException = P.Just e}
          T.writeMessage oprot ("getNotebook", T.M_REPLY, seqid) $
            write_GetNotebook_result oprot res))
      (\e  -> do
        let res = default_GetNotebook_result{getNotebook_result_notFoundException = P.Just e}
        T.writeMessage oprot ("getNotebook", T.M_REPLY, seqid) $
          write_GetNotebook_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getNotebook", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getDefaultNotebook (seqid, iprot, oprot, handler) = do
  args <- read_GetDefaultNotebook_args iprot
  (X.catch
    (X.catch
      (X.catch
        (do
          val <- Iface.getDefaultNotebook handler (getDefaultNotebook_args_authenticationToken args)
          let res = default_GetDefaultNotebook_result{getDefaultNotebook_result_success = val}
          T.writeMessage oprot ("getDefaultNotebook", T.M_REPLY, seqid) $
            write_GetDefaultNotebook_result oprot res)
        (\e  -> do
          let res = default_GetDefaultNotebook_result{getDefaultNotebook_result_userException = P.Just e}
          T.writeMessage oprot ("getDefaultNotebook", T.M_REPLY, seqid) $
            write_GetDefaultNotebook_result oprot res))
      (\e  -> do
        let res = default_GetDefaultNotebook_result{getDefaultNotebook_result_systemException = P.Just e}
        T.writeMessage oprot ("getDefaultNotebook", T.M_REPLY, seqid) $
          write_GetDefaultNotebook_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getDefaultNotebook", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_createNotebook (seqid, iprot, oprot, handler) = do
  args <- read_CreateNotebook_args iprot
  (X.catch
    (X.catch
      (X.catch
        (do
          val <- Iface.createNotebook handler (createNotebook_args_authenticationToken args) (createNotebook_args_notebook args)
          let res = default_CreateNotebook_result{createNotebook_result_success = val}
          T.writeMessage oprot ("createNotebook", T.M_REPLY, seqid) $
            write_CreateNotebook_result oprot res)
        (\e  -> do
          let res = default_CreateNotebook_result{createNotebook_result_userException = P.Just e}
          T.writeMessage oprot ("createNotebook", T.M_REPLY, seqid) $
            write_CreateNotebook_result oprot res))
      (\e  -> do
        let res = default_CreateNotebook_result{createNotebook_result_systemException = P.Just e}
        T.writeMessage oprot ("createNotebook", T.M_REPLY, seqid) $
          write_CreateNotebook_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("createNotebook", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_updateNotebook (seqid, iprot, oprot, handler) = do
  args <- read_UpdateNotebook_args iprot
  (X.catch
    (X.catch
      (X.catch
        (X.catch
          (do
            val <- Iface.updateNotebook handler (updateNotebook_args_authenticationToken args) (updateNotebook_args_notebook args)
            let res = default_UpdateNotebook_result{updateNotebook_result_success = val}
            T.writeMessage oprot ("updateNotebook", T.M_REPLY, seqid) $
              write_UpdateNotebook_result oprot res)
          (\e  -> do
            let res = default_UpdateNotebook_result{updateNotebook_result_userException = P.Just e}
            T.writeMessage oprot ("updateNotebook", T.M_REPLY, seqid) $
              write_UpdateNotebook_result oprot res))
        (\e  -> do
          let res = default_UpdateNotebook_result{updateNotebook_result_systemException = P.Just e}
          T.writeMessage oprot ("updateNotebook", T.M_REPLY, seqid) $
            write_UpdateNotebook_result oprot res))
      (\e  -> do
        let res = default_UpdateNotebook_result{updateNotebook_result_notFoundException = P.Just e}
        T.writeMessage oprot ("updateNotebook", T.M_REPLY, seqid) $
          write_UpdateNotebook_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("updateNotebook", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_expungeNotebook (seqid, iprot, oprot, handler) = do
  args <- read_ExpungeNotebook_args iprot
  (X.catch
    (X.catch
      (X.catch
        (X.catch
          (do
            val <- Iface.expungeNotebook handler (expungeNotebook_args_authenticationToken args) (expungeNotebook_args_guid args)
            let res = default_ExpungeNotebook_result{expungeNotebook_result_success = val}
            T.writeMessage oprot ("expungeNotebook", T.M_REPLY, seqid) $
              write_ExpungeNotebook_result oprot res)
          (\e  -> do
            let res = default_ExpungeNotebook_result{expungeNotebook_result_userException = P.Just e}
            T.writeMessage oprot ("expungeNotebook", T.M_REPLY, seqid) $
              write_ExpungeNotebook_result oprot res))
        (\e  -> do
          let res = default_ExpungeNotebook_result{expungeNotebook_result_systemException = P.Just e}
          T.writeMessage oprot ("expungeNotebook", T.M_REPLY, seqid) $
            write_ExpungeNotebook_result oprot res))
      (\e  -> do
        let res = default_ExpungeNotebook_result{expungeNotebook_result_notFoundException = P.Just e}
        T.writeMessage oprot ("expungeNotebook", T.M_REPLY, seqid) $
          write_ExpungeNotebook_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("expungeNotebook", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_listTags (seqid, iprot, oprot, handler) = do
  args <- read_ListTags_args iprot
  (X.catch
    (X.catch
      (X.catch
        (do
          val <- Iface.listTags handler (listTags_args_authenticationToken args)
          let res = default_ListTags_result{listTags_result_success = val}
          T.writeMessage oprot ("listTags", T.M_REPLY, seqid) $
            write_ListTags_result oprot res)
        (\e  -> do
          let res = default_ListTags_result{listTags_result_userException = P.Just e}
          T.writeMessage oprot ("listTags", T.M_REPLY, seqid) $
            write_ListTags_result oprot res))
      (\e  -> do
        let res = default_ListTags_result{listTags_result_systemException = P.Just e}
        T.writeMessage oprot ("listTags", T.M_REPLY, seqid) $
          write_ListTags_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("listTags", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_listTagsByNotebook (seqid, iprot, oprot, handler) = do
  args <- read_ListTagsByNotebook_args iprot
  (X.catch
    (X.catch
      (X.catch
        (X.catch
          (do
            val <- Iface.listTagsByNotebook handler (listTagsByNotebook_args_authenticationToken args) (listTagsByNotebook_args_notebookGuid args)
            let res = default_ListTagsByNotebook_result{listTagsByNotebook_result_success = val}
            T.writeMessage oprot ("listTagsByNotebook", T.M_REPLY, seqid) $
              write_ListTagsByNotebook_result oprot res)
          (\e  -> do
            let res = default_ListTagsByNotebook_result{listTagsByNotebook_result_userException = P.Just e}
            T.writeMessage oprot ("listTagsByNotebook", T.M_REPLY, seqid) $
              write_ListTagsByNotebook_result oprot res))
        (\e  -> do
          let res = default_ListTagsByNotebook_result{listTagsByNotebook_result_systemException = P.Just e}
          T.writeMessage oprot ("listTagsByNotebook", T.M_REPLY, seqid) $
            write_ListTagsByNotebook_result oprot res))
      (\e  -> do
        let res = default_ListTagsByNotebook_result{listTagsByNotebook_result_notFoundException = P.Just e}
        T.writeMessage oprot ("listTagsByNotebook", T.M_REPLY, seqid) $
          write_ListTagsByNotebook_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("listTagsByNotebook", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getTag (seqid, iprot, oprot, handler) = do
  args <- read_GetTag_args iprot
  (X.catch
    (X.catch
      (X.catch
        (X.catch
          (do
            val <- Iface.getTag handler (getTag_args_authenticationToken args) (getTag_args_guid args)
            let res = default_GetTag_result{getTag_result_success = val}
            T.writeMessage oprot ("getTag", T.M_REPLY, seqid) $
              write_GetTag_result oprot res)
          (\e  -> do
            let res = default_GetTag_result{getTag_result_userException = P.Just e}
            T.writeMessage oprot ("getTag", T.M_REPLY, seqid) $
              write_GetTag_result oprot res))
        (\e  -> do
          let res = default_GetTag_result{getTag_result_systemException = P.Just e}
          T.writeMessage oprot ("getTag", T.M_REPLY, seqid) $
            write_GetTag_result oprot res))
      (\e  -> do
        let res = default_GetTag_result{getTag_result_notFoundException = P.Just e}
        T.writeMessage oprot ("getTag", T.M_REPLY, seqid) $
          write_GetTag_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getTag", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_createTag (seqid, iprot, oprot, handler) = do
  args <- read_CreateTag_args iprot
  (X.catch
    (X.catch
      (X.catch
        (X.catch
          (do
            val <- Iface.createTag handler (createTag_args_authenticationToken args) (createTag_args_tag args)
            let res = default_CreateTag_result{createTag_result_success = val}
            T.writeMessage oprot ("createTag", T.M_REPLY, seqid) $
              write_CreateTag_result oprot res)
          (\e  -> do
            let res = default_CreateTag_result{createTag_result_userException = P.Just e}
            T.writeMessage oprot ("createTag", T.M_REPLY, seqid) $
              write_CreateTag_result oprot res))
        (\e  -> do
          let res = default_CreateTag_result{createTag_result_systemException = P.Just e}
          T.writeMessage oprot ("createTag", T.M_REPLY, seqid) $
            write_CreateTag_result oprot res))
      (\e  -> do
        let res = default_CreateTag_result{createTag_result_notFoundException = P.Just e}
        T.writeMessage oprot ("createTag", T.M_REPLY, seqid) $
          write_CreateTag_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("createTag", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_updateTag (seqid, iprot, oprot, handler) = do
  args <- read_UpdateTag_args iprot
  (X.catch
    (X.catch
      (X.catch
        (X.catch
          (do
            val <- Iface.updateTag handler (updateTag_args_authenticationToken args) (updateTag_args_tag args)
            let res = default_UpdateTag_result{updateTag_result_success = val}
            T.writeMessage oprot ("updateTag", T.M_REPLY, seqid) $
              write_UpdateTag_result oprot res)
          (\e  -> do
            let res = default_UpdateTag_result{updateTag_result_userException = P.Just e}
            T.writeMessage oprot ("updateTag", T.M_REPLY, seqid) $
              write_UpdateTag_result oprot res))
        (\e  -> do
          let res = default_UpdateTag_result{updateTag_result_systemException = P.Just e}
          T.writeMessage oprot ("updateTag", T.M_REPLY, seqid) $
            write_UpdateTag_result oprot res))
      (\e  -> do
        let res = default_UpdateTag_result{updateTag_result_notFoundException = P.Just e}
        T.writeMessage oprot ("updateTag", T.M_REPLY, seqid) $
          write_UpdateTag_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("updateTag", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_untagAll (seqid, iprot, oprot, handler) = do
  args <- read_UntagAll_args iprot
  (X.catch
    (X.catch
      (X.catch
        (X.catch
          (do
            Iface.untagAll handler (untagAll_args_authenticationToken args) (untagAll_args_guid args)
            let res = default_UntagAll_result
            T.writeMessage oprot ("untagAll", T.M_REPLY, seqid) $
              write_UntagAll_result oprot res)
          (\e  -> do
            let res = default_UntagAll_result{untagAll_result_userException = P.Just e}
            T.writeMessage oprot ("untagAll", T.M_REPLY, seqid) $
              write_UntagAll_result oprot res))
        (\e  -> do
          let res = default_UntagAll_result{untagAll_result_systemException = P.Just e}
          T.writeMessage oprot ("untagAll", T.M_REPLY, seqid) $
            write_UntagAll_result oprot res))
      (\e  -> do
        let res = default_UntagAll_result{untagAll_result_notFoundException = P.Just e}
        T.writeMessage oprot ("untagAll", T.M_REPLY, seqid) $
          write_UntagAll_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("untagAll", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_expungeTag (seqid, iprot, oprot, handler) = do
  args <- read_ExpungeTag_args iprot
  (X.catch
    (X.catch
      (X.catch
        (X.catch
          (do
            val <- Iface.expungeTag handler (expungeTag_args_authenticationToken args) (expungeTag_args_guid args)
            let res = default_ExpungeTag_result{expungeTag_result_success = val}
            T.writeMessage oprot ("expungeTag", T.M_REPLY, seqid) $
              write_ExpungeTag_result oprot res)
          (\e  -> do
            let res = default_ExpungeTag_result{expungeTag_result_userException = P.Just e}
            T.writeMessage oprot ("expungeTag", T.M_REPLY, seqid) $
              write_ExpungeTag_result oprot res))
        (\e  -> do
          let res = default_ExpungeTag_result{expungeTag_result_systemException = P.Just e}
          T.writeMessage oprot ("expungeTag", T.M_REPLY, seqid) $
            write_ExpungeTag_result oprot res))
      (\e  -> do
        let res = default_ExpungeTag_result{expungeTag_result_notFoundException = P.Just e}
        T.writeMessage oprot ("expungeTag", T.M_REPLY, seqid) $
          write_ExpungeTag_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("expungeTag", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_listSearches (seqid, iprot, oprot, handler) = do
  args <- read_ListSearches_args iprot
  (X.catch
    (X.catch
      (X.catch
        (do
          val <- Iface.listSearches handler (listSearches_args_authenticationToken args)
          let res = default_ListSearches_result{listSearches_result_success = val}
          T.writeMessage oprot ("listSearches", T.M_REPLY, seqid) $
            write_ListSearches_result oprot res)
        (\e  -> do
          let res = default_ListSearches_result{listSearches_result_userException = P.Just e}
          T.writeMessage oprot ("listSearches", T.M_REPLY, seqid) $
            write_ListSearches_result oprot res))
      (\e  -> do
        let res = default_ListSearches_result{listSearches_result_systemException = P.Just e}
        T.writeMessage oprot ("listSearches", T.M_REPLY, seqid) $
          write_ListSearches_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("listSearches", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getSearch (seqid, iprot, oprot, handler) = do
  args <- read_GetSearch_args iprot
  (X.catch
    (X.catch
      (X.catch
        (X.catch
          (do
            val <- Iface.getSearch handler (getSearch_args_authenticationToken args) (getSearch_args_guid args)
            let res = default_GetSearch_result{getSearch_result_success = val}
            T.writeMessage oprot ("getSearch", T.M_REPLY, seqid) $
              write_GetSearch_result oprot res)
          (\e  -> do
            let res = default_GetSearch_result{getSearch_result_userException = P.Just e}
            T.writeMessage oprot ("getSearch", T.M_REPLY, seqid) $
              write_GetSearch_result oprot res))
        (\e  -> do
          let res = default_GetSearch_result{getSearch_result_systemException = P.Just e}
          T.writeMessage oprot ("getSearch", T.M_REPLY, seqid) $
            write_GetSearch_result oprot res))
      (\e  -> do
        let res = default_GetSearch_result{getSearch_result_notFoundException = P.Just e}
        T.writeMessage oprot ("getSearch", T.M_REPLY, seqid) $
          write_GetSearch_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getSearch", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_createSearch (seqid, iprot, oprot, handler) = do
  args <- read_CreateSearch_args iprot
  (X.catch
    (X.catch
      (X.catch
        (do
          val <- Iface.createSearch handler (createSearch_args_authenticationToken args) (createSearch_args_search args)
          let res = default_CreateSearch_result{createSearch_result_success = val}
          T.writeMessage oprot ("createSearch", T.M_REPLY, seqid) $
            write_CreateSearch_result oprot res)
        (\e  -> do
          let res = default_CreateSearch_result{createSearch_result_userException = P.Just e}
          T.writeMessage oprot ("createSearch", T.M_REPLY, seqid) $
            write_CreateSearch_result oprot res))
      (\e  -> do
        let res = default_CreateSearch_result{createSearch_result_systemException = P.Just e}
        T.writeMessage oprot ("createSearch", T.M_REPLY, seqid) $
          write_CreateSearch_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("createSearch", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_updateSearch (seqid, iprot, oprot, handler) = do
  args <- read_UpdateSearch_args iprot
  (X.catch
    (X.catch
      (X.catch
        (X.catch
          (do
            val <- Iface.updateSearch handler (updateSearch_args_authenticationToken args) (updateSearch_args_search args)
            let res = default_UpdateSearch_result{updateSearch_result_success = val}
            T.writeMessage oprot ("updateSearch", T.M_REPLY, seqid) $
              write_UpdateSearch_result oprot res)
          (\e  -> do
            let res = default_UpdateSearch_result{updateSearch_result_userException = P.Just e}
            T.writeMessage oprot ("updateSearch", T.M_REPLY, seqid) $
              write_UpdateSearch_result oprot res))
        (\e  -> do
          let res = default_UpdateSearch_result{updateSearch_result_systemException = P.Just e}
          T.writeMessage oprot ("updateSearch", T.M_REPLY, seqid) $
            write_UpdateSearch_result oprot res))
      (\e  -> do
        let res = default_UpdateSearch_result{updateSearch_result_notFoundException = P.Just e}
        T.writeMessage oprot ("updateSearch", T.M_REPLY, seqid) $
          write_UpdateSearch_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("updateSearch", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_expungeSearch (seqid, iprot, oprot, handler) = do
  args <- read_ExpungeSearch_args iprot
  (X.catch
    (X.catch
      (X.catch
        (X.catch
          (do
            val <- Iface.expungeSearch handler (expungeSearch_args_authenticationToken args) (expungeSearch_args_guid args)
            let res = default_ExpungeSearch_result{expungeSearch_result_success = val}
            T.writeMessage oprot ("expungeSearch", T.M_REPLY, seqid) $
              write_ExpungeSearch_result oprot res)
          (\e  -> do
            let res = default_ExpungeSearch_result{expungeSearch_result_userException = P.Just e}
            T.writeMessage oprot ("expungeSearch", T.M_REPLY, seqid) $
              write_ExpungeSearch_result oprot res))
        (\e  -> do
          let res = default_ExpungeSearch_result{expungeSearch_result_systemException = P.Just e}
          T.writeMessage oprot ("expungeSearch", T.M_REPLY, seqid) $
            write_ExpungeSearch_result oprot res))
      (\e  -> do
        let res = default_ExpungeSearch_result{expungeSearch_result_notFoundException = P.Just e}
        T.writeMessage oprot ("expungeSearch", T.M_REPLY, seqid) $
          write_ExpungeSearch_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("expungeSearch", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_findNoteOffset (seqid, iprot, oprot, handler) = do
  args <- read_FindNoteOffset_args iprot
  (X.catch
    (X.catch
      (X.catch
        (X.catch
          (do
            val <- Iface.findNoteOffset handler (findNoteOffset_args_authenticationToken args) (findNoteOffset_args_filter args) (findNoteOffset_args_guid args)
            let res = default_FindNoteOffset_result{findNoteOffset_result_success = val}
            T.writeMessage oprot ("findNoteOffset", T.M_REPLY, seqid) $
              write_FindNoteOffset_result oprot res)
          (\e  -> do
            let res = default_FindNoteOffset_result{findNoteOffset_result_userException = P.Just e}
            T.writeMessage oprot ("findNoteOffset", T.M_REPLY, seqid) $
              write_FindNoteOffset_result oprot res))
        (\e  -> do
          let res = default_FindNoteOffset_result{findNoteOffset_result_systemException = P.Just e}
          T.writeMessage oprot ("findNoteOffset", T.M_REPLY, seqid) $
            write_FindNoteOffset_result oprot res))
      (\e  -> do
        let res = default_FindNoteOffset_result{findNoteOffset_result_notFoundException = P.Just e}
        T.writeMessage oprot ("findNoteOffset", T.M_REPLY, seqid) $
          write_FindNoteOffset_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("findNoteOffset", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_findNotesMetadata (seqid, iprot, oprot, handler) = do
  args <- read_FindNotesMetadata_args iprot
  (X.catch
    (X.catch
      (X.catch
        (X.catch
          (do
            val <- Iface.findNotesMetadata handler (findNotesMetadata_args_authenticationToken args) (findNotesMetadata_args_filter args) (findNotesMetadata_args_offset args) (findNotesMetadata_args_maxNotes args) (findNotesMetadata_args_resultSpec args)
            let res = default_FindNotesMetadata_result{findNotesMetadata_result_success = val}
            T.writeMessage oprot ("findNotesMetadata", T.M_REPLY, seqid) $
              write_FindNotesMetadata_result oprot res)
          (\e  -> do
            let res = default_FindNotesMetadata_result{findNotesMetadata_result_userException = P.Just e}
            T.writeMessage oprot ("findNotesMetadata", T.M_REPLY, seqid) $
              write_FindNotesMetadata_result oprot res))
        (\e  -> do
          let res = default_FindNotesMetadata_result{findNotesMetadata_result_systemException = P.Just e}
          T.writeMessage oprot ("findNotesMetadata", T.M_REPLY, seqid) $
            write_FindNotesMetadata_result oprot res))
      (\e  -> do
        let res = default_FindNotesMetadata_result{findNotesMetadata_result_notFoundException = P.Just e}
        T.writeMessage oprot ("findNotesMetadata", T.M_REPLY, seqid) $
          write_FindNotesMetadata_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("findNotesMetadata", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_findNoteCounts (seqid, iprot, oprot, handler) = do
  args <- read_FindNoteCounts_args iprot
  (X.catch
    (X.catch
      (X.catch
        (X.catch
          (do
            val <- Iface.findNoteCounts handler (findNoteCounts_args_authenticationToken args) (findNoteCounts_args_filter args) (findNoteCounts_args_withTrash args)
            let res = default_FindNoteCounts_result{findNoteCounts_result_success = val}
            T.writeMessage oprot ("findNoteCounts", T.M_REPLY, seqid) $
              write_FindNoteCounts_result oprot res)
          (\e  -> do
            let res = default_FindNoteCounts_result{findNoteCounts_result_userException = P.Just e}
            T.writeMessage oprot ("findNoteCounts", T.M_REPLY, seqid) $
              write_FindNoteCounts_result oprot res))
        (\e  -> do
          let res = default_FindNoteCounts_result{findNoteCounts_result_systemException = P.Just e}
          T.writeMessage oprot ("findNoteCounts", T.M_REPLY, seqid) $
            write_FindNoteCounts_result oprot res))
      (\e  -> do
        let res = default_FindNoteCounts_result{findNoteCounts_result_notFoundException = P.Just e}
        T.writeMessage oprot ("findNoteCounts", T.M_REPLY, seqid) $
          write_FindNoteCounts_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("findNoteCounts", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getNoteWithResultSpec (seqid, iprot, oprot, handler) = do
  args <- read_GetNoteWithResultSpec_args iprot
  (X.catch
    (X.catch
      (X.catch
        (X.catch
          (do
            val <- Iface.getNoteWithResultSpec handler (getNoteWithResultSpec_args_authenticationToken args) (getNoteWithResultSpec_args_guid args) (getNoteWithResultSpec_args_resultSpec args)
            let res = default_GetNoteWithResultSpec_result{getNoteWithResultSpec_result_success = val}
            T.writeMessage oprot ("getNoteWithResultSpec", T.M_REPLY, seqid) $
              write_GetNoteWithResultSpec_result oprot res)
          (\e  -> do
            let res = default_GetNoteWithResultSpec_result{getNoteWithResultSpec_result_userException = P.Just e}
            T.writeMessage oprot ("getNoteWithResultSpec", T.M_REPLY, seqid) $
              write_GetNoteWithResultSpec_result oprot res))
        (\e  -> do
          let res = default_GetNoteWithResultSpec_result{getNoteWithResultSpec_result_systemException = P.Just e}
          T.writeMessage oprot ("getNoteWithResultSpec", T.M_REPLY, seqid) $
            write_GetNoteWithResultSpec_result oprot res))
      (\e  -> do
        let res = default_GetNoteWithResultSpec_result{getNoteWithResultSpec_result_notFoundException = P.Just e}
        T.writeMessage oprot ("getNoteWithResultSpec", T.M_REPLY, seqid) $
          write_GetNoteWithResultSpec_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getNoteWithResultSpec", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getNote (seqid, iprot, oprot, handler) = do
  args <- read_GetNote_args iprot
  (X.catch
    (X.catch
      (X.catch
        (X.catch
          (do
            val <- Iface.getNote handler (getNote_args_authenticationToken args) (getNote_args_guid args) (getNote_args_withContent args) (getNote_args_withResourcesData args) (getNote_args_withResourcesRecognition args) (getNote_args_withResourcesAlternateData args)
            let res = default_GetNote_result{getNote_result_success = val}
            T.writeMessage oprot ("getNote", T.M_REPLY, seqid) $
              write_GetNote_result oprot res)
          (\e  -> do
            let res = default_GetNote_result{getNote_result_userException = P.Just e}
            T.writeMessage oprot ("getNote", T.M_REPLY, seqid) $
              write_GetNote_result oprot res))
        (\e  -> do
          let res = default_GetNote_result{getNote_result_systemException = P.Just e}
          T.writeMessage oprot ("getNote", T.M_REPLY, seqid) $
            write_GetNote_result oprot res))
      (\e  -> do
        let res = default_GetNote_result{getNote_result_notFoundException = P.Just e}
        T.writeMessage oprot ("getNote", T.M_REPLY, seqid) $
          write_GetNote_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getNote", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getNoteApplicationData (seqid, iprot, oprot, handler) = do
  args <- read_GetNoteApplicationData_args iprot
  (X.catch
    (X.catch
      (X.catch
        (X.catch
          (do
            val <- Iface.getNoteApplicationData handler (getNoteApplicationData_args_authenticationToken args) (getNoteApplicationData_args_guid args)
            let res = default_GetNoteApplicationData_result{getNoteApplicationData_result_success = val}
            T.writeMessage oprot ("getNoteApplicationData", T.M_REPLY, seqid) $
              write_GetNoteApplicationData_result oprot res)
          (\e  -> do
            let res = default_GetNoteApplicationData_result{getNoteApplicationData_result_userException = P.Just e}
            T.writeMessage oprot ("getNoteApplicationData", T.M_REPLY, seqid) $
              write_GetNoteApplicationData_result oprot res))
        (\e  -> do
          let res = default_GetNoteApplicationData_result{getNoteApplicationData_result_systemException = P.Just e}
          T.writeMessage oprot ("getNoteApplicationData", T.M_REPLY, seqid) $
            write_GetNoteApplicationData_result oprot res))
      (\e  -> do
        let res = default_GetNoteApplicationData_result{getNoteApplicationData_result_notFoundException = P.Just e}
        T.writeMessage oprot ("getNoteApplicationData", T.M_REPLY, seqid) $
          write_GetNoteApplicationData_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getNoteApplicationData", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getNoteApplicationDataEntry (seqid, iprot, oprot, handler) = do
  args <- read_GetNoteApplicationDataEntry_args iprot
  (X.catch
    (X.catch
      (X.catch
        (X.catch
          (do
            val <- Iface.getNoteApplicationDataEntry handler (getNoteApplicationDataEntry_args_authenticationToken args) (getNoteApplicationDataEntry_args_guid args) (getNoteApplicationDataEntry_args_key args)
            let res = default_GetNoteApplicationDataEntry_result{getNoteApplicationDataEntry_result_success = val}
            T.writeMessage oprot ("getNoteApplicationDataEntry", T.M_REPLY, seqid) $
              write_GetNoteApplicationDataEntry_result oprot res)
          (\e  -> do
            let res = default_GetNoteApplicationDataEntry_result{getNoteApplicationDataEntry_result_userException = P.Just e}
            T.writeMessage oprot ("getNoteApplicationDataEntry", T.M_REPLY, seqid) $
              write_GetNoteApplicationDataEntry_result oprot res))
        (\e  -> do
          let res = default_GetNoteApplicationDataEntry_result{getNoteApplicationDataEntry_result_systemException = P.Just e}
          T.writeMessage oprot ("getNoteApplicationDataEntry", T.M_REPLY, seqid) $
            write_GetNoteApplicationDataEntry_result oprot res))
      (\e  -> do
        let res = default_GetNoteApplicationDataEntry_result{getNoteApplicationDataEntry_result_notFoundException = P.Just e}
        T.writeMessage oprot ("getNoteApplicationDataEntry", T.M_REPLY, seqid) $
          write_GetNoteApplicationDataEntry_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getNoteApplicationDataEntry", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_setNoteApplicationDataEntry (seqid, iprot, oprot, handler) = do
  args <- read_SetNoteApplicationDataEntry_args iprot
  (X.catch
    (X.catch
      (X.catch
        (X.catch
          (do
            val <- Iface.setNoteApplicationDataEntry handler (setNoteApplicationDataEntry_args_authenticationToken args) (setNoteApplicationDataEntry_args_guid args) (setNoteApplicationDataEntry_args_key args) (setNoteApplicationDataEntry_args_value args)
            let res = default_SetNoteApplicationDataEntry_result{setNoteApplicationDataEntry_result_success = val}
            T.writeMessage oprot ("setNoteApplicationDataEntry", T.M_REPLY, seqid) $
              write_SetNoteApplicationDataEntry_result oprot res)
          (\e  -> do
            let res = default_SetNoteApplicationDataEntry_result{setNoteApplicationDataEntry_result_userException = P.Just e}
            T.writeMessage oprot ("setNoteApplicationDataEntry", T.M_REPLY, seqid) $
              write_SetNoteApplicationDataEntry_result oprot res))
        (\e  -> do
          let res = default_SetNoteApplicationDataEntry_result{setNoteApplicationDataEntry_result_systemException = P.Just e}
          T.writeMessage oprot ("setNoteApplicationDataEntry", T.M_REPLY, seqid) $
            write_SetNoteApplicationDataEntry_result oprot res))
      (\e  -> do
        let res = default_SetNoteApplicationDataEntry_result{setNoteApplicationDataEntry_result_notFoundException = P.Just e}
        T.writeMessage oprot ("setNoteApplicationDataEntry", T.M_REPLY, seqid) $
          write_SetNoteApplicationDataEntry_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("setNoteApplicationDataEntry", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_unsetNoteApplicationDataEntry (seqid, iprot, oprot, handler) = do
  args <- read_UnsetNoteApplicationDataEntry_args iprot
  (X.catch
    (X.catch
      (X.catch
        (X.catch
          (do
            val <- Iface.unsetNoteApplicationDataEntry handler (unsetNoteApplicationDataEntry_args_authenticationToken args) (unsetNoteApplicationDataEntry_args_guid args) (unsetNoteApplicationDataEntry_args_key args)
            let res = default_UnsetNoteApplicationDataEntry_result{unsetNoteApplicationDataEntry_result_success = val}
            T.writeMessage oprot ("unsetNoteApplicationDataEntry", T.M_REPLY, seqid) $
              write_UnsetNoteApplicationDataEntry_result oprot res)
          (\e  -> do
            let res = default_UnsetNoteApplicationDataEntry_result{unsetNoteApplicationDataEntry_result_userException = P.Just e}
            T.writeMessage oprot ("unsetNoteApplicationDataEntry", T.M_REPLY, seqid) $
              write_UnsetNoteApplicationDataEntry_result oprot res))
        (\e  -> do
          let res = default_UnsetNoteApplicationDataEntry_result{unsetNoteApplicationDataEntry_result_systemException = P.Just e}
          T.writeMessage oprot ("unsetNoteApplicationDataEntry", T.M_REPLY, seqid) $
            write_UnsetNoteApplicationDataEntry_result oprot res))
      (\e  -> do
        let res = default_UnsetNoteApplicationDataEntry_result{unsetNoteApplicationDataEntry_result_notFoundException = P.Just e}
        T.writeMessage oprot ("unsetNoteApplicationDataEntry", T.M_REPLY, seqid) $
          write_UnsetNoteApplicationDataEntry_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("unsetNoteApplicationDataEntry", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getNoteContent (seqid, iprot, oprot, handler) = do
  args <- read_GetNoteContent_args iprot
  (X.catch
    (X.catch
      (X.catch
        (X.catch
          (do
            val <- Iface.getNoteContent handler (getNoteContent_args_authenticationToken args) (getNoteContent_args_guid args)
            let res = default_GetNoteContent_result{getNoteContent_result_success = val}
            T.writeMessage oprot ("getNoteContent", T.M_REPLY, seqid) $
              write_GetNoteContent_result oprot res)
          (\e  -> do
            let res = default_GetNoteContent_result{getNoteContent_result_userException = P.Just e}
            T.writeMessage oprot ("getNoteContent", T.M_REPLY, seqid) $
              write_GetNoteContent_result oprot res))
        (\e  -> do
          let res = default_GetNoteContent_result{getNoteContent_result_systemException = P.Just e}
          T.writeMessage oprot ("getNoteContent", T.M_REPLY, seqid) $
            write_GetNoteContent_result oprot res))
      (\e  -> do
        let res = default_GetNoteContent_result{getNoteContent_result_notFoundException = P.Just e}
        T.writeMessage oprot ("getNoteContent", T.M_REPLY, seqid) $
          write_GetNoteContent_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getNoteContent", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getNoteSearchText (seqid, iprot, oprot, handler) = do
  args <- read_GetNoteSearchText_args iprot
  (X.catch
    (X.catch
      (X.catch
        (X.catch
          (do
            val <- Iface.getNoteSearchText handler (getNoteSearchText_args_authenticationToken args) (getNoteSearchText_args_guid args) (getNoteSearchText_args_noteOnly args) (getNoteSearchText_args_tokenizeForIndexing args)
            let res = default_GetNoteSearchText_result{getNoteSearchText_result_success = val}
            T.writeMessage oprot ("getNoteSearchText", T.M_REPLY, seqid) $
              write_GetNoteSearchText_result oprot res)
          (\e  -> do
            let res = default_GetNoteSearchText_result{getNoteSearchText_result_userException = P.Just e}
            T.writeMessage oprot ("getNoteSearchText", T.M_REPLY, seqid) $
              write_GetNoteSearchText_result oprot res))
        (\e  -> do
          let res = default_GetNoteSearchText_result{getNoteSearchText_result_systemException = P.Just e}
          T.writeMessage oprot ("getNoteSearchText", T.M_REPLY, seqid) $
            write_GetNoteSearchText_result oprot res))
      (\e  -> do
        let res = default_GetNoteSearchText_result{getNoteSearchText_result_notFoundException = P.Just e}
        T.writeMessage oprot ("getNoteSearchText", T.M_REPLY, seqid) $
          write_GetNoteSearchText_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getNoteSearchText", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getResourceSearchText (seqid, iprot, oprot, handler) = do
  args <- read_GetResourceSearchText_args iprot
  (X.catch
    (X.catch
      (X.catch
        (X.catch
          (do
            val <- Iface.getResourceSearchText handler (getResourceSearchText_args_authenticationToken args) (getResourceSearchText_args_guid args)
            let res = default_GetResourceSearchText_result{getResourceSearchText_result_success = val}
            T.writeMessage oprot ("getResourceSearchText", T.M_REPLY, seqid) $
              write_GetResourceSearchText_result oprot res)
          (\e  -> do
            let res = default_GetResourceSearchText_result{getResourceSearchText_result_userException = P.Just e}
            T.writeMessage oprot ("getResourceSearchText", T.M_REPLY, seqid) $
              write_GetResourceSearchText_result oprot res))
        (\e  -> do
          let res = default_GetResourceSearchText_result{getResourceSearchText_result_systemException = P.Just e}
          T.writeMessage oprot ("getResourceSearchText", T.M_REPLY, seqid) $
            write_GetResourceSearchText_result oprot res))
      (\e  -> do
        let res = default_GetResourceSearchText_result{getResourceSearchText_result_notFoundException = P.Just e}
        T.writeMessage oprot ("getResourceSearchText", T.M_REPLY, seqid) $
          write_GetResourceSearchText_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getResourceSearchText", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getNoteTagNames (seqid, iprot, oprot, handler) = do
  args <- read_GetNoteTagNames_args iprot
  (X.catch
    (X.catch
      (X.catch
        (X.catch
          (do
            val <- Iface.getNoteTagNames handler (getNoteTagNames_args_authenticationToken args) (getNoteTagNames_args_guid args)
            let res = default_GetNoteTagNames_result{getNoteTagNames_result_success = val}
            T.writeMessage oprot ("getNoteTagNames", T.M_REPLY, seqid) $
              write_GetNoteTagNames_result oprot res)
          (\e  -> do
            let res = default_GetNoteTagNames_result{getNoteTagNames_result_userException = P.Just e}
            T.writeMessage oprot ("getNoteTagNames", T.M_REPLY, seqid) $
              write_GetNoteTagNames_result oprot res))
        (\e  -> do
          let res = default_GetNoteTagNames_result{getNoteTagNames_result_systemException = P.Just e}
          T.writeMessage oprot ("getNoteTagNames", T.M_REPLY, seqid) $
            write_GetNoteTagNames_result oprot res))
      (\e  -> do
        let res = default_GetNoteTagNames_result{getNoteTagNames_result_notFoundException = P.Just e}
        T.writeMessage oprot ("getNoteTagNames", T.M_REPLY, seqid) $
          write_GetNoteTagNames_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getNoteTagNames", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_createNote (seqid, iprot, oprot, handler) = do
  args <- read_CreateNote_args iprot
  (X.catch
    (X.catch
      (X.catch
        (X.catch
          (do
            val <- Iface.createNote handler (createNote_args_authenticationToken args) (createNote_args_note args)
            let res = default_CreateNote_result{createNote_result_success = val}
            T.writeMessage oprot ("createNote", T.M_REPLY, seqid) $
              write_CreateNote_result oprot res)
          (\e  -> do
            let res = default_CreateNote_result{createNote_result_userException = P.Just e}
            T.writeMessage oprot ("createNote", T.M_REPLY, seqid) $
              write_CreateNote_result oprot res))
        (\e  -> do
          let res = default_CreateNote_result{createNote_result_systemException = P.Just e}
          T.writeMessage oprot ("createNote", T.M_REPLY, seqid) $
            write_CreateNote_result oprot res))
      (\e  -> do
        let res = default_CreateNote_result{createNote_result_notFoundException = P.Just e}
        T.writeMessage oprot ("createNote", T.M_REPLY, seqid) $
          write_CreateNote_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("createNote", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_updateNote (seqid, iprot, oprot, handler) = do
  args <- read_UpdateNote_args iprot
  (X.catch
    (X.catch
      (X.catch
        (X.catch
          (do
            val <- Iface.updateNote handler (updateNote_args_authenticationToken args) (updateNote_args_note args)
            let res = default_UpdateNote_result{updateNote_result_success = val}
            T.writeMessage oprot ("updateNote", T.M_REPLY, seqid) $
              write_UpdateNote_result oprot res)
          (\e  -> do
            let res = default_UpdateNote_result{updateNote_result_userException = P.Just e}
            T.writeMessage oprot ("updateNote", T.M_REPLY, seqid) $
              write_UpdateNote_result oprot res))
        (\e  -> do
          let res = default_UpdateNote_result{updateNote_result_systemException = P.Just e}
          T.writeMessage oprot ("updateNote", T.M_REPLY, seqid) $
            write_UpdateNote_result oprot res))
      (\e  -> do
        let res = default_UpdateNote_result{updateNote_result_notFoundException = P.Just e}
        T.writeMessage oprot ("updateNote", T.M_REPLY, seqid) $
          write_UpdateNote_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("updateNote", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_deleteNote (seqid, iprot, oprot, handler) = do
  args <- read_DeleteNote_args iprot
  (X.catch
    (X.catch
      (X.catch
        (X.catch
          (do
            val <- Iface.deleteNote handler (deleteNote_args_authenticationToken args) (deleteNote_args_guid args)
            let res = default_DeleteNote_result{deleteNote_result_success = val}
            T.writeMessage oprot ("deleteNote", T.M_REPLY, seqid) $
              write_DeleteNote_result oprot res)
          (\e  -> do
            let res = default_DeleteNote_result{deleteNote_result_userException = P.Just e}
            T.writeMessage oprot ("deleteNote", T.M_REPLY, seqid) $
              write_DeleteNote_result oprot res))
        (\e  -> do
          let res = default_DeleteNote_result{deleteNote_result_systemException = P.Just e}
          T.writeMessage oprot ("deleteNote", T.M_REPLY, seqid) $
            write_DeleteNote_result oprot res))
      (\e  -> do
        let res = default_DeleteNote_result{deleteNote_result_notFoundException = P.Just e}
        T.writeMessage oprot ("deleteNote", T.M_REPLY, seqid) $
          write_DeleteNote_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("deleteNote", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_expungeNote (seqid, iprot, oprot, handler) = do
  args <- read_ExpungeNote_args iprot
  (X.catch
    (X.catch
      (X.catch
        (X.catch
          (do
            val <- Iface.expungeNote handler (expungeNote_args_authenticationToken args) (expungeNote_args_guid args)
            let res = default_ExpungeNote_result{expungeNote_result_success = val}
            T.writeMessage oprot ("expungeNote", T.M_REPLY, seqid) $
              write_ExpungeNote_result oprot res)
          (\e  -> do
            let res = default_ExpungeNote_result{expungeNote_result_userException = P.Just e}
            T.writeMessage oprot ("expungeNote", T.M_REPLY, seqid) $
              write_ExpungeNote_result oprot res))
        (\e  -> do
          let res = default_ExpungeNote_result{expungeNote_result_systemException = P.Just e}
          T.writeMessage oprot ("expungeNote", T.M_REPLY, seqid) $
            write_ExpungeNote_result oprot res))
      (\e  -> do
        let res = default_ExpungeNote_result{expungeNote_result_notFoundException = P.Just e}
        T.writeMessage oprot ("expungeNote", T.M_REPLY, seqid) $
          write_ExpungeNote_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("expungeNote", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_copyNote (seqid, iprot, oprot, handler) = do
  args <- read_CopyNote_args iprot
  (X.catch
    (X.catch
      (X.catch
        (X.catch
          (do
            val <- Iface.copyNote handler (copyNote_args_authenticationToken args) (copyNote_args_noteGuid args) (copyNote_args_toNotebookGuid args)
            let res = default_CopyNote_result{copyNote_result_success = val}
            T.writeMessage oprot ("copyNote", T.M_REPLY, seqid) $
              write_CopyNote_result oprot res)
          (\e  -> do
            let res = default_CopyNote_result{copyNote_result_userException = P.Just e}
            T.writeMessage oprot ("copyNote", T.M_REPLY, seqid) $
              write_CopyNote_result oprot res))
        (\e  -> do
          let res = default_CopyNote_result{copyNote_result_systemException = P.Just e}
          T.writeMessage oprot ("copyNote", T.M_REPLY, seqid) $
            write_CopyNote_result oprot res))
      (\e  -> do
        let res = default_CopyNote_result{copyNote_result_notFoundException = P.Just e}
        T.writeMessage oprot ("copyNote", T.M_REPLY, seqid) $
          write_CopyNote_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("copyNote", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_listNoteVersions (seqid, iprot, oprot, handler) = do
  args <- read_ListNoteVersions_args iprot
  (X.catch
    (X.catch
      (X.catch
        (X.catch
          (do
            val <- Iface.listNoteVersions handler (listNoteVersions_args_authenticationToken args) (listNoteVersions_args_noteGuid args)
            let res = default_ListNoteVersions_result{listNoteVersions_result_success = val}
            T.writeMessage oprot ("listNoteVersions", T.M_REPLY, seqid) $
              write_ListNoteVersions_result oprot res)
          (\e  -> do
            let res = default_ListNoteVersions_result{listNoteVersions_result_userException = P.Just e}
            T.writeMessage oprot ("listNoteVersions", T.M_REPLY, seqid) $
              write_ListNoteVersions_result oprot res))
        (\e  -> do
          let res = default_ListNoteVersions_result{listNoteVersions_result_systemException = P.Just e}
          T.writeMessage oprot ("listNoteVersions", T.M_REPLY, seqid) $
            write_ListNoteVersions_result oprot res))
      (\e  -> do
        let res = default_ListNoteVersions_result{listNoteVersions_result_notFoundException = P.Just e}
        T.writeMessage oprot ("listNoteVersions", T.M_REPLY, seqid) $
          write_ListNoteVersions_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("listNoteVersions", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getNoteVersion (seqid, iprot, oprot, handler) = do
  args <- read_GetNoteVersion_args iprot
  (X.catch
    (X.catch
      (X.catch
        (X.catch
          (do
            val <- Iface.getNoteVersion handler (getNoteVersion_args_authenticationToken args) (getNoteVersion_args_noteGuid args) (getNoteVersion_args_updateSequenceNum args) (getNoteVersion_args_withResourcesData args) (getNoteVersion_args_withResourcesRecognition args) (getNoteVersion_args_withResourcesAlternateData args)
            let res = default_GetNoteVersion_result{getNoteVersion_result_success = val}
            T.writeMessage oprot ("getNoteVersion", T.M_REPLY, seqid) $
              write_GetNoteVersion_result oprot res)
          (\e  -> do
            let res = default_GetNoteVersion_result{getNoteVersion_result_userException = P.Just e}
            T.writeMessage oprot ("getNoteVersion", T.M_REPLY, seqid) $
              write_GetNoteVersion_result oprot res))
        (\e  -> do
          let res = default_GetNoteVersion_result{getNoteVersion_result_systemException = P.Just e}
          T.writeMessage oprot ("getNoteVersion", T.M_REPLY, seqid) $
            write_GetNoteVersion_result oprot res))
      (\e  -> do
        let res = default_GetNoteVersion_result{getNoteVersion_result_notFoundException = P.Just e}
        T.writeMessage oprot ("getNoteVersion", T.M_REPLY, seqid) $
          write_GetNoteVersion_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getNoteVersion", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getResource (seqid, iprot, oprot, handler) = do
  args <- read_GetResource_args iprot
  (X.catch
    (X.catch
      (X.catch
        (X.catch
          (do
            val <- Iface.getResource handler (getResource_args_authenticationToken args) (getResource_args_guid args) (getResource_args_withData args) (getResource_args_withRecognition args) (getResource_args_withAttributes args) (getResource_args_withAlternateData args)
            let res = default_GetResource_result{getResource_result_success = val}
            T.writeMessage oprot ("getResource", T.M_REPLY, seqid) $
              write_GetResource_result oprot res)
          (\e  -> do
            let res = default_GetResource_result{getResource_result_userException = P.Just e}
            T.writeMessage oprot ("getResource", T.M_REPLY, seqid) $
              write_GetResource_result oprot res))
        (\e  -> do
          let res = default_GetResource_result{getResource_result_systemException = P.Just e}
          T.writeMessage oprot ("getResource", T.M_REPLY, seqid) $
            write_GetResource_result oprot res))
      (\e  -> do
        let res = default_GetResource_result{getResource_result_notFoundException = P.Just e}
        T.writeMessage oprot ("getResource", T.M_REPLY, seqid) $
          write_GetResource_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getResource", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getResourceApplicationData (seqid, iprot, oprot, handler) = do
  args <- read_GetResourceApplicationData_args iprot
  (X.catch
    (X.catch
      (X.catch
        (X.catch
          (do
            val <- Iface.getResourceApplicationData handler (getResourceApplicationData_args_authenticationToken args) (getResourceApplicationData_args_guid args)
            let res = default_GetResourceApplicationData_result{getResourceApplicationData_result_success = val}
            T.writeMessage oprot ("getResourceApplicationData", T.M_REPLY, seqid) $
              write_GetResourceApplicationData_result oprot res)
          (\e  -> do
            let res = default_GetResourceApplicationData_result{getResourceApplicationData_result_userException = P.Just e}
            T.writeMessage oprot ("getResourceApplicationData", T.M_REPLY, seqid) $
              write_GetResourceApplicationData_result oprot res))
        (\e  -> do
          let res = default_GetResourceApplicationData_result{getResourceApplicationData_result_systemException = P.Just e}
          T.writeMessage oprot ("getResourceApplicationData", T.M_REPLY, seqid) $
            write_GetResourceApplicationData_result oprot res))
      (\e  -> do
        let res = default_GetResourceApplicationData_result{getResourceApplicationData_result_notFoundException = P.Just e}
        T.writeMessage oprot ("getResourceApplicationData", T.M_REPLY, seqid) $
          write_GetResourceApplicationData_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getResourceApplicationData", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getResourceApplicationDataEntry (seqid, iprot, oprot, handler) = do
  args <- read_GetResourceApplicationDataEntry_args iprot
  (X.catch
    (X.catch
      (X.catch
        (X.catch
          (do
            val <- Iface.getResourceApplicationDataEntry handler (getResourceApplicationDataEntry_args_authenticationToken args) (getResourceApplicationDataEntry_args_guid args) (getResourceApplicationDataEntry_args_key args)
            let res = default_GetResourceApplicationDataEntry_result{getResourceApplicationDataEntry_result_success = val}
            T.writeMessage oprot ("getResourceApplicationDataEntry", T.M_REPLY, seqid) $
              write_GetResourceApplicationDataEntry_result oprot res)
          (\e  -> do
            let res = default_GetResourceApplicationDataEntry_result{getResourceApplicationDataEntry_result_userException = P.Just e}
            T.writeMessage oprot ("getResourceApplicationDataEntry", T.M_REPLY, seqid) $
              write_GetResourceApplicationDataEntry_result oprot res))
        (\e  -> do
          let res = default_GetResourceApplicationDataEntry_result{getResourceApplicationDataEntry_result_systemException = P.Just e}
          T.writeMessage oprot ("getResourceApplicationDataEntry", T.M_REPLY, seqid) $
            write_GetResourceApplicationDataEntry_result oprot res))
      (\e  -> do
        let res = default_GetResourceApplicationDataEntry_result{getResourceApplicationDataEntry_result_notFoundException = P.Just e}
        T.writeMessage oprot ("getResourceApplicationDataEntry", T.M_REPLY, seqid) $
          write_GetResourceApplicationDataEntry_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getResourceApplicationDataEntry", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_setResourceApplicationDataEntry (seqid, iprot, oprot, handler) = do
  args <- read_SetResourceApplicationDataEntry_args iprot
  (X.catch
    (X.catch
      (X.catch
        (X.catch
          (do
            val <- Iface.setResourceApplicationDataEntry handler (setResourceApplicationDataEntry_args_authenticationToken args) (setResourceApplicationDataEntry_args_guid args) (setResourceApplicationDataEntry_args_key args) (setResourceApplicationDataEntry_args_value args)
            let res = default_SetResourceApplicationDataEntry_result{setResourceApplicationDataEntry_result_success = val}
            T.writeMessage oprot ("setResourceApplicationDataEntry", T.M_REPLY, seqid) $
              write_SetResourceApplicationDataEntry_result oprot res)
          (\e  -> do
            let res = default_SetResourceApplicationDataEntry_result{setResourceApplicationDataEntry_result_userException = P.Just e}
            T.writeMessage oprot ("setResourceApplicationDataEntry", T.M_REPLY, seqid) $
              write_SetResourceApplicationDataEntry_result oprot res))
        (\e  -> do
          let res = default_SetResourceApplicationDataEntry_result{setResourceApplicationDataEntry_result_systemException = P.Just e}
          T.writeMessage oprot ("setResourceApplicationDataEntry", T.M_REPLY, seqid) $
            write_SetResourceApplicationDataEntry_result oprot res))
      (\e  -> do
        let res = default_SetResourceApplicationDataEntry_result{setResourceApplicationDataEntry_result_notFoundException = P.Just e}
        T.writeMessage oprot ("setResourceApplicationDataEntry", T.M_REPLY, seqid) $
          write_SetResourceApplicationDataEntry_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("setResourceApplicationDataEntry", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_unsetResourceApplicationDataEntry (seqid, iprot, oprot, handler) = do
  args <- read_UnsetResourceApplicationDataEntry_args iprot
  (X.catch
    (X.catch
      (X.catch
        (X.catch
          (do
            val <- Iface.unsetResourceApplicationDataEntry handler (unsetResourceApplicationDataEntry_args_authenticationToken args) (unsetResourceApplicationDataEntry_args_guid args) (unsetResourceApplicationDataEntry_args_key args)
            let res = default_UnsetResourceApplicationDataEntry_result{unsetResourceApplicationDataEntry_result_success = val}
            T.writeMessage oprot ("unsetResourceApplicationDataEntry", T.M_REPLY, seqid) $
              write_UnsetResourceApplicationDataEntry_result oprot res)
          (\e  -> do
            let res = default_UnsetResourceApplicationDataEntry_result{unsetResourceApplicationDataEntry_result_userException = P.Just e}
            T.writeMessage oprot ("unsetResourceApplicationDataEntry", T.M_REPLY, seqid) $
              write_UnsetResourceApplicationDataEntry_result oprot res))
        (\e  -> do
          let res = default_UnsetResourceApplicationDataEntry_result{unsetResourceApplicationDataEntry_result_systemException = P.Just e}
          T.writeMessage oprot ("unsetResourceApplicationDataEntry", T.M_REPLY, seqid) $
            write_UnsetResourceApplicationDataEntry_result oprot res))
      (\e  -> do
        let res = default_UnsetResourceApplicationDataEntry_result{unsetResourceApplicationDataEntry_result_notFoundException = P.Just e}
        T.writeMessage oprot ("unsetResourceApplicationDataEntry", T.M_REPLY, seqid) $
          write_UnsetResourceApplicationDataEntry_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("unsetResourceApplicationDataEntry", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_updateResource (seqid, iprot, oprot, handler) = do
  args <- read_UpdateResource_args iprot
  (X.catch
    (X.catch
      (X.catch
        (X.catch
          (do
            val <- Iface.updateResource handler (updateResource_args_authenticationToken args) (updateResource_args_resource args)
            let res = default_UpdateResource_result{updateResource_result_success = val}
            T.writeMessage oprot ("updateResource", T.M_REPLY, seqid) $
              write_UpdateResource_result oprot res)
          (\e  -> do
            let res = default_UpdateResource_result{updateResource_result_userException = P.Just e}
            T.writeMessage oprot ("updateResource", T.M_REPLY, seqid) $
              write_UpdateResource_result oprot res))
        (\e  -> do
          let res = default_UpdateResource_result{updateResource_result_systemException = P.Just e}
          T.writeMessage oprot ("updateResource", T.M_REPLY, seqid) $
            write_UpdateResource_result oprot res))
      (\e  -> do
        let res = default_UpdateResource_result{updateResource_result_notFoundException = P.Just e}
        T.writeMessage oprot ("updateResource", T.M_REPLY, seqid) $
          write_UpdateResource_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("updateResource", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getResourceData (seqid, iprot, oprot, handler) = do
  args <- read_GetResourceData_args iprot
  (X.catch
    (X.catch
      (X.catch
        (X.catch
          (do
            val <- Iface.getResourceData handler (getResourceData_args_authenticationToken args) (getResourceData_args_guid args)
            let res = default_GetResourceData_result{getResourceData_result_success = val}
            T.writeMessage oprot ("getResourceData", T.M_REPLY, seqid) $
              write_GetResourceData_result oprot res)
          (\e  -> do
            let res = default_GetResourceData_result{getResourceData_result_userException = P.Just e}
            T.writeMessage oprot ("getResourceData", T.M_REPLY, seqid) $
              write_GetResourceData_result oprot res))
        (\e  -> do
          let res = default_GetResourceData_result{getResourceData_result_systemException = P.Just e}
          T.writeMessage oprot ("getResourceData", T.M_REPLY, seqid) $
            write_GetResourceData_result oprot res))
      (\e  -> do
        let res = default_GetResourceData_result{getResourceData_result_notFoundException = P.Just e}
        T.writeMessage oprot ("getResourceData", T.M_REPLY, seqid) $
          write_GetResourceData_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getResourceData", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getResourceByHash (seqid, iprot, oprot, handler) = do
  args <- read_GetResourceByHash_args iprot
  (X.catch
    (X.catch
      (X.catch
        (X.catch
          (do
            val <- Iface.getResourceByHash handler (getResourceByHash_args_authenticationToken args) (getResourceByHash_args_noteGuid args) (getResourceByHash_args_contentHash args) (getResourceByHash_args_withData args) (getResourceByHash_args_withRecognition args) (getResourceByHash_args_withAlternateData args)
            let res = default_GetResourceByHash_result{getResourceByHash_result_success = val}
            T.writeMessage oprot ("getResourceByHash", T.M_REPLY, seqid) $
              write_GetResourceByHash_result oprot res)
          (\e  -> do
            let res = default_GetResourceByHash_result{getResourceByHash_result_userException = P.Just e}
            T.writeMessage oprot ("getResourceByHash", T.M_REPLY, seqid) $
              write_GetResourceByHash_result oprot res))
        (\e  -> do
          let res = default_GetResourceByHash_result{getResourceByHash_result_systemException = P.Just e}
          T.writeMessage oprot ("getResourceByHash", T.M_REPLY, seqid) $
            write_GetResourceByHash_result oprot res))
      (\e  -> do
        let res = default_GetResourceByHash_result{getResourceByHash_result_notFoundException = P.Just e}
        T.writeMessage oprot ("getResourceByHash", T.M_REPLY, seqid) $
          write_GetResourceByHash_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getResourceByHash", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getResourceRecognition (seqid, iprot, oprot, handler) = do
  args <- read_GetResourceRecognition_args iprot
  (X.catch
    (X.catch
      (X.catch
        (X.catch
          (do
            val <- Iface.getResourceRecognition handler (getResourceRecognition_args_authenticationToken args) (getResourceRecognition_args_guid args)
            let res = default_GetResourceRecognition_result{getResourceRecognition_result_success = val}
            T.writeMessage oprot ("getResourceRecognition", T.M_REPLY, seqid) $
              write_GetResourceRecognition_result oprot res)
          (\e  -> do
            let res = default_GetResourceRecognition_result{getResourceRecognition_result_userException = P.Just e}
            T.writeMessage oprot ("getResourceRecognition", T.M_REPLY, seqid) $
              write_GetResourceRecognition_result oprot res))
        (\e  -> do
          let res = default_GetResourceRecognition_result{getResourceRecognition_result_systemException = P.Just e}
          T.writeMessage oprot ("getResourceRecognition", T.M_REPLY, seqid) $
            write_GetResourceRecognition_result oprot res))
      (\e  -> do
        let res = default_GetResourceRecognition_result{getResourceRecognition_result_notFoundException = P.Just e}
        T.writeMessage oprot ("getResourceRecognition", T.M_REPLY, seqid) $
          write_GetResourceRecognition_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getResourceRecognition", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getResourceAlternateData (seqid, iprot, oprot, handler) = do
  args <- read_GetResourceAlternateData_args iprot
  (X.catch
    (X.catch
      (X.catch
        (X.catch
          (do
            val <- Iface.getResourceAlternateData handler (getResourceAlternateData_args_authenticationToken args) (getResourceAlternateData_args_guid args)
            let res = default_GetResourceAlternateData_result{getResourceAlternateData_result_success = val}
            T.writeMessage oprot ("getResourceAlternateData", T.M_REPLY, seqid) $
              write_GetResourceAlternateData_result oprot res)
          (\e  -> do
            let res = default_GetResourceAlternateData_result{getResourceAlternateData_result_userException = P.Just e}
            T.writeMessage oprot ("getResourceAlternateData", T.M_REPLY, seqid) $
              write_GetResourceAlternateData_result oprot res))
        (\e  -> do
          let res = default_GetResourceAlternateData_result{getResourceAlternateData_result_systemException = P.Just e}
          T.writeMessage oprot ("getResourceAlternateData", T.M_REPLY, seqid) $
            write_GetResourceAlternateData_result oprot res))
      (\e  -> do
        let res = default_GetResourceAlternateData_result{getResourceAlternateData_result_notFoundException = P.Just e}
        T.writeMessage oprot ("getResourceAlternateData", T.M_REPLY, seqid) $
          write_GetResourceAlternateData_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getResourceAlternateData", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getResourceAttributes (seqid, iprot, oprot, handler) = do
  args <- read_GetResourceAttributes_args iprot
  (X.catch
    (X.catch
      (X.catch
        (X.catch
          (do
            val <- Iface.getResourceAttributes handler (getResourceAttributes_args_authenticationToken args) (getResourceAttributes_args_guid args)
            let res = default_GetResourceAttributes_result{getResourceAttributes_result_success = val}
            T.writeMessage oprot ("getResourceAttributes", T.M_REPLY, seqid) $
              write_GetResourceAttributes_result oprot res)
          (\e  -> do
            let res = default_GetResourceAttributes_result{getResourceAttributes_result_userException = P.Just e}
            T.writeMessage oprot ("getResourceAttributes", T.M_REPLY, seqid) $
              write_GetResourceAttributes_result oprot res))
        (\e  -> do
          let res = default_GetResourceAttributes_result{getResourceAttributes_result_systemException = P.Just e}
          T.writeMessage oprot ("getResourceAttributes", T.M_REPLY, seqid) $
            write_GetResourceAttributes_result oprot res))
      (\e  -> do
        let res = default_GetResourceAttributes_result{getResourceAttributes_result_notFoundException = P.Just e}
        T.writeMessage oprot ("getResourceAttributes", T.M_REPLY, seqid) $
          write_GetResourceAttributes_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getResourceAttributes", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getPublicNotebook (seqid, iprot, oprot, handler) = do
  args <- read_GetPublicNotebook_args iprot
  (X.catch
    (X.catch
      (X.catch
        (do
          val <- Iface.getPublicNotebook handler (getPublicNotebook_args_userId args) (getPublicNotebook_args_publicUri args)
          let res = default_GetPublicNotebook_result{getPublicNotebook_result_success = val}
          T.writeMessage oprot ("getPublicNotebook", T.M_REPLY, seqid) $
            write_GetPublicNotebook_result oprot res)
        (\e  -> do
          let res = default_GetPublicNotebook_result{getPublicNotebook_result_systemException = P.Just e}
          T.writeMessage oprot ("getPublicNotebook", T.M_REPLY, seqid) $
            write_GetPublicNotebook_result oprot res))
      (\e  -> do
        let res = default_GetPublicNotebook_result{getPublicNotebook_result_notFoundException = P.Just e}
        T.writeMessage oprot ("getPublicNotebook", T.M_REPLY, seqid) $
          write_GetPublicNotebook_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getPublicNotebook", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_shareNotebook (seqid, iprot, oprot, handler) = do
  args <- read_ShareNotebook_args iprot
  (X.catch
    (X.catch
      (X.catch
        (X.catch
          (do
            val <- Iface.shareNotebook handler (shareNotebook_args_authenticationToken args) (shareNotebook_args_sharedNotebook args) (shareNotebook_args_message args)
            let res = default_ShareNotebook_result{shareNotebook_result_success = val}
            T.writeMessage oprot ("shareNotebook", T.M_REPLY, seqid) $
              write_ShareNotebook_result oprot res)
          (\e  -> do
            let res = default_ShareNotebook_result{shareNotebook_result_userException = P.Just e}
            T.writeMessage oprot ("shareNotebook", T.M_REPLY, seqid) $
              write_ShareNotebook_result oprot res))
        (\e  -> do
          let res = default_ShareNotebook_result{shareNotebook_result_notFoundException = P.Just e}
          T.writeMessage oprot ("shareNotebook", T.M_REPLY, seqid) $
            write_ShareNotebook_result oprot res))
      (\e  -> do
        let res = default_ShareNotebook_result{shareNotebook_result_systemException = P.Just e}
        T.writeMessage oprot ("shareNotebook", T.M_REPLY, seqid) $
          write_ShareNotebook_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("shareNotebook", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_createOrUpdateNotebookShares (seqid, iprot, oprot, handler) = do
  args <- read_CreateOrUpdateNotebookShares_args iprot
  (X.catch
    (X.catch
      (X.catch
        (X.catch
          (X.catch
            (do
              val <- Iface.createOrUpdateNotebookShares handler (createOrUpdateNotebookShares_args_authenticationToken args) (createOrUpdateNotebookShares_args_shareTemplate args)
              let res = default_CreateOrUpdateNotebookShares_result{createOrUpdateNotebookShares_result_success = val}
              T.writeMessage oprot ("createOrUpdateNotebookShares", T.M_REPLY, seqid) $
                write_CreateOrUpdateNotebookShares_result oprot res)
            (\e  -> do
              let res = default_CreateOrUpdateNotebookShares_result{createOrUpdateNotebookShares_result_userException = P.Just e}
              T.writeMessage oprot ("createOrUpdateNotebookShares", T.M_REPLY, seqid) $
                write_CreateOrUpdateNotebookShares_result oprot res))
          (\e  -> do
            let res = default_CreateOrUpdateNotebookShares_result{createOrUpdateNotebookShares_result_notFoundException = P.Just e}
            T.writeMessage oprot ("createOrUpdateNotebookShares", T.M_REPLY, seqid) $
              write_CreateOrUpdateNotebookShares_result oprot res))
        (\e  -> do
          let res = default_CreateOrUpdateNotebookShares_result{createOrUpdateNotebookShares_result_systemException = P.Just e}
          T.writeMessage oprot ("createOrUpdateNotebookShares", T.M_REPLY, seqid) $
            write_CreateOrUpdateNotebookShares_result oprot res))
      (\e  -> do
        let res = default_CreateOrUpdateNotebookShares_result{createOrUpdateNotebookShares_result_invalidContactsException = P.Just e}
        T.writeMessage oprot ("createOrUpdateNotebookShares", T.M_REPLY, seqid) $
          write_CreateOrUpdateNotebookShares_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("createOrUpdateNotebookShares", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_updateSharedNotebook (seqid, iprot, oprot, handler) = do
  args <- read_UpdateSharedNotebook_args iprot
  (X.catch
    (X.catch
      (X.catch
        (X.catch
          (do
            val <- Iface.updateSharedNotebook handler (updateSharedNotebook_args_authenticationToken args) (updateSharedNotebook_args_sharedNotebook args)
            let res = default_UpdateSharedNotebook_result{updateSharedNotebook_result_success = val}
            T.writeMessage oprot ("updateSharedNotebook", T.M_REPLY, seqid) $
              write_UpdateSharedNotebook_result oprot res)
          (\e  -> do
            let res = default_UpdateSharedNotebook_result{updateSharedNotebook_result_userException = P.Just e}
            T.writeMessage oprot ("updateSharedNotebook", T.M_REPLY, seqid) $
              write_UpdateSharedNotebook_result oprot res))
        (\e  -> do
          let res = default_UpdateSharedNotebook_result{updateSharedNotebook_result_notFoundException = P.Just e}
          T.writeMessage oprot ("updateSharedNotebook", T.M_REPLY, seqid) $
            write_UpdateSharedNotebook_result oprot res))
      (\e  -> do
        let res = default_UpdateSharedNotebook_result{updateSharedNotebook_result_systemException = P.Just e}
        T.writeMessage oprot ("updateSharedNotebook", T.M_REPLY, seqid) $
          write_UpdateSharedNotebook_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("updateSharedNotebook", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_setNotebookRecipientSettings (seqid, iprot, oprot, handler) = do
  args <- read_SetNotebookRecipientSettings_args iprot
  (X.catch
    (X.catch
      (X.catch
        (X.catch
          (do
            val <- Iface.setNotebookRecipientSettings handler (setNotebookRecipientSettings_args_authenticationToken args) (setNotebookRecipientSettings_args_notebookGuid args) (setNotebookRecipientSettings_args_recipientSettings args)
            let res = default_SetNotebookRecipientSettings_result{setNotebookRecipientSettings_result_success = val}
            T.writeMessage oprot ("setNotebookRecipientSettings", T.M_REPLY, seqid) $
              write_SetNotebookRecipientSettings_result oprot res)
          (\e  -> do
            let res = default_SetNotebookRecipientSettings_result{setNotebookRecipientSettings_result_userException = P.Just e}
            T.writeMessage oprot ("setNotebookRecipientSettings", T.M_REPLY, seqid) $
              write_SetNotebookRecipientSettings_result oprot res))
        (\e  -> do
          let res = default_SetNotebookRecipientSettings_result{setNotebookRecipientSettings_result_notFoundException = P.Just e}
          T.writeMessage oprot ("setNotebookRecipientSettings", T.M_REPLY, seqid) $
            write_SetNotebookRecipientSettings_result oprot res))
      (\e  -> do
        let res = default_SetNotebookRecipientSettings_result{setNotebookRecipientSettings_result_systemException = P.Just e}
        T.writeMessage oprot ("setNotebookRecipientSettings", T.M_REPLY, seqid) $
          write_SetNotebookRecipientSettings_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("setNotebookRecipientSettings", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_listSharedNotebooks (seqid, iprot, oprot, handler) = do
  args <- read_ListSharedNotebooks_args iprot
  (X.catch
    (X.catch
      (X.catch
        (X.catch
          (do
            val <- Iface.listSharedNotebooks handler (listSharedNotebooks_args_authenticationToken args)
            let res = default_ListSharedNotebooks_result{listSharedNotebooks_result_success = val}
            T.writeMessage oprot ("listSharedNotebooks", T.M_REPLY, seqid) $
              write_ListSharedNotebooks_result oprot res)
          (\e  -> do
            let res = default_ListSharedNotebooks_result{listSharedNotebooks_result_userException = P.Just e}
            T.writeMessage oprot ("listSharedNotebooks", T.M_REPLY, seqid) $
              write_ListSharedNotebooks_result oprot res))
        (\e  -> do
          let res = default_ListSharedNotebooks_result{listSharedNotebooks_result_notFoundException = P.Just e}
          T.writeMessage oprot ("listSharedNotebooks", T.M_REPLY, seqid) $
            write_ListSharedNotebooks_result oprot res))
      (\e  -> do
        let res = default_ListSharedNotebooks_result{listSharedNotebooks_result_systemException = P.Just e}
        T.writeMessage oprot ("listSharedNotebooks", T.M_REPLY, seqid) $
          write_ListSharedNotebooks_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("listSharedNotebooks", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_createLinkedNotebook (seqid, iprot, oprot, handler) = do
  args <- read_CreateLinkedNotebook_args iprot
  (X.catch
    (X.catch
      (X.catch
        (X.catch
          (do
            val <- Iface.createLinkedNotebook handler (createLinkedNotebook_args_authenticationToken args) (createLinkedNotebook_args_linkedNotebook args)
            let res = default_CreateLinkedNotebook_result{createLinkedNotebook_result_success = val}
            T.writeMessage oprot ("createLinkedNotebook", T.M_REPLY, seqid) $
              write_CreateLinkedNotebook_result oprot res)
          (\e  -> do
            let res = default_CreateLinkedNotebook_result{createLinkedNotebook_result_userException = P.Just e}
            T.writeMessage oprot ("createLinkedNotebook", T.M_REPLY, seqid) $
              write_CreateLinkedNotebook_result oprot res))
        (\e  -> do
          let res = default_CreateLinkedNotebook_result{createLinkedNotebook_result_notFoundException = P.Just e}
          T.writeMessage oprot ("createLinkedNotebook", T.M_REPLY, seqid) $
            write_CreateLinkedNotebook_result oprot res))
      (\e  -> do
        let res = default_CreateLinkedNotebook_result{createLinkedNotebook_result_systemException = P.Just e}
        T.writeMessage oprot ("createLinkedNotebook", T.M_REPLY, seqid) $
          write_CreateLinkedNotebook_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("createLinkedNotebook", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_updateLinkedNotebook (seqid, iprot, oprot, handler) = do
  args <- read_UpdateLinkedNotebook_args iprot
  (X.catch
    (X.catch
      (X.catch
        (X.catch
          (do
            val <- Iface.updateLinkedNotebook handler (updateLinkedNotebook_args_authenticationToken args) (updateLinkedNotebook_args_linkedNotebook args)
            let res = default_UpdateLinkedNotebook_result{updateLinkedNotebook_result_success = val}
            T.writeMessage oprot ("updateLinkedNotebook", T.M_REPLY, seqid) $
              write_UpdateLinkedNotebook_result oprot res)
          (\e  -> do
            let res = default_UpdateLinkedNotebook_result{updateLinkedNotebook_result_userException = P.Just e}
            T.writeMessage oprot ("updateLinkedNotebook", T.M_REPLY, seqid) $
              write_UpdateLinkedNotebook_result oprot res))
        (\e  -> do
          let res = default_UpdateLinkedNotebook_result{updateLinkedNotebook_result_notFoundException = P.Just e}
          T.writeMessage oprot ("updateLinkedNotebook", T.M_REPLY, seqid) $
            write_UpdateLinkedNotebook_result oprot res))
      (\e  -> do
        let res = default_UpdateLinkedNotebook_result{updateLinkedNotebook_result_systemException = P.Just e}
        T.writeMessage oprot ("updateLinkedNotebook", T.M_REPLY, seqid) $
          write_UpdateLinkedNotebook_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("updateLinkedNotebook", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_listLinkedNotebooks (seqid, iprot, oprot, handler) = do
  args <- read_ListLinkedNotebooks_args iprot
  (X.catch
    (X.catch
      (X.catch
        (X.catch
          (do
            val <- Iface.listLinkedNotebooks handler (listLinkedNotebooks_args_authenticationToken args)
            let res = default_ListLinkedNotebooks_result{listLinkedNotebooks_result_success = val}
            T.writeMessage oprot ("listLinkedNotebooks", T.M_REPLY, seqid) $
              write_ListLinkedNotebooks_result oprot res)
          (\e  -> do
            let res = default_ListLinkedNotebooks_result{listLinkedNotebooks_result_userException = P.Just e}
            T.writeMessage oprot ("listLinkedNotebooks", T.M_REPLY, seqid) $
              write_ListLinkedNotebooks_result oprot res))
        (\e  -> do
          let res = default_ListLinkedNotebooks_result{listLinkedNotebooks_result_notFoundException = P.Just e}
          T.writeMessage oprot ("listLinkedNotebooks", T.M_REPLY, seqid) $
            write_ListLinkedNotebooks_result oprot res))
      (\e  -> do
        let res = default_ListLinkedNotebooks_result{listLinkedNotebooks_result_systemException = P.Just e}
        T.writeMessage oprot ("listLinkedNotebooks", T.M_REPLY, seqid) $
          write_ListLinkedNotebooks_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("listLinkedNotebooks", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_expungeLinkedNotebook (seqid, iprot, oprot, handler) = do
  args <- read_ExpungeLinkedNotebook_args iprot
  (X.catch
    (X.catch
      (X.catch
        (X.catch
          (do
            val <- Iface.expungeLinkedNotebook handler (expungeLinkedNotebook_args_authenticationToken args) (expungeLinkedNotebook_args_guid args)
            let res = default_ExpungeLinkedNotebook_result{expungeLinkedNotebook_result_success = val}
            T.writeMessage oprot ("expungeLinkedNotebook", T.M_REPLY, seqid) $
              write_ExpungeLinkedNotebook_result oprot res)
          (\e  -> do
            let res = default_ExpungeLinkedNotebook_result{expungeLinkedNotebook_result_userException = P.Just e}
            T.writeMessage oprot ("expungeLinkedNotebook", T.M_REPLY, seqid) $
              write_ExpungeLinkedNotebook_result oprot res))
        (\e  -> do
          let res = default_ExpungeLinkedNotebook_result{expungeLinkedNotebook_result_notFoundException = P.Just e}
          T.writeMessage oprot ("expungeLinkedNotebook", T.M_REPLY, seqid) $
            write_ExpungeLinkedNotebook_result oprot res))
      (\e  -> do
        let res = default_ExpungeLinkedNotebook_result{expungeLinkedNotebook_result_systemException = P.Just e}
        T.writeMessage oprot ("expungeLinkedNotebook", T.M_REPLY, seqid) $
          write_ExpungeLinkedNotebook_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("expungeLinkedNotebook", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_authenticateToSharedNotebook (seqid, iprot, oprot, handler) = do
  args <- read_AuthenticateToSharedNotebook_args iprot
  (X.catch
    (X.catch
      (X.catch
        (X.catch
          (do
            val <- Iface.authenticateToSharedNotebook handler (authenticateToSharedNotebook_args_shareKeyOrGlobalId args) (authenticateToSharedNotebook_args_authenticationToken args)
            let res = default_AuthenticateToSharedNotebook_result{authenticateToSharedNotebook_result_success = val}
            T.writeMessage oprot ("authenticateToSharedNotebook", T.M_REPLY, seqid) $
              write_AuthenticateToSharedNotebook_result oprot res)
          (\e  -> do
            let res = default_AuthenticateToSharedNotebook_result{authenticateToSharedNotebook_result_userException = P.Just e}
            T.writeMessage oprot ("authenticateToSharedNotebook", T.M_REPLY, seqid) $
              write_AuthenticateToSharedNotebook_result oprot res))
        (\e  -> do
          let res = default_AuthenticateToSharedNotebook_result{authenticateToSharedNotebook_result_notFoundException = P.Just e}
          T.writeMessage oprot ("authenticateToSharedNotebook", T.M_REPLY, seqid) $
            write_AuthenticateToSharedNotebook_result oprot res))
      (\e  -> do
        let res = default_AuthenticateToSharedNotebook_result{authenticateToSharedNotebook_result_systemException = P.Just e}
        T.writeMessage oprot ("authenticateToSharedNotebook", T.M_REPLY, seqid) $
          write_AuthenticateToSharedNotebook_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("authenticateToSharedNotebook", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getSharedNotebookByAuth (seqid, iprot, oprot, handler) = do
  args <- read_GetSharedNotebookByAuth_args iprot
  (X.catch
    (X.catch
      (X.catch
        (X.catch
          (do
            val <- Iface.getSharedNotebookByAuth handler (getSharedNotebookByAuth_args_authenticationToken args)
            let res = default_GetSharedNotebookByAuth_result{getSharedNotebookByAuth_result_success = val}
            T.writeMessage oprot ("getSharedNotebookByAuth", T.M_REPLY, seqid) $
              write_GetSharedNotebookByAuth_result oprot res)
          (\e  -> do
            let res = default_GetSharedNotebookByAuth_result{getSharedNotebookByAuth_result_userException = P.Just e}
            T.writeMessage oprot ("getSharedNotebookByAuth", T.M_REPLY, seqid) $
              write_GetSharedNotebookByAuth_result oprot res))
        (\e  -> do
          let res = default_GetSharedNotebookByAuth_result{getSharedNotebookByAuth_result_notFoundException = P.Just e}
          T.writeMessage oprot ("getSharedNotebookByAuth", T.M_REPLY, seqid) $
            write_GetSharedNotebookByAuth_result oprot res))
      (\e  -> do
        let res = default_GetSharedNotebookByAuth_result{getSharedNotebookByAuth_result_systemException = P.Just e}
        T.writeMessage oprot ("getSharedNotebookByAuth", T.M_REPLY, seqid) $
          write_GetSharedNotebookByAuth_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getSharedNotebookByAuth", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_emailNote (seqid, iprot, oprot, handler) = do
  args <- read_EmailNote_args iprot
  (X.catch
    (X.catch
      (X.catch
        (X.catch
          (do
            Iface.emailNote handler (emailNote_args_authenticationToken args) (emailNote_args_parameters args)
            let res = default_EmailNote_result
            T.writeMessage oprot ("emailNote", T.M_REPLY, seqid) $
              write_EmailNote_result oprot res)
          (\e  -> do
            let res = default_EmailNote_result{emailNote_result_userException = P.Just e}
            T.writeMessage oprot ("emailNote", T.M_REPLY, seqid) $
              write_EmailNote_result oprot res))
        (\e  -> do
          let res = default_EmailNote_result{emailNote_result_notFoundException = P.Just e}
          T.writeMessage oprot ("emailNote", T.M_REPLY, seqid) $
            write_EmailNote_result oprot res))
      (\e  -> do
        let res = default_EmailNote_result{emailNote_result_systemException = P.Just e}
        T.writeMessage oprot ("emailNote", T.M_REPLY, seqid) $
          write_EmailNote_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("emailNote", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_shareNote (seqid, iprot, oprot, handler) = do
  args <- read_ShareNote_args iprot
  (X.catch
    (X.catch
      (X.catch
        (X.catch
          (do
            val <- Iface.shareNote handler (shareNote_args_authenticationToken args) (shareNote_args_guid args)
            let res = default_ShareNote_result{shareNote_result_success = val}
            T.writeMessage oprot ("shareNote", T.M_REPLY, seqid) $
              write_ShareNote_result oprot res)
          (\e  -> do
            let res = default_ShareNote_result{shareNote_result_userException = P.Just e}
            T.writeMessage oprot ("shareNote", T.M_REPLY, seqid) $
              write_ShareNote_result oprot res))
        (\e  -> do
          let res = default_ShareNote_result{shareNote_result_notFoundException = P.Just e}
          T.writeMessage oprot ("shareNote", T.M_REPLY, seqid) $
            write_ShareNote_result oprot res))
      (\e  -> do
        let res = default_ShareNote_result{shareNote_result_systemException = P.Just e}
        T.writeMessage oprot ("shareNote", T.M_REPLY, seqid) $
          write_ShareNote_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("shareNote", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_stopSharingNote (seqid, iprot, oprot, handler) = do
  args <- read_StopSharingNote_args iprot
  (X.catch
    (X.catch
      (X.catch
        (X.catch
          (do
            Iface.stopSharingNote handler (stopSharingNote_args_authenticationToken args) (stopSharingNote_args_guid args)
            let res = default_StopSharingNote_result
            T.writeMessage oprot ("stopSharingNote", T.M_REPLY, seqid) $
              write_StopSharingNote_result oprot res)
          (\e  -> do
            let res = default_StopSharingNote_result{stopSharingNote_result_userException = P.Just e}
            T.writeMessage oprot ("stopSharingNote", T.M_REPLY, seqid) $
              write_StopSharingNote_result oprot res))
        (\e  -> do
          let res = default_StopSharingNote_result{stopSharingNote_result_notFoundException = P.Just e}
          T.writeMessage oprot ("stopSharingNote", T.M_REPLY, seqid) $
            write_StopSharingNote_result oprot res))
      (\e  -> do
        let res = default_StopSharingNote_result{stopSharingNote_result_systemException = P.Just e}
        T.writeMessage oprot ("stopSharingNote", T.M_REPLY, seqid) $
          write_StopSharingNote_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("stopSharingNote", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_authenticateToSharedNote (seqid, iprot, oprot, handler) = do
  args <- read_AuthenticateToSharedNote_args iprot
  (X.catch
    (X.catch
      (X.catch
        (X.catch
          (do
            val <- Iface.authenticateToSharedNote handler (authenticateToSharedNote_args_guid args) (authenticateToSharedNote_args_noteKey args) (authenticateToSharedNote_args_authenticationToken args)
            let res = default_AuthenticateToSharedNote_result{authenticateToSharedNote_result_success = val}
            T.writeMessage oprot ("authenticateToSharedNote", T.M_REPLY, seqid) $
              write_AuthenticateToSharedNote_result oprot res)
          (\e  -> do
            let res = default_AuthenticateToSharedNote_result{authenticateToSharedNote_result_userException = P.Just e}
            T.writeMessage oprot ("authenticateToSharedNote", T.M_REPLY, seqid) $
              write_AuthenticateToSharedNote_result oprot res))
        (\e  -> do
          let res = default_AuthenticateToSharedNote_result{authenticateToSharedNote_result_notFoundException = P.Just e}
          T.writeMessage oprot ("authenticateToSharedNote", T.M_REPLY, seqid) $
            write_AuthenticateToSharedNote_result oprot res))
      (\e  -> do
        let res = default_AuthenticateToSharedNote_result{authenticateToSharedNote_result_systemException = P.Just e}
        T.writeMessage oprot ("authenticateToSharedNote", T.M_REPLY, seqid) $
          write_AuthenticateToSharedNote_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("authenticateToSharedNote", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_findRelated (seqid, iprot, oprot, handler) = do
  args <- read_FindRelated_args iprot
  (X.catch
    (X.catch
      (X.catch
        (X.catch
          (do
            val <- Iface.findRelated handler (findRelated_args_authenticationToken args) (findRelated_args_query args) (findRelated_args_resultSpec args)
            let res = default_FindRelated_result{findRelated_result_success = val}
            T.writeMessage oprot ("findRelated", T.M_REPLY, seqid) $
              write_FindRelated_result oprot res)
          (\e  -> do
            let res = default_FindRelated_result{findRelated_result_userException = P.Just e}
            T.writeMessage oprot ("findRelated", T.M_REPLY, seqid) $
              write_FindRelated_result oprot res))
        (\e  -> do
          let res = default_FindRelated_result{findRelated_result_systemException = P.Just e}
          T.writeMessage oprot ("findRelated", T.M_REPLY, seqid) $
            write_FindRelated_result oprot res))
      (\e  -> do
        let res = default_FindRelated_result{findRelated_result_notFoundException = P.Just e}
        T.writeMessage oprot ("findRelated", T.M_REPLY, seqid) $
          write_FindRelated_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("findRelated", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_updateNoteIfUsnMatches (seqid, iprot, oprot, handler) = do
  args <- read_UpdateNoteIfUsnMatches_args iprot
  (X.catch
    (X.catch
      (X.catch
        (X.catch
          (do
            val <- Iface.updateNoteIfUsnMatches handler (updateNoteIfUsnMatches_args_authenticationToken args) (updateNoteIfUsnMatches_args_note args)
            let res = default_UpdateNoteIfUsnMatches_result{updateNoteIfUsnMatches_result_success = val}
            T.writeMessage oprot ("updateNoteIfUsnMatches", T.M_REPLY, seqid) $
              write_UpdateNoteIfUsnMatches_result oprot res)
          (\e  -> do
            let res = default_UpdateNoteIfUsnMatches_result{updateNoteIfUsnMatches_result_userException = P.Just e}
            T.writeMessage oprot ("updateNoteIfUsnMatches", T.M_REPLY, seqid) $
              write_UpdateNoteIfUsnMatches_result oprot res))
        (\e  -> do
          let res = default_UpdateNoteIfUsnMatches_result{updateNoteIfUsnMatches_result_notFoundException = P.Just e}
          T.writeMessage oprot ("updateNoteIfUsnMatches", T.M_REPLY, seqid) $
            write_UpdateNoteIfUsnMatches_result oprot res))
      (\e  -> do
        let res = default_UpdateNoteIfUsnMatches_result{updateNoteIfUsnMatches_result_systemException = P.Just e}
        T.writeMessage oprot ("updateNoteIfUsnMatches", T.M_REPLY, seqid) $
          write_UpdateNoteIfUsnMatches_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("updateNoteIfUsnMatches", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_manageNotebookShares (seqid, iprot, oprot, handler) = do
  args <- read_ManageNotebookShares_args iprot
  (X.catch
    (X.catch
      (X.catch
        (X.catch
          (do
            val <- Iface.manageNotebookShares handler (manageNotebookShares_args_authenticationToken args) (manageNotebookShares_args_parameters args)
            let res = default_ManageNotebookShares_result{manageNotebookShares_result_success = val}
            T.writeMessage oprot ("manageNotebookShares", T.M_REPLY, seqid) $
              write_ManageNotebookShares_result oprot res)
          (\e  -> do
            let res = default_ManageNotebookShares_result{manageNotebookShares_result_userException = P.Just e}
            T.writeMessage oprot ("manageNotebookShares", T.M_REPLY, seqid) $
              write_ManageNotebookShares_result oprot res))
        (\e  -> do
          let res = default_ManageNotebookShares_result{manageNotebookShares_result_notFoundException = P.Just e}
          T.writeMessage oprot ("manageNotebookShares", T.M_REPLY, seqid) $
            write_ManageNotebookShares_result oprot res))
      (\e  -> do
        let res = default_ManageNotebookShares_result{manageNotebookShares_result_systemException = P.Just e}
        T.writeMessage oprot ("manageNotebookShares", T.M_REPLY, seqid) $
          write_ManageNotebookShares_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("manageNotebookShares", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
process_getNotebookShares (seqid, iprot, oprot, handler) = do
  args <- read_GetNotebookShares_args iprot
  (X.catch
    (X.catch
      (X.catch
        (X.catch
          (do
            val <- Iface.getNotebookShares handler (getNotebookShares_args_authenticationToken args) (getNotebookShares_args_notebookGuid args)
            let res = default_GetNotebookShares_result{getNotebookShares_result_success = val}
            T.writeMessage oprot ("getNotebookShares", T.M_REPLY, seqid) $
              write_GetNotebookShares_result oprot res)
          (\e  -> do
            let res = default_GetNotebookShares_result{getNotebookShares_result_userException = P.Just e}
            T.writeMessage oprot ("getNotebookShares", T.M_REPLY, seqid) $
              write_GetNotebookShares_result oprot res))
        (\e  -> do
          let res = default_GetNotebookShares_result{getNotebookShares_result_notFoundException = P.Just e}
          T.writeMessage oprot ("getNotebookShares", T.M_REPLY, seqid) $
            write_GetNotebookShares_result oprot res))
      (\e  -> do
        let res = default_GetNotebookShares_result{getNotebookShares_result_systemException = P.Just e}
        T.writeMessage oprot ("getNotebookShares", T.M_REPLY, seqid) $
          write_GetNotebookShares_result oprot res))
    ((\_ -> do
      T.writeMessage oprot ("getNotebookShares", T.M_EXCEPTION, seqid) $
        T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN "")) :: X.SomeException -> P.IO ()))
proc_ handler (iprot,oprot) (name,typ,seqid) = case name of
  "getSyncState" -> process_getSyncState (seqid,iprot,oprot,handler)
  "getFilteredSyncChunk" -> process_getFilteredSyncChunk (seqid,iprot,oprot,handler)
  "getLinkedNotebookSyncState" -> process_getLinkedNotebookSyncState (seqid,iprot,oprot,handler)
  "getLinkedNotebookSyncChunk" -> process_getLinkedNotebookSyncChunk (seqid,iprot,oprot,handler)
  "listNotebooks" -> process_listNotebooks (seqid,iprot,oprot,handler)
  "listAccessibleBusinessNotebooks" -> process_listAccessibleBusinessNotebooks (seqid,iprot,oprot,handler)
  "getNotebook" -> process_getNotebook (seqid,iprot,oprot,handler)
  "getDefaultNotebook" -> process_getDefaultNotebook (seqid,iprot,oprot,handler)
  "createNotebook" -> process_createNotebook (seqid,iprot,oprot,handler)
  "updateNotebook" -> process_updateNotebook (seqid,iprot,oprot,handler)
  "expungeNotebook" -> process_expungeNotebook (seqid,iprot,oprot,handler)
  "listTags" -> process_listTags (seqid,iprot,oprot,handler)
  "listTagsByNotebook" -> process_listTagsByNotebook (seqid,iprot,oprot,handler)
  "getTag" -> process_getTag (seqid,iprot,oprot,handler)
  "createTag" -> process_createTag (seqid,iprot,oprot,handler)
  "updateTag" -> process_updateTag (seqid,iprot,oprot,handler)
  "untagAll" -> process_untagAll (seqid,iprot,oprot,handler)
  "expungeTag" -> process_expungeTag (seqid,iprot,oprot,handler)
  "listSearches" -> process_listSearches (seqid,iprot,oprot,handler)
  "getSearch" -> process_getSearch (seqid,iprot,oprot,handler)
  "createSearch" -> process_createSearch (seqid,iprot,oprot,handler)
  "updateSearch" -> process_updateSearch (seqid,iprot,oprot,handler)
  "expungeSearch" -> process_expungeSearch (seqid,iprot,oprot,handler)
  "findNoteOffset" -> process_findNoteOffset (seqid,iprot,oprot,handler)
  "findNotesMetadata" -> process_findNotesMetadata (seqid,iprot,oprot,handler)
  "findNoteCounts" -> process_findNoteCounts (seqid,iprot,oprot,handler)
  "getNoteWithResultSpec" -> process_getNoteWithResultSpec (seqid,iprot,oprot,handler)
  "getNote" -> process_getNote (seqid,iprot,oprot,handler)
  "getNoteApplicationData" -> process_getNoteApplicationData (seqid,iprot,oprot,handler)
  "getNoteApplicationDataEntry" -> process_getNoteApplicationDataEntry (seqid,iprot,oprot,handler)
  "setNoteApplicationDataEntry" -> process_setNoteApplicationDataEntry (seqid,iprot,oprot,handler)
  "unsetNoteApplicationDataEntry" -> process_unsetNoteApplicationDataEntry (seqid,iprot,oprot,handler)
  "getNoteContent" -> process_getNoteContent (seqid,iprot,oprot,handler)
  "getNoteSearchText" -> process_getNoteSearchText (seqid,iprot,oprot,handler)
  "getResourceSearchText" -> process_getResourceSearchText (seqid,iprot,oprot,handler)
  "getNoteTagNames" -> process_getNoteTagNames (seqid,iprot,oprot,handler)
  "createNote" -> process_createNote (seqid,iprot,oprot,handler)
  "updateNote" -> process_updateNote (seqid,iprot,oprot,handler)
  "deleteNote" -> process_deleteNote (seqid,iprot,oprot,handler)
  "expungeNote" -> process_expungeNote (seqid,iprot,oprot,handler)
  "copyNote" -> process_copyNote (seqid,iprot,oprot,handler)
  "listNoteVersions" -> process_listNoteVersions (seqid,iprot,oprot,handler)
  "getNoteVersion" -> process_getNoteVersion (seqid,iprot,oprot,handler)
  "getResource" -> process_getResource (seqid,iprot,oprot,handler)
  "getResourceApplicationData" -> process_getResourceApplicationData (seqid,iprot,oprot,handler)
  "getResourceApplicationDataEntry" -> process_getResourceApplicationDataEntry (seqid,iprot,oprot,handler)
  "setResourceApplicationDataEntry" -> process_setResourceApplicationDataEntry (seqid,iprot,oprot,handler)
  "unsetResourceApplicationDataEntry" -> process_unsetResourceApplicationDataEntry (seqid,iprot,oprot,handler)
  "updateResource" -> process_updateResource (seqid,iprot,oprot,handler)
  "getResourceData" -> process_getResourceData (seqid,iprot,oprot,handler)
  "getResourceByHash" -> process_getResourceByHash (seqid,iprot,oprot,handler)
  "getResourceRecognition" -> process_getResourceRecognition (seqid,iprot,oprot,handler)
  "getResourceAlternateData" -> process_getResourceAlternateData (seqid,iprot,oprot,handler)
  "getResourceAttributes" -> process_getResourceAttributes (seqid,iprot,oprot,handler)
  "getPublicNotebook" -> process_getPublicNotebook (seqid,iprot,oprot,handler)
  "shareNotebook" -> process_shareNotebook (seqid,iprot,oprot,handler)
  "createOrUpdateNotebookShares" -> process_createOrUpdateNotebookShares (seqid,iprot,oprot,handler)
  "updateSharedNotebook" -> process_updateSharedNotebook (seqid,iprot,oprot,handler)
  "setNotebookRecipientSettings" -> process_setNotebookRecipientSettings (seqid,iprot,oprot,handler)
  "listSharedNotebooks" -> process_listSharedNotebooks (seqid,iprot,oprot,handler)
  "createLinkedNotebook" -> process_createLinkedNotebook (seqid,iprot,oprot,handler)
  "updateLinkedNotebook" -> process_updateLinkedNotebook (seqid,iprot,oprot,handler)
  "listLinkedNotebooks" -> process_listLinkedNotebooks (seqid,iprot,oprot,handler)
  "expungeLinkedNotebook" -> process_expungeLinkedNotebook (seqid,iprot,oprot,handler)
  "authenticateToSharedNotebook" -> process_authenticateToSharedNotebook (seqid,iprot,oprot,handler)
  "getSharedNotebookByAuth" -> process_getSharedNotebookByAuth (seqid,iprot,oprot,handler)
  "emailNote" -> process_emailNote (seqid,iprot,oprot,handler)
  "shareNote" -> process_shareNote (seqid,iprot,oprot,handler)
  "stopSharingNote" -> process_stopSharingNote (seqid,iprot,oprot,handler)
  "authenticateToSharedNote" -> process_authenticateToSharedNote (seqid,iprot,oprot,handler)
  "findRelated" -> process_findRelated (seqid,iprot,oprot,handler)
  "updateNoteIfUsnMatches" -> process_updateNoteIfUsnMatches (seqid,iprot,oprot,handler)
  "manageNotebookShares" -> process_manageNotebookShares (seqid,iprot,oprot,handler)
  "getNotebookShares" -> process_getNotebookShares (seqid,iprot,oprot,handler)
  _ -> do
    _ <- T.readVal iprot (T.T_STRUCT Map.empty)
    T.writeMessage oprot (name,T.M_EXCEPTION,seqid) $
      T.writeAppExn oprot (T.AppExn T.AE_UNKNOWN_METHOD ("Unknown function " ++ LT.unpack name))
process handler (iprot, oprot) = do
  T.readMessage iprot (
    proc_ handler (iprot,oprot))
  P.return P.True
