{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-missing-fields #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-----------------------------------------------------------------
-- Autogenerated by Thrift Compiler (0.11.0)                      --
--                                                             --
-- DO NOT EDIT UNLESS YOU ARE SURE YOU KNOW WHAT YOU ARE DOING --
-----------------------------------------------------------------

module Types_Types where
import Prelude (($), (.), (>>=), (==), (++))
import qualified Prelude as P
import qualified Control.Exception as X
import qualified Control.Monad as M ( liftM, ap, when )
import Data.Functor ( (<$>) )
import qualified Data.ByteString.Lazy as LBS
import qualified Data.Hashable as H
import qualified Data.Int as I
import qualified Data.Maybe as M (catMaybes)
import qualified Data.Text.Lazy.Encoding as E ( decodeUtf8, encodeUtf8 )
import qualified Data.Text.Lazy as LT
import qualified GHC.Generics as G (Generic)
import qualified Data.Typeable as TY ( Typeable )
import qualified Data.HashMap.Strict as Map
import qualified Data.HashSet as Set
import qualified Data.Vector as Vector
import qualified Test.QuickCheck.Arbitrary as QC ( Arbitrary(..) )
import qualified Test.QuickCheck as QC ( elements )

import qualified Thrift as T
import qualified Thrift.Types as T
import qualified Thrift.Arbitraries as T

import qualified Limits_Types


data PrivilegeLevel = NORMAL|PREMIUM|VIP|MANAGER|SUPPORT|ADMIN  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum PrivilegeLevel where
  fromEnum t = case t of
    NORMAL -> 1
    PREMIUM -> 3
    VIP -> 5
    MANAGER -> 7
    SUPPORT -> 8
    ADMIN -> 9
  toEnum t = case t of
    1 -> NORMAL
    3 -> PREMIUM
    5 -> VIP
    7 -> MANAGER
    8 -> SUPPORT
    9 -> ADMIN
    _ -> X.throw T.ThriftException
instance H.Hashable PrivilegeLevel where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary PrivilegeLevel where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data ServiceLevel = BASIC|PLUS|PREMIUM  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum ServiceLevel where
  fromEnum t = case t of
    BASIC -> 1
    PLUS -> 2
    PREMIUM -> 3
  toEnum t = case t of
    1 -> BASIC
    2 -> PLUS
    3 -> PREMIUM
    _ -> X.throw T.ThriftException
instance H.Hashable ServiceLevel where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary ServiceLevel where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data QueryFormat = USER|SEXP  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum QueryFormat where
  fromEnum t = case t of
    USER -> 1
    SEXP -> 2
  toEnum t = case t of
    1 -> USER
    2 -> SEXP
    _ -> X.throw T.ThriftException
instance H.Hashable QueryFormat where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary QueryFormat where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data NoteSortOrder = CREATED|UPDATED|RELEVANCE|UPDATE_SEQUENCE_NUMBER|TITLE  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum NoteSortOrder where
  fromEnum t = case t of
    CREATED -> 1
    UPDATED -> 2
    RELEVANCE -> 3
    UPDATE_SEQUENCE_NUMBER -> 4
    TITLE -> 5
  toEnum t = case t of
    1 -> CREATED
    2 -> UPDATED
    3 -> RELEVANCE
    4 -> UPDATE_SEQUENCE_NUMBER
    5 -> TITLE
    _ -> X.throw T.ThriftException
instance H.Hashable NoteSortOrder where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary NoteSortOrder where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data PremiumOrderStatus = NONE|PENDING|ACTIVE|FAILED|CANCELLATION_PENDING|CANCELED  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum PremiumOrderStatus where
  fromEnum t = case t of
    NONE -> 0
    PENDING -> 1
    ACTIVE -> 2
    FAILED -> 3
    CANCELLATION_PENDING -> 4
    CANCELED -> 5
  toEnum t = case t of
    0 -> NONE
    1 -> PENDING
    2 -> ACTIVE
    3 -> FAILED
    4 -> CANCELLATION_PENDING
    5 -> CANCELED
    _ -> X.throw T.ThriftException
instance H.Hashable PremiumOrderStatus where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary PremiumOrderStatus where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data SharedNotebookPrivilegeLevel = READ_NOTEBOOK|MODIFY_NOTEBOOK_PLUS_ACTIVITY|READ_NOTEBOOK_PLUS_ACTIVITY|GROUP|FULL_ACCESS|BUSINESS_FULL_ACCESS  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum SharedNotebookPrivilegeLevel where
  fromEnum t = case t of
    READ_NOTEBOOK -> 0
    MODIFY_NOTEBOOK_PLUS_ACTIVITY -> 1
    READ_NOTEBOOK_PLUS_ACTIVITY -> 2
    GROUP -> 3
    FULL_ACCESS -> 4
    BUSINESS_FULL_ACCESS -> 5
  toEnum t = case t of
    0 -> READ_NOTEBOOK
    1 -> MODIFY_NOTEBOOK_PLUS_ACTIVITY
    2 -> READ_NOTEBOOK_PLUS_ACTIVITY
    3 -> GROUP
    4 -> FULL_ACCESS
    5 -> BUSINESS_FULL_ACCESS
    _ -> X.throw T.ThriftException
instance H.Hashable SharedNotebookPrivilegeLevel where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary SharedNotebookPrivilegeLevel where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data SharedNotePrivilegeLevel = READ_NOTE|MODIFY_NOTE|FULL_ACCESS  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum SharedNotePrivilegeLevel where
  fromEnum t = case t of
    READ_NOTE -> 0
    MODIFY_NOTE -> 1
    FULL_ACCESS -> 2
  toEnum t = case t of
    0 -> READ_NOTE
    1 -> MODIFY_NOTE
    2 -> FULL_ACCESS
    _ -> X.throw T.ThriftException
instance H.Hashable SharedNotePrivilegeLevel where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary SharedNotePrivilegeLevel where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data SponsoredGroupRole = GROUP_MEMBER|GROUP_ADMIN|GROUP_OWNER  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum SponsoredGroupRole where
  fromEnum t = case t of
    GROUP_MEMBER -> 1
    GROUP_ADMIN -> 2
    GROUP_OWNER -> 3
  toEnum t = case t of
    1 -> GROUP_MEMBER
    2 -> GROUP_ADMIN
    3 -> GROUP_OWNER
    _ -> X.throw T.ThriftException
instance H.Hashable SponsoredGroupRole where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary SponsoredGroupRole where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data BusinessUserRole = ADMIN|NORMAL  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum BusinessUserRole where
  fromEnum t = case t of
    ADMIN -> 1
    NORMAL -> 2
  toEnum t = case t of
    1 -> ADMIN
    2 -> NORMAL
    _ -> X.throw T.ThriftException
instance H.Hashable BusinessUserRole where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary BusinessUserRole where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data SharedNotebookInstanceRestrictions = ASSIGNED|NO_SHARED_NOTEBOOKS  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum SharedNotebookInstanceRestrictions where
  fromEnum t = case t of
    ASSIGNED -> 1
    NO_SHARED_NOTEBOOKS -> 2
  toEnum t = case t of
    1 -> ASSIGNED
    2 -> NO_SHARED_NOTEBOOKS
    _ -> X.throw T.ThriftException
instance H.Hashable SharedNotebookInstanceRestrictions where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary SharedNotebookInstanceRestrictions where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data ReminderEmailConfig = DO_NOT_SEND|SEND_DAILY_EMAIL  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum ReminderEmailConfig where
  fromEnum t = case t of
    DO_NOT_SEND -> 1
    SEND_DAILY_EMAIL -> 2
  toEnum t = case t of
    1 -> DO_NOT_SEND
    2 -> SEND_DAILY_EMAIL
    _ -> X.throw T.ThriftException
instance H.Hashable ReminderEmailConfig where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary ReminderEmailConfig where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data BusinessInvitationStatus = APPROVED|REQUESTED|REDEEMED  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum BusinessInvitationStatus where
  fromEnum t = case t of
    APPROVED -> 0
    REQUESTED -> 1
    REDEEMED -> 2
  toEnum t = case t of
    0 -> APPROVED
    1 -> REQUESTED
    2 -> REDEEMED
    _ -> X.throw T.ThriftException
instance H.Hashable BusinessInvitationStatus where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary BusinessInvitationStatus where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data ContactType = EVERNOTE|SMS|FACEBOOK|EMAIL|TWITTER|LINKEDIN  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum ContactType where
  fromEnum t = case t of
    EVERNOTE -> 1
    SMS -> 2
    FACEBOOK -> 3
    EMAIL -> 4
    TWITTER -> 5
    LINKEDIN -> 6
  toEnum t = case t of
    1 -> EVERNOTE
    2 -> SMS
    3 -> FACEBOOK
    4 -> EMAIL
    5 -> TWITTER
    6 -> LINKEDIN
    _ -> X.throw T.ThriftException
instance H.Hashable ContactType where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary ContactType where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data RelatedContentType = NEWS_ARTICLE|PROFILE_PERSON|PROFILE_ORGANIZATION|REFERENCE_MATERIAL  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum RelatedContentType where
  fromEnum t = case t of
    NEWS_ARTICLE -> 1
    PROFILE_PERSON -> 2
    PROFILE_ORGANIZATION -> 3
    REFERENCE_MATERIAL -> 4
  toEnum t = case t of
    1 -> NEWS_ARTICLE
    2 -> PROFILE_PERSON
    3 -> PROFILE_ORGANIZATION
    4 -> REFERENCE_MATERIAL
    _ -> X.throw T.ThriftException
instance H.Hashable RelatedContentType where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary RelatedContentType where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data RelatedContentAccess = NOT_ACCESSIBLE|DIRECT_LINK_ACCESS_OK|DIRECT_LINK_LOGIN_REQUIRED|DIRECT_LINK_EMBEDDED_VIEW  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum RelatedContentAccess where
  fromEnum t = case t of
    NOT_ACCESSIBLE -> 0
    DIRECT_LINK_ACCESS_OK -> 1
    DIRECT_LINK_LOGIN_REQUIRED -> 2
    DIRECT_LINK_EMBEDDED_VIEW -> 3
  toEnum t = case t of
    0 -> NOT_ACCESSIBLE
    1 -> DIRECT_LINK_ACCESS_OK
    2 -> DIRECT_LINK_LOGIN_REQUIRED
    3 -> DIRECT_LINK_EMBEDDED_VIEW
    _ -> X.throw T.ThriftException
instance H.Hashable RelatedContentAccess where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary RelatedContentAccess where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data UserIdentityType = EVERNOTE_USERID|EMAIL|IDENTITYID  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum UserIdentityType where
  fromEnum t = case t of
    EVERNOTE_USERID -> 1
    EMAIL -> 2
    IDENTITYID -> 3
  toEnum t = case t of
    1 -> EVERNOTE_USERID
    2 -> EMAIL
    3 -> IDENTITYID
    _ -> X.throw T.ThriftException
instance H.Hashable UserIdentityType where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary UserIdentityType where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
type InvalidationSequenceNumber = I.Int64

type IdentityID = I.Int64

type UserID = I.Int32

type Guid = LT.Text

type Timestamp = I.Int64

type MessageEventID = I.Int64

type MessageThreadID = I.Int64

data Data = Data  { data_bodyHash :: P.Maybe LBS.ByteString
  , data_size :: P.Maybe I.Int32
  , data_body :: P.Maybe LBS.ByteString
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Data where
  hashWithSalt salt record = salt   `H.hashWithSalt` data_bodyHash record   `H.hashWithSalt` data_size record   `H.hashWithSalt` data_body record  
instance QC.Arbitrary Data where 
  arbitrary = M.liftM Data (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_Data = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Data{data_bodyHash = data_bodyHash obj} then P.Nothing else P.Just $ default_Data{data_bodyHash = data_bodyHash obj}
    , if obj == default_Data{data_size = data_size obj} then P.Nothing else P.Just $ default_Data{data_size = data_size obj}
    , if obj == default_Data{data_body = data_body obj} then P.Nothing else P.Just $ default_Data{data_body = data_body obj}
    ]
from_Data :: Data -> T.ThriftVal
from_Data record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2 -> (1, ("bodyHash",T.TBinary _v2))) <$> data_bodyHash record
  , (\_v2 -> (2, ("size",T.TI32 _v2))) <$> data_size record
  , (\_v2 -> (3, ("body",T.TBinary _v2))) <$> data_body record
  ]
write_Data :: T.Protocol p => p -> Data -> P.IO ()
write_Data oprot record = T.writeVal oprot $ from_Data record
encode_Data :: T.StatelessProtocol p => p -> Data -> LBS.ByteString
encode_Data oprot record = T.serializeVal oprot $ from_Data record
to_Data :: T.ThriftVal -> Data
to_Data (T.TStruct fields) = Data{
  data_bodyHash = P.maybe (P.Nothing) (\(_,_val4) -> P.Just (case _val4 of {T.TBinary _val5 -> _val5; T.TString _val5 -> _val5; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  data_size = P.maybe (P.Nothing) (\(_,_val4) -> P.Just (case _val4 of {T.TI32 _val6 -> _val6; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  data_body = P.maybe (P.Nothing) (\(_,_val4) -> P.Just (case _val4 of {T.TBinary _val7 -> _val7; T.TString _val7 -> _val7; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_Data _ = P.error "not a struct"
read_Data :: T.Protocol p => p -> P.IO Data
read_Data iprot = to_Data <$> T.readVal iprot (T.T_STRUCT typemap_Data)
decode_Data :: T.StatelessProtocol p => p -> LBS.ByteString -> Data
decode_Data iprot bs = to_Data $ T.deserializeVal iprot (T.T_STRUCT typemap_Data) bs
typemap_Data :: T.TypeMap
typemap_Data = Map.fromList [(1,("bodyHash",T.T_BINARY)),(2,("size",T.T_I32)),(3,("body",T.T_BINARY))]
default_Data :: Data
default_Data = Data{
  data_bodyHash = P.Nothing,
  data_size = P.Nothing,
  data_body = P.Nothing}
data UserAttributes = UserAttributes  { userAttributes_defaultLocationName :: P.Maybe LT.Text
  , userAttributes_defaultLatitude :: P.Maybe P.Double
  , userAttributes_defaultLongitude :: P.Maybe P.Double
  , userAttributes_preactivation :: P.Maybe P.Bool
  , userAttributes_viewedPromotions :: P.Maybe (Vector.Vector LT.Text)
  , userAttributes_incomingEmailAddress :: P.Maybe LT.Text
  , userAttributes_recentMailedAddresses :: P.Maybe (Vector.Vector LT.Text)
  , userAttributes_comments :: P.Maybe LT.Text
  , userAttributes_dateAgreedToTermsOfService :: P.Maybe I.Int64
  , userAttributes_maxReferrals :: P.Maybe I.Int32
  , userAttributes_referralCount :: P.Maybe I.Int32
  , userAttributes_refererCode :: P.Maybe LT.Text
  , userAttributes_sentEmailDate :: P.Maybe I.Int64
  , userAttributes_sentEmailCount :: P.Maybe I.Int32
  , userAttributes_dailyEmailLimit :: P.Maybe I.Int32
  , userAttributes_emailOptOutDate :: P.Maybe I.Int64
  , userAttributes_partnerEmailOptInDate :: P.Maybe I.Int64
  , userAttributes_preferredLanguage :: P.Maybe LT.Text
  , userAttributes_preferredCountry :: P.Maybe LT.Text
  , userAttributes_clipFullPage :: P.Maybe P.Bool
  , userAttributes_twitterUserName :: P.Maybe LT.Text
  , userAttributes_twitterId :: P.Maybe LT.Text
  , userAttributes_groupName :: P.Maybe LT.Text
  , userAttributes_recognitionLanguage :: P.Maybe LT.Text
  , userAttributes_referralProof :: P.Maybe LT.Text
  , userAttributes_educationalDiscount :: P.Maybe P.Bool
  , userAttributes_businessAddress :: P.Maybe LT.Text
  , userAttributes_hideSponsorBilling :: P.Maybe P.Bool
  , userAttributes_useEmailAutoFiling :: P.Maybe P.Bool
  , userAttributes_reminderEmailConfig :: P.Maybe ReminderEmailConfig
  , userAttributes_emailAddressLastConfirmed :: P.Maybe I.Int64
  , userAttributes_passwordUpdated :: P.Maybe I.Int64
  , userAttributes_salesforcePushEnabled :: P.Maybe P.Bool
  , userAttributes_shouldLogClientEvent :: P.Maybe P.Bool
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UserAttributes where
  hashWithSalt salt record = salt   `H.hashWithSalt` userAttributes_defaultLocationName record   `H.hashWithSalt` userAttributes_defaultLatitude record   `H.hashWithSalt` userAttributes_defaultLongitude record   `H.hashWithSalt` userAttributes_preactivation record   `H.hashWithSalt` userAttributes_viewedPromotions record   `H.hashWithSalt` userAttributes_incomingEmailAddress record   `H.hashWithSalt` userAttributes_recentMailedAddresses record   `H.hashWithSalt` userAttributes_comments record   `H.hashWithSalt` userAttributes_dateAgreedToTermsOfService record   `H.hashWithSalt` userAttributes_maxReferrals record   `H.hashWithSalt` userAttributes_referralCount record   `H.hashWithSalt` userAttributes_refererCode record   `H.hashWithSalt` userAttributes_sentEmailDate record   `H.hashWithSalt` userAttributes_sentEmailCount record   `H.hashWithSalt` userAttributes_dailyEmailLimit record   `H.hashWithSalt` userAttributes_emailOptOutDate record   `H.hashWithSalt` userAttributes_partnerEmailOptInDate record   `H.hashWithSalt` userAttributes_preferredLanguage record   `H.hashWithSalt` userAttributes_preferredCountry record   `H.hashWithSalt` userAttributes_clipFullPage record   `H.hashWithSalt` userAttributes_twitterUserName record   `H.hashWithSalt` userAttributes_twitterId record   `H.hashWithSalt` userAttributes_groupName record   `H.hashWithSalt` userAttributes_recognitionLanguage record   `H.hashWithSalt` userAttributes_referralProof record   `H.hashWithSalt` userAttributes_educationalDiscount record   `H.hashWithSalt` userAttributes_businessAddress record   `H.hashWithSalt` userAttributes_hideSponsorBilling record   `H.hashWithSalt` userAttributes_useEmailAutoFiling record   `H.hashWithSalt` userAttributes_reminderEmailConfig record   `H.hashWithSalt` userAttributes_emailAddressLastConfirmed record   `H.hashWithSalt` userAttributes_passwordUpdated record   `H.hashWithSalt` userAttributes_salesforcePushEnabled record   `H.hashWithSalt` userAttributes_shouldLogClientEvent record  
instance QC.Arbitrary UserAttributes where 
  arbitrary = M.liftM UserAttributes (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_UserAttributes = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UserAttributes{userAttributes_defaultLocationName = userAttributes_defaultLocationName obj} then P.Nothing else P.Just $ default_UserAttributes{userAttributes_defaultLocationName = userAttributes_defaultLocationName obj}
    , if obj == default_UserAttributes{userAttributes_defaultLatitude = userAttributes_defaultLatitude obj} then P.Nothing else P.Just $ default_UserAttributes{userAttributes_defaultLatitude = userAttributes_defaultLatitude obj}
    , if obj == default_UserAttributes{userAttributes_defaultLongitude = userAttributes_defaultLongitude obj} then P.Nothing else P.Just $ default_UserAttributes{userAttributes_defaultLongitude = userAttributes_defaultLongitude obj}
    , if obj == default_UserAttributes{userAttributes_preactivation = userAttributes_preactivation obj} then P.Nothing else P.Just $ default_UserAttributes{userAttributes_preactivation = userAttributes_preactivation obj}
    , if obj == default_UserAttributes{userAttributes_viewedPromotions = userAttributes_viewedPromotions obj} then P.Nothing else P.Just $ default_UserAttributes{userAttributes_viewedPromotions = userAttributes_viewedPromotions obj}
    , if obj == default_UserAttributes{userAttributes_incomingEmailAddress = userAttributes_incomingEmailAddress obj} then P.Nothing else P.Just $ default_UserAttributes{userAttributes_incomingEmailAddress = userAttributes_incomingEmailAddress obj}
    , if obj == default_UserAttributes{userAttributes_recentMailedAddresses = userAttributes_recentMailedAddresses obj} then P.Nothing else P.Just $ default_UserAttributes{userAttributes_recentMailedAddresses = userAttributes_recentMailedAddresses obj}
    , if obj == default_UserAttributes{userAttributes_comments = userAttributes_comments obj} then P.Nothing else P.Just $ default_UserAttributes{userAttributes_comments = userAttributes_comments obj}
    , if obj == default_UserAttributes{userAttributes_dateAgreedToTermsOfService = userAttributes_dateAgreedToTermsOfService obj} then P.Nothing else P.Just $ default_UserAttributes{userAttributes_dateAgreedToTermsOfService = userAttributes_dateAgreedToTermsOfService obj}
    , if obj == default_UserAttributes{userAttributes_maxReferrals = userAttributes_maxReferrals obj} then P.Nothing else P.Just $ default_UserAttributes{userAttributes_maxReferrals = userAttributes_maxReferrals obj}
    , if obj == default_UserAttributes{userAttributes_referralCount = userAttributes_referralCount obj} then P.Nothing else P.Just $ default_UserAttributes{userAttributes_referralCount = userAttributes_referralCount obj}
    , if obj == default_UserAttributes{userAttributes_refererCode = userAttributes_refererCode obj} then P.Nothing else P.Just $ default_UserAttributes{userAttributes_refererCode = userAttributes_refererCode obj}
    , if obj == default_UserAttributes{userAttributes_sentEmailDate = userAttributes_sentEmailDate obj} then P.Nothing else P.Just $ default_UserAttributes{userAttributes_sentEmailDate = userAttributes_sentEmailDate obj}
    , if obj == default_UserAttributes{userAttributes_sentEmailCount = userAttributes_sentEmailCount obj} then P.Nothing else P.Just $ default_UserAttributes{userAttributes_sentEmailCount = userAttributes_sentEmailCount obj}
    , if obj == default_UserAttributes{userAttributes_dailyEmailLimit = userAttributes_dailyEmailLimit obj} then P.Nothing else P.Just $ default_UserAttributes{userAttributes_dailyEmailLimit = userAttributes_dailyEmailLimit obj}
    , if obj == default_UserAttributes{userAttributes_emailOptOutDate = userAttributes_emailOptOutDate obj} then P.Nothing else P.Just $ default_UserAttributes{userAttributes_emailOptOutDate = userAttributes_emailOptOutDate obj}
    , if obj == default_UserAttributes{userAttributes_partnerEmailOptInDate = userAttributes_partnerEmailOptInDate obj} then P.Nothing else P.Just $ default_UserAttributes{userAttributes_partnerEmailOptInDate = userAttributes_partnerEmailOptInDate obj}
    , if obj == default_UserAttributes{userAttributes_preferredLanguage = userAttributes_preferredLanguage obj} then P.Nothing else P.Just $ default_UserAttributes{userAttributes_preferredLanguage = userAttributes_preferredLanguage obj}
    , if obj == default_UserAttributes{userAttributes_preferredCountry = userAttributes_preferredCountry obj} then P.Nothing else P.Just $ default_UserAttributes{userAttributes_preferredCountry = userAttributes_preferredCountry obj}
    , if obj == default_UserAttributes{userAttributes_clipFullPage = userAttributes_clipFullPage obj} then P.Nothing else P.Just $ default_UserAttributes{userAttributes_clipFullPage = userAttributes_clipFullPage obj}
    , if obj == default_UserAttributes{userAttributes_twitterUserName = userAttributes_twitterUserName obj} then P.Nothing else P.Just $ default_UserAttributes{userAttributes_twitterUserName = userAttributes_twitterUserName obj}
    , if obj == default_UserAttributes{userAttributes_twitterId = userAttributes_twitterId obj} then P.Nothing else P.Just $ default_UserAttributes{userAttributes_twitterId = userAttributes_twitterId obj}
    , if obj == default_UserAttributes{userAttributes_groupName = userAttributes_groupName obj} then P.Nothing else P.Just $ default_UserAttributes{userAttributes_groupName = userAttributes_groupName obj}
    , if obj == default_UserAttributes{userAttributes_recognitionLanguage = userAttributes_recognitionLanguage obj} then P.Nothing else P.Just $ default_UserAttributes{userAttributes_recognitionLanguage = userAttributes_recognitionLanguage obj}
    , if obj == default_UserAttributes{userAttributes_referralProof = userAttributes_referralProof obj} then P.Nothing else P.Just $ default_UserAttributes{userAttributes_referralProof = userAttributes_referralProof obj}
    , if obj == default_UserAttributes{userAttributes_educationalDiscount = userAttributes_educationalDiscount obj} then P.Nothing else P.Just $ default_UserAttributes{userAttributes_educationalDiscount = userAttributes_educationalDiscount obj}
    , if obj == default_UserAttributes{userAttributes_businessAddress = userAttributes_businessAddress obj} then P.Nothing else P.Just $ default_UserAttributes{userAttributes_businessAddress = userAttributes_businessAddress obj}
    , if obj == default_UserAttributes{userAttributes_hideSponsorBilling = userAttributes_hideSponsorBilling obj} then P.Nothing else P.Just $ default_UserAttributes{userAttributes_hideSponsorBilling = userAttributes_hideSponsorBilling obj}
    , if obj == default_UserAttributes{userAttributes_useEmailAutoFiling = userAttributes_useEmailAutoFiling obj} then P.Nothing else P.Just $ default_UserAttributes{userAttributes_useEmailAutoFiling = userAttributes_useEmailAutoFiling obj}
    , if obj == default_UserAttributes{userAttributes_reminderEmailConfig = userAttributes_reminderEmailConfig obj} then P.Nothing else P.Just $ default_UserAttributes{userAttributes_reminderEmailConfig = userAttributes_reminderEmailConfig obj}
    , if obj == default_UserAttributes{userAttributes_emailAddressLastConfirmed = userAttributes_emailAddressLastConfirmed obj} then P.Nothing else P.Just $ default_UserAttributes{userAttributes_emailAddressLastConfirmed = userAttributes_emailAddressLastConfirmed obj}
    , if obj == default_UserAttributes{userAttributes_passwordUpdated = userAttributes_passwordUpdated obj} then P.Nothing else P.Just $ default_UserAttributes{userAttributes_passwordUpdated = userAttributes_passwordUpdated obj}
    , if obj == default_UserAttributes{userAttributes_salesforcePushEnabled = userAttributes_salesforcePushEnabled obj} then P.Nothing else P.Just $ default_UserAttributes{userAttributes_salesforcePushEnabled = userAttributes_salesforcePushEnabled obj}
    , if obj == default_UserAttributes{userAttributes_shouldLogClientEvent = userAttributes_shouldLogClientEvent obj} then P.Nothing else P.Just $ default_UserAttributes{userAttributes_shouldLogClientEvent = userAttributes_shouldLogClientEvent obj}
    ]
from_UserAttributes :: UserAttributes -> T.ThriftVal
from_UserAttributes record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v10 -> (1, ("defaultLocationName",T.TString $ E.encodeUtf8 _v10))) <$> userAttributes_defaultLocationName record
  , (\_v10 -> (2, ("defaultLatitude",T.TDouble _v10))) <$> userAttributes_defaultLatitude record
  , (\_v10 -> (3, ("defaultLongitude",T.TDouble _v10))) <$> userAttributes_defaultLongitude record
  , (\_v10 -> (4, ("preactivation",T.TBool _v10))) <$> userAttributes_preactivation record
  , (\_v10 -> (5, ("viewedPromotions",T.TList T.T_STRING $ P.map (\_v12 -> T.TString $ E.encodeUtf8 _v12) $ Vector.toList _v10))) <$> userAttributes_viewedPromotions record
  , (\_v10 -> (6, ("incomingEmailAddress",T.TString $ E.encodeUtf8 _v10))) <$> userAttributes_incomingEmailAddress record
  , (\_v10 -> (7, ("recentMailedAddresses",T.TList T.T_STRING $ P.map (\_v14 -> T.TString $ E.encodeUtf8 _v14) $ Vector.toList _v10))) <$> userAttributes_recentMailedAddresses record
  , (\_v10 -> (9, ("comments",T.TString $ E.encodeUtf8 _v10))) <$> userAttributes_comments record
  , (\_v10 -> (11, ("dateAgreedToTermsOfService",T.TI64 _v10))) <$> userAttributes_dateAgreedToTermsOfService record
  , (\_v10 -> (12, ("maxReferrals",T.TI32 _v10))) <$> userAttributes_maxReferrals record
  , (\_v10 -> (13, ("referralCount",T.TI32 _v10))) <$> userAttributes_referralCount record
  , (\_v10 -> (14, ("refererCode",T.TString $ E.encodeUtf8 _v10))) <$> userAttributes_refererCode record
  , (\_v10 -> (15, ("sentEmailDate",T.TI64 _v10))) <$> userAttributes_sentEmailDate record
  , (\_v10 -> (16, ("sentEmailCount",T.TI32 _v10))) <$> userAttributes_sentEmailCount record
  , (\_v10 -> (17, ("dailyEmailLimit",T.TI32 _v10))) <$> userAttributes_dailyEmailLimit record
  , (\_v10 -> (18, ("emailOptOutDate",T.TI64 _v10))) <$> userAttributes_emailOptOutDate record
  , (\_v10 -> (19, ("partnerEmailOptInDate",T.TI64 _v10))) <$> userAttributes_partnerEmailOptInDate record
  , (\_v10 -> (20, ("preferredLanguage",T.TString $ E.encodeUtf8 _v10))) <$> userAttributes_preferredLanguage record
  , (\_v10 -> (21, ("preferredCountry",T.TString $ E.encodeUtf8 _v10))) <$> userAttributes_preferredCountry record
  , (\_v10 -> (22, ("clipFullPage",T.TBool _v10))) <$> userAttributes_clipFullPage record
  , (\_v10 -> (23, ("twitterUserName",T.TString $ E.encodeUtf8 _v10))) <$> userAttributes_twitterUserName record
  , (\_v10 -> (24, ("twitterId",T.TString $ E.encodeUtf8 _v10))) <$> userAttributes_twitterId record
  , (\_v10 -> (25, ("groupName",T.TString $ E.encodeUtf8 _v10))) <$> userAttributes_groupName record
  , (\_v10 -> (26, ("recognitionLanguage",T.TString $ E.encodeUtf8 _v10))) <$> userAttributes_recognitionLanguage record
  , (\_v10 -> (28, ("referralProof",T.TString $ E.encodeUtf8 _v10))) <$> userAttributes_referralProof record
  , (\_v10 -> (29, ("educationalDiscount",T.TBool _v10))) <$> userAttributes_educationalDiscount record
  , (\_v10 -> (30, ("businessAddress",T.TString $ E.encodeUtf8 _v10))) <$> userAttributes_businessAddress record
  , (\_v10 -> (31, ("hideSponsorBilling",T.TBool _v10))) <$> userAttributes_hideSponsorBilling record
  , (\_v10 -> (33, ("useEmailAutoFiling",T.TBool _v10))) <$> userAttributes_useEmailAutoFiling record
  , (\_v10 -> (34, ("reminderEmailConfig",T.TI32 $ P.fromIntegral $ P.fromEnum _v10))) <$> userAttributes_reminderEmailConfig record
  , (\_v10 -> (35, ("emailAddressLastConfirmed",T.TI64 _v10))) <$> userAttributes_emailAddressLastConfirmed record
  , (\_v10 -> (36, ("passwordUpdated",T.TI64 _v10))) <$> userAttributes_passwordUpdated record
  , (\_v10 -> (37, ("salesforcePushEnabled",T.TBool _v10))) <$> userAttributes_salesforcePushEnabled record
  , (\_v10 -> (38, ("shouldLogClientEvent",T.TBool _v10))) <$> userAttributes_shouldLogClientEvent record
  ]
write_UserAttributes :: T.Protocol p => p -> UserAttributes -> P.IO ()
write_UserAttributes oprot record = T.writeVal oprot $ from_UserAttributes record
encode_UserAttributes :: T.StatelessProtocol p => p -> UserAttributes -> LBS.ByteString
encode_UserAttributes oprot record = T.serializeVal oprot $ from_UserAttributes record
to_UserAttributes :: T.ThriftVal -> UserAttributes
to_UserAttributes (T.TStruct fields) = UserAttributes{
  userAttributes_defaultLocationName = P.maybe (P.Nothing) (\(_,_val16) -> P.Just (case _val16 of {T.TString _val17 -> E.decodeUtf8 _val17; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  userAttributes_defaultLatitude = P.maybe (P.Nothing) (\(_,_val16) -> P.Just (case _val16 of {T.TDouble _val18 -> _val18; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  userAttributes_defaultLongitude = P.maybe (P.Nothing) (\(_,_val16) -> P.Just (case _val16 of {T.TDouble _val19 -> _val19; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  userAttributes_preactivation = P.maybe (P.Nothing) (\(_,_val16) -> P.Just (case _val16 of {T.TBool _val20 -> _val20; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  userAttributes_viewedPromotions = P.maybe (P.Nothing) (\(_,_val16) -> P.Just (case _val16 of {T.TList _ _val21 -> (Vector.fromList $ P.map (\_v22 -> (case _v22 of {T.TString _val23 -> E.decodeUtf8 _val23; _ -> P.error "wrong type"})) _val21); _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  userAttributes_incomingEmailAddress = P.maybe (P.Nothing) (\(_,_val16) -> P.Just (case _val16 of {T.TString _val24 -> E.decodeUtf8 _val24; _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  userAttributes_recentMailedAddresses = P.maybe (P.Nothing) (\(_,_val16) -> P.Just (case _val16 of {T.TList _ _val25 -> (Vector.fromList $ P.map (\_v26 -> (case _v26 of {T.TString _val27 -> E.decodeUtf8 _val27; _ -> P.error "wrong type"})) _val25); _ -> P.error "wrong type"})) (Map.lookup (7) fields),
  userAttributes_comments = P.maybe (P.Nothing) (\(_,_val16) -> P.Just (case _val16 of {T.TString _val28 -> E.decodeUtf8 _val28; _ -> P.error "wrong type"})) (Map.lookup (9) fields),
  userAttributes_dateAgreedToTermsOfService = P.maybe (P.Nothing) (\(_,_val16) -> P.Just (case _val16 of {T.TI64 _val29 -> _val29; _ -> P.error "wrong type"})) (Map.lookup (11) fields),
  userAttributes_maxReferrals = P.maybe (P.Nothing) (\(_,_val16) -> P.Just (case _val16 of {T.TI32 _val30 -> _val30; _ -> P.error "wrong type"})) (Map.lookup (12) fields),
  userAttributes_referralCount = P.maybe (P.Nothing) (\(_,_val16) -> P.Just (case _val16 of {T.TI32 _val31 -> _val31; _ -> P.error "wrong type"})) (Map.lookup (13) fields),
  userAttributes_refererCode = P.maybe (P.Nothing) (\(_,_val16) -> P.Just (case _val16 of {T.TString _val32 -> E.decodeUtf8 _val32; _ -> P.error "wrong type"})) (Map.lookup (14) fields),
  userAttributes_sentEmailDate = P.maybe (P.Nothing) (\(_,_val16) -> P.Just (case _val16 of {T.TI64 _val33 -> _val33; _ -> P.error "wrong type"})) (Map.lookup (15) fields),
  userAttributes_sentEmailCount = P.maybe (P.Nothing) (\(_,_val16) -> P.Just (case _val16 of {T.TI32 _val34 -> _val34; _ -> P.error "wrong type"})) (Map.lookup (16) fields),
  userAttributes_dailyEmailLimit = P.maybe (P.Nothing) (\(_,_val16) -> P.Just (case _val16 of {T.TI32 _val35 -> _val35; _ -> P.error "wrong type"})) (Map.lookup (17) fields),
  userAttributes_emailOptOutDate = P.maybe (P.Nothing) (\(_,_val16) -> P.Just (case _val16 of {T.TI64 _val36 -> _val36; _ -> P.error "wrong type"})) (Map.lookup (18) fields),
  userAttributes_partnerEmailOptInDate = P.maybe (P.Nothing) (\(_,_val16) -> P.Just (case _val16 of {T.TI64 _val37 -> _val37; _ -> P.error "wrong type"})) (Map.lookup (19) fields),
  userAttributes_preferredLanguage = P.maybe (P.Nothing) (\(_,_val16) -> P.Just (case _val16 of {T.TString _val38 -> E.decodeUtf8 _val38; _ -> P.error "wrong type"})) (Map.lookup (20) fields),
  userAttributes_preferredCountry = P.maybe (P.Nothing) (\(_,_val16) -> P.Just (case _val16 of {T.TString _val39 -> E.decodeUtf8 _val39; _ -> P.error "wrong type"})) (Map.lookup (21) fields),
  userAttributes_clipFullPage = P.maybe (P.Nothing) (\(_,_val16) -> P.Just (case _val16 of {T.TBool _val40 -> _val40; _ -> P.error "wrong type"})) (Map.lookup (22) fields),
  userAttributes_twitterUserName = P.maybe (P.Nothing) (\(_,_val16) -> P.Just (case _val16 of {T.TString _val41 -> E.decodeUtf8 _val41; _ -> P.error "wrong type"})) (Map.lookup (23) fields),
  userAttributes_twitterId = P.maybe (P.Nothing) (\(_,_val16) -> P.Just (case _val16 of {T.TString _val42 -> E.decodeUtf8 _val42; _ -> P.error "wrong type"})) (Map.lookup (24) fields),
  userAttributes_groupName = P.maybe (P.Nothing) (\(_,_val16) -> P.Just (case _val16 of {T.TString _val43 -> E.decodeUtf8 _val43; _ -> P.error "wrong type"})) (Map.lookup (25) fields),
  userAttributes_recognitionLanguage = P.maybe (P.Nothing) (\(_,_val16) -> P.Just (case _val16 of {T.TString _val44 -> E.decodeUtf8 _val44; _ -> P.error "wrong type"})) (Map.lookup (26) fields),
  userAttributes_referralProof = P.maybe (P.Nothing) (\(_,_val16) -> P.Just (case _val16 of {T.TString _val45 -> E.decodeUtf8 _val45; _ -> P.error "wrong type"})) (Map.lookup (28) fields),
  userAttributes_educationalDiscount = P.maybe (P.Nothing) (\(_,_val16) -> P.Just (case _val16 of {T.TBool _val46 -> _val46; _ -> P.error "wrong type"})) (Map.lookup (29) fields),
  userAttributes_businessAddress = P.maybe (P.Nothing) (\(_,_val16) -> P.Just (case _val16 of {T.TString _val47 -> E.decodeUtf8 _val47; _ -> P.error "wrong type"})) (Map.lookup (30) fields),
  userAttributes_hideSponsorBilling = P.maybe (P.Nothing) (\(_,_val16) -> P.Just (case _val16 of {T.TBool _val48 -> _val48; _ -> P.error "wrong type"})) (Map.lookup (31) fields),
  userAttributes_useEmailAutoFiling = P.maybe (P.Nothing) (\(_,_val16) -> P.Just (case _val16 of {T.TBool _val49 -> _val49; _ -> P.error "wrong type"})) (Map.lookup (33) fields),
  userAttributes_reminderEmailConfig = P.maybe (P.Nothing) (\(_,_val16) -> P.Just (case _val16 of {T.TI32 _val50 -> P.toEnum $ P.fromIntegral _val50; _ -> P.error "wrong type"})) (Map.lookup (34) fields),
  userAttributes_emailAddressLastConfirmed = P.maybe (P.Nothing) (\(_,_val16) -> P.Just (case _val16 of {T.TI64 _val51 -> _val51; _ -> P.error "wrong type"})) (Map.lookup (35) fields),
  userAttributes_passwordUpdated = P.maybe (P.Nothing) (\(_,_val16) -> P.Just (case _val16 of {T.TI64 _val52 -> _val52; _ -> P.error "wrong type"})) (Map.lookup (36) fields),
  userAttributes_salesforcePushEnabled = P.maybe (P.Nothing) (\(_,_val16) -> P.Just (case _val16 of {T.TBool _val53 -> _val53; _ -> P.error "wrong type"})) (Map.lookup (37) fields),
  userAttributes_shouldLogClientEvent = P.maybe (P.Nothing) (\(_,_val16) -> P.Just (case _val16 of {T.TBool _val54 -> _val54; _ -> P.error "wrong type"})) (Map.lookup (38) fields)
  }
to_UserAttributes _ = P.error "not a struct"
read_UserAttributes :: T.Protocol p => p -> P.IO UserAttributes
read_UserAttributes iprot = to_UserAttributes <$> T.readVal iprot (T.T_STRUCT typemap_UserAttributes)
decode_UserAttributes :: T.StatelessProtocol p => p -> LBS.ByteString -> UserAttributes
decode_UserAttributes iprot bs = to_UserAttributes $ T.deserializeVal iprot (T.T_STRUCT typemap_UserAttributes) bs
typemap_UserAttributes :: T.TypeMap
typemap_UserAttributes = Map.fromList [(1,("defaultLocationName",T.T_STRING)),(2,("defaultLatitude",T.T_DOUBLE)),(3,("defaultLongitude",T.T_DOUBLE)),(4,("preactivation",T.T_BOOL)),(5,("viewedPromotions",(T.T_LIST T.T_STRING))),(6,("incomingEmailAddress",T.T_STRING)),(7,("recentMailedAddresses",(T.T_LIST T.T_STRING))),(9,("comments",T.T_STRING)),(11,("dateAgreedToTermsOfService",T.T_I64)),(12,("maxReferrals",T.T_I32)),(13,("referralCount",T.T_I32)),(14,("refererCode",T.T_STRING)),(15,("sentEmailDate",T.T_I64)),(16,("sentEmailCount",T.T_I32)),(17,("dailyEmailLimit",T.T_I32)),(18,("emailOptOutDate",T.T_I64)),(19,("partnerEmailOptInDate",T.T_I64)),(20,("preferredLanguage",T.T_STRING)),(21,("preferredCountry",T.T_STRING)),(22,("clipFullPage",T.T_BOOL)),(23,("twitterUserName",T.T_STRING)),(24,("twitterId",T.T_STRING)),(25,("groupName",T.T_STRING)),(26,("recognitionLanguage",T.T_STRING)),(28,("referralProof",T.T_STRING)),(29,("educationalDiscount",T.T_BOOL)),(30,("businessAddress",T.T_STRING)),(31,("hideSponsorBilling",T.T_BOOL)),(33,("useEmailAutoFiling",T.T_BOOL)),(34,("reminderEmailConfig",T.T_I32)),(35,("emailAddressLastConfirmed",T.T_I64)),(36,("passwordUpdated",T.T_I64)),(37,("salesforcePushEnabled",T.T_BOOL)),(38,("shouldLogClientEvent",T.T_BOOL))]
default_UserAttributes :: UserAttributes
default_UserAttributes = UserAttributes{
  userAttributes_defaultLocationName = P.Nothing,
  userAttributes_defaultLatitude = P.Nothing,
  userAttributes_defaultLongitude = P.Nothing,
  userAttributes_preactivation = P.Nothing,
  userAttributes_viewedPromotions = P.Nothing,
  userAttributes_incomingEmailAddress = P.Nothing,
  userAttributes_recentMailedAddresses = P.Nothing,
  userAttributes_comments = P.Nothing,
  userAttributes_dateAgreedToTermsOfService = P.Nothing,
  userAttributes_maxReferrals = P.Nothing,
  userAttributes_referralCount = P.Nothing,
  userAttributes_refererCode = P.Nothing,
  userAttributes_sentEmailDate = P.Nothing,
  userAttributes_sentEmailCount = P.Nothing,
  userAttributes_dailyEmailLimit = P.Nothing,
  userAttributes_emailOptOutDate = P.Nothing,
  userAttributes_partnerEmailOptInDate = P.Nothing,
  userAttributes_preferredLanguage = P.Nothing,
  userAttributes_preferredCountry = P.Nothing,
  userAttributes_clipFullPage = P.Nothing,
  userAttributes_twitterUserName = P.Nothing,
  userAttributes_twitterId = P.Nothing,
  userAttributes_groupName = P.Nothing,
  userAttributes_recognitionLanguage = P.Nothing,
  userAttributes_referralProof = P.Nothing,
  userAttributes_educationalDiscount = P.Nothing,
  userAttributes_businessAddress = P.Nothing,
  userAttributes_hideSponsorBilling = P.Nothing,
  userAttributes_useEmailAutoFiling = P.Nothing,
  userAttributes_reminderEmailConfig = P.Nothing,
  userAttributes_emailAddressLastConfirmed = P.Nothing,
  userAttributes_passwordUpdated = P.Nothing,
  userAttributes_salesforcePushEnabled = P.Nothing,
  userAttributes_shouldLogClientEvent = P.Nothing}
data BusinessUserAttributes = BusinessUserAttributes  { businessUserAttributes_title :: P.Maybe LT.Text
  , businessUserAttributes_location :: P.Maybe LT.Text
  , businessUserAttributes_department :: P.Maybe LT.Text
  , businessUserAttributes_mobilePhone :: P.Maybe LT.Text
  , businessUserAttributes_linkedInProfileUrl :: P.Maybe LT.Text
  , businessUserAttributes_workPhone :: P.Maybe LT.Text
  , businessUserAttributes_companyStartDate :: P.Maybe I.Int64
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable BusinessUserAttributes where
  hashWithSalt salt record = salt   `H.hashWithSalt` businessUserAttributes_title record   `H.hashWithSalt` businessUserAttributes_location record   `H.hashWithSalt` businessUserAttributes_department record   `H.hashWithSalt` businessUserAttributes_mobilePhone record   `H.hashWithSalt` businessUserAttributes_linkedInProfileUrl record   `H.hashWithSalt` businessUserAttributes_workPhone record   `H.hashWithSalt` businessUserAttributes_companyStartDate record  
instance QC.Arbitrary BusinessUserAttributes where 
  arbitrary = M.liftM BusinessUserAttributes (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_BusinessUserAttributes = []
             | P.otherwise = M.catMaybes
    [ if obj == default_BusinessUserAttributes{businessUserAttributes_title = businessUserAttributes_title obj} then P.Nothing else P.Just $ default_BusinessUserAttributes{businessUserAttributes_title = businessUserAttributes_title obj}
    , if obj == default_BusinessUserAttributes{businessUserAttributes_location = businessUserAttributes_location obj} then P.Nothing else P.Just $ default_BusinessUserAttributes{businessUserAttributes_location = businessUserAttributes_location obj}
    , if obj == default_BusinessUserAttributes{businessUserAttributes_department = businessUserAttributes_department obj} then P.Nothing else P.Just $ default_BusinessUserAttributes{businessUserAttributes_department = businessUserAttributes_department obj}
    , if obj == default_BusinessUserAttributes{businessUserAttributes_mobilePhone = businessUserAttributes_mobilePhone obj} then P.Nothing else P.Just $ default_BusinessUserAttributes{businessUserAttributes_mobilePhone = businessUserAttributes_mobilePhone obj}
    , if obj == default_BusinessUserAttributes{businessUserAttributes_linkedInProfileUrl = businessUserAttributes_linkedInProfileUrl obj} then P.Nothing else P.Just $ default_BusinessUserAttributes{businessUserAttributes_linkedInProfileUrl = businessUserAttributes_linkedInProfileUrl obj}
    , if obj == default_BusinessUserAttributes{businessUserAttributes_workPhone = businessUserAttributes_workPhone obj} then P.Nothing else P.Just $ default_BusinessUserAttributes{businessUserAttributes_workPhone = businessUserAttributes_workPhone obj}
    , if obj == default_BusinessUserAttributes{businessUserAttributes_companyStartDate = businessUserAttributes_companyStartDate obj} then P.Nothing else P.Just $ default_BusinessUserAttributes{businessUserAttributes_companyStartDate = businessUserAttributes_companyStartDate obj}
    ]
from_BusinessUserAttributes :: BusinessUserAttributes -> T.ThriftVal
from_BusinessUserAttributes record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v57 -> (1, ("title",T.TString $ E.encodeUtf8 _v57))) <$> businessUserAttributes_title record
  , (\_v57 -> (2, ("location",T.TString $ E.encodeUtf8 _v57))) <$> businessUserAttributes_location record
  , (\_v57 -> (3, ("department",T.TString $ E.encodeUtf8 _v57))) <$> businessUserAttributes_department record
  , (\_v57 -> (4, ("mobilePhone",T.TString $ E.encodeUtf8 _v57))) <$> businessUserAttributes_mobilePhone record
  , (\_v57 -> (5, ("linkedInProfileUrl",T.TString $ E.encodeUtf8 _v57))) <$> businessUserAttributes_linkedInProfileUrl record
  , (\_v57 -> (6, ("workPhone",T.TString $ E.encodeUtf8 _v57))) <$> businessUserAttributes_workPhone record
  , (\_v57 -> (7, ("companyStartDate",T.TI64 _v57))) <$> businessUserAttributes_companyStartDate record
  ]
write_BusinessUserAttributes :: T.Protocol p => p -> BusinessUserAttributes -> P.IO ()
write_BusinessUserAttributes oprot record = T.writeVal oprot $ from_BusinessUserAttributes record
encode_BusinessUserAttributes :: T.StatelessProtocol p => p -> BusinessUserAttributes -> LBS.ByteString
encode_BusinessUserAttributes oprot record = T.serializeVal oprot $ from_BusinessUserAttributes record
to_BusinessUserAttributes :: T.ThriftVal -> BusinessUserAttributes
to_BusinessUserAttributes (T.TStruct fields) = BusinessUserAttributes{
  businessUserAttributes_title = P.maybe (P.Nothing) (\(_,_val59) -> P.Just (case _val59 of {T.TString _val60 -> E.decodeUtf8 _val60; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  businessUserAttributes_location = P.maybe (P.Nothing) (\(_,_val59) -> P.Just (case _val59 of {T.TString _val61 -> E.decodeUtf8 _val61; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  businessUserAttributes_department = P.maybe (P.Nothing) (\(_,_val59) -> P.Just (case _val59 of {T.TString _val62 -> E.decodeUtf8 _val62; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  businessUserAttributes_mobilePhone = P.maybe (P.Nothing) (\(_,_val59) -> P.Just (case _val59 of {T.TString _val63 -> E.decodeUtf8 _val63; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  businessUserAttributes_linkedInProfileUrl = P.maybe (P.Nothing) (\(_,_val59) -> P.Just (case _val59 of {T.TString _val64 -> E.decodeUtf8 _val64; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  businessUserAttributes_workPhone = P.maybe (P.Nothing) (\(_,_val59) -> P.Just (case _val59 of {T.TString _val65 -> E.decodeUtf8 _val65; _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  businessUserAttributes_companyStartDate = P.maybe (P.Nothing) (\(_,_val59) -> P.Just (case _val59 of {T.TI64 _val66 -> _val66; _ -> P.error "wrong type"})) (Map.lookup (7) fields)
  }
to_BusinessUserAttributes _ = P.error "not a struct"
read_BusinessUserAttributes :: T.Protocol p => p -> P.IO BusinessUserAttributes
read_BusinessUserAttributes iprot = to_BusinessUserAttributes <$> T.readVal iprot (T.T_STRUCT typemap_BusinessUserAttributes)
decode_BusinessUserAttributes :: T.StatelessProtocol p => p -> LBS.ByteString -> BusinessUserAttributes
decode_BusinessUserAttributes iprot bs = to_BusinessUserAttributes $ T.deserializeVal iprot (T.T_STRUCT typemap_BusinessUserAttributes) bs
typemap_BusinessUserAttributes :: T.TypeMap
typemap_BusinessUserAttributes = Map.fromList [(1,("title",T.T_STRING)),(2,("location",T.T_STRING)),(3,("department",T.T_STRING)),(4,("mobilePhone",T.T_STRING)),(5,("linkedInProfileUrl",T.T_STRING)),(6,("workPhone",T.T_STRING)),(7,("companyStartDate",T.T_I64))]
default_BusinessUserAttributes :: BusinessUserAttributes
default_BusinessUserAttributes = BusinessUserAttributes{
  businessUserAttributes_title = P.Nothing,
  businessUserAttributes_location = P.Nothing,
  businessUserAttributes_department = P.Nothing,
  businessUserAttributes_mobilePhone = P.Nothing,
  businessUserAttributes_linkedInProfileUrl = P.Nothing,
  businessUserAttributes_workPhone = P.Nothing,
  businessUserAttributes_companyStartDate = P.Nothing}
data Accounting = Accounting  { accounting_uploadLimitEnd :: P.Maybe I.Int64
  , accounting_uploadLimitNextMonth :: P.Maybe I.Int64
  , accounting_premiumServiceStatus :: P.Maybe PremiumOrderStatus
  , accounting_premiumOrderNumber :: P.Maybe LT.Text
  , accounting_premiumCommerceService :: P.Maybe LT.Text
  , accounting_premiumServiceStart :: P.Maybe I.Int64
  , accounting_premiumServiceSKU :: P.Maybe LT.Text
  , accounting_lastSuccessfulCharge :: P.Maybe I.Int64
  , accounting_lastFailedCharge :: P.Maybe I.Int64
  , accounting_lastFailedChargeReason :: P.Maybe LT.Text
  , accounting_nextPaymentDue :: P.Maybe I.Int64
  , accounting_premiumLockUntil :: P.Maybe I.Int64
  , accounting_updated :: P.Maybe I.Int64
  , accounting_premiumSubscriptionNumber :: P.Maybe LT.Text
  , accounting_lastRequestedCharge :: P.Maybe I.Int64
  , accounting_currency :: P.Maybe LT.Text
  , accounting_unitPrice :: P.Maybe I.Int32
  , accounting_businessId :: P.Maybe I.Int32
  , accounting_businessName :: P.Maybe LT.Text
  , accounting_businessRole :: P.Maybe BusinessUserRole
  , accounting_unitDiscount :: P.Maybe I.Int32
  , accounting_nextChargeDate :: P.Maybe I.Int64
  , accounting_availablePoints :: P.Maybe I.Int32
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Accounting where
  hashWithSalt salt record = salt   `H.hashWithSalt` accounting_uploadLimitEnd record   `H.hashWithSalt` accounting_uploadLimitNextMonth record   `H.hashWithSalt` accounting_premiumServiceStatus record   `H.hashWithSalt` accounting_premiumOrderNumber record   `H.hashWithSalt` accounting_premiumCommerceService record   `H.hashWithSalt` accounting_premiumServiceStart record   `H.hashWithSalt` accounting_premiumServiceSKU record   `H.hashWithSalt` accounting_lastSuccessfulCharge record   `H.hashWithSalt` accounting_lastFailedCharge record   `H.hashWithSalt` accounting_lastFailedChargeReason record   `H.hashWithSalt` accounting_nextPaymentDue record   `H.hashWithSalt` accounting_premiumLockUntil record   `H.hashWithSalt` accounting_updated record   `H.hashWithSalt` accounting_premiumSubscriptionNumber record   `H.hashWithSalt` accounting_lastRequestedCharge record   `H.hashWithSalt` accounting_currency record   `H.hashWithSalt` accounting_unitPrice record   `H.hashWithSalt` accounting_businessId record   `H.hashWithSalt` accounting_businessName record   `H.hashWithSalt` accounting_businessRole record   `H.hashWithSalt` accounting_unitDiscount record   `H.hashWithSalt` accounting_nextChargeDate record   `H.hashWithSalt` accounting_availablePoints record  
instance QC.Arbitrary Accounting where 
  arbitrary = M.liftM Accounting (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_Accounting = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Accounting{accounting_uploadLimitEnd = accounting_uploadLimitEnd obj} then P.Nothing else P.Just $ default_Accounting{accounting_uploadLimitEnd = accounting_uploadLimitEnd obj}
    , if obj == default_Accounting{accounting_uploadLimitNextMonth = accounting_uploadLimitNextMonth obj} then P.Nothing else P.Just $ default_Accounting{accounting_uploadLimitNextMonth = accounting_uploadLimitNextMonth obj}
    , if obj == default_Accounting{accounting_premiumServiceStatus = accounting_premiumServiceStatus obj} then P.Nothing else P.Just $ default_Accounting{accounting_premiumServiceStatus = accounting_premiumServiceStatus obj}
    , if obj == default_Accounting{accounting_premiumOrderNumber = accounting_premiumOrderNumber obj} then P.Nothing else P.Just $ default_Accounting{accounting_premiumOrderNumber = accounting_premiumOrderNumber obj}
    , if obj == default_Accounting{accounting_premiumCommerceService = accounting_premiumCommerceService obj} then P.Nothing else P.Just $ default_Accounting{accounting_premiumCommerceService = accounting_premiumCommerceService obj}
    , if obj == default_Accounting{accounting_premiumServiceStart = accounting_premiumServiceStart obj} then P.Nothing else P.Just $ default_Accounting{accounting_premiumServiceStart = accounting_premiumServiceStart obj}
    , if obj == default_Accounting{accounting_premiumServiceSKU = accounting_premiumServiceSKU obj} then P.Nothing else P.Just $ default_Accounting{accounting_premiumServiceSKU = accounting_premiumServiceSKU obj}
    , if obj == default_Accounting{accounting_lastSuccessfulCharge = accounting_lastSuccessfulCharge obj} then P.Nothing else P.Just $ default_Accounting{accounting_lastSuccessfulCharge = accounting_lastSuccessfulCharge obj}
    , if obj == default_Accounting{accounting_lastFailedCharge = accounting_lastFailedCharge obj} then P.Nothing else P.Just $ default_Accounting{accounting_lastFailedCharge = accounting_lastFailedCharge obj}
    , if obj == default_Accounting{accounting_lastFailedChargeReason = accounting_lastFailedChargeReason obj} then P.Nothing else P.Just $ default_Accounting{accounting_lastFailedChargeReason = accounting_lastFailedChargeReason obj}
    , if obj == default_Accounting{accounting_nextPaymentDue = accounting_nextPaymentDue obj} then P.Nothing else P.Just $ default_Accounting{accounting_nextPaymentDue = accounting_nextPaymentDue obj}
    , if obj == default_Accounting{accounting_premiumLockUntil = accounting_premiumLockUntil obj} then P.Nothing else P.Just $ default_Accounting{accounting_premiumLockUntil = accounting_premiumLockUntil obj}
    , if obj == default_Accounting{accounting_updated = accounting_updated obj} then P.Nothing else P.Just $ default_Accounting{accounting_updated = accounting_updated obj}
    , if obj == default_Accounting{accounting_premiumSubscriptionNumber = accounting_premiumSubscriptionNumber obj} then P.Nothing else P.Just $ default_Accounting{accounting_premiumSubscriptionNumber = accounting_premiumSubscriptionNumber obj}
    , if obj == default_Accounting{accounting_lastRequestedCharge = accounting_lastRequestedCharge obj} then P.Nothing else P.Just $ default_Accounting{accounting_lastRequestedCharge = accounting_lastRequestedCharge obj}
    , if obj == default_Accounting{accounting_currency = accounting_currency obj} then P.Nothing else P.Just $ default_Accounting{accounting_currency = accounting_currency obj}
    , if obj == default_Accounting{accounting_unitPrice = accounting_unitPrice obj} then P.Nothing else P.Just $ default_Accounting{accounting_unitPrice = accounting_unitPrice obj}
    , if obj == default_Accounting{accounting_businessId = accounting_businessId obj} then P.Nothing else P.Just $ default_Accounting{accounting_businessId = accounting_businessId obj}
    , if obj == default_Accounting{accounting_businessName = accounting_businessName obj} then P.Nothing else P.Just $ default_Accounting{accounting_businessName = accounting_businessName obj}
    , if obj == default_Accounting{accounting_businessRole = accounting_businessRole obj} then P.Nothing else P.Just $ default_Accounting{accounting_businessRole = accounting_businessRole obj}
    , if obj == default_Accounting{accounting_unitDiscount = accounting_unitDiscount obj} then P.Nothing else P.Just $ default_Accounting{accounting_unitDiscount = accounting_unitDiscount obj}
    , if obj == default_Accounting{accounting_nextChargeDate = accounting_nextChargeDate obj} then P.Nothing else P.Just $ default_Accounting{accounting_nextChargeDate = accounting_nextChargeDate obj}
    , if obj == default_Accounting{accounting_availablePoints = accounting_availablePoints obj} then P.Nothing else P.Just $ default_Accounting{accounting_availablePoints = accounting_availablePoints obj}
    ]
from_Accounting :: Accounting -> T.ThriftVal
from_Accounting record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v69 -> (2, ("uploadLimitEnd",T.TI64 _v69))) <$> accounting_uploadLimitEnd record
  , (\_v69 -> (3, ("uploadLimitNextMonth",T.TI64 _v69))) <$> accounting_uploadLimitNextMonth record
  , (\_v69 -> (4, ("premiumServiceStatus",T.TI32 $ P.fromIntegral $ P.fromEnum _v69))) <$> accounting_premiumServiceStatus record
  , (\_v69 -> (5, ("premiumOrderNumber",T.TString $ E.encodeUtf8 _v69))) <$> accounting_premiumOrderNumber record
  , (\_v69 -> (6, ("premiumCommerceService",T.TString $ E.encodeUtf8 _v69))) <$> accounting_premiumCommerceService record
  , (\_v69 -> (7, ("premiumServiceStart",T.TI64 _v69))) <$> accounting_premiumServiceStart record
  , (\_v69 -> (8, ("premiumServiceSKU",T.TString $ E.encodeUtf8 _v69))) <$> accounting_premiumServiceSKU record
  , (\_v69 -> (9, ("lastSuccessfulCharge",T.TI64 _v69))) <$> accounting_lastSuccessfulCharge record
  , (\_v69 -> (10, ("lastFailedCharge",T.TI64 _v69))) <$> accounting_lastFailedCharge record
  , (\_v69 -> (11, ("lastFailedChargeReason",T.TString $ E.encodeUtf8 _v69))) <$> accounting_lastFailedChargeReason record
  , (\_v69 -> (12, ("nextPaymentDue",T.TI64 _v69))) <$> accounting_nextPaymentDue record
  , (\_v69 -> (13, ("premiumLockUntil",T.TI64 _v69))) <$> accounting_premiumLockUntil record
  , (\_v69 -> (14, ("updated",T.TI64 _v69))) <$> accounting_updated record
  , (\_v69 -> (16, ("premiumSubscriptionNumber",T.TString $ E.encodeUtf8 _v69))) <$> accounting_premiumSubscriptionNumber record
  , (\_v69 -> (17, ("lastRequestedCharge",T.TI64 _v69))) <$> accounting_lastRequestedCharge record
  , (\_v69 -> (18, ("currency",T.TString $ E.encodeUtf8 _v69))) <$> accounting_currency record
  , (\_v69 -> (19, ("unitPrice",T.TI32 _v69))) <$> accounting_unitPrice record
  , (\_v69 -> (20, ("businessId",T.TI32 _v69))) <$> accounting_businessId record
  , (\_v69 -> (21, ("businessName",T.TString $ E.encodeUtf8 _v69))) <$> accounting_businessName record
  , (\_v69 -> (22, ("businessRole",T.TI32 $ P.fromIntegral $ P.fromEnum _v69))) <$> accounting_businessRole record
  , (\_v69 -> (23, ("unitDiscount",T.TI32 _v69))) <$> accounting_unitDiscount record
  , (\_v69 -> (24, ("nextChargeDate",T.TI64 _v69))) <$> accounting_nextChargeDate record
  , (\_v69 -> (25, ("availablePoints",T.TI32 _v69))) <$> accounting_availablePoints record
  ]
write_Accounting :: T.Protocol p => p -> Accounting -> P.IO ()
write_Accounting oprot record = T.writeVal oprot $ from_Accounting record
encode_Accounting :: T.StatelessProtocol p => p -> Accounting -> LBS.ByteString
encode_Accounting oprot record = T.serializeVal oprot $ from_Accounting record
to_Accounting :: T.ThriftVal -> Accounting
to_Accounting (T.TStruct fields) = Accounting{
  accounting_uploadLimitEnd = P.maybe (P.Nothing) (\(_,_val71) -> P.Just (case _val71 of {T.TI64 _val72 -> _val72; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  accounting_uploadLimitNextMonth = P.maybe (P.Nothing) (\(_,_val71) -> P.Just (case _val71 of {T.TI64 _val73 -> _val73; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  accounting_premiumServiceStatus = P.maybe (P.Nothing) (\(_,_val71) -> P.Just (case _val71 of {T.TI32 _val74 -> P.toEnum $ P.fromIntegral _val74; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  accounting_premiumOrderNumber = P.maybe (P.Nothing) (\(_,_val71) -> P.Just (case _val71 of {T.TString _val75 -> E.decodeUtf8 _val75; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  accounting_premiumCommerceService = P.maybe (P.Nothing) (\(_,_val71) -> P.Just (case _val71 of {T.TString _val76 -> E.decodeUtf8 _val76; _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  accounting_premiumServiceStart = P.maybe (P.Nothing) (\(_,_val71) -> P.Just (case _val71 of {T.TI64 _val77 -> _val77; _ -> P.error "wrong type"})) (Map.lookup (7) fields),
  accounting_premiumServiceSKU = P.maybe (P.Nothing) (\(_,_val71) -> P.Just (case _val71 of {T.TString _val78 -> E.decodeUtf8 _val78; _ -> P.error "wrong type"})) (Map.lookup (8) fields),
  accounting_lastSuccessfulCharge = P.maybe (P.Nothing) (\(_,_val71) -> P.Just (case _val71 of {T.TI64 _val79 -> _val79; _ -> P.error "wrong type"})) (Map.lookup (9) fields),
  accounting_lastFailedCharge = P.maybe (P.Nothing) (\(_,_val71) -> P.Just (case _val71 of {T.TI64 _val80 -> _val80; _ -> P.error "wrong type"})) (Map.lookup (10) fields),
  accounting_lastFailedChargeReason = P.maybe (P.Nothing) (\(_,_val71) -> P.Just (case _val71 of {T.TString _val81 -> E.decodeUtf8 _val81; _ -> P.error "wrong type"})) (Map.lookup (11) fields),
  accounting_nextPaymentDue = P.maybe (P.Nothing) (\(_,_val71) -> P.Just (case _val71 of {T.TI64 _val82 -> _val82; _ -> P.error "wrong type"})) (Map.lookup (12) fields),
  accounting_premiumLockUntil = P.maybe (P.Nothing) (\(_,_val71) -> P.Just (case _val71 of {T.TI64 _val83 -> _val83; _ -> P.error "wrong type"})) (Map.lookup (13) fields),
  accounting_updated = P.maybe (P.Nothing) (\(_,_val71) -> P.Just (case _val71 of {T.TI64 _val84 -> _val84; _ -> P.error "wrong type"})) (Map.lookup (14) fields),
  accounting_premiumSubscriptionNumber = P.maybe (P.Nothing) (\(_,_val71) -> P.Just (case _val71 of {T.TString _val85 -> E.decodeUtf8 _val85; _ -> P.error "wrong type"})) (Map.lookup (16) fields),
  accounting_lastRequestedCharge = P.maybe (P.Nothing) (\(_,_val71) -> P.Just (case _val71 of {T.TI64 _val86 -> _val86; _ -> P.error "wrong type"})) (Map.lookup (17) fields),
  accounting_currency = P.maybe (P.Nothing) (\(_,_val71) -> P.Just (case _val71 of {T.TString _val87 -> E.decodeUtf8 _val87; _ -> P.error "wrong type"})) (Map.lookup (18) fields),
  accounting_unitPrice = P.maybe (P.Nothing) (\(_,_val71) -> P.Just (case _val71 of {T.TI32 _val88 -> _val88; _ -> P.error "wrong type"})) (Map.lookup (19) fields),
  accounting_businessId = P.maybe (P.Nothing) (\(_,_val71) -> P.Just (case _val71 of {T.TI32 _val89 -> _val89; _ -> P.error "wrong type"})) (Map.lookup (20) fields),
  accounting_businessName = P.maybe (P.Nothing) (\(_,_val71) -> P.Just (case _val71 of {T.TString _val90 -> E.decodeUtf8 _val90; _ -> P.error "wrong type"})) (Map.lookup (21) fields),
  accounting_businessRole = P.maybe (P.Nothing) (\(_,_val71) -> P.Just (case _val71 of {T.TI32 _val91 -> P.toEnum $ P.fromIntegral _val91; _ -> P.error "wrong type"})) (Map.lookup (22) fields),
  accounting_unitDiscount = P.maybe (P.Nothing) (\(_,_val71) -> P.Just (case _val71 of {T.TI32 _val92 -> _val92; _ -> P.error "wrong type"})) (Map.lookup (23) fields),
  accounting_nextChargeDate = P.maybe (P.Nothing) (\(_,_val71) -> P.Just (case _val71 of {T.TI64 _val93 -> _val93; _ -> P.error "wrong type"})) (Map.lookup (24) fields),
  accounting_availablePoints = P.maybe (P.Nothing) (\(_,_val71) -> P.Just (case _val71 of {T.TI32 _val94 -> _val94; _ -> P.error "wrong type"})) (Map.lookup (25) fields)
  }
to_Accounting _ = P.error "not a struct"
read_Accounting :: T.Protocol p => p -> P.IO Accounting
read_Accounting iprot = to_Accounting <$> T.readVal iprot (T.T_STRUCT typemap_Accounting)
decode_Accounting :: T.StatelessProtocol p => p -> LBS.ByteString -> Accounting
decode_Accounting iprot bs = to_Accounting $ T.deserializeVal iprot (T.T_STRUCT typemap_Accounting) bs
typemap_Accounting :: T.TypeMap
typemap_Accounting = Map.fromList [(2,("uploadLimitEnd",T.T_I64)),(3,("uploadLimitNextMonth",T.T_I64)),(4,("premiumServiceStatus",T.T_I32)),(5,("premiumOrderNumber",T.T_STRING)),(6,("premiumCommerceService",T.T_STRING)),(7,("premiumServiceStart",T.T_I64)),(8,("premiumServiceSKU",T.T_STRING)),(9,("lastSuccessfulCharge",T.T_I64)),(10,("lastFailedCharge",T.T_I64)),(11,("lastFailedChargeReason",T.T_STRING)),(12,("nextPaymentDue",T.T_I64)),(13,("premiumLockUntil",T.T_I64)),(14,("updated",T.T_I64)),(16,("premiumSubscriptionNumber",T.T_STRING)),(17,("lastRequestedCharge",T.T_I64)),(18,("currency",T.T_STRING)),(19,("unitPrice",T.T_I32)),(20,("businessId",T.T_I32)),(21,("businessName",T.T_STRING)),(22,("businessRole",T.T_I32)),(23,("unitDiscount",T.T_I32)),(24,("nextChargeDate",T.T_I64)),(25,("availablePoints",T.T_I32))]
default_Accounting :: Accounting
default_Accounting = Accounting{
  accounting_uploadLimitEnd = P.Nothing,
  accounting_uploadLimitNextMonth = P.Nothing,
  accounting_premiumServiceStatus = P.Nothing,
  accounting_premiumOrderNumber = P.Nothing,
  accounting_premiumCommerceService = P.Nothing,
  accounting_premiumServiceStart = P.Nothing,
  accounting_premiumServiceSKU = P.Nothing,
  accounting_lastSuccessfulCharge = P.Nothing,
  accounting_lastFailedCharge = P.Nothing,
  accounting_lastFailedChargeReason = P.Nothing,
  accounting_nextPaymentDue = P.Nothing,
  accounting_premiumLockUntil = P.Nothing,
  accounting_updated = P.Nothing,
  accounting_premiumSubscriptionNumber = P.Nothing,
  accounting_lastRequestedCharge = P.Nothing,
  accounting_currency = P.Nothing,
  accounting_unitPrice = P.Nothing,
  accounting_businessId = P.Nothing,
  accounting_businessName = P.Nothing,
  accounting_businessRole = P.Nothing,
  accounting_unitDiscount = P.Nothing,
  accounting_nextChargeDate = P.Nothing,
  accounting_availablePoints = P.Nothing}
data BusinessUserInfo = BusinessUserInfo  { businessUserInfo_businessId :: P.Maybe I.Int32
  , businessUserInfo_businessName :: P.Maybe LT.Text
  , businessUserInfo_role :: P.Maybe BusinessUserRole
  , businessUserInfo_email :: P.Maybe LT.Text
  , businessUserInfo_updated :: P.Maybe I.Int64
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable BusinessUserInfo where
  hashWithSalt salt record = salt   `H.hashWithSalt` businessUserInfo_businessId record   `H.hashWithSalt` businessUserInfo_businessName record   `H.hashWithSalt` businessUserInfo_role record   `H.hashWithSalt` businessUserInfo_email record   `H.hashWithSalt` businessUserInfo_updated record  
instance QC.Arbitrary BusinessUserInfo where 
  arbitrary = M.liftM BusinessUserInfo (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_BusinessUserInfo = []
             | P.otherwise = M.catMaybes
    [ if obj == default_BusinessUserInfo{businessUserInfo_businessId = businessUserInfo_businessId obj} then P.Nothing else P.Just $ default_BusinessUserInfo{businessUserInfo_businessId = businessUserInfo_businessId obj}
    , if obj == default_BusinessUserInfo{businessUserInfo_businessName = businessUserInfo_businessName obj} then P.Nothing else P.Just $ default_BusinessUserInfo{businessUserInfo_businessName = businessUserInfo_businessName obj}
    , if obj == default_BusinessUserInfo{businessUserInfo_role = businessUserInfo_role obj} then P.Nothing else P.Just $ default_BusinessUserInfo{businessUserInfo_role = businessUserInfo_role obj}
    , if obj == default_BusinessUserInfo{businessUserInfo_email = businessUserInfo_email obj} then P.Nothing else P.Just $ default_BusinessUserInfo{businessUserInfo_email = businessUserInfo_email obj}
    , if obj == default_BusinessUserInfo{businessUserInfo_updated = businessUserInfo_updated obj} then P.Nothing else P.Just $ default_BusinessUserInfo{businessUserInfo_updated = businessUserInfo_updated obj}
    ]
from_BusinessUserInfo :: BusinessUserInfo -> T.ThriftVal
from_BusinessUserInfo record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v97 -> (1, ("businessId",T.TI32 _v97))) <$> businessUserInfo_businessId record
  , (\_v97 -> (2, ("businessName",T.TString $ E.encodeUtf8 _v97))) <$> businessUserInfo_businessName record
  , (\_v97 -> (3, ("role",T.TI32 $ P.fromIntegral $ P.fromEnum _v97))) <$> businessUserInfo_role record
  , (\_v97 -> (4, ("email",T.TString $ E.encodeUtf8 _v97))) <$> businessUserInfo_email record
  , (\_v97 -> (5, ("updated",T.TI64 _v97))) <$> businessUserInfo_updated record
  ]
write_BusinessUserInfo :: T.Protocol p => p -> BusinessUserInfo -> P.IO ()
write_BusinessUserInfo oprot record = T.writeVal oprot $ from_BusinessUserInfo record
encode_BusinessUserInfo :: T.StatelessProtocol p => p -> BusinessUserInfo -> LBS.ByteString
encode_BusinessUserInfo oprot record = T.serializeVal oprot $ from_BusinessUserInfo record
to_BusinessUserInfo :: T.ThriftVal -> BusinessUserInfo
to_BusinessUserInfo (T.TStruct fields) = BusinessUserInfo{
  businessUserInfo_businessId = P.maybe (P.Nothing) (\(_,_val99) -> P.Just (case _val99 of {T.TI32 _val100 -> _val100; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  businessUserInfo_businessName = P.maybe (P.Nothing) (\(_,_val99) -> P.Just (case _val99 of {T.TString _val101 -> E.decodeUtf8 _val101; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  businessUserInfo_role = P.maybe (P.Nothing) (\(_,_val99) -> P.Just (case _val99 of {T.TI32 _val102 -> P.toEnum $ P.fromIntegral _val102; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  businessUserInfo_email = P.maybe (P.Nothing) (\(_,_val99) -> P.Just (case _val99 of {T.TString _val103 -> E.decodeUtf8 _val103; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  businessUserInfo_updated = P.maybe (P.Nothing) (\(_,_val99) -> P.Just (case _val99 of {T.TI64 _val104 -> _val104; _ -> P.error "wrong type"})) (Map.lookup (5) fields)
  }
to_BusinessUserInfo _ = P.error "not a struct"
read_BusinessUserInfo :: T.Protocol p => p -> P.IO BusinessUserInfo
read_BusinessUserInfo iprot = to_BusinessUserInfo <$> T.readVal iprot (T.T_STRUCT typemap_BusinessUserInfo)
decode_BusinessUserInfo :: T.StatelessProtocol p => p -> LBS.ByteString -> BusinessUserInfo
decode_BusinessUserInfo iprot bs = to_BusinessUserInfo $ T.deserializeVal iprot (T.T_STRUCT typemap_BusinessUserInfo) bs
typemap_BusinessUserInfo :: T.TypeMap
typemap_BusinessUserInfo = Map.fromList [(1,("businessId",T.T_I32)),(2,("businessName",T.T_STRING)),(3,("role",T.T_I32)),(4,("email",T.T_STRING)),(5,("updated",T.T_I64))]
default_BusinessUserInfo :: BusinessUserInfo
default_BusinessUserInfo = BusinessUserInfo{
  businessUserInfo_businessId = P.Nothing,
  businessUserInfo_businessName = P.Nothing,
  businessUserInfo_role = P.Nothing,
  businessUserInfo_email = P.Nothing,
  businessUserInfo_updated = P.Nothing}
data AccountLimits = AccountLimits  { accountLimits_userMailLimitDaily :: P.Maybe I.Int32
  , accountLimits_noteSizeMax :: P.Maybe I.Int64
  , accountLimits_resourceSizeMax :: P.Maybe I.Int64
  , accountLimits_userLinkedNotebookMax :: P.Maybe I.Int32
  , accountLimits_uploadLimit :: P.Maybe I.Int64
  , accountLimits_userNoteCountMax :: P.Maybe I.Int32
  , accountLimits_userNotebookCountMax :: P.Maybe I.Int32
  , accountLimits_userTagCountMax :: P.Maybe I.Int32
  , accountLimits_noteTagCountMax :: P.Maybe I.Int32
  , accountLimits_userSavedSearchesMax :: P.Maybe I.Int32
  , accountLimits_noteResourceCountMax :: P.Maybe I.Int32
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable AccountLimits where
  hashWithSalt salt record = salt   `H.hashWithSalt` accountLimits_userMailLimitDaily record   `H.hashWithSalt` accountLimits_noteSizeMax record   `H.hashWithSalt` accountLimits_resourceSizeMax record   `H.hashWithSalt` accountLimits_userLinkedNotebookMax record   `H.hashWithSalt` accountLimits_uploadLimit record   `H.hashWithSalt` accountLimits_userNoteCountMax record   `H.hashWithSalt` accountLimits_userNotebookCountMax record   `H.hashWithSalt` accountLimits_userTagCountMax record   `H.hashWithSalt` accountLimits_noteTagCountMax record   `H.hashWithSalt` accountLimits_userSavedSearchesMax record   `H.hashWithSalt` accountLimits_noteResourceCountMax record  
instance QC.Arbitrary AccountLimits where 
  arbitrary = M.liftM AccountLimits (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_AccountLimits = []
             | P.otherwise = M.catMaybes
    [ if obj == default_AccountLimits{accountLimits_userMailLimitDaily = accountLimits_userMailLimitDaily obj} then P.Nothing else P.Just $ default_AccountLimits{accountLimits_userMailLimitDaily = accountLimits_userMailLimitDaily obj}
    , if obj == default_AccountLimits{accountLimits_noteSizeMax = accountLimits_noteSizeMax obj} then P.Nothing else P.Just $ default_AccountLimits{accountLimits_noteSizeMax = accountLimits_noteSizeMax obj}
    , if obj == default_AccountLimits{accountLimits_resourceSizeMax = accountLimits_resourceSizeMax obj} then P.Nothing else P.Just $ default_AccountLimits{accountLimits_resourceSizeMax = accountLimits_resourceSizeMax obj}
    , if obj == default_AccountLimits{accountLimits_userLinkedNotebookMax = accountLimits_userLinkedNotebookMax obj} then P.Nothing else P.Just $ default_AccountLimits{accountLimits_userLinkedNotebookMax = accountLimits_userLinkedNotebookMax obj}
    , if obj == default_AccountLimits{accountLimits_uploadLimit = accountLimits_uploadLimit obj} then P.Nothing else P.Just $ default_AccountLimits{accountLimits_uploadLimit = accountLimits_uploadLimit obj}
    , if obj == default_AccountLimits{accountLimits_userNoteCountMax = accountLimits_userNoteCountMax obj} then P.Nothing else P.Just $ default_AccountLimits{accountLimits_userNoteCountMax = accountLimits_userNoteCountMax obj}
    , if obj == default_AccountLimits{accountLimits_userNotebookCountMax = accountLimits_userNotebookCountMax obj} then P.Nothing else P.Just $ default_AccountLimits{accountLimits_userNotebookCountMax = accountLimits_userNotebookCountMax obj}
    , if obj == default_AccountLimits{accountLimits_userTagCountMax = accountLimits_userTagCountMax obj} then P.Nothing else P.Just $ default_AccountLimits{accountLimits_userTagCountMax = accountLimits_userTagCountMax obj}
    , if obj == default_AccountLimits{accountLimits_noteTagCountMax = accountLimits_noteTagCountMax obj} then P.Nothing else P.Just $ default_AccountLimits{accountLimits_noteTagCountMax = accountLimits_noteTagCountMax obj}
    , if obj == default_AccountLimits{accountLimits_userSavedSearchesMax = accountLimits_userSavedSearchesMax obj} then P.Nothing else P.Just $ default_AccountLimits{accountLimits_userSavedSearchesMax = accountLimits_userSavedSearchesMax obj}
    , if obj == default_AccountLimits{accountLimits_noteResourceCountMax = accountLimits_noteResourceCountMax obj} then P.Nothing else P.Just $ default_AccountLimits{accountLimits_noteResourceCountMax = accountLimits_noteResourceCountMax obj}
    ]
from_AccountLimits :: AccountLimits -> T.ThriftVal
from_AccountLimits record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v107 -> (1, ("userMailLimitDaily",T.TI32 _v107))) <$> accountLimits_userMailLimitDaily record
  , (\_v107 -> (2, ("noteSizeMax",T.TI64 _v107))) <$> accountLimits_noteSizeMax record
  , (\_v107 -> (3, ("resourceSizeMax",T.TI64 _v107))) <$> accountLimits_resourceSizeMax record
  , (\_v107 -> (4, ("userLinkedNotebookMax",T.TI32 _v107))) <$> accountLimits_userLinkedNotebookMax record
  , (\_v107 -> (5, ("uploadLimit",T.TI64 _v107))) <$> accountLimits_uploadLimit record
  , (\_v107 -> (6, ("userNoteCountMax",T.TI32 _v107))) <$> accountLimits_userNoteCountMax record
  , (\_v107 -> (7, ("userNotebookCountMax",T.TI32 _v107))) <$> accountLimits_userNotebookCountMax record
  , (\_v107 -> (8, ("userTagCountMax",T.TI32 _v107))) <$> accountLimits_userTagCountMax record
  , (\_v107 -> (9, ("noteTagCountMax",T.TI32 _v107))) <$> accountLimits_noteTagCountMax record
  , (\_v107 -> (10, ("userSavedSearchesMax",T.TI32 _v107))) <$> accountLimits_userSavedSearchesMax record
  , (\_v107 -> (11, ("noteResourceCountMax",T.TI32 _v107))) <$> accountLimits_noteResourceCountMax record
  ]
write_AccountLimits :: T.Protocol p => p -> AccountLimits -> P.IO ()
write_AccountLimits oprot record = T.writeVal oprot $ from_AccountLimits record
encode_AccountLimits :: T.StatelessProtocol p => p -> AccountLimits -> LBS.ByteString
encode_AccountLimits oprot record = T.serializeVal oprot $ from_AccountLimits record
to_AccountLimits :: T.ThriftVal -> AccountLimits
to_AccountLimits (T.TStruct fields) = AccountLimits{
  accountLimits_userMailLimitDaily = P.maybe (P.Nothing) (\(_,_val109) -> P.Just (case _val109 of {T.TI32 _val110 -> _val110; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  accountLimits_noteSizeMax = P.maybe (P.Nothing) (\(_,_val109) -> P.Just (case _val109 of {T.TI64 _val111 -> _val111; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  accountLimits_resourceSizeMax = P.maybe (P.Nothing) (\(_,_val109) -> P.Just (case _val109 of {T.TI64 _val112 -> _val112; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  accountLimits_userLinkedNotebookMax = P.maybe (P.Nothing) (\(_,_val109) -> P.Just (case _val109 of {T.TI32 _val113 -> _val113; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  accountLimits_uploadLimit = P.maybe (P.Nothing) (\(_,_val109) -> P.Just (case _val109 of {T.TI64 _val114 -> _val114; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  accountLimits_userNoteCountMax = P.maybe (P.Nothing) (\(_,_val109) -> P.Just (case _val109 of {T.TI32 _val115 -> _val115; _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  accountLimits_userNotebookCountMax = P.maybe (P.Nothing) (\(_,_val109) -> P.Just (case _val109 of {T.TI32 _val116 -> _val116; _ -> P.error "wrong type"})) (Map.lookup (7) fields),
  accountLimits_userTagCountMax = P.maybe (P.Nothing) (\(_,_val109) -> P.Just (case _val109 of {T.TI32 _val117 -> _val117; _ -> P.error "wrong type"})) (Map.lookup (8) fields),
  accountLimits_noteTagCountMax = P.maybe (P.Nothing) (\(_,_val109) -> P.Just (case _val109 of {T.TI32 _val118 -> _val118; _ -> P.error "wrong type"})) (Map.lookup (9) fields),
  accountLimits_userSavedSearchesMax = P.maybe (P.Nothing) (\(_,_val109) -> P.Just (case _val109 of {T.TI32 _val119 -> _val119; _ -> P.error "wrong type"})) (Map.lookup (10) fields),
  accountLimits_noteResourceCountMax = P.maybe (P.Nothing) (\(_,_val109) -> P.Just (case _val109 of {T.TI32 _val120 -> _val120; _ -> P.error "wrong type"})) (Map.lookup (11) fields)
  }
to_AccountLimits _ = P.error "not a struct"
read_AccountLimits :: T.Protocol p => p -> P.IO AccountLimits
read_AccountLimits iprot = to_AccountLimits <$> T.readVal iprot (T.T_STRUCT typemap_AccountLimits)
decode_AccountLimits :: T.StatelessProtocol p => p -> LBS.ByteString -> AccountLimits
decode_AccountLimits iprot bs = to_AccountLimits $ T.deserializeVal iprot (T.T_STRUCT typemap_AccountLimits) bs
typemap_AccountLimits :: T.TypeMap
typemap_AccountLimits = Map.fromList [(1,("userMailLimitDaily",T.T_I32)),(2,("noteSizeMax",T.T_I64)),(3,("resourceSizeMax",T.T_I64)),(4,("userLinkedNotebookMax",T.T_I32)),(5,("uploadLimit",T.T_I64)),(6,("userNoteCountMax",T.T_I32)),(7,("userNotebookCountMax",T.T_I32)),(8,("userTagCountMax",T.T_I32)),(9,("noteTagCountMax",T.T_I32)),(10,("userSavedSearchesMax",T.T_I32)),(11,("noteResourceCountMax",T.T_I32))]
default_AccountLimits :: AccountLimits
default_AccountLimits = AccountLimits{
  accountLimits_userMailLimitDaily = P.Nothing,
  accountLimits_noteSizeMax = P.Nothing,
  accountLimits_resourceSizeMax = P.Nothing,
  accountLimits_userLinkedNotebookMax = P.Nothing,
  accountLimits_uploadLimit = P.Nothing,
  accountLimits_userNoteCountMax = P.Nothing,
  accountLimits_userNotebookCountMax = P.Nothing,
  accountLimits_userTagCountMax = P.Nothing,
  accountLimits_noteTagCountMax = P.Nothing,
  accountLimits_userSavedSearchesMax = P.Nothing,
  accountLimits_noteResourceCountMax = P.Nothing}
data User = User  { user_id :: P.Maybe I.Int32
  , user_username :: P.Maybe LT.Text
  , user_email :: P.Maybe LT.Text
  , user_name :: P.Maybe LT.Text
  , user_timezone :: P.Maybe LT.Text
  , user_privilege :: P.Maybe PrivilegeLevel
  , user_serviceLevel :: P.Maybe ServiceLevel
  , user_created :: P.Maybe I.Int64
  , user_updated :: P.Maybe I.Int64
  , user_deleted :: P.Maybe I.Int64
  , user_active :: P.Maybe P.Bool
  , user_shardId :: P.Maybe LT.Text
  , user_attributes :: P.Maybe UserAttributes
  , user_accounting :: P.Maybe Accounting
  , user_businessUserInfo :: P.Maybe BusinessUserInfo
  , user_photoUrl :: P.Maybe LT.Text
  , user_photoLastUpdated :: P.Maybe I.Int64
  , user_accountLimits :: P.Maybe AccountLimits
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable User where
  hashWithSalt salt record = salt   `H.hashWithSalt` user_id record   `H.hashWithSalt` user_username record   `H.hashWithSalt` user_email record   `H.hashWithSalt` user_name record   `H.hashWithSalt` user_timezone record   `H.hashWithSalt` user_privilege record   `H.hashWithSalt` user_serviceLevel record   `H.hashWithSalt` user_created record   `H.hashWithSalt` user_updated record   `H.hashWithSalt` user_deleted record   `H.hashWithSalt` user_active record   `H.hashWithSalt` user_shardId record   `H.hashWithSalt` user_attributes record   `H.hashWithSalt` user_accounting record   `H.hashWithSalt` user_businessUserInfo record   `H.hashWithSalt` user_photoUrl record   `H.hashWithSalt` user_photoLastUpdated record   `H.hashWithSalt` user_accountLimits record  
instance QC.Arbitrary User where 
  arbitrary = M.liftM User (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_User = []
             | P.otherwise = M.catMaybes
    [ if obj == default_User{user_id = user_id obj} then P.Nothing else P.Just $ default_User{user_id = user_id obj}
    , if obj == default_User{user_username = user_username obj} then P.Nothing else P.Just $ default_User{user_username = user_username obj}
    , if obj == default_User{user_email = user_email obj} then P.Nothing else P.Just $ default_User{user_email = user_email obj}
    , if obj == default_User{user_name = user_name obj} then P.Nothing else P.Just $ default_User{user_name = user_name obj}
    , if obj == default_User{user_timezone = user_timezone obj} then P.Nothing else P.Just $ default_User{user_timezone = user_timezone obj}
    , if obj == default_User{user_privilege = user_privilege obj} then P.Nothing else P.Just $ default_User{user_privilege = user_privilege obj}
    , if obj == default_User{user_serviceLevel = user_serviceLevel obj} then P.Nothing else P.Just $ default_User{user_serviceLevel = user_serviceLevel obj}
    , if obj == default_User{user_created = user_created obj} then P.Nothing else P.Just $ default_User{user_created = user_created obj}
    , if obj == default_User{user_updated = user_updated obj} then P.Nothing else P.Just $ default_User{user_updated = user_updated obj}
    , if obj == default_User{user_deleted = user_deleted obj} then P.Nothing else P.Just $ default_User{user_deleted = user_deleted obj}
    , if obj == default_User{user_active = user_active obj} then P.Nothing else P.Just $ default_User{user_active = user_active obj}
    , if obj == default_User{user_shardId = user_shardId obj} then P.Nothing else P.Just $ default_User{user_shardId = user_shardId obj}
    , if obj == default_User{user_attributes = user_attributes obj} then P.Nothing else P.Just $ default_User{user_attributes = user_attributes obj}
    , if obj == default_User{user_accounting = user_accounting obj} then P.Nothing else P.Just $ default_User{user_accounting = user_accounting obj}
    , if obj == default_User{user_businessUserInfo = user_businessUserInfo obj} then P.Nothing else P.Just $ default_User{user_businessUserInfo = user_businessUserInfo obj}
    , if obj == default_User{user_photoUrl = user_photoUrl obj} then P.Nothing else P.Just $ default_User{user_photoUrl = user_photoUrl obj}
    , if obj == default_User{user_photoLastUpdated = user_photoLastUpdated obj} then P.Nothing else P.Just $ default_User{user_photoLastUpdated = user_photoLastUpdated obj}
    , if obj == default_User{user_accountLimits = user_accountLimits obj} then P.Nothing else P.Just $ default_User{user_accountLimits = user_accountLimits obj}
    ]
from_User :: User -> T.ThriftVal
from_User record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v123 -> (1, ("id",T.TI32 _v123))) <$> user_id record
  , (\_v123 -> (2, ("username",T.TString $ E.encodeUtf8 _v123))) <$> user_username record
  , (\_v123 -> (3, ("email",T.TString $ E.encodeUtf8 _v123))) <$> user_email record
  , (\_v123 -> (4, ("name",T.TString $ E.encodeUtf8 _v123))) <$> user_name record
  , (\_v123 -> (6, ("timezone",T.TString $ E.encodeUtf8 _v123))) <$> user_timezone record
  , (\_v123 -> (7, ("privilege",T.TI32 $ P.fromIntegral $ P.fromEnum _v123))) <$> user_privilege record
  , (\_v123 -> (9, ("created",T.TI64 _v123))) <$> user_created record
  , (\_v123 -> (10, ("updated",T.TI64 _v123))) <$> user_updated record
  , (\_v123 -> (11, ("deleted",T.TI64 _v123))) <$> user_deleted record
  , (\_v123 -> (13, ("active",T.TBool _v123))) <$> user_active record
  , (\_v123 -> (14, ("shardId",T.TString $ E.encodeUtf8 _v123))) <$> user_shardId record
  , (\_v123 -> (15, ("attributes",from_UserAttributes _v123))) <$> user_attributes record
  , (\_v123 -> (16, ("accounting",from_Accounting _v123))) <$> user_accounting record
  , (\_v123 -> (18, ("businessUserInfo",from_BusinessUserInfo _v123))) <$> user_businessUserInfo record
  , (\_v123 -> (19, ("photoUrl",T.TString $ E.encodeUtf8 _v123))) <$> user_photoUrl record
  , (\_v123 -> (20, ("photoLastUpdated",T.TI64 _v123))) <$> user_photoLastUpdated record
  , (\_v123 -> (21, ("serviceLevel",T.TI32 $ P.fromIntegral $ P.fromEnum _v123))) <$> user_serviceLevel record
  , (\_v123 -> (22, ("accountLimits",from_AccountLimits _v123))) <$> user_accountLimits record
  ]
write_User :: T.Protocol p => p -> User -> P.IO ()
write_User oprot record = T.writeVal oprot $ from_User record
encode_User :: T.StatelessProtocol p => p -> User -> LBS.ByteString
encode_User oprot record = T.serializeVal oprot $ from_User record
to_User :: T.ThriftVal -> User
to_User (T.TStruct fields) = User{
  user_id = P.maybe (P.Nothing) (\(_,_val125) -> P.Just (case _val125 of {T.TI32 _val126 -> _val126; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  user_username = P.maybe (P.Nothing) (\(_,_val125) -> P.Just (case _val125 of {T.TString _val127 -> E.decodeUtf8 _val127; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  user_email = P.maybe (P.Nothing) (\(_,_val125) -> P.Just (case _val125 of {T.TString _val128 -> E.decodeUtf8 _val128; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  user_name = P.maybe (P.Nothing) (\(_,_val125) -> P.Just (case _val125 of {T.TString _val129 -> E.decodeUtf8 _val129; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  user_timezone = P.maybe (P.Nothing) (\(_,_val125) -> P.Just (case _val125 of {T.TString _val130 -> E.decodeUtf8 _val130; _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  user_privilege = P.maybe (P.Nothing) (\(_,_val125) -> P.Just (case _val125 of {T.TI32 _val131 -> P.toEnum $ P.fromIntegral _val131; _ -> P.error "wrong type"})) (Map.lookup (7) fields),
  user_serviceLevel = P.maybe (P.Nothing) (\(_,_val125) -> P.Just (case _val125 of {T.TI32 _val132 -> P.toEnum $ P.fromIntegral _val132; _ -> P.error "wrong type"})) (Map.lookup (21) fields),
  user_created = P.maybe (P.Nothing) (\(_,_val125) -> P.Just (case _val125 of {T.TI64 _val133 -> _val133; _ -> P.error "wrong type"})) (Map.lookup (9) fields),
  user_updated = P.maybe (P.Nothing) (\(_,_val125) -> P.Just (case _val125 of {T.TI64 _val134 -> _val134; _ -> P.error "wrong type"})) (Map.lookup (10) fields),
  user_deleted = P.maybe (P.Nothing) (\(_,_val125) -> P.Just (case _val125 of {T.TI64 _val135 -> _val135; _ -> P.error "wrong type"})) (Map.lookup (11) fields),
  user_active = P.maybe (P.Nothing) (\(_,_val125) -> P.Just (case _val125 of {T.TBool _val136 -> _val136; _ -> P.error "wrong type"})) (Map.lookup (13) fields),
  user_shardId = P.maybe (P.Nothing) (\(_,_val125) -> P.Just (case _val125 of {T.TString _val137 -> E.decodeUtf8 _val137; _ -> P.error "wrong type"})) (Map.lookup (14) fields),
  user_attributes = P.maybe (P.Nothing) (\(_,_val125) -> P.Just (case _val125 of {T.TStruct _val138 -> (to_UserAttributes (T.TStruct _val138)); _ -> P.error "wrong type"})) (Map.lookup (15) fields),
  user_accounting = P.maybe (P.Nothing) (\(_,_val125) -> P.Just (case _val125 of {T.TStruct _val139 -> (to_Accounting (T.TStruct _val139)); _ -> P.error "wrong type"})) (Map.lookup (16) fields),
  user_businessUserInfo = P.maybe (P.Nothing) (\(_,_val125) -> P.Just (case _val125 of {T.TStruct _val140 -> (to_BusinessUserInfo (T.TStruct _val140)); _ -> P.error "wrong type"})) (Map.lookup (18) fields),
  user_photoUrl = P.maybe (P.Nothing) (\(_,_val125) -> P.Just (case _val125 of {T.TString _val141 -> E.decodeUtf8 _val141; _ -> P.error "wrong type"})) (Map.lookup (19) fields),
  user_photoLastUpdated = P.maybe (P.Nothing) (\(_,_val125) -> P.Just (case _val125 of {T.TI64 _val142 -> _val142; _ -> P.error "wrong type"})) (Map.lookup (20) fields),
  user_accountLimits = P.maybe (P.Nothing) (\(_,_val125) -> P.Just (case _val125 of {T.TStruct _val143 -> (to_AccountLimits (T.TStruct _val143)); _ -> P.error "wrong type"})) (Map.lookup (22) fields)
  }
to_User _ = P.error "not a struct"
read_User :: T.Protocol p => p -> P.IO User
read_User iprot = to_User <$> T.readVal iprot (T.T_STRUCT typemap_User)
decode_User :: T.StatelessProtocol p => p -> LBS.ByteString -> User
decode_User iprot bs = to_User $ T.deserializeVal iprot (T.T_STRUCT typemap_User) bs
typemap_User :: T.TypeMap
typemap_User = Map.fromList [(1,("id",T.T_I32)),(2,("username",T.T_STRING)),(3,("email",T.T_STRING)),(4,("name",T.T_STRING)),(6,("timezone",T.T_STRING)),(7,("privilege",T.T_I32)),(9,("created",T.T_I64)),(10,("updated",T.T_I64)),(11,("deleted",T.T_I64)),(13,("active",T.T_BOOL)),(14,("shardId",T.T_STRING)),(15,("attributes",(T.T_STRUCT typemap_UserAttributes))),(16,("accounting",(T.T_STRUCT typemap_Accounting))),(18,("businessUserInfo",(T.T_STRUCT typemap_BusinessUserInfo))),(19,("photoUrl",T.T_STRING)),(20,("photoLastUpdated",T.T_I64)),(21,("serviceLevel",T.T_I32)),(22,("accountLimits",(T.T_STRUCT typemap_AccountLimits)))]
default_User :: User
default_User = User{
  user_id = P.Nothing,
  user_username = P.Nothing,
  user_email = P.Nothing,
  user_name = P.Nothing,
  user_timezone = P.Nothing,
  user_privilege = P.Nothing,
  user_created = P.Nothing,
  user_updated = P.Nothing,
  user_deleted = P.Nothing,
  user_active = P.Nothing,
  user_shardId = P.Nothing,
  user_attributes = P.Nothing,
  user_accounting = P.Nothing,
  user_businessUserInfo = P.Nothing,
  user_photoUrl = P.Nothing,
  user_photoLastUpdated = P.Nothing,
  user_serviceLevel = P.Nothing,
  user_accountLimits = P.Nothing}
data Contact = Contact  { contact_name :: P.Maybe LT.Text
  , contact_id :: P.Maybe LT.Text
  , contact_type :: P.Maybe ContactType
  , contact_photoUrl :: P.Maybe LT.Text
  , contact_photoLastUpdated :: P.Maybe I.Int64
  , contact_messagingPermit :: P.Maybe LBS.ByteString
  , contact_messagingPermitExpires :: P.Maybe I.Int64
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Contact where
  hashWithSalt salt record = salt   `H.hashWithSalt` contact_name record   `H.hashWithSalt` contact_id record   `H.hashWithSalt` contact_type record   `H.hashWithSalt` contact_photoUrl record   `H.hashWithSalt` contact_photoLastUpdated record   `H.hashWithSalt` contact_messagingPermit record   `H.hashWithSalt` contact_messagingPermitExpires record  
instance QC.Arbitrary Contact where 
  arbitrary = M.liftM Contact (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_Contact = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Contact{contact_name = contact_name obj} then P.Nothing else P.Just $ default_Contact{contact_name = contact_name obj}
    , if obj == default_Contact{contact_id = contact_id obj} then P.Nothing else P.Just $ default_Contact{contact_id = contact_id obj}
    , if obj == default_Contact{contact_type = contact_type obj} then P.Nothing else P.Just $ default_Contact{contact_type = contact_type obj}
    , if obj == default_Contact{contact_photoUrl = contact_photoUrl obj} then P.Nothing else P.Just $ default_Contact{contact_photoUrl = contact_photoUrl obj}
    , if obj == default_Contact{contact_photoLastUpdated = contact_photoLastUpdated obj} then P.Nothing else P.Just $ default_Contact{contact_photoLastUpdated = contact_photoLastUpdated obj}
    , if obj == default_Contact{contact_messagingPermit = contact_messagingPermit obj} then P.Nothing else P.Just $ default_Contact{contact_messagingPermit = contact_messagingPermit obj}
    , if obj == default_Contact{contact_messagingPermitExpires = contact_messagingPermitExpires obj} then P.Nothing else P.Just $ default_Contact{contact_messagingPermitExpires = contact_messagingPermitExpires obj}
    ]
from_Contact :: Contact -> T.ThriftVal
from_Contact record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v146 -> (1, ("name",T.TString $ E.encodeUtf8 _v146))) <$> contact_name record
  , (\_v146 -> (2, ("id",T.TString $ E.encodeUtf8 _v146))) <$> contact_id record
  , (\_v146 -> (3, ("type",T.TI32 $ P.fromIntegral $ P.fromEnum _v146))) <$> contact_type record
  , (\_v146 -> (4, ("photoUrl",T.TString $ E.encodeUtf8 _v146))) <$> contact_photoUrl record
  , (\_v146 -> (5, ("photoLastUpdated",T.TI64 _v146))) <$> contact_photoLastUpdated record
  , (\_v146 -> (6, ("messagingPermit",T.TBinary _v146))) <$> contact_messagingPermit record
  , (\_v146 -> (7, ("messagingPermitExpires",T.TI64 _v146))) <$> contact_messagingPermitExpires record
  ]
write_Contact :: T.Protocol p => p -> Contact -> P.IO ()
write_Contact oprot record = T.writeVal oprot $ from_Contact record
encode_Contact :: T.StatelessProtocol p => p -> Contact -> LBS.ByteString
encode_Contact oprot record = T.serializeVal oprot $ from_Contact record
to_Contact :: T.ThriftVal -> Contact
to_Contact (T.TStruct fields) = Contact{
  contact_name = P.maybe (P.Nothing) (\(_,_val148) -> P.Just (case _val148 of {T.TString _val149 -> E.decodeUtf8 _val149; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  contact_id = P.maybe (P.Nothing) (\(_,_val148) -> P.Just (case _val148 of {T.TString _val150 -> E.decodeUtf8 _val150; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  contact_type = P.maybe (P.Nothing) (\(_,_val148) -> P.Just (case _val148 of {T.TI32 _val151 -> P.toEnum $ P.fromIntegral _val151; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  contact_photoUrl = P.maybe (P.Nothing) (\(_,_val148) -> P.Just (case _val148 of {T.TString _val152 -> E.decodeUtf8 _val152; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  contact_photoLastUpdated = P.maybe (P.Nothing) (\(_,_val148) -> P.Just (case _val148 of {T.TI64 _val153 -> _val153; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  contact_messagingPermit = P.maybe (P.Nothing) (\(_,_val148) -> P.Just (case _val148 of {T.TBinary _val154 -> _val154; T.TString _val154 -> _val154; _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  contact_messagingPermitExpires = P.maybe (P.Nothing) (\(_,_val148) -> P.Just (case _val148 of {T.TI64 _val155 -> _val155; _ -> P.error "wrong type"})) (Map.lookup (7) fields)
  }
to_Contact _ = P.error "not a struct"
read_Contact :: T.Protocol p => p -> P.IO Contact
read_Contact iprot = to_Contact <$> T.readVal iprot (T.T_STRUCT typemap_Contact)
decode_Contact :: T.StatelessProtocol p => p -> LBS.ByteString -> Contact
decode_Contact iprot bs = to_Contact $ T.deserializeVal iprot (T.T_STRUCT typemap_Contact) bs
typemap_Contact :: T.TypeMap
typemap_Contact = Map.fromList [(1,("name",T.T_STRING)),(2,("id",T.T_STRING)),(3,("type",T.T_I32)),(4,("photoUrl",T.T_STRING)),(5,("photoLastUpdated",T.T_I64)),(6,("messagingPermit",T.T_BINARY)),(7,("messagingPermitExpires",T.T_I64))]
default_Contact :: Contact
default_Contact = Contact{
  contact_name = P.Nothing,
  contact_id = P.Nothing,
  contact_type = P.Nothing,
  contact_photoUrl = P.Nothing,
  contact_photoLastUpdated = P.Nothing,
  contact_messagingPermit = P.Nothing,
  contact_messagingPermitExpires = P.Nothing}
data Identity = Identity  { identity_id :: I.Int64
  , identity_contact :: P.Maybe Contact
  , identity_userId :: P.Maybe I.Int32
  , identity_deactivated :: P.Maybe P.Bool
  , identity_sameBusiness :: P.Maybe P.Bool
  , identity_blocked :: P.Maybe P.Bool
  , identity_userConnected :: P.Maybe P.Bool
  , identity_eventId :: P.Maybe I.Int64
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Identity where
  hashWithSalt salt record = salt   `H.hashWithSalt` identity_id record   `H.hashWithSalt` identity_contact record   `H.hashWithSalt` identity_userId record   `H.hashWithSalt` identity_deactivated record   `H.hashWithSalt` identity_sameBusiness record   `H.hashWithSalt` identity_blocked record   `H.hashWithSalt` identity_userConnected record   `H.hashWithSalt` identity_eventId record  
instance QC.Arbitrary Identity where 
  arbitrary = M.liftM Identity (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_Identity = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Identity{identity_id = identity_id obj} then P.Nothing else P.Just $ default_Identity{identity_id = identity_id obj}
    , if obj == default_Identity{identity_contact = identity_contact obj} then P.Nothing else P.Just $ default_Identity{identity_contact = identity_contact obj}
    , if obj == default_Identity{identity_userId = identity_userId obj} then P.Nothing else P.Just $ default_Identity{identity_userId = identity_userId obj}
    , if obj == default_Identity{identity_deactivated = identity_deactivated obj} then P.Nothing else P.Just $ default_Identity{identity_deactivated = identity_deactivated obj}
    , if obj == default_Identity{identity_sameBusiness = identity_sameBusiness obj} then P.Nothing else P.Just $ default_Identity{identity_sameBusiness = identity_sameBusiness obj}
    , if obj == default_Identity{identity_blocked = identity_blocked obj} then P.Nothing else P.Just $ default_Identity{identity_blocked = identity_blocked obj}
    , if obj == default_Identity{identity_userConnected = identity_userConnected obj} then P.Nothing else P.Just $ default_Identity{identity_userConnected = identity_userConnected obj}
    , if obj == default_Identity{identity_eventId = identity_eventId obj} then P.Nothing else P.Just $ default_Identity{identity_eventId = identity_eventId obj}
    ]
from_Identity :: Identity -> T.ThriftVal
from_Identity record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v158 -> P.Just (1, ("id",T.TI64 _v158))) $ identity_id record
  , (\_v158 -> (2, ("contact",from_Contact _v158))) <$> identity_contact record
  , (\_v158 -> (3, ("userId",T.TI32 _v158))) <$> identity_userId record
  , (\_v158 -> (4, ("deactivated",T.TBool _v158))) <$> identity_deactivated record
  , (\_v158 -> (5, ("sameBusiness",T.TBool _v158))) <$> identity_sameBusiness record
  , (\_v158 -> (6, ("blocked",T.TBool _v158))) <$> identity_blocked record
  , (\_v158 -> (7, ("userConnected",T.TBool _v158))) <$> identity_userConnected record
  , (\_v158 -> (8, ("eventId",T.TI64 _v158))) <$> identity_eventId record
  ]
write_Identity :: T.Protocol p => p -> Identity -> P.IO ()
write_Identity oprot record = T.writeVal oprot $ from_Identity record
encode_Identity :: T.StatelessProtocol p => p -> Identity -> LBS.ByteString
encode_Identity oprot record = T.serializeVal oprot $ from_Identity record
to_Identity :: T.ThriftVal -> Identity
to_Identity (T.TStruct fields) = Identity{
  identity_id = P.maybe (P.error "Missing required field: id") (\(_,_val160) -> (case _val160 of {T.TI64 _val161 -> _val161; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  identity_contact = P.maybe (P.Nothing) (\(_,_val160) -> P.Just (case _val160 of {T.TStruct _val162 -> (to_Contact (T.TStruct _val162)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  identity_userId = P.maybe (P.Nothing) (\(_,_val160) -> P.Just (case _val160 of {T.TI32 _val163 -> _val163; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  identity_deactivated = P.maybe (P.Nothing) (\(_,_val160) -> P.Just (case _val160 of {T.TBool _val164 -> _val164; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  identity_sameBusiness = P.maybe (P.Nothing) (\(_,_val160) -> P.Just (case _val160 of {T.TBool _val165 -> _val165; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  identity_blocked = P.maybe (P.Nothing) (\(_,_val160) -> P.Just (case _val160 of {T.TBool _val166 -> _val166; _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  identity_userConnected = P.maybe (P.Nothing) (\(_,_val160) -> P.Just (case _val160 of {T.TBool _val167 -> _val167; _ -> P.error "wrong type"})) (Map.lookup (7) fields),
  identity_eventId = P.maybe (P.Nothing) (\(_,_val160) -> P.Just (case _val160 of {T.TI64 _val168 -> _val168; _ -> P.error "wrong type"})) (Map.lookup (8) fields)
  }
to_Identity _ = P.error "not a struct"
read_Identity :: T.Protocol p => p -> P.IO Identity
read_Identity iprot = to_Identity <$> T.readVal iprot (T.T_STRUCT typemap_Identity)
decode_Identity :: T.StatelessProtocol p => p -> LBS.ByteString -> Identity
decode_Identity iprot bs = to_Identity $ T.deserializeVal iprot (T.T_STRUCT typemap_Identity) bs
typemap_Identity :: T.TypeMap
typemap_Identity = Map.fromList [(1,("id",T.T_I64)),(2,("contact",(T.T_STRUCT typemap_Contact))),(3,("userId",T.T_I32)),(4,("deactivated",T.T_BOOL)),(5,("sameBusiness",T.T_BOOL)),(6,("blocked",T.T_BOOL)),(7,("userConnected",T.T_BOOL)),(8,("eventId",T.T_I64))]
default_Identity :: Identity
default_Identity = Identity{
  identity_id = 0,
  identity_contact = P.Nothing,
  identity_userId = P.Nothing,
  identity_deactivated = P.Nothing,
  identity_sameBusiness = P.Nothing,
  identity_blocked = P.Nothing,
  identity_userConnected = P.Nothing,
  identity_eventId = P.Nothing}
data Tag = Tag  { tag_guid :: P.Maybe LT.Text
  , tag_name :: P.Maybe LT.Text
  , tag_parentGuid :: P.Maybe LT.Text
  , tag_updateSequenceNum :: P.Maybe I.Int32
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Tag where
  hashWithSalt salt record = salt   `H.hashWithSalt` tag_guid record   `H.hashWithSalt` tag_name record   `H.hashWithSalt` tag_parentGuid record   `H.hashWithSalt` tag_updateSequenceNum record  
instance QC.Arbitrary Tag where 
  arbitrary = M.liftM Tag (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_Tag = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Tag{tag_guid = tag_guid obj} then P.Nothing else P.Just $ default_Tag{tag_guid = tag_guid obj}
    , if obj == default_Tag{tag_name = tag_name obj} then P.Nothing else P.Just $ default_Tag{tag_name = tag_name obj}
    , if obj == default_Tag{tag_parentGuid = tag_parentGuid obj} then P.Nothing else P.Just $ default_Tag{tag_parentGuid = tag_parentGuid obj}
    , if obj == default_Tag{tag_updateSequenceNum = tag_updateSequenceNum obj} then P.Nothing else P.Just $ default_Tag{tag_updateSequenceNum = tag_updateSequenceNum obj}
    ]
from_Tag :: Tag -> T.ThriftVal
from_Tag record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v171 -> (1, ("guid",T.TString $ E.encodeUtf8 _v171))) <$> tag_guid record
  , (\_v171 -> (2, ("name",T.TString $ E.encodeUtf8 _v171))) <$> tag_name record
  , (\_v171 -> (3, ("parentGuid",T.TString $ E.encodeUtf8 _v171))) <$> tag_parentGuid record
  , (\_v171 -> (4, ("updateSequenceNum",T.TI32 _v171))) <$> tag_updateSequenceNum record
  ]
write_Tag :: T.Protocol p => p -> Tag -> P.IO ()
write_Tag oprot record = T.writeVal oprot $ from_Tag record
encode_Tag :: T.StatelessProtocol p => p -> Tag -> LBS.ByteString
encode_Tag oprot record = T.serializeVal oprot $ from_Tag record
to_Tag :: T.ThriftVal -> Tag
to_Tag (T.TStruct fields) = Tag{
  tag_guid = P.maybe (P.Nothing) (\(_,_val173) -> P.Just (case _val173 of {T.TString _val174 -> E.decodeUtf8 _val174; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  tag_name = P.maybe (P.Nothing) (\(_,_val173) -> P.Just (case _val173 of {T.TString _val175 -> E.decodeUtf8 _val175; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  tag_parentGuid = P.maybe (P.Nothing) (\(_,_val173) -> P.Just (case _val173 of {T.TString _val176 -> E.decodeUtf8 _val176; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  tag_updateSequenceNum = P.maybe (P.Nothing) (\(_,_val173) -> P.Just (case _val173 of {T.TI32 _val177 -> _val177; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_Tag _ = P.error "not a struct"
read_Tag :: T.Protocol p => p -> P.IO Tag
read_Tag iprot = to_Tag <$> T.readVal iprot (T.T_STRUCT typemap_Tag)
decode_Tag :: T.StatelessProtocol p => p -> LBS.ByteString -> Tag
decode_Tag iprot bs = to_Tag $ T.deserializeVal iprot (T.T_STRUCT typemap_Tag) bs
typemap_Tag :: T.TypeMap
typemap_Tag = Map.fromList [(1,("guid",T.T_STRING)),(2,("name",T.T_STRING)),(3,("parentGuid",T.T_STRING)),(4,("updateSequenceNum",T.T_I32))]
default_Tag :: Tag
default_Tag = Tag{
  tag_guid = P.Nothing,
  tag_name = P.Nothing,
  tag_parentGuid = P.Nothing,
  tag_updateSequenceNum = P.Nothing}
data LazyMap = LazyMap  { lazyMap_keysOnly :: P.Maybe (Set.HashSet LT.Text)
  , lazyMap_fullMap :: P.Maybe (Map.HashMap LT.Text LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable LazyMap where
  hashWithSalt salt record = salt   `H.hashWithSalt` lazyMap_keysOnly record   `H.hashWithSalt` lazyMap_fullMap record  
instance QC.Arbitrary LazyMap where 
  arbitrary = M.liftM LazyMap (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_LazyMap = []
             | P.otherwise = M.catMaybes
    [ if obj == default_LazyMap{lazyMap_keysOnly = lazyMap_keysOnly obj} then P.Nothing else P.Just $ default_LazyMap{lazyMap_keysOnly = lazyMap_keysOnly obj}
    , if obj == default_LazyMap{lazyMap_fullMap = lazyMap_fullMap obj} then P.Nothing else P.Just $ default_LazyMap{lazyMap_fullMap = lazyMap_fullMap obj}
    ]
from_LazyMap :: LazyMap -> T.ThriftVal
from_LazyMap record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v180 -> (1, ("keysOnly",T.TSet T.T_STRING $ P.map (\_v182 -> T.TString $ E.encodeUtf8 _v182) $ Set.toList _v180))) <$> lazyMap_keysOnly record
  , (\_v180 -> (2, ("fullMap",T.TMap T.T_STRING T.T_STRING $ P.map (\(_k183,_v184) -> (T.TString $ E.encodeUtf8 _k183, T.TString $ E.encodeUtf8 _v184)) $ Map.toList _v180))) <$> lazyMap_fullMap record
  ]
write_LazyMap :: T.Protocol p => p -> LazyMap -> P.IO ()
write_LazyMap oprot record = T.writeVal oprot $ from_LazyMap record
encode_LazyMap :: T.StatelessProtocol p => p -> LazyMap -> LBS.ByteString
encode_LazyMap oprot record = T.serializeVal oprot $ from_LazyMap record
to_LazyMap :: T.ThriftVal -> LazyMap
to_LazyMap (T.TStruct fields) = LazyMap{
  lazyMap_keysOnly = P.maybe (P.Nothing) (\(_,_val186) -> P.Just (case _val186 of {T.TSet _ _val187 -> (Set.fromList $ P.map (\_v188 -> (case _v188 of {T.TString _val189 -> E.decodeUtf8 _val189; _ -> P.error "wrong type"})) _val187); _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  lazyMap_fullMap = P.maybe (P.Nothing) (\(_,_val186) -> P.Just (case _val186 of {T.TMap _ _ _val190 -> (Map.fromList $ P.map (\(_k192,_v191) -> ((case _k192 of {T.TString _val193 -> E.decodeUtf8 _val193; _ -> P.error "wrong type"}),(case _v191 of {T.TString _val194 -> E.decodeUtf8 _val194; _ -> P.error "wrong type"}))) _val190); _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_LazyMap _ = P.error "not a struct"
read_LazyMap :: T.Protocol p => p -> P.IO LazyMap
read_LazyMap iprot = to_LazyMap <$> T.readVal iprot (T.T_STRUCT typemap_LazyMap)
decode_LazyMap :: T.StatelessProtocol p => p -> LBS.ByteString -> LazyMap
decode_LazyMap iprot bs = to_LazyMap $ T.deserializeVal iprot (T.T_STRUCT typemap_LazyMap) bs
typemap_LazyMap :: T.TypeMap
typemap_LazyMap = Map.fromList [(1,("keysOnly",(T.T_SET T.T_STRING))),(2,("fullMap",(T.T_MAP T.T_STRING T.T_STRING)))]
default_LazyMap :: LazyMap
default_LazyMap = LazyMap{
  lazyMap_keysOnly = P.Nothing,
  lazyMap_fullMap = P.Nothing}
data ResourceAttributes = ResourceAttributes  { resourceAttributes_sourceURL :: P.Maybe LT.Text
  , resourceAttributes_timestamp :: P.Maybe I.Int64
  , resourceAttributes_latitude :: P.Maybe P.Double
  , resourceAttributes_longitude :: P.Maybe P.Double
  , resourceAttributes_altitude :: P.Maybe P.Double
  , resourceAttributes_cameraMake :: P.Maybe LT.Text
  , resourceAttributes_cameraModel :: P.Maybe LT.Text
  , resourceAttributes_clientWillIndex :: P.Maybe P.Bool
  , resourceAttributes_recoType :: P.Maybe LT.Text
  , resourceAttributes_fileName :: P.Maybe LT.Text
  , resourceAttributes_attachment :: P.Maybe P.Bool
  , resourceAttributes_applicationData :: P.Maybe LazyMap
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable ResourceAttributes where
  hashWithSalt salt record = salt   `H.hashWithSalt` resourceAttributes_sourceURL record   `H.hashWithSalt` resourceAttributes_timestamp record   `H.hashWithSalt` resourceAttributes_latitude record   `H.hashWithSalt` resourceAttributes_longitude record   `H.hashWithSalt` resourceAttributes_altitude record   `H.hashWithSalt` resourceAttributes_cameraMake record   `H.hashWithSalt` resourceAttributes_cameraModel record   `H.hashWithSalt` resourceAttributes_clientWillIndex record   `H.hashWithSalt` resourceAttributes_recoType record   `H.hashWithSalt` resourceAttributes_fileName record   `H.hashWithSalt` resourceAttributes_attachment record   `H.hashWithSalt` resourceAttributes_applicationData record  
instance QC.Arbitrary ResourceAttributes where 
  arbitrary = M.liftM ResourceAttributes (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_ResourceAttributes = []
             | P.otherwise = M.catMaybes
    [ if obj == default_ResourceAttributes{resourceAttributes_sourceURL = resourceAttributes_sourceURL obj} then P.Nothing else P.Just $ default_ResourceAttributes{resourceAttributes_sourceURL = resourceAttributes_sourceURL obj}
    , if obj == default_ResourceAttributes{resourceAttributes_timestamp = resourceAttributes_timestamp obj} then P.Nothing else P.Just $ default_ResourceAttributes{resourceAttributes_timestamp = resourceAttributes_timestamp obj}
    , if obj == default_ResourceAttributes{resourceAttributes_latitude = resourceAttributes_latitude obj} then P.Nothing else P.Just $ default_ResourceAttributes{resourceAttributes_latitude = resourceAttributes_latitude obj}
    , if obj == default_ResourceAttributes{resourceAttributes_longitude = resourceAttributes_longitude obj} then P.Nothing else P.Just $ default_ResourceAttributes{resourceAttributes_longitude = resourceAttributes_longitude obj}
    , if obj == default_ResourceAttributes{resourceAttributes_altitude = resourceAttributes_altitude obj} then P.Nothing else P.Just $ default_ResourceAttributes{resourceAttributes_altitude = resourceAttributes_altitude obj}
    , if obj == default_ResourceAttributes{resourceAttributes_cameraMake = resourceAttributes_cameraMake obj} then P.Nothing else P.Just $ default_ResourceAttributes{resourceAttributes_cameraMake = resourceAttributes_cameraMake obj}
    , if obj == default_ResourceAttributes{resourceAttributes_cameraModel = resourceAttributes_cameraModel obj} then P.Nothing else P.Just $ default_ResourceAttributes{resourceAttributes_cameraModel = resourceAttributes_cameraModel obj}
    , if obj == default_ResourceAttributes{resourceAttributes_clientWillIndex = resourceAttributes_clientWillIndex obj} then P.Nothing else P.Just $ default_ResourceAttributes{resourceAttributes_clientWillIndex = resourceAttributes_clientWillIndex obj}
    , if obj == default_ResourceAttributes{resourceAttributes_recoType = resourceAttributes_recoType obj} then P.Nothing else P.Just $ default_ResourceAttributes{resourceAttributes_recoType = resourceAttributes_recoType obj}
    , if obj == default_ResourceAttributes{resourceAttributes_fileName = resourceAttributes_fileName obj} then P.Nothing else P.Just $ default_ResourceAttributes{resourceAttributes_fileName = resourceAttributes_fileName obj}
    , if obj == default_ResourceAttributes{resourceAttributes_attachment = resourceAttributes_attachment obj} then P.Nothing else P.Just $ default_ResourceAttributes{resourceAttributes_attachment = resourceAttributes_attachment obj}
    , if obj == default_ResourceAttributes{resourceAttributes_applicationData = resourceAttributes_applicationData obj} then P.Nothing else P.Just $ default_ResourceAttributes{resourceAttributes_applicationData = resourceAttributes_applicationData obj}
    ]
from_ResourceAttributes :: ResourceAttributes -> T.ThriftVal
from_ResourceAttributes record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v197 -> (1, ("sourceURL",T.TString $ E.encodeUtf8 _v197))) <$> resourceAttributes_sourceURL record
  , (\_v197 -> (2, ("timestamp",T.TI64 _v197))) <$> resourceAttributes_timestamp record
  , (\_v197 -> (3, ("latitude",T.TDouble _v197))) <$> resourceAttributes_latitude record
  , (\_v197 -> (4, ("longitude",T.TDouble _v197))) <$> resourceAttributes_longitude record
  , (\_v197 -> (5, ("altitude",T.TDouble _v197))) <$> resourceAttributes_altitude record
  , (\_v197 -> (6, ("cameraMake",T.TString $ E.encodeUtf8 _v197))) <$> resourceAttributes_cameraMake record
  , (\_v197 -> (7, ("cameraModel",T.TString $ E.encodeUtf8 _v197))) <$> resourceAttributes_cameraModel record
  , (\_v197 -> (8, ("clientWillIndex",T.TBool _v197))) <$> resourceAttributes_clientWillIndex record
  , (\_v197 -> (9, ("recoType",T.TString $ E.encodeUtf8 _v197))) <$> resourceAttributes_recoType record
  , (\_v197 -> (10, ("fileName",T.TString $ E.encodeUtf8 _v197))) <$> resourceAttributes_fileName record
  , (\_v197 -> (11, ("attachment",T.TBool _v197))) <$> resourceAttributes_attachment record
  , (\_v197 -> (12, ("applicationData",from_LazyMap _v197))) <$> resourceAttributes_applicationData record
  ]
write_ResourceAttributes :: T.Protocol p => p -> ResourceAttributes -> P.IO ()
write_ResourceAttributes oprot record = T.writeVal oprot $ from_ResourceAttributes record
encode_ResourceAttributes :: T.StatelessProtocol p => p -> ResourceAttributes -> LBS.ByteString
encode_ResourceAttributes oprot record = T.serializeVal oprot $ from_ResourceAttributes record
to_ResourceAttributes :: T.ThriftVal -> ResourceAttributes
to_ResourceAttributes (T.TStruct fields) = ResourceAttributes{
  resourceAttributes_sourceURL = P.maybe (P.Nothing) (\(_,_val199) -> P.Just (case _val199 of {T.TString _val200 -> E.decodeUtf8 _val200; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  resourceAttributes_timestamp = P.maybe (P.Nothing) (\(_,_val199) -> P.Just (case _val199 of {T.TI64 _val201 -> _val201; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  resourceAttributes_latitude = P.maybe (P.Nothing) (\(_,_val199) -> P.Just (case _val199 of {T.TDouble _val202 -> _val202; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  resourceAttributes_longitude = P.maybe (P.Nothing) (\(_,_val199) -> P.Just (case _val199 of {T.TDouble _val203 -> _val203; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  resourceAttributes_altitude = P.maybe (P.Nothing) (\(_,_val199) -> P.Just (case _val199 of {T.TDouble _val204 -> _val204; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  resourceAttributes_cameraMake = P.maybe (P.Nothing) (\(_,_val199) -> P.Just (case _val199 of {T.TString _val205 -> E.decodeUtf8 _val205; _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  resourceAttributes_cameraModel = P.maybe (P.Nothing) (\(_,_val199) -> P.Just (case _val199 of {T.TString _val206 -> E.decodeUtf8 _val206; _ -> P.error "wrong type"})) (Map.lookup (7) fields),
  resourceAttributes_clientWillIndex = P.maybe (P.Nothing) (\(_,_val199) -> P.Just (case _val199 of {T.TBool _val207 -> _val207; _ -> P.error "wrong type"})) (Map.lookup (8) fields),
  resourceAttributes_recoType = P.maybe (P.Nothing) (\(_,_val199) -> P.Just (case _val199 of {T.TString _val208 -> E.decodeUtf8 _val208; _ -> P.error "wrong type"})) (Map.lookup (9) fields),
  resourceAttributes_fileName = P.maybe (P.Nothing) (\(_,_val199) -> P.Just (case _val199 of {T.TString _val209 -> E.decodeUtf8 _val209; _ -> P.error "wrong type"})) (Map.lookup (10) fields),
  resourceAttributes_attachment = P.maybe (P.Nothing) (\(_,_val199) -> P.Just (case _val199 of {T.TBool _val210 -> _val210; _ -> P.error "wrong type"})) (Map.lookup (11) fields),
  resourceAttributes_applicationData = P.maybe (P.Nothing) (\(_,_val199) -> P.Just (case _val199 of {T.TStruct _val211 -> (to_LazyMap (T.TStruct _val211)); _ -> P.error "wrong type"})) (Map.lookup (12) fields)
  }
to_ResourceAttributes _ = P.error "not a struct"
read_ResourceAttributes :: T.Protocol p => p -> P.IO ResourceAttributes
read_ResourceAttributes iprot = to_ResourceAttributes <$> T.readVal iprot (T.T_STRUCT typemap_ResourceAttributes)
decode_ResourceAttributes :: T.StatelessProtocol p => p -> LBS.ByteString -> ResourceAttributes
decode_ResourceAttributes iprot bs = to_ResourceAttributes $ T.deserializeVal iprot (T.T_STRUCT typemap_ResourceAttributes) bs
typemap_ResourceAttributes :: T.TypeMap
typemap_ResourceAttributes = Map.fromList [(1,("sourceURL",T.T_STRING)),(2,("timestamp",T.T_I64)),(3,("latitude",T.T_DOUBLE)),(4,("longitude",T.T_DOUBLE)),(5,("altitude",T.T_DOUBLE)),(6,("cameraMake",T.T_STRING)),(7,("cameraModel",T.T_STRING)),(8,("clientWillIndex",T.T_BOOL)),(9,("recoType",T.T_STRING)),(10,("fileName",T.T_STRING)),(11,("attachment",T.T_BOOL)),(12,("applicationData",(T.T_STRUCT typemap_LazyMap)))]
default_ResourceAttributes :: ResourceAttributes
default_ResourceAttributes = ResourceAttributes{
  resourceAttributes_sourceURL = P.Nothing,
  resourceAttributes_timestamp = P.Nothing,
  resourceAttributes_latitude = P.Nothing,
  resourceAttributes_longitude = P.Nothing,
  resourceAttributes_altitude = P.Nothing,
  resourceAttributes_cameraMake = P.Nothing,
  resourceAttributes_cameraModel = P.Nothing,
  resourceAttributes_clientWillIndex = P.Nothing,
  resourceAttributes_recoType = P.Nothing,
  resourceAttributes_fileName = P.Nothing,
  resourceAttributes_attachment = P.Nothing,
  resourceAttributes_applicationData = P.Nothing}
data Resource = Resource  { resource_guid :: P.Maybe LT.Text
  , resource_noteGuid :: P.Maybe LT.Text
  , resource_data :: P.Maybe Data
  , resource_mime :: P.Maybe LT.Text
  , resource_width :: P.Maybe I.Int16
  , resource_height :: P.Maybe I.Int16
  , resource_duration :: P.Maybe I.Int16
  , resource_active :: P.Maybe P.Bool
  , resource_recognition :: P.Maybe Data
  , resource_attributes :: P.Maybe ResourceAttributes
  , resource_updateSequenceNum :: P.Maybe I.Int32
  , resource_alternateData :: P.Maybe Data
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Resource where
  hashWithSalt salt record = salt   `H.hashWithSalt` resource_guid record   `H.hashWithSalt` resource_noteGuid record   `H.hashWithSalt` resource_data record   `H.hashWithSalt` resource_mime record   `H.hashWithSalt` resource_width record   `H.hashWithSalt` resource_height record   `H.hashWithSalt` resource_duration record   `H.hashWithSalt` resource_active record   `H.hashWithSalt` resource_recognition record   `H.hashWithSalt` resource_attributes record   `H.hashWithSalt` resource_updateSequenceNum record   `H.hashWithSalt` resource_alternateData record  
instance QC.Arbitrary Resource where 
  arbitrary = M.liftM Resource (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_Resource = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Resource{resource_guid = resource_guid obj} then P.Nothing else P.Just $ default_Resource{resource_guid = resource_guid obj}
    , if obj == default_Resource{resource_noteGuid = resource_noteGuid obj} then P.Nothing else P.Just $ default_Resource{resource_noteGuid = resource_noteGuid obj}
    , if obj == default_Resource{resource_data = resource_data obj} then P.Nothing else P.Just $ default_Resource{resource_data = resource_data obj}
    , if obj == default_Resource{resource_mime = resource_mime obj} then P.Nothing else P.Just $ default_Resource{resource_mime = resource_mime obj}
    , if obj == default_Resource{resource_width = resource_width obj} then P.Nothing else P.Just $ default_Resource{resource_width = resource_width obj}
    , if obj == default_Resource{resource_height = resource_height obj} then P.Nothing else P.Just $ default_Resource{resource_height = resource_height obj}
    , if obj == default_Resource{resource_duration = resource_duration obj} then P.Nothing else P.Just $ default_Resource{resource_duration = resource_duration obj}
    , if obj == default_Resource{resource_active = resource_active obj} then P.Nothing else P.Just $ default_Resource{resource_active = resource_active obj}
    , if obj == default_Resource{resource_recognition = resource_recognition obj} then P.Nothing else P.Just $ default_Resource{resource_recognition = resource_recognition obj}
    , if obj == default_Resource{resource_attributes = resource_attributes obj} then P.Nothing else P.Just $ default_Resource{resource_attributes = resource_attributes obj}
    , if obj == default_Resource{resource_updateSequenceNum = resource_updateSequenceNum obj} then P.Nothing else P.Just $ default_Resource{resource_updateSequenceNum = resource_updateSequenceNum obj}
    , if obj == default_Resource{resource_alternateData = resource_alternateData obj} then P.Nothing else P.Just $ default_Resource{resource_alternateData = resource_alternateData obj}
    ]
from_Resource :: Resource -> T.ThriftVal
from_Resource record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v214 -> (1, ("guid",T.TString $ E.encodeUtf8 _v214))) <$> resource_guid record
  , (\_v214 -> (2, ("noteGuid",T.TString $ E.encodeUtf8 _v214))) <$> resource_noteGuid record
  , (\_v214 -> (3, ("data",from_Data _v214))) <$> resource_data record
  , (\_v214 -> (4, ("mime",T.TString $ E.encodeUtf8 _v214))) <$> resource_mime record
  , (\_v214 -> (5, ("width",T.TI16 _v214))) <$> resource_width record
  , (\_v214 -> (6, ("height",T.TI16 _v214))) <$> resource_height record
  , (\_v214 -> (7, ("duration",T.TI16 _v214))) <$> resource_duration record
  , (\_v214 -> (8, ("active",T.TBool _v214))) <$> resource_active record
  , (\_v214 -> (9, ("recognition",from_Data _v214))) <$> resource_recognition record
  , (\_v214 -> (11, ("attributes",from_ResourceAttributes _v214))) <$> resource_attributes record
  , (\_v214 -> (12, ("updateSequenceNum",T.TI32 _v214))) <$> resource_updateSequenceNum record
  , (\_v214 -> (13, ("alternateData",from_Data _v214))) <$> resource_alternateData record
  ]
write_Resource :: T.Protocol p => p -> Resource -> P.IO ()
write_Resource oprot record = T.writeVal oprot $ from_Resource record
encode_Resource :: T.StatelessProtocol p => p -> Resource -> LBS.ByteString
encode_Resource oprot record = T.serializeVal oprot $ from_Resource record
to_Resource :: T.ThriftVal -> Resource
to_Resource (T.TStruct fields) = Resource{
  resource_guid = P.maybe (P.Nothing) (\(_,_val216) -> P.Just (case _val216 of {T.TString _val217 -> E.decodeUtf8 _val217; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  resource_noteGuid = P.maybe (P.Nothing) (\(_,_val216) -> P.Just (case _val216 of {T.TString _val218 -> E.decodeUtf8 _val218; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  resource_data = P.maybe (P.Nothing) (\(_,_val216) -> P.Just (case _val216 of {T.TStruct _val219 -> (to_Data (T.TStruct _val219)); _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  resource_mime = P.maybe (P.Nothing) (\(_,_val216) -> P.Just (case _val216 of {T.TString _val220 -> E.decodeUtf8 _val220; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  resource_width = P.maybe (P.Nothing) (\(_,_val216) -> P.Just (case _val216 of {T.TI16 _val221 -> _val221; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  resource_height = P.maybe (P.Nothing) (\(_,_val216) -> P.Just (case _val216 of {T.TI16 _val222 -> _val222; _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  resource_duration = P.maybe (P.Nothing) (\(_,_val216) -> P.Just (case _val216 of {T.TI16 _val223 -> _val223; _ -> P.error "wrong type"})) (Map.lookup (7) fields),
  resource_active = P.maybe (P.Nothing) (\(_,_val216) -> P.Just (case _val216 of {T.TBool _val224 -> _val224; _ -> P.error "wrong type"})) (Map.lookup (8) fields),
  resource_recognition = P.maybe (P.Nothing) (\(_,_val216) -> P.Just (case _val216 of {T.TStruct _val225 -> (to_Data (T.TStruct _val225)); _ -> P.error "wrong type"})) (Map.lookup (9) fields),
  resource_attributes = P.maybe (P.Nothing) (\(_,_val216) -> P.Just (case _val216 of {T.TStruct _val226 -> (to_ResourceAttributes (T.TStruct _val226)); _ -> P.error "wrong type"})) (Map.lookup (11) fields),
  resource_updateSequenceNum = P.maybe (P.Nothing) (\(_,_val216) -> P.Just (case _val216 of {T.TI32 _val227 -> _val227; _ -> P.error "wrong type"})) (Map.lookup (12) fields),
  resource_alternateData = P.maybe (P.Nothing) (\(_,_val216) -> P.Just (case _val216 of {T.TStruct _val228 -> (to_Data (T.TStruct _val228)); _ -> P.error "wrong type"})) (Map.lookup (13) fields)
  }
to_Resource _ = P.error "not a struct"
read_Resource :: T.Protocol p => p -> P.IO Resource
read_Resource iprot = to_Resource <$> T.readVal iprot (T.T_STRUCT typemap_Resource)
decode_Resource :: T.StatelessProtocol p => p -> LBS.ByteString -> Resource
decode_Resource iprot bs = to_Resource $ T.deserializeVal iprot (T.T_STRUCT typemap_Resource) bs
typemap_Resource :: T.TypeMap
typemap_Resource = Map.fromList [(1,("guid",T.T_STRING)),(2,("noteGuid",T.T_STRING)),(3,("data",(T.T_STRUCT typemap_Data))),(4,("mime",T.T_STRING)),(5,("width",T.T_I16)),(6,("height",T.T_I16)),(7,("duration",T.T_I16)),(8,("active",T.T_BOOL)),(9,("recognition",(T.T_STRUCT typemap_Data))),(11,("attributes",(T.T_STRUCT typemap_ResourceAttributes))),(12,("updateSequenceNum",T.T_I32)),(13,("alternateData",(T.T_STRUCT typemap_Data)))]
default_Resource :: Resource
default_Resource = Resource{
  resource_guid = P.Nothing,
  resource_noteGuid = P.Nothing,
  resource_data = P.Nothing,
  resource_mime = P.Nothing,
  resource_width = P.Nothing,
  resource_height = P.Nothing,
  resource_duration = P.Nothing,
  resource_active = P.Nothing,
  resource_recognition = P.Nothing,
  resource_attributes = P.Nothing,
  resource_updateSequenceNum = P.Nothing,
  resource_alternateData = P.Nothing}
data NoteAttributes = NoteAttributes  { noteAttributes_subjectDate :: P.Maybe I.Int64
  , noteAttributes_latitude :: P.Maybe P.Double
  , noteAttributes_longitude :: P.Maybe P.Double
  , noteAttributes_altitude :: P.Maybe P.Double
  , noteAttributes_author :: P.Maybe LT.Text
  , noteAttributes_source :: P.Maybe LT.Text
  , noteAttributes_sourceURL :: P.Maybe LT.Text
  , noteAttributes_sourceApplication :: P.Maybe LT.Text
  , noteAttributes_shareDate :: P.Maybe I.Int64
  , noteAttributes_reminderOrder :: P.Maybe I.Int64
  , noteAttributes_reminderDoneTime :: P.Maybe I.Int64
  , noteAttributes_reminderTime :: P.Maybe I.Int64
  , noteAttributes_placeName :: P.Maybe LT.Text
  , noteAttributes_contentClass :: P.Maybe LT.Text
  , noteAttributes_applicationData :: P.Maybe LazyMap
  , noteAttributes_lastEditedBy :: P.Maybe LT.Text
  , noteAttributes_classifications :: P.Maybe (Map.HashMap LT.Text LT.Text)
  , noteAttributes_creatorId :: P.Maybe I.Int32
  , noteAttributes_lastEditorId :: P.Maybe I.Int32
  , noteAttributes_sharedWithBusiness :: P.Maybe P.Bool
  , noteAttributes_conflictSourceNoteGuid :: P.Maybe LT.Text
  , noteAttributes_noteTitleQuality :: P.Maybe I.Int32
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable NoteAttributes where
  hashWithSalt salt record = salt   `H.hashWithSalt` noteAttributes_subjectDate record   `H.hashWithSalt` noteAttributes_latitude record   `H.hashWithSalt` noteAttributes_longitude record   `H.hashWithSalt` noteAttributes_altitude record   `H.hashWithSalt` noteAttributes_author record   `H.hashWithSalt` noteAttributes_source record   `H.hashWithSalt` noteAttributes_sourceURL record   `H.hashWithSalt` noteAttributes_sourceApplication record   `H.hashWithSalt` noteAttributes_shareDate record   `H.hashWithSalt` noteAttributes_reminderOrder record   `H.hashWithSalt` noteAttributes_reminderDoneTime record   `H.hashWithSalt` noteAttributes_reminderTime record   `H.hashWithSalt` noteAttributes_placeName record   `H.hashWithSalt` noteAttributes_contentClass record   `H.hashWithSalt` noteAttributes_applicationData record   `H.hashWithSalt` noteAttributes_lastEditedBy record   `H.hashWithSalt` noteAttributes_classifications record   `H.hashWithSalt` noteAttributes_creatorId record   `H.hashWithSalt` noteAttributes_lastEditorId record   `H.hashWithSalt` noteAttributes_sharedWithBusiness record   `H.hashWithSalt` noteAttributes_conflictSourceNoteGuid record   `H.hashWithSalt` noteAttributes_noteTitleQuality record  
instance QC.Arbitrary NoteAttributes where 
  arbitrary = M.liftM NoteAttributes (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_NoteAttributes = []
             | P.otherwise = M.catMaybes
    [ if obj == default_NoteAttributes{noteAttributes_subjectDate = noteAttributes_subjectDate obj} then P.Nothing else P.Just $ default_NoteAttributes{noteAttributes_subjectDate = noteAttributes_subjectDate obj}
    , if obj == default_NoteAttributes{noteAttributes_latitude = noteAttributes_latitude obj} then P.Nothing else P.Just $ default_NoteAttributes{noteAttributes_latitude = noteAttributes_latitude obj}
    , if obj == default_NoteAttributes{noteAttributes_longitude = noteAttributes_longitude obj} then P.Nothing else P.Just $ default_NoteAttributes{noteAttributes_longitude = noteAttributes_longitude obj}
    , if obj == default_NoteAttributes{noteAttributes_altitude = noteAttributes_altitude obj} then P.Nothing else P.Just $ default_NoteAttributes{noteAttributes_altitude = noteAttributes_altitude obj}
    , if obj == default_NoteAttributes{noteAttributes_author = noteAttributes_author obj} then P.Nothing else P.Just $ default_NoteAttributes{noteAttributes_author = noteAttributes_author obj}
    , if obj == default_NoteAttributes{noteAttributes_source = noteAttributes_source obj} then P.Nothing else P.Just $ default_NoteAttributes{noteAttributes_source = noteAttributes_source obj}
    , if obj == default_NoteAttributes{noteAttributes_sourceURL = noteAttributes_sourceURL obj} then P.Nothing else P.Just $ default_NoteAttributes{noteAttributes_sourceURL = noteAttributes_sourceURL obj}
    , if obj == default_NoteAttributes{noteAttributes_sourceApplication = noteAttributes_sourceApplication obj} then P.Nothing else P.Just $ default_NoteAttributes{noteAttributes_sourceApplication = noteAttributes_sourceApplication obj}
    , if obj == default_NoteAttributes{noteAttributes_shareDate = noteAttributes_shareDate obj} then P.Nothing else P.Just $ default_NoteAttributes{noteAttributes_shareDate = noteAttributes_shareDate obj}
    , if obj == default_NoteAttributes{noteAttributes_reminderOrder = noteAttributes_reminderOrder obj} then P.Nothing else P.Just $ default_NoteAttributes{noteAttributes_reminderOrder = noteAttributes_reminderOrder obj}
    , if obj == default_NoteAttributes{noteAttributes_reminderDoneTime = noteAttributes_reminderDoneTime obj} then P.Nothing else P.Just $ default_NoteAttributes{noteAttributes_reminderDoneTime = noteAttributes_reminderDoneTime obj}
    , if obj == default_NoteAttributes{noteAttributes_reminderTime = noteAttributes_reminderTime obj} then P.Nothing else P.Just $ default_NoteAttributes{noteAttributes_reminderTime = noteAttributes_reminderTime obj}
    , if obj == default_NoteAttributes{noteAttributes_placeName = noteAttributes_placeName obj} then P.Nothing else P.Just $ default_NoteAttributes{noteAttributes_placeName = noteAttributes_placeName obj}
    , if obj == default_NoteAttributes{noteAttributes_contentClass = noteAttributes_contentClass obj} then P.Nothing else P.Just $ default_NoteAttributes{noteAttributes_contentClass = noteAttributes_contentClass obj}
    , if obj == default_NoteAttributes{noteAttributes_applicationData = noteAttributes_applicationData obj} then P.Nothing else P.Just $ default_NoteAttributes{noteAttributes_applicationData = noteAttributes_applicationData obj}
    , if obj == default_NoteAttributes{noteAttributes_lastEditedBy = noteAttributes_lastEditedBy obj} then P.Nothing else P.Just $ default_NoteAttributes{noteAttributes_lastEditedBy = noteAttributes_lastEditedBy obj}
    , if obj == default_NoteAttributes{noteAttributes_classifications = noteAttributes_classifications obj} then P.Nothing else P.Just $ default_NoteAttributes{noteAttributes_classifications = noteAttributes_classifications obj}
    , if obj == default_NoteAttributes{noteAttributes_creatorId = noteAttributes_creatorId obj} then P.Nothing else P.Just $ default_NoteAttributes{noteAttributes_creatorId = noteAttributes_creatorId obj}
    , if obj == default_NoteAttributes{noteAttributes_lastEditorId = noteAttributes_lastEditorId obj} then P.Nothing else P.Just $ default_NoteAttributes{noteAttributes_lastEditorId = noteAttributes_lastEditorId obj}
    , if obj == default_NoteAttributes{noteAttributes_sharedWithBusiness = noteAttributes_sharedWithBusiness obj} then P.Nothing else P.Just $ default_NoteAttributes{noteAttributes_sharedWithBusiness = noteAttributes_sharedWithBusiness obj}
    , if obj == default_NoteAttributes{noteAttributes_conflictSourceNoteGuid = noteAttributes_conflictSourceNoteGuid obj} then P.Nothing else P.Just $ default_NoteAttributes{noteAttributes_conflictSourceNoteGuid = noteAttributes_conflictSourceNoteGuid obj}
    , if obj == default_NoteAttributes{noteAttributes_noteTitleQuality = noteAttributes_noteTitleQuality obj} then P.Nothing else P.Just $ default_NoteAttributes{noteAttributes_noteTitleQuality = noteAttributes_noteTitleQuality obj}
    ]
from_NoteAttributes :: NoteAttributes -> T.ThriftVal
from_NoteAttributes record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v231 -> (1, ("subjectDate",T.TI64 _v231))) <$> noteAttributes_subjectDate record
  , (\_v231 -> (10, ("latitude",T.TDouble _v231))) <$> noteAttributes_latitude record
  , (\_v231 -> (11, ("longitude",T.TDouble _v231))) <$> noteAttributes_longitude record
  , (\_v231 -> (12, ("altitude",T.TDouble _v231))) <$> noteAttributes_altitude record
  , (\_v231 -> (13, ("author",T.TString $ E.encodeUtf8 _v231))) <$> noteAttributes_author record
  , (\_v231 -> (14, ("source",T.TString $ E.encodeUtf8 _v231))) <$> noteAttributes_source record
  , (\_v231 -> (15, ("sourceURL",T.TString $ E.encodeUtf8 _v231))) <$> noteAttributes_sourceURL record
  , (\_v231 -> (16, ("sourceApplication",T.TString $ E.encodeUtf8 _v231))) <$> noteAttributes_sourceApplication record
  , (\_v231 -> (17, ("shareDate",T.TI64 _v231))) <$> noteAttributes_shareDate record
  , (\_v231 -> (18, ("reminderOrder",T.TI64 _v231))) <$> noteAttributes_reminderOrder record
  , (\_v231 -> (19, ("reminderDoneTime",T.TI64 _v231))) <$> noteAttributes_reminderDoneTime record
  , (\_v231 -> (20, ("reminderTime",T.TI64 _v231))) <$> noteAttributes_reminderTime record
  , (\_v231 -> (21, ("placeName",T.TString $ E.encodeUtf8 _v231))) <$> noteAttributes_placeName record
  , (\_v231 -> (22, ("contentClass",T.TString $ E.encodeUtf8 _v231))) <$> noteAttributes_contentClass record
  , (\_v231 -> (23, ("applicationData",from_LazyMap _v231))) <$> noteAttributes_applicationData record
  , (\_v231 -> (24, ("lastEditedBy",T.TString $ E.encodeUtf8 _v231))) <$> noteAttributes_lastEditedBy record
  , (\_v231 -> (26, ("classifications",T.TMap T.T_STRING T.T_STRING $ P.map (\(_k232,_v233) -> (T.TString $ E.encodeUtf8 _k232, T.TString $ E.encodeUtf8 _v233)) $ Map.toList _v231))) <$> noteAttributes_classifications record
  , (\_v231 -> (27, ("creatorId",T.TI32 _v231))) <$> noteAttributes_creatorId record
  , (\_v231 -> (28, ("lastEditorId",T.TI32 _v231))) <$> noteAttributes_lastEditorId record
  , (\_v231 -> (29, ("sharedWithBusiness",T.TBool _v231))) <$> noteAttributes_sharedWithBusiness record
  , (\_v231 -> (30, ("conflictSourceNoteGuid",T.TString $ E.encodeUtf8 _v231))) <$> noteAttributes_conflictSourceNoteGuid record
  , (\_v231 -> (31, ("noteTitleQuality",T.TI32 _v231))) <$> noteAttributes_noteTitleQuality record
  ]
write_NoteAttributes :: T.Protocol p => p -> NoteAttributes -> P.IO ()
write_NoteAttributes oprot record = T.writeVal oprot $ from_NoteAttributes record
encode_NoteAttributes :: T.StatelessProtocol p => p -> NoteAttributes -> LBS.ByteString
encode_NoteAttributes oprot record = T.serializeVal oprot $ from_NoteAttributes record
to_NoteAttributes :: T.ThriftVal -> NoteAttributes
to_NoteAttributes (T.TStruct fields) = NoteAttributes{
  noteAttributes_subjectDate = P.maybe (P.Nothing) (\(_,_val235) -> P.Just (case _val235 of {T.TI64 _val236 -> _val236; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  noteAttributes_latitude = P.maybe (P.Nothing) (\(_,_val235) -> P.Just (case _val235 of {T.TDouble _val237 -> _val237; _ -> P.error "wrong type"})) (Map.lookup (10) fields),
  noteAttributes_longitude = P.maybe (P.Nothing) (\(_,_val235) -> P.Just (case _val235 of {T.TDouble _val238 -> _val238; _ -> P.error "wrong type"})) (Map.lookup (11) fields),
  noteAttributes_altitude = P.maybe (P.Nothing) (\(_,_val235) -> P.Just (case _val235 of {T.TDouble _val239 -> _val239; _ -> P.error "wrong type"})) (Map.lookup (12) fields),
  noteAttributes_author = P.maybe (P.Nothing) (\(_,_val235) -> P.Just (case _val235 of {T.TString _val240 -> E.decodeUtf8 _val240; _ -> P.error "wrong type"})) (Map.lookup (13) fields),
  noteAttributes_source = P.maybe (P.Nothing) (\(_,_val235) -> P.Just (case _val235 of {T.TString _val241 -> E.decodeUtf8 _val241; _ -> P.error "wrong type"})) (Map.lookup (14) fields),
  noteAttributes_sourceURL = P.maybe (P.Nothing) (\(_,_val235) -> P.Just (case _val235 of {T.TString _val242 -> E.decodeUtf8 _val242; _ -> P.error "wrong type"})) (Map.lookup (15) fields),
  noteAttributes_sourceApplication = P.maybe (P.Nothing) (\(_,_val235) -> P.Just (case _val235 of {T.TString _val243 -> E.decodeUtf8 _val243; _ -> P.error "wrong type"})) (Map.lookup (16) fields),
  noteAttributes_shareDate = P.maybe (P.Nothing) (\(_,_val235) -> P.Just (case _val235 of {T.TI64 _val244 -> _val244; _ -> P.error "wrong type"})) (Map.lookup (17) fields),
  noteAttributes_reminderOrder = P.maybe (P.Nothing) (\(_,_val235) -> P.Just (case _val235 of {T.TI64 _val245 -> _val245; _ -> P.error "wrong type"})) (Map.lookup (18) fields),
  noteAttributes_reminderDoneTime = P.maybe (P.Nothing) (\(_,_val235) -> P.Just (case _val235 of {T.TI64 _val246 -> _val246; _ -> P.error "wrong type"})) (Map.lookup (19) fields),
  noteAttributes_reminderTime = P.maybe (P.Nothing) (\(_,_val235) -> P.Just (case _val235 of {T.TI64 _val247 -> _val247; _ -> P.error "wrong type"})) (Map.lookup (20) fields),
  noteAttributes_placeName = P.maybe (P.Nothing) (\(_,_val235) -> P.Just (case _val235 of {T.TString _val248 -> E.decodeUtf8 _val248; _ -> P.error "wrong type"})) (Map.lookup (21) fields),
  noteAttributes_contentClass = P.maybe (P.Nothing) (\(_,_val235) -> P.Just (case _val235 of {T.TString _val249 -> E.decodeUtf8 _val249; _ -> P.error "wrong type"})) (Map.lookup (22) fields),
  noteAttributes_applicationData = P.maybe (P.Nothing) (\(_,_val235) -> P.Just (case _val235 of {T.TStruct _val250 -> (to_LazyMap (T.TStruct _val250)); _ -> P.error "wrong type"})) (Map.lookup (23) fields),
  noteAttributes_lastEditedBy = P.maybe (P.Nothing) (\(_,_val235) -> P.Just (case _val235 of {T.TString _val251 -> E.decodeUtf8 _val251; _ -> P.error "wrong type"})) (Map.lookup (24) fields),
  noteAttributes_classifications = P.maybe (P.Nothing) (\(_,_val235) -> P.Just (case _val235 of {T.TMap _ _ _val252 -> (Map.fromList $ P.map (\(_k254,_v253) -> ((case _k254 of {T.TString _val255 -> E.decodeUtf8 _val255; _ -> P.error "wrong type"}),(case _v253 of {T.TString _val256 -> E.decodeUtf8 _val256; _ -> P.error "wrong type"}))) _val252); _ -> P.error "wrong type"})) (Map.lookup (26) fields),
  noteAttributes_creatorId = P.maybe (P.Nothing) (\(_,_val235) -> P.Just (case _val235 of {T.TI32 _val257 -> _val257; _ -> P.error "wrong type"})) (Map.lookup (27) fields),
  noteAttributes_lastEditorId = P.maybe (P.Nothing) (\(_,_val235) -> P.Just (case _val235 of {T.TI32 _val258 -> _val258; _ -> P.error "wrong type"})) (Map.lookup (28) fields),
  noteAttributes_sharedWithBusiness = P.maybe (P.Nothing) (\(_,_val235) -> P.Just (case _val235 of {T.TBool _val259 -> _val259; _ -> P.error "wrong type"})) (Map.lookup (29) fields),
  noteAttributes_conflictSourceNoteGuid = P.maybe (P.Nothing) (\(_,_val235) -> P.Just (case _val235 of {T.TString _val260 -> E.decodeUtf8 _val260; _ -> P.error "wrong type"})) (Map.lookup (30) fields),
  noteAttributes_noteTitleQuality = P.maybe (P.Nothing) (\(_,_val235) -> P.Just (case _val235 of {T.TI32 _val261 -> _val261; _ -> P.error "wrong type"})) (Map.lookup (31) fields)
  }
to_NoteAttributes _ = P.error "not a struct"
read_NoteAttributes :: T.Protocol p => p -> P.IO NoteAttributes
read_NoteAttributes iprot = to_NoteAttributes <$> T.readVal iprot (T.T_STRUCT typemap_NoteAttributes)
decode_NoteAttributes :: T.StatelessProtocol p => p -> LBS.ByteString -> NoteAttributes
decode_NoteAttributes iprot bs = to_NoteAttributes $ T.deserializeVal iprot (T.T_STRUCT typemap_NoteAttributes) bs
typemap_NoteAttributes :: T.TypeMap
typemap_NoteAttributes = Map.fromList [(1,("subjectDate",T.T_I64)),(10,("latitude",T.T_DOUBLE)),(11,("longitude",T.T_DOUBLE)),(12,("altitude",T.T_DOUBLE)),(13,("author",T.T_STRING)),(14,("source",T.T_STRING)),(15,("sourceURL",T.T_STRING)),(16,("sourceApplication",T.T_STRING)),(17,("shareDate",T.T_I64)),(18,("reminderOrder",T.T_I64)),(19,("reminderDoneTime",T.T_I64)),(20,("reminderTime",T.T_I64)),(21,("placeName",T.T_STRING)),(22,("contentClass",T.T_STRING)),(23,("applicationData",(T.T_STRUCT typemap_LazyMap))),(24,("lastEditedBy",T.T_STRING)),(26,("classifications",(T.T_MAP T.T_STRING T.T_STRING))),(27,("creatorId",T.T_I32)),(28,("lastEditorId",T.T_I32)),(29,("sharedWithBusiness",T.T_BOOL)),(30,("conflictSourceNoteGuid",T.T_STRING)),(31,("noteTitleQuality",T.T_I32))]
default_NoteAttributes :: NoteAttributes
default_NoteAttributes = NoteAttributes{
  noteAttributes_subjectDate = P.Nothing,
  noteAttributes_latitude = P.Nothing,
  noteAttributes_longitude = P.Nothing,
  noteAttributes_altitude = P.Nothing,
  noteAttributes_author = P.Nothing,
  noteAttributes_source = P.Nothing,
  noteAttributes_sourceURL = P.Nothing,
  noteAttributes_sourceApplication = P.Nothing,
  noteAttributes_shareDate = P.Nothing,
  noteAttributes_reminderOrder = P.Nothing,
  noteAttributes_reminderDoneTime = P.Nothing,
  noteAttributes_reminderTime = P.Nothing,
  noteAttributes_placeName = P.Nothing,
  noteAttributes_contentClass = P.Nothing,
  noteAttributes_applicationData = P.Nothing,
  noteAttributes_lastEditedBy = P.Nothing,
  noteAttributes_classifications = P.Nothing,
  noteAttributes_creatorId = P.Nothing,
  noteAttributes_lastEditorId = P.Nothing,
  noteAttributes_sharedWithBusiness = P.Nothing,
  noteAttributes_conflictSourceNoteGuid = P.Nothing,
  noteAttributes_noteTitleQuality = P.Nothing}
data SharedNote = SharedNote  { sharedNote_sharerUserID :: P.Maybe I.Int32
  , sharedNote_recipientIdentity :: P.Maybe Identity
  , sharedNote_privilege :: P.Maybe SharedNotePrivilegeLevel
  , sharedNote_serviceCreated :: P.Maybe I.Int64
  , sharedNote_serviceUpdated :: P.Maybe I.Int64
  , sharedNote_serviceAssigned :: P.Maybe I.Int64
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SharedNote where
  hashWithSalt salt record = salt   `H.hashWithSalt` sharedNote_sharerUserID record   `H.hashWithSalt` sharedNote_recipientIdentity record   `H.hashWithSalt` sharedNote_privilege record   `H.hashWithSalt` sharedNote_serviceCreated record   `H.hashWithSalt` sharedNote_serviceUpdated record   `H.hashWithSalt` sharedNote_serviceAssigned record  
instance QC.Arbitrary SharedNote where 
  arbitrary = M.liftM SharedNote (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_SharedNote = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SharedNote{sharedNote_sharerUserID = sharedNote_sharerUserID obj} then P.Nothing else P.Just $ default_SharedNote{sharedNote_sharerUserID = sharedNote_sharerUserID obj}
    , if obj == default_SharedNote{sharedNote_recipientIdentity = sharedNote_recipientIdentity obj} then P.Nothing else P.Just $ default_SharedNote{sharedNote_recipientIdentity = sharedNote_recipientIdentity obj}
    , if obj == default_SharedNote{sharedNote_privilege = sharedNote_privilege obj} then P.Nothing else P.Just $ default_SharedNote{sharedNote_privilege = sharedNote_privilege obj}
    , if obj == default_SharedNote{sharedNote_serviceCreated = sharedNote_serviceCreated obj} then P.Nothing else P.Just $ default_SharedNote{sharedNote_serviceCreated = sharedNote_serviceCreated obj}
    , if obj == default_SharedNote{sharedNote_serviceUpdated = sharedNote_serviceUpdated obj} then P.Nothing else P.Just $ default_SharedNote{sharedNote_serviceUpdated = sharedNote_serviceUpdated obj}
    , if obj == default_SharedNote{sharedNote_serviceAssigned = sharedNote_serviceAssigned obj} then P.Nothing else P.Just $ default_SharedNote{sharedNote_serviceAssigned = sharedNote_serviceAssigned obj}
    ]
from_SharedNote :: SharedNote -> T.ThriftVal
from_SharedNote record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v264 -> (1, ("sharerUserID",T.TI32 _v264))) <$> sharedNote_sharerUserID record
  , (\_v264 -> (2, ("recipientIdentity",from_Identity _v264))) <$> sharedNote_recipientIdentity record
  , (\_v264 -> (3, ("privilege",T.TI32 $ P.fromIntegral $ P.fromEnum _v264))) <$> sharedNote_privilege record
  , (\_v264 -> (4, ("serviceCreated",T.TI64 _v264))) <$> sharedNote_serviceCreated record
  , (\_v264 -> (5, ("serviceUpdated",T.TI64 _v264))) <$> sharedNote_serviceUpdated record
  , (\_v264 -> (6, ("serviceAssigned",T.TI64 _v264))) <$> sharedNote_serviceAssigned record
  ]
write_SharedNote :: T.Protocol p => p -> SharedNote -> P.IO ()
write_SharedNote oprot record = T.writeVal oprot $ from_SharedNote record
encode_SharedNote :: T.StatelessProtocol p => p -> SharedNote -> LBS.ByteString
encode_SharedNote oprot record = T.serializeVal oprot $ from_SharedNote record
to_SharedNote :: T.ThriftVal -> SharedNote
to_SharedNote (T.TStruct fields) = SharedNote{
  sharedNote_sharerUserID = P.maybe (P.Nothing) (\(_,_val266) -> P.Just (case _val266 of {T.TI32 _val267 -> _val267; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  sharedNote_recipientIdentity = P.maybe (P.Nothing) (\(_,_val266) -> P.Just (case _val266 of {T.TStruct _val268 -> (to_Identity (T.TStruct _val268)); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  sharedNote_privilege = P.maybe (P.Nothing) (\(_,_val266) -> P.Just (case _val266 of {T.TI32 _val269 -> P.toEnum $ P.fromIntegral _val269; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  sharedNote_serviceCreated = P.maybe (P.Nothing) (\(_,_val266) -> P.Just (case _val266 of {T.TI64 _val270 -> _val270; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  sharedNote_serviceUpdated = P.maybe (P.Nothing) (\(_,_val266) -> P.Just (case _val266 of {T.TI64 _val271 -> _val271; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  sharedNote_serviceAssigned = P.maybe (P.Nothing) (\(_,_val266) -> P.Just (case _val266 of {T.TI64 _val272 -> _val272; _ -> P.error "wrong type"})) (Map.lookup (6) fields)
  }
to_SharedNote _ = P.error "not a struct"
read_SharedNote :: T.Protocol p => p -> P.IO SharedNote
read_SharedNote iprot = to_SharedNote <$> T.readVal iprot (T.T_STRUCT typemap_SharedNote)
decode_SharedNote :: T.StatelessProtocol p => p -> LBS.ByteString -> SharedNote
decode_SharedNote iprot bs = to_SharedNote $ T.deserializeVal iprot (T.T_STRUCT typemap_SharedNote) bs
typemap_SharedNote :: T.TypeMap
typemap_SharedNote = Map.fromList [(1,("sharerUserID",T.T_I32)),(2,("recipientIdentity",(T.T_STRUCT typemap_Identity))),(3,("privilege",T.T_I32)),(4,("serviceCreated",T.T_I64)),(5,("serviceUpdated",T.T_I64)),(6,("serviceAssigned",T.T_I64))]
default_SharedNote :: SharedNote
default_SharedNote = SharedNote{
  sharedNote_sharerUserID = P.Nothing,
  sharedNote_recipientIdentity = P.Nothing,
  sharedNote_privilege = P.Nothing,
  sharedNote_serviceCreated = P.Nothing,
  sharedNote_serviceUpdated = P.Nothing,
  sharedNote_serviceAssigned = P.Nothing}
data NoteRestrictions = NoteRestrictions  { noteRestrictions_noUpdateTitle :: P.Maybe P.Bool
  , noteRestrictions_noUpdateContent :: P.Maybe P.Bool
  , noteRestrictions_noEmail :: P.Maybe P.Bool
  , noteRestrictions_noShare :: P.Maybe P.Bool
  , noteRestrictions_noSharePublicly :: P.Maybe P.Bool
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable NoteRestrictions where
  hashWithSalt salt record = salt   `H.hashWithSalt` noteRestrictions_noUpdateTitle record   `H.hashWithSalt` noteRestrictions_noUpdateContent record   `H.hashWithSalt` noteRestrictions_noEmail record   `H.hashWithSalt` noteRestrictions_noShare record   `H.hashWithSalt` noteRestrictions_noSharePublicly record  
instance QC.Arbitrary NoteRestrictions where 
  arbitrary = M.liftM NoteRestrictions (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_NoteRestrictions = []
             | P.otherwise = M.catMaybes
    [ if obj == default_NoteRestrictions{noteRestrictions_noUpdateTitle = noteRestrictions_noUpdateTitle obj} then P.Nothing else P.Just $ default_NoteRestrictions{noteRestrictions_noUpdateTitle = noteRestrictions_noUpdateTitle obj}
    , if obj == default_NoteRestrictions{noteRestrictions_noUpdateContent = noteRestrictions_noUpdateContent obj} then P.Nothing else P.Just $ default_NoteRestrictions{noteRestrictions_noUpdateContent = noteRestrictions_noUpdateContent obj}
    , if obj == default_NoteRestrictions{noteRestrictions_noEmail = noteRestrictions_noEmail obj} then P.Nothing else P.Just $ default_NoteRestrictions{noteRestrictions_noEmail = noteRestrictions_noEmail obj}
    , if obj == default_NoteRestrictions{noteRestrictions_noShare = noteRestrictions_noShare obj} then P.Nothing else P.Just $ default_NoteRestrictions{noteRestrictions_noShare = noteRestrictions_noShare obj}
    , if obj == default_NoteRestrictions{noteRestrictions_noSharePublicly = noteRestrictions_noSharePublicly obj} then P.Nothing else P.Just $ default_NoteRestrictions{noteRestrictions_noSharePublicly = noteRestrictions_noSharePublicly obj}
    ]
from_NoteRestrictions :: NoteRestrictions -> T.ThriftVal
from_NoteRestrictions record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v275 -> (1, ("noUpdateTitle",T.TBool _v275))) <$> noteRestrictions_noUpdateTitle record
  , (\_v275 -> (2, ("noUpdateContent",T.TBool _v275))) <$> noteRestrictions_noUpdateContent record
  , (\_v275 -> (3, ("noEmail",T.TBool _v275))) <$> noteRestrictions_noEmail record
  , (\_v275 -> (4, ("noShare",T.TBool _v275))) <$> noteRestrictions_noShare record
  , (\_v275 -> (5, ("noSharePublicly",T.TBool _v275))) <$> noteRestrictions_noSharePublicly record
  ]
write_NoteRestrictions :: T.Protocol p => p -> NoteRestrictions -> P.IO ()
write_NoteRestrictions oprot record = T.writeVal oprot $ from_NoteRestrictions record
encode_NoteRestrictions :: T.StatelessProtocol p => p -> NoteRestrictions -> LBS.ByteString
encode_NoteRestrictions oprot record = T.serializeVal oprot $ from_NoteRestrictions record
to_NoteRestrictions :: T.ThriftVal -> NoteRestrictions
to_NoteRestrictions (T.TStruct fields) = NoteRestrictions{
  noteRestrictions_noUpdateTitle = P.maybe (P.Nothing) (\(_,_val277) -> P.Just (case _val277 of {T.TBool _val278 -> _val278; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  noteRestrictions_noUpdateContent = P.maybe (P.Nothing) (\(_,_val277) -> P.Just (case _val277 of {T.TBool _val279 -> _val279; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  noteRestrictions_noEmail = P.maybe (P.Nothing) (\(_,_val277) -> P.Just (case _val277 of {T.TBool _val280 -> _val280; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  noteRestrictions_noShare = P.maybe (P.Nothing) (\(_,_val277) -> P.Just (case _val277 of {T.TBool _val281 -> _val281; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  noteRestrictions_noSharePublicly = P.maybe (P.Nothing) (\(_,_val277) -> P.Just (case _val277 of {T.TBool _val282 -> _val282; _ -> P.error "wrong type"})) (Map.lookup (5) fields)
  }
to_NoteRestrictions _ = P.error "not a struct"
read_NoteRestrictions :: T.Protocol p => p -> P.IO NoteRestrictions
read_NoteRestrictions iprot = to_NoteRestrictions <$> T.readVal iprot (T.T_STRUCT typemap_NoteRestrictions)
decode_NoteRestrictions :: T.StatelessProtocol p => p -> LBS.ByteString -> NoteRestrictions
decode_NoteRestrictions iprot bs = to_NoteRestrictions $ T.deserializeVal iprot (T.T_STRUCT typemap_NoteRestrictions) bs
typemap_NoteRestrictions :: T.TypeMap
typemap_NoteRestrictions = Map.fromList [(1,("noUpdateTitle",T.T_BOOL)),(2,("noUpdateContent",T.T_BOOL)),(3,("noEmail",T.T_BOOL)),(4,("noShare",T.T_BOOL)),(5,("noSharePublicly",T.T_BOOL))]
default_NoteRestrictions :: NoteRestrictions
default_NoteRestrictions = NoteRestrictions{
  noteRestrictions_noUpdateTitle = P.Nothing,
  noteRestrictions_noUpdateContent = P.Nothing,
  noteRestrictions_noEmail = P.Nothing,
  noteRestrictions_noShare = P.Nothing,
  noteRestrictions_noSharePublicly = P.Nothing}
data NoteLimits = NoteLimits  { noteLimits_noteResourceCountMax :: P.Maybe I.Int32
  , noteLimits_uploadLimit :: P.Maybe I.Int64
  , noteLimits_resourceSizeMax :: P.Maybe I.Int64
  , noteLimits_noteSizeMax :: P.Maybe I.Int64
  , noteLimits_uploaded :: P.Maybe I.Int64
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable NoteLimits where
  hashWithSalt salt record = salt   `H.hashWithSalt` noteLimits_noteResourceCountMax record   `H.hashWithSalt` noteLimits_uploadLimit record   `H.hashWithSalt` noteLimits_resourceSizeMax record   `H.hashWithSalt` noteLimits_noteSizeMax record   `H.hashWithSalt` noteLimits_uploaded record  
instance QC.Arbitrary NoteLimits where 
  arbitrary = M.liftM NoteLimits (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_NoteLimits = []
             | P.otherwise = M.catMaybes
    [ if obj == default_NoteLimits{noteLimits_noteResourceCountMax = noteLimits_noteResourceCountMax obj} then P.Nothing else P.Just $ default_NoteLimits{noteLimits_noteResourceCountMax = noteLimits_noteResourceCountMax obj}
    , if obj == default_NoteLimits{noteLimits_uploadLimit = noteLimits_uploadLimit obj} then P.Nothing else P.Just $ default_NoteLimits{noteLimits_uploadLimit = noteLimits_uploadLimit obj}
    , if obj == default_NoteLimits{noteLimits_resourceSizeMax = noteLimits_resourceSizeMax obj} then P.Nothing else P.Just $ default_NoteLimits{noteLimits_resourceSizeMax = noteLimits_resourceSizeMax obj}
    , if obj == default_NoteLimits{noteLimits_noteSizeMax = noteLimits_noteSizeMax obj} then P.Nothing else P.Just $ default_NoteLimits{noteLimits_noteSizeMax = noteLimits_noteSizeMax obj}
    , if obj == default_NoteLimits{noteLimits_uploaded = noteLimits_uploaded obj} then P.Nothing else P.Just $ default_NoteLimits{noteLimits_uploaded = noteLimits_uploaded obj}
    ]
from_NoteLimits :: NoteLimits -> T.ThriftVal
from_NoteLimits record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v285 -> (1, ("noteResourceCountMax",T.TI32 _v285))) <$> noteLimits_noteResourceCountMax record
  , (\_v285 -> (2, ("uploadLimit",T.TI64 _v285))) <$> noteLimits_uploadLimit record
  , (\_v285 -> (3, ("resourceSizeMax",T.TI64 _v285))) <$> noteLimits_resourceSizeMax record
  , (\_v285 -> (4, ("noteSizeMax",T.TI64 _v285))) <$> noteLimits_noteSizeMax record
  , (\_v285 -> (5, ("uploaded",T.TI64 _v285))) <$> noteLimits_uploaded record
  ]
write_NoteLimits :: T.Protocol p => p -> NoteLimits -> P.IO ()
write_NoteLimits oprot record = T.writeVal oprot $ from_NoteLimits record
encode_NoteLimits :: T.StatelessProtocol p => p -> NoteLimits -> LBS.ByteString
encode_NoteLimits oprot record = T.serializeVal oprot $ from_NoteLimits record
to_NoteLimits :: T.ThriftVal -> NoteLimits
to_NoteLimits (T.TStruct fields) = NoteLimits{
  noteLimits_noteResourceCountMax = P.maybe (P.Nothing) (\(_,_val287) -> P.Just (case _val287 of {T.TI32 _val288 -> _val288; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  noteLimits_uploadLimit = P.maybe (P.Nothing) (\(_,_val287) -> P.Just (case _val287 of {T.TI64 _val289 -> _val289; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  noteLimits_resourceSizeMax = P.maybe (P.Nothing) (\(_,_val287) -> P.Just (case _val287 of {T.TI64 _val290 -> _val290; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  noteLimits_noteSizeMax = P.maybe (P.Nothing) (\(_,_val287) -> P.Just (case _val287 of {T.TI64 _val291 -> _val291; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  noteLimits_uploaded = P.maybe (P.Nothing) (\(_,_val287) -> P.Just (case _val287 of {T.TI64 _val292 -> _val292; _ -> P.error "wrong type"})) (Map.lookup (5) fields)
  }
to_NoteLimits _ = P.error "not a struct"
read_NoteLimits :: T.Protocol p => p -> P.IO NoteLimits
read_NoteLimits iprot = to_NoteLimits <$> T.readVal iprot (T.T_STRUCT typemap_NoteLimits)
decode_NoteLimits :: T.StatelessProtocol p => p -> LBS.ByteString -> NoteLimits
decode_NoteLimits iprot bs = to_NoteLimits $ T.deserializeVal iprot (T.T_STRUCT typemap_NoteLimits) bs
typemap_NoteLimits :: T.TypeMap
typemap_NoteLimits = Map.fromList [(1,("noteResourceCountMax",T.T_I32)),(2,("uploadLimit",T.T_I64)),(3,("resourceSizeMax",T.T_I64)),(4,("noteSizeMax",T.T_I64)),(5,("uploaded",T.T_I64))]
default_NoteLimits :: NoteLimits
default_NoteLimits = NoteLimits{
  noteLimits_noteResourceCountMax = P.Nothing,
  noteLimits_uploadLimit = P.Nothing,
  noteLimits_resourceSizeMax = P.Nothing,
  noteLimits_noteSizeMax = P.Nothing,
  noteLimits_uploaded = P.Nothing}
data Note = Note  { note_guid :: P.Maybe LT.Text
  , note_title :: P.Maybe LT.Text
  , note_content :: P.Maybe LT.Text
  , note_contentHash :: P.Maybe LBS.ByteString
  , note_contentLength :: P.Maybe I.Int32
  , note_created :: P.Maybe I.Int64
  , note_updated :: P.Maybe I.Int64
  , note_deleted :: P.Maybe I.Int64
  , note_active :: P.Maybe P.Bool
  , note_updateSequenceNum :: P.Maybe I.Int32
  , note_notebookGuid :: P.Maybe LT.Text
  , note_tagGuids :: P.Maybe (Vector.Vector LT.Text)
  , note_resources :: P.Maybe (Vector.Vector Resource)
  , note_attributes :: P.Maybe NoteAttributes
  , note_tagNames :: P.Maybe (Vector.Vector LT.Text)
  , note_sharedNotes :: P.Maybe (Vector.Vector SharedNote)
  , note_restrictions :: P.Maybe NoteRestrictions
  , note_limits :: P.Maybe NoteLimits
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Note where
  hashWithSalt salt record = salt   `H.hashWithSalt` note_guid record   `H.hashWithSalt` note_title record   `H.hashWithSalt` note_content record   `H.hashWithSalt` note_contentHash record   `H.hashWithSalt` note_contentLength record   `H.hashWithSalt` note_created record   `H.hashWithSalt` note_updated record   `H.hashWithSalt` note_deleted record   `H.hashWithSalt` note_active record   `H.hashWithSalt` note_updateSequenceNum record   `H.hashWithSalt` note_notebookGuid record   `H.hashWithSalt` note_tagGuids record   `H.hashWithSalt` note_resources record   `H.hashWithSalt` note_attributes record   `H.hashWithSalt` note_tagNames record   `H.hashWithSalt` note_sharedNotes record   `H.hashWithSalt` note_restrictions record   `H.hashWithSalt` note_limits record  
instance QC.Arbitrary Note where 
  arbitrary = M.liftM Note (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_Note = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Note{note_guid = note_guid obj} then P.Nothing else P.Just $ default_Note{note_guid = note_guid obj}
    , if obj == default_Note{note_title = note_title obj} then P.Nothing else P.Just $ default_Note{note_title = note_title obj}
    , if obj == default_Note{note_content = note_content obj} then P.Nothing else P.Just $ default_Note{note_content = note_content obj}
    , if obj == default_Note{note_contentHash = note_contentHash obj} then P.Nothing else P.Just $ default_Note{note_contentHash = note_contentHash obj}
    , if obj == default_Note{note_contentLength = note_contentLength obj} then P.Nothing else P.Just $ default_Note{note_contentLength = note_contentLength obj}
    , if obj == default_Note{note_created = note_created obj} then P.Nothing else P.Just $ default_Note{note_created = note_created obj}
    , if obj == default_Note{note_updated = note_updated obj} then P.Nothing else P.Just $ default_Note{note_updated = note_updated obj}
    , if obj == default_Note{note_deleted = note_deleted obj} then P.Nothing else P.Just $ default_Note{note_deleted = note_deleted obj}
    , if obj == default_Note{note_active = note_active obj} then P.Nothing else P.Just $ default_Note{note_active = note_active obj}
    , if obj == default_Note{note_updateSequenceNum = note_updateSequenceNum obj} then P.Nothing else P.Just $ default_Note{note_updateSequenceNum = note_updateSequenceNum obj}
    , if obj == default_Note{note_notebookGuid = note_notebookGuid obj} then P.Nothing else P.Just $ default_Note{note_notebookGuid = note_notebookGuid obj}
    , if obj == default_Note{note_tagGuids = note_tagGuids obj} then P.Nothing else P.Just $ default_Note{note_tagGuids = note_tagGuids obj}
    , if obj == default_Note{note_resources = note_resources obj} then P.Nothing else P.Just $ default_Note{note_resources = note_resources obj}
    , if obj == default_Note{note_attributes = note_attributes obj} then P.Nothing else P.Just $ default_Note{note_attributes = note_attributes obj}
    , if obj == default_Note{note_tagNames = note_tagNames obj} then P.Nothing else P.Just $ default_Note{note_tagNames = note_tagNames obj}
    , if obj == default_Note{note_sharedNotes = note_sharedNotes obj} then P.Nothing else P.Just $ default_Note{note_sharedNotes = note_sharedNotes obj}
    , if obj == default_Note{note_restrictions = note_restrictions obj} then P.Nothing else P.Just $ default_Note{note_restrictions = note_restrictions obj}
    , if obj == default_Note{note_limits = note_limits obj} then P.Nothing else P.Just $ default_Note{note_limits = note_limits obj}
    ]
from_Note :: Note -> T.ThriftVal
from_Note record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v295 -> (1, ("guid",T.TString $ E.encodeUtf8 _v295))) <$> note_guid record
  , (\_v295 -> (2, ("title",T.TString $ E.encodeUtf8 _v295))) <$> note_title record
  , (\_v295 -> (3, ("content",T.TString $ E.encodeUtf8 _v295))) <$> note_content record
  , (\_v295 -> (4, ("contentHash",T.TBinary _v295))) <$> note_contentHash record
  , (\_v295 -> (5, ("contentLength",T.TI32 _v295))) <$> note_contentLength record
  , (\_v295 -> (6, ("created",T.TI64 _v295))) <$> note_created record
  , (\_v295 -> (7, ("updated",T.TI64 _v295))) <$> note_updated record
  , (\_v295 -> (8, ("deleted",T.TI64 _v295))) <$> note_deleted record
  , (\_v295 -> (9, ("active",T.TBool _v295))) <$> note_active record
  , (\_v295 -> (10, ("updateSequenceNum",T.TI32 _v295))) <$> note_updateSequenceNum record
  , (\_v295 -> (11, ("notebookGuid",T.TString $ E.encodeUtf8 _v295))) <$> note_notebookGuid record
  , (\_v295 -> (12, ("tagGuids",T.TList T.T_STRING $ P.map (\_v297 -> T.TString $ E.encodeUtf8 _v297) $ Vector.toList _v295))) <$> note_tagGuids record
  , (\_v295 -> (13, ("resources",T.TList (T.T_STRUCT typemap_Resource) $ P.map (\_v299 -> from_Resource _v299) $ Vector.toList _v295))) <$> note_resources record
  , (\_v295 -> (14, ("attributes",from_NoteAttributes _v295))) <$> note_attributes record
  , (\_v295 -> (15, ("tagNames",T.TList T.T_STRING $ P.map (\_v301 -> T.TString $ E.encodeUtf8 _v301) $ Vector.toList _v295))) <$> note_tagNames record
  , (\_v295 -> (16, ("sharedNotes",T.TList (T.T_STRUCT typemap_SharedNote) $ P.map (\_v303 -> from_SharedNote _v303) $ Vector.toList _v295))) <$> note_sharedNotes record
  , (\_v295 -> (17, ("restrictions",from_NoteRestrictions _v295))) <$> note_restrictions record
  , (\_v295 -> (18, ("limits",from_NoteLimits _v295))) <$> note_limits record
  ]
write_Note :: T.Protocol p => p -> Note -> P.IO ()
write_Note oprot record = T.writeVal oprot $ from_Note record
encode_Note :: T.StatelessProtocol p => p -> Note -> LBS.ByteString
encode_Note oprot record = T.serializeVal oprot $ from_Note record
to_Note :: T.ThriftVal -> Note
to_Note (T.TStruct fields) = Note{
  note_guid = P.maybe (P.Nothing) (\(_,_val305) -> P.Just (case _val305 of {T.TString _val306 -> E.decodeUtf8 _val306; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  note_title = P.maybe (P.Nothing) (\(_,_val305) -> P.Just (case _val305 of {T.TString _val307 -> E.decodeUtf8 _val307; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  note_content = P.maybe (P.Nothing) (\(_,_val305) -> P.Just (case _val305 of {T.TString _val308 -> E.decodeUtf8 _val308; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  note_contentHash = P.maybe (P.Nothing) (\(_,_val305) -> P.Just (case _val305 of {T.TBinary _val309 -> _val309; T.TString _val309 -> _val309; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  note_contentLength = P.maybe (P.Nothing) (\(_,_val305) -> P.Just (case _val305 of {T.TI32 _val310 -> _val310; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  note_created = P.maybe (P.Nothing) (\(_,_val305) -> P.Just (case _val305 of {T.TI64 _val311 -> _val311; _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  note_updated = P.maybe (P.Nothing) (\(_,_val305) -> P.Just (case _val305 of {T.TI64 _val312 -> _val312; _ -> P.error "wrong type"})) (Map.lookup (7) fields),
  note_deleted = P.maybe (P.Nothing) (\(_,_val305) -> P.Just (case _val305 of {T.TI64 _val313 -> _val313; _ -> P.error "wrong type"})) (Map.lookup (8) fields),
  note_active = P.maybe (P.Nothing) (\(_,_val305) -> P.Just (case _val305 of {T.TBool _val314 -> _val314; _ -> P.error "wrong type"})) (Map.lookup (9) fields),
  note_updateSequenceNum = P.maybe (P.Nothing) (\(_,_val305) -> P.Just (case _val305 of {T.TI32 _val315 -> _val315; _ -> P.error "wrong type"})) (Map.lookup (10) fields),
  note_notebookGuid = P.maybe (P.Nothing) (\(_,_val305) -> P.Just (case _val305 of {T.TString _val316 -> E.decodeUtf8 _val316; _ -> P.error "wrong type"})) (Map.lookup (11) fields),
  note_tagGuids = P.maybe (P.Nothing) (\(_,_val305) -> P.Just (case _val305 of {T.TList _ _val317 -> (Vector.fromList $ P.map (\_v318 -> (case _v318 of {T.TString _val319 -> E.decodeUtf8 _val319; _ -> P.error "wrong type"})) _val317); _ -> P.error "wrong type"})) (Map.lookup (12) fields),
  note_resources = P.maybe (P.Nothing) (\(_,_val305) -> P.Just (case _val305 of {T.TList _ _val320 -> (Vector.fromList $ P.map (\_v321 -> (case _v321 of {T.TStruct _val322 -> (to_Resource (T.TStruct _val322)); _ -> P.error "wrong type"})) _val320); _ -> P.error "wrong type"})) (Map.lookup (13) fields),
  note_attributes = P.maybe (P.Nothing) (\(_,_val305) -> P.Just (case _val305 of {T.TStruct _val323 -> (to_NoteAttributes (T.TStruct _val323)); _ -> P.error "wrong type"})) (Map.lookup (14) fields),
  note_tagNames = P.maybe (P.Nothing) (\(_,_val305) -> P.Just (case _val305 of {T.TList _ _val324 -> (Vector.fromList $ P.map (\_v325 -> (case _v325 of {T.TString _val326 -> E.decodeUtf8 _val326; _ -> P.error "wrong type"})) _val324); _ -> P.error "wrong type"})) (Map.lookup (15) fields),
  note_sharedNotes = P.maybe (P.Nothing) (\(_,_val305) -> P.Just (case _val305 of {T.TList _ _val327 -> (Vector.fromList $ P.map (\_v328 -> (case _v328 of {T.TStruct _val329 -> (to_SharedNote (T.TStruct _val329)); _ -> P.error "wrong type"})) _val327); _ -> P.error "wrong type"})) (Map.lookup (16) fields),
  note_restrictions = P.maybe (P.Nothing) (\(_,_val305) -> P.Just (case _val305 of {T.TStruct _val330 -> (to_NoteRestrictions (T.TStruct _val330)); _ -> P.error "wrong type"})) (Map.lookup (17) fields),
  note_limits = P.maybe (P.Nothing) (\(_,_val305) -> P.Just (case _val305 of {T.TStruct _val331 -> (to_NoteLimits (T.TStruct _val331)); _ -> P.error "wrong type"})) (Map.lookup (18) fields)
  }
to_Note _ = P.error "not a struct"
read_Note :: T.Protocol p => p -> P.IO Note
read_Note iprot = to_Note <$> T.readVal iprot (T.T_STRUCT typemap_Note)
decode_Note :: T.StatelessProtocol p => p -> LBS.ByteString -> Note
decode_Note iprot bs = to_Note $ T.deserializeVal iprot (T.T_STRUCT typemap_Note) bs
typemap_Note :: T.TypeMap
typemap_Note = Map.fromList [(1,("guid",T.T_STRING)),(2,("title",T.T_STRING)),(3,("content",T.T_STRING)),(4,("contentHash",T.T_BINARY)),(5,("contentLength",T.T_I32)),(6,("created",T.T_I64)),(7,("updated",T.T_I64)),(8,("deleted",T.T_I64)),(9,("active",T.T_BOOL)),(10,("updateSequenceNum",T.T_I32)),(11,("notebookGuid",T.T_STRING)),(12,("tagGuids",(T.T_LIST T.T_STRING))),(13,("resources",(T.T_LIST (T.T_STRUCT typemap_Resource)))),(14,("attributes",(T.T_STRUCT typemap_NoteAttributes))),(15,("tagNames",(T.T_LIST T.T_STRING))),(16,("sharedNotes",(T.T_LIST (T.T_STRUCT typemap_SharedNote)))),(17,("restrictions",(T.T_STRUCT typemap_NoteRestrictions))),(18,("limits",(T.T_STRUCT typemap_NoteLimits)))]
default_Note :: Note
default_Note = Note{
  note_guid = P.Nothing,
  note_title = P.Nothing,
  note_content = P.Nothing,
  note_contentHash = P.Nothing,
  note_contentLength = P.Nothing,
  note_created = P.Nothing,
  note_updated = P.Nothing,
  note_deleted = P.Nothing,
  note_active = P.Nothing,
  note_updateSequenceNum = P.Nothing,
  note_notebookGuid = P.Nothing,
  note_tagGuids = P.Nothing,
  note_resources = P.Nothing,
  note_attributes = P.Nothing,
  note_tagNames = P.Nothing,
  note_sharedNotes = P.Nothing,
  note_restrictions = P.Nothing,
  note_limits = P.Nothing}
data Publishing = Publishing  { publishing_uri :: P.Maybe LT.Text
  , publishing_order :: P.Maybe NoteSortOrder
  , publishing_ascending :: P.Maybe P.Bool
  , publishing_publicDescription :: P.Maybe LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Publishing where
  hashWithSalt salt record = salt   `H.hashWithSalt` publishing_uri record   `H.hashWithSalt` publishing_order record   `H.hashWithSalt` publishing_ascending record   `H.hashWithSalt` publishing_publicDescription record  
instance QC.Arbitrary Publishing where 
  arbitrary = M.liftM Publishing (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_Publishing = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Publishing{publishing_uri = publishing_uri obj} then P.Nothing else P.Just $ default_Publishing{publishing_uri = publishing_uri obj}
    , if obj == default_Publishing{publishing_order = publishing_order obj} then P.Nothing else P.Just $ default_Publishing{publishing_order = publishing_order obj}
    , if obj == default_Publishing{publishing_ascending = publishing_ascending obj} then P.Nothing else P.Just $ default_Publishing{publishing_ascending = publishing_ascending obj}
    , if obj == default_Publishing{publishing_publicDescription = publishing_publicDescription obj} then P.Nothing else P.Just $ default_Publishing{publishing_publicDescription = publishing_publicDescription obj}
    ]
from_Publishing :: Publishing -> T.ThriftVal
from_Publishing record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v334 -> (1, ("uri",T.TString $ E.encodeUtf8 _v334))) <$> publishing_uri record
  , (\_v334 -> (2, ("order",T.TI32 $ P.fromIntegral $ P.fromEnum _v334))) <$> publishing_order record
  , (\_v334 -> (3, ("ascending",T.TBool _v334))) <$> publishing_ascending record
  , (\_v334 -> (4, ("publicDescription",T.TString $ E.encodeUtf8 _v334))) <$> publishing_publicDescription record
  ]
write_Publishing :: T.Protocol p => p -> Publishing -> P.IO ()
write_Publishing oprot record = T.writeVal oprot $ from_Publishing record
encode_Publishing :: T.StatelessProtocol p => p -> Publishing -> LBS.ByteString
encode_Publishing oprot record = T.serializeVal oprot $ from_Publishing record
to_Publishing :: T.ThriftVal -> Publishing
to_Publishing (T.TStruct fields) = Publishing{
  publishing_uri = P.maybe (P.Nothing) (\(_,_val336) -> P.Just (case _val336 of {T.TString _val337 -> E.decodeUtf8 _val337; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  publishing_order = P.maybe (P.Nothing) (\(_,_val336) -> P.Just (case _val336 of {T.TI32 _val338 -> P.toEnum $ P.fromIntegral _val338; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  publishing_ascending = P.maybe (P.Nothing) (\(_,_val336) -> P.Just (case _val336 of {T.TBool _val339 -> _val339; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  publishing_publicDescription = P.maybe (P.Nothing) (\(_,_val336) -> P.Just (case _val336 of {T.TString _val340 -> E.decodeUtf8 _val340; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_Publishing _ = P.error "not a struct"
read_Publishing :: T.Protocol p => p -> P.IO Publishing
read_Publishing iprot = to_Publishing <$> T.readVal iprot (T.T_STRUCT typemap_Publishing)
decode_Publishing :: T.StatelessProtocol p => p -> LBS.ByteString -> Publishing
decode_Publishing iprot bs = to_Publishing $ T.deserializeVal iprot (T.T_STRUCT typemap_Publishing) bs
typemap_Publishing :: T.TypeMap
typemap_Publishing = Map.fromList [(1,("uri",T.T_STRING)),(2,("order",T.T_I32)),(3,("ascending",T.T_BOOL)),(4,("publicDescription",T.T_STRING))]
default_Publishing :: Publishing
default_Publishing = Publishing{
  publishing_uri = P.Nothing,
  publishing_order = P.Nothing,
  publishing_ascending = P.Nothing,
  publishing_publicDescription = P.Nothing}
data BusinessNotebook = BusinessNotebook  { businessNotebook_notebookDescription :: P.Maybe LT.Text
  , businessNotebook_privilege :: P.Maybe SharedNotebookPrivilegeLevel
  , businessNotebook_recommended :: P.Maybe P.Bool
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable BusinessNotebook where
  hashWithSalt salt record = salt   `H.hashWithSalt` businessNotebook_notebookDescription record   `H.hashWithSalt` businessNotebook_privilege record   `H.hashWithSalt` businessNotebook_recommended record  
instance QC.Arbitrary BusinessNotebook where 
  arbitrary = M.liftM BusinessNotebook (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_BusinessNotebook = []
             | P.otherwise = M.catMaybes
    [ if obj == default_BusinessNotebook{businessNotebook_notebookDescription = businessNotebook_notebookDescription obj} then P.Nothing else P.Just $ default_BusinessNotebook{businessNotebook_notebookDescription = businessNotebook_notebookDescription obj}
    , if obj == default_BusinessNotebook{businessNotebook_privilege = businessNotebook_privilege obj} then P.Nothing else P.Just $ default_BusinessNotebook{businessNotebook_privilege = businessNotebook_privilege obj}
    , if obj == default_BusinessNotebook{businessNotebook_recommended = businessNotebook_recommended obj} then P.Nothing else P.Just $ default_BusinessNotebook{businessNotebook_recommended = businessNotebook_recommended obj}
    ]
from_BusinessNotebook :: BusinessNotebook -> T.ThriftVal
from_BusinessNotebook record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v343 -> (1, ("notebookDescription",T.TString $ E.encodeUtf8 _v343))) <$> businessNotebook_notebookDescription record
  , (\_v343 -> (2, ("privilege",T.TI32 $ P.fromIntegral $ P.fromEnum _v343))) <$> businessNotebook_privilege record
  , (\_v343 -> (3, ("recommended",T.TBool _v343))) <$> businessNotebook_recommended record
  ]
write_BusinessNotebook :: T.Protocol p => p -> BusinessNotebook -> P.IO ()
write_BusinessNotebook oprot record = T.writeVal oprot $ from_BusinessNotebook record
encode_BusinessNotebook :: T.StatelessProtocol p => p -> BusinessNotebook -> LBS.ByteString
encode_BusinessNotebook oprot record = T.serializeVal oprot $ from_BusinessNotebook record
to_BusinessNotebook :: T.ThriftVal -> BusinessNotebook
to_BusinessNotebook (T.TStruct fields) = BusinessNotebook{
  businessNotebook_notebookDescription = P.maybe (P.Nothing) (\(_,_val345) -> P.Just (case _val345 of {T.TString _val346 -> E.decodeUtf8 _val346; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  businessNotebook_privilege = P.maybe (P.Nothing) (\(_,_val345) -> P.Just (case _val345 of {T.TI32 _val347 -> P.toEnum $ P.fromIntegral _val347; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  businessNotebook_recommended = P.maybe (P.Nothing) (\(_,_val345) -> P.Just (case _val345 of {T.TBool _val348 -> _val348; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_BusinessNotebook _ = P.error "not a struct"
read_BusinessNotebook :: T.Protocol p => p -> P.IO BusinessNotebook
read_BusinessNotebook iprot = to_BusinessNotebook <$> T.readVal iprot (T.T_STRUCT typemap_BusinessNotebook)
decode_BusinessNotebook :: T.StatelessProtocol p => p -> LBS.ByteString -> BusinessNotebook
decode_BusinessNotebook iprot bs = to_BusinessNotebook $ T.deserializeVal iprot (T.T_STRUCT typemap_BusinessNotebook) bs
typemap_BusinessNotebook :: T.TypeMap
typemap_BusinessNotebook = Map.fromList [(1,("notebookDescription",T.T_STRING)),(2,("privilege",T.T_I32)),(3,("recommended",T.T_BOOL))]
default_BusinessNotebook :: BusinessNotebook
default_BusinessNotebook = BusinessNotebook{
  businessNotebook_notebookDescription = P.Nothing,
  businessNotebook_privilege = P.Nothing,
  businessNotebook_recommended = P.Nothing}
data SavedSearchScope = SavedSearchScope  { savedSearchScope_includeAccount :: P.Maybe P.Bool
  , savedSearchScope_includePersonalLinkedNotebooks :: P.Maybe P.Bool
  , savedSearchScope_includeBusinessLinkedNotebooks :: P.Maybe P.Bool
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SavedSearchScope where
  hashWithSalt salt record = salt   `H.hashWithSalt` savedSearchScope_includeAccount record   `H.hashWithSalt` savedSearchScope_includePersonalLinkedNotebooks record   `H.hashWithSalt` savedSearchScope_includeBusinessLinkedNotebooks record  
instance QC.Arbitrary SavedSearchScope where 
  arbitrary = M.liftM SavedSearchScope (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_SavedSearchScope = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SavedSearchScope{savedSearchScope_includeAccount = savedSearchScope_includeAccount obj} then P.Nothing else P.Just $ default_SavedSearchScope{savedSearchScope_includeAccount = savedSearchScope_includeAccount obj}
    , if obj == default_SavedSearchScope{savedSearchScope_includePersonalLinkedNotebooks = savedSearchScope_includePersonalLinkedNotebooks obj} then P.Nothing else P.Just $ default_SavedSearchScope{savedSearchScope_includePersonalLinkedNotebooks = savedSearchScope_includePersonalLinkedNotebooks obj}
    , if obj == default_SavedSearchScope{savedSearchScope_includeBusinessLinkedNotebooks = savedSearchScope_includeBusinessLinkedNotebooks obj} then P.Nothing else P.Just $ default_SavedSearchScope{savedSearchScope_includeBusinessLinkedNotebooks = savedSearchScope_includeBusinessLinkedNotebooks obj}
    ]
from_SavedSearchScope :: SavedSearchScope -> T.ThriftVal
from_SavedSearchScope record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v351 -> (1, ("includeAccount",T.TBool _v351))) <$> savedSearchScope_includeAccount record
  , (\_v351 -> (2, ("includePersonalLinkedNotebooks",T.TBool _v351))) <$> savedSearchScope_includePersonalLinkedNotebooks record
  , (\_v351 -> (3, ("includeBusinessLinkedNotebooks",T.TBool _v351))) <$> savedSearchScope_includeBusinessLinkedNotebooks record
  ]
write_SavedSearchScope :: T.Protocol p => p -> SavedSearchScope -> P.IO ()
write_SavedSearchScope oprot record = T.writeVal oprot $ from_SavedSearchScope record
encode_SavedSearchScope :: T.StatelessProtocol p => p -> SavedSearchScope -> LBS.ByteString
encode_SavedSearchScope oprot record = T.serializeVal oprot $ from_SavedSearchScope record
to_SavedSearchScope :: T.ThriftVal -> SavedSearchScope
to_SavedSearchScope (T.TStruct fields) = SavedSearchScope{
  savedSearchScope_includeAccount = P.maybe (P.Nothing) (\(_,_val353) -> P.Just (case _val353 of {T.TBool _val354 -> _val354; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  savedSearchScope_includePersonalLinkedNotebooks = P.maybe (P.Nothing) (\(_,_val353) -> P.Just (case _val353 of {T.TBool _val355 -> _val355; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  savedSearchScope_includeBusinessLinkedNotebooks = P.maybe (P.Nothing) (\(_,_val353) -> P.Just (case _val353 of {T.TBool _val356 -> _val356; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_SavedSearchScope _ = P.error "not a struct"
read_SavedSearchScope :: T.Protocol p => p -> P.IO SavedSearchScope
read_SavedSearchScope iprot = to_SavedSearchScope <$> T.readVal iprot (T.T_STRUCT typemap_SavedSearchScope)
decode_SavedSearchScope :: T.StatelessProtocol p => p -> LBS.ByteString -> SavedSearchScope
decode_SavedSearchScope iprot bs = to_SavedSearchScope $ T.deserializeVal iprot (T.T_STRUCT typemap_SavedSearchScope) bs
typemap_SavedSearchScope :: T.TypeMap
typemap_SavedSearchScope = Map.fromList [(1,("includeAccount",T.T_BOOL)),(2,("includePersonalLinkedNotebooks",T.T_BOOL)),(3,("includeBusinessLinkedNotebooks",T.T_BOOL))]
default_SavedSearchScope :: SavedSearchScope
default_SavedSearchScope = SavedSearchScope{
  savedSearchScope_includeAccount = P.Nothing,
  savedSearchScope_includePersonalLinkedNotebooks = P.Nothing,
  savedSearchScope_includeBusinessLinkedNotebooks = P.Nothing}
data SavedSearch = SavedSearch  { savedSearch_guid :: P.Maybe LT.Text
  , savedSearch_name :: P.Maybe LT.Text
  , savedSearch_query :: P.Maybe LT.Text
  , savedSearch_format :: P.Maybe QueryFormat
  , savedSearch_updateSequenceNum :: P.Maybe I.Int32
  , savedSearch_scope :: P.Maybe SavedSearchScope
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SavedSearch where
  hashWithSalt salt record = salt   `H.hashWithSalt` savedSearch_guid record   `H.hashWithSalt` savedSearch_name record   `H.hashWithSalt` savedSearch_query record   `H.hashWithSalt` savedSearch_format record   `H.hashWithSalt` savedSearch_updateSequenceNum record   `H.hashWithSalt` savedSearch_scope record  
instance QC.Arbitrary SavedSearch where 
  arbitrary = M.liftM SavedSearch (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_SavedSearch = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SavedSearch{savedSearch_guid = savedSearch_guid obj} then P.Nothing else P.Just $ default_SavedSearch{savedSearch_guid = savedSearch_guid obj}
    , if obj == default_SavedSearch{savedSearch_name = savedSearch_name obj} then P.Nothing else P.Just $ default_SavedSearch{savedSearch_name = savedSearch_name obj}
    , if obj == default_SavedSearch{savedSearch_query = savedSearch_query obj} then P.Nothing else P.Just $ default_SavedSearch{savedSearch_query = savedSearch_query obj}
    , if obj == default_SavedSearch{savedSearch_format = savedSearch_format obj} then P.Nothing else P.Just $ default_SavedSearch{savedSearch_format = savedSearch_format obj}
    , if obj == default_SavedSearch{savedSearch_updateSequenceNum = savedSearch_updateSequenceNum obj} then P.Nothing else P.Just $ default_SavedSearch{savedSearch_updateSequenceNum = savedSearch_updateSequenceNum obj}
    , if obj == default_SavedSearch{savedSearch_scope = savedSearch_scope obj} then P.Nothing else P.Just $ default_SavedSearch{savedSearch_scope = savedSearch_scope obj}
    ]
from_SavedSearch :: SavedSearch -> T.ThriftVal
from_SavedSearch record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v359 -> (1, ("guid",T.TString $ E.encodeUtf8 _v359))) <$> savedSearch_guid record
  , (\_v359 -> (2, ("name",T.TString $ E.encodeUtf8 _v359))) <$> savedSearch_name record
  , (\_v359 -> (3, ("query",T.TString $ E.encodeUtf8 _v359))) <$> savedSearch_query record
  , (\_v359 -> (4, ("format",T.TI32 $ P.fromIntegral $ P.fromEnum _v359))) <$> savedSearch_format record
  , (\_v359 -> (5, ("updateSequenceNum",T.TI32 _v359))) <$> savedSearch_updateSequenceNum record
  , (\_v359 -> (6, ("scope",from_SavedSearchScope _v359))) <$> savedSearch_scope record
  ]
write_SavedSearch :: T.Protocol p => p -> SavedSearch -> P.IO ()
write_SavedSearch oprot record = T.writeVal oprot $ from_SavedSearch record
encode_SavedSearch :: T.StatelessProtocol p => p -> SavedSearch -> LBS.ByteString
encode_SavedSearch oprot record = T.serializeVal oprot $ from_SavedSearch record
to_SavedSearch :: T.ThriftVal -> SavedSearch
to_SavedSearch (T.TStruct fields) = SavedSearch{
  savedSearch_guid = P.maybe (P.Nothing) (\(_,_val361) -> P.Just (case _val361 of {T.TString _val362 -> E.decodeUtf8 _val362; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  savedSearch_name = P.maybe (P.Nothing) (\(_,_val361) -> P.Just (case _val361 of {T.TString _val363 -> E.decodeUtf8 _val363; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  savedSearch_query = P.maybe (P.Nothing) (\(_,_val361) -> P.Just (case _val361 of {T.TString _val364 -> E.decodeUtf8 _val364; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  savedSearch_format = P.maybe (P.Nothing) (\(_,_val361) -> P.Just (case _val361 of {T.TI32 _val365 -> P.toEnum $ P.fromIntegral _val365; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  savedSearch_updateSequenceNum = P.maybe (P.Nothing) (\(_,_val361) -> P.Just (case _val361 of {T.TI32 _val366 -> _val366; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  savedSearch_scope = P.maybe (P.Nothing) (\(_,_val361) -> P.Just (case _val361 of {T.TStruct _val367 -> (to_SavedSearchScope (T.TStruct _val367)); _ -> P.error "wrong type"})) (Map.lookup (6) fields)
  }
to_SavedSearch _ = P.error "not a struct"
read_SavedSearch :: T.Protocol p => p -> P.IO SavedSearch
read_SavedSearch iprot = to_SavedSearch <$> T.readVal iprot (T.T_STRUCT typemap_SavedSearch)
decode_SavedSearch :: T.StatelessProtocol p => p -> LBS.ByteString -> SavedSearch
decode_SavedSearch iprot bs = to_SavedSearch $ T.deserializeVal iprot (T.T_STRUCT typemap_SavedSearch) bs
typemap_SavedSearch :: T.TypeMap
typemap_SavedSearch = Map.fromList [(1,("guid",T.T_STRING)),(2,("name",T.T_STRING)),(3,("query",T.T_STRING)),(4,("format",T.T_I32)),(5,("updateSequenceNum",T.T_I32)),(6,("scope",(T.T_STRUCT typemap_SavedSearchScope)))]
default_SavedSearch :: SavedSearch
default_SavedSearch = SavedSearch{
  savedSearch_guid = P.Nothing,
  savedSearch_name = P.Nothing,
  savedSearch_query = P.Nothing,
  savedSearch_format = P.Nothing,
  savedSearch_updateSequenceNum = P.Nothing,
  savedSearch_scope = P.Nothing}
data SharedNotebookRecipientSettings = SharedNotebookRecipientSettings  { sharedNotebookRecipientSettings_reminderNotifyEmail :: P.Maybe P.Bool
  , sharedNotebookRecipientSettings_reminderNotifyInApp :: P.Maybe P.Bool
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SharedNotebookRecipientSettings where
  hashWithSalt salt record = salt   `H.hashWithSalt` sharedNotebookRecipientSettings_reminderNotifyEmail record   `H.hashWithSalt` sharedNotebookRecipientSettings_reminderNotifyInApp record  
instance QC.Arbitrary SharedNotebookRecipientSettings where 
  arbitrary = M.liftM SharedNotebookRecipientSettings (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_SharedNotebookRecipientSettings = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SharedNotebookRecipientSettings{sharedNotebookRecipientSettings_reminderNotifyEmail = sharedNotebookRecipientSettings_reminderNotifyEmail obj} then P.Nothing else P.Just $ default_SharedNotebookRecipientSettings{sharedNotebookRecipientSettings_reminderNotifyEmail = sharedNotebookRecipientSettings_reminderNotifyEmail obj}
    , if obj == default_SharedNotebookRecipientSettings{sharedNotebookRecipientSettings_reminderNotifyInApp = sharedNotebookRecipientSettings_reminderNotifyInApp obj} then P.Nothing else P.Just $ default_SharedNotebookRecipientSettings{sharedNotebookRecipientSettings_reminderNotifyInApp = sharedNotebookRecipientSettings_reminderNotifyInApp obj}
    ]
from_SharedNotebookRecipientSettings :: SharedNotebookRecipientSettings -> T.ThriftVal
from_SharedNotebookRecipientSettings record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v370 -> (1, ("reminderNotifyEmail",T.TBool _v370))) <$> sharedNotebookRecipientSettings_reminderNotifyEmail record
  , (\_v370 -> (2, ("reminderNotifyInApp",T.TBool _v370))) <$> sharedNotebookRecipientSettings_reminderNotifyInApp record
  ]
write_SharedNotebookRecipientSettings :: T.Protocol p => p -> SharedNotebookRecipientSettings -> P.IO ()
write_SharedNotebookRecipientSettings oprot record = T.writeVal oprot $ from_SharedNotebookRecipientSettings record
encode_SharedNotebookRecipientSettings :: T.StatelessProtocol p => p -> SharedNotebookRecipientSettings -> LBS.ByteString
encode_SharedNotebookRecipientSettings oprot record = T.serializeVal oprot $ from_SharedNotebookRecipientSettings record
to_SharedNotebookRecipientSettings :: T.ThriftVal -> SharedNotebookRecipientSettings
to_SharedNotebookRecipientSettings (T.TStruct fields) = SharedNotebookRecipientSettings{
  sharedNotebookRecipientSettings_reminderNotifyEmail = P.maybe (P.Nothing) (\(_,_val372) -> P.Just (case _val372 of {T.TBool _val373 -> _val373; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  sharedNotebookRecipientSettings_reminderNotifyInApp = P.maybe (P.Nothing) (\(_,_val372) -> P.Just (case _val372 of {T.TBool _val374 -> _val374; _ -> P.error "wrong type"})) (Map.lookup (2) fields)
  }
to_SharedNotebookRecipientSettings _ = P.error "not a struct"
read_SharedNotebookRecipientSettings :: T.Protocol p => p -> P.IO SharedNotebookRecipientSettings
read_SharedNotebookRecipientSettings iprot = to_SharedNotebookRecipientSettings <$> T.readVal iprot (T.T_STRUCT typemap_SharedNotebookRecipientSettings)
decode_SharedNotebookRecipientSettings :: T.StatelessProtocol p => p -> LBS.ByteString -> SharedNotebookRecipientSettings
decode_SharedNotebookRecipientSettings iprot bs = to_SharedNotebookRecipientSettings $ T.deserializeVal iprot (T.T_STRUCT typemap_SharedNotebookRecipientSettings) bs
typemap_SharedNotebookRecipientSettings :: T.TypeMap
typemap_SharedNotebookRecipientSettings = Map.fromList [(1,("reminderNotifyEmail",T.T_BOOL)),(2,("reminderNotifyInApp",T.T_BOOL))]
default_SharedNotebookRecipientSettings :: SharedNotebookRecipientSettings
default_SharedNotebookRecipientSettings = SharedNotebookRecipientSettings{
  sharedNotebookRecipientSettings_reminderNotifyEmail = P.Nothing,
  sharedNotebookRecipientSettings_reminderNotifyInApp = P.Nothing}
data NotebookRecipientSettings = NotebookRecipientSettings  { notebookRecipientSettings_reminderNotifyEmail :: P.Maybe P.Bool
  , notebookRecipientSettings_reminderNotifyInApp :: P.Maybe P.Bool
  , notebookRecipientSettings_inMyList :: P.Maybe P.Bool
  , notebookRecipientSettings_stack :: P.Maybe LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable NotebookRecipientSettings where
  hashWithSalt salt record = salt   `H.hashWithSalt` notebookRecipientSettings_reminderNotifyEmail record   `H.hashWithSalt` notebookRecipientSettings_reminderNotifyInApp record   `H.hashWithSalt` notebookRecipientSettings_inMyList record   `H.hashWithSalt` notebookRecipientSettings_stack record  
instance QC.Arbitrary NotebookRecipientSettings where 
  arbitrary = M.liftM NotebookRecipientSettings (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_NotebookRecipientSettings = []
             | P.otherwise = M.catMaybes
    [ if obj == default_NotebookRecipientSettings{notebookRecipientSettings_reminderNotifyEmail = notebookRecipientSettings_reminderNotifyEmail obj} then P.Nothing else P.Just $ default_NotebookRecipientSettings{notebookRecipientSettings_reminderNotifyEmail = notebookRecipientSettings_reminderNotifyEmail obj}
    , if obj == default_NotebookRecipientSettings{notebookRecipientSettings_reminderNotifyInApp = notebookRecipientSettings_reminderNotifyInApp obj} then P.Nothing else P.Just $ default_NotebookRecipientSettings{notebookRecipientSettings_reminderNotifyInApp = notebookRecipientSettings_reminderNotifyInApp obj}
    , if obj == default_NotebookRecipientSettings{notebookRecipientSettings_inMyList = notebookRecipientSettings_inMyList obj} then P.Nothing else P.Just $ default_NotebookRecipientSettings{notebookRecipientSettings_inMyList = notebookRecipientSettings_inMyList obj}
    , if obj == default_NotebookRecipientSettings{notebookRecipientSettings_stack = notebookRecipientSettings_stack obj} then P.Nothing else P.Just $ default_NotebookRecipientSettings{notebookRecipientSettings_stack = notebookRecipientSettings_stack obj}
    ]
from_NotebookRecipientSettings :: NotebookRecipientSettings -> T.ThriftVal
from_NotebookRecipientSettings record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v377 -> (1, ("reminderNotifyEmail",T.TBool _v377))) <$> notebookRecipientSettings_reminderNotifyEmail record
  , (\_v377 -> (2, ("reminderNotifyInApp",T.TBool _v377))) <$> notebookRecipientSettings_reminderNotifyInApp record
  , (\_v377 -> (3, ("inMyList",T.TBool _v377))) <$> notebookRecipientSettings_inMyList record
  , (\_v377 -> (4, ("stack",T.TString $ E.encodeUtf8 _v377))) <$> notebookRecipientSettings_stack record
  ]
write_NotebookRecipientSettings :: T.Protocol p => p -> NotebookRecipientSettings -> P.IO ()
write_NotebookRecipientSettings oprot record = T.writeVal oprot $ from_NotebookRecipientSettings record
encode_NotebookRecipientSettings :: T.StatelessProtocol p => p -> NotebookRecipientSettings -> LBS.ByteString
encode_NotebookRecipientSettings oprot record = T.serializeVal oprot $ from_NotebookRecipientSettings record
to_NotebookRecipientSettings :: T.ThriftVal -> NotebookRecipientSettings
to_NotebookRecipientSettings (T.TStruct fields) = NotebookRecipientSettings{
  notebookRecipientSettings_reminderNotifyEmail = P.maybe (P.Nothing) (\(_,_val379) -> P.Just (case _val379 of {T.TBool _val380 -> _val380; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  notebookRecipientSettings_reminderNotifyInApp = P.maybe (P.Nothing) (\(_,_val379) -> P.Just (case _val379 of {T.TBool _val381 -> _val381; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  notebookRecipientSettings_inMyList = P.maybe (P.Nothing) (\(_,_val379) -> P.Just (case _val379 of {T.TBool _val382 -> _val382; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  notebookRecipientSettings_stack = P.maybe (P.Nothing) (\(_,_val379) -> P.Just (case _val379 of {T.TString _val383 -> E.decodeUtf8 _val383; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_NotebookRecipientSettings _ = P.error "not a struct"
read_NotebookRecipientSettings :: T.Protocol p => p -> P.IO NotebookRecipientSettings
read_NotebookRecipientSettings iprot = to_NotebookRecipientSettings <$> T.readVal iprot (T.T_STRUCT typemap_NotebookRecipientSettings)
decode_NotebookRecipientSettings :: T.StatelessProtocol p => p -> LBS.ByteString -> NotebookRecipientSettings
decode_NotebookRecipientSettings iprot bs = to_NotebookRecipientSettings $ T.deserializeVal iprot (T.T_STRUCT typemap_NotebookRecipientSettings) bs
typemap_NotebookRecipientSettings :: T.TypeMap
typemap_NotebookRecipientSettings = Map.fromList [(1,("reminderNotifyEmail",T.T_BOOL)),(2,("reminderNotifyInApp",T.T_BOOL)),(3,("inMyList",T.T_BOOL)),(4,("stack",T.T_STRING))]
default_NotebookRecipientSettings :: NotebookRecipientSettings
default_NotebookRecipientSettings = NotebookRecipientSettings{
  notebookRecipientSettings_reminderNotifyEmail = P.Nothing,
  notebookRecipientSettings_reminderNotifyInApp = P.Nothing,
  notebookRecipientSettings_inMyList = P.Nothing,
  notebookRecipientSettings_stack = P.Nothing}
data SharedNotebook = SharedNotebook  { sharedNotebook_id :: P.Maybe I.Int64
  , sharedNotebook_userId :: P.Maybe I.Int32
  , sharedNotebook_notebookGuid :: P.Maybe LT.Text
  , sharedNotebook_email :: P.Maybe LT.Text
  , sharedNotebook_recipientIdentityId :: P.Maybe I.Int64
  , sharedNotebook_notebookModifiable :: P.Maybe P.Bool
  , sharedNotebook_serviceCreated :: P.Maybe I.Int64
  , sharedNotebook_serviceUpdated :: P.Maybe I.Int64
  , sharedNotebook_globalId :: P.Maybe LT.Text
  , sharedNotebook_username :: P.Maybe LT.Text
  , sharedNotebook_privilege :: P.Maybe SharedNotebookPrivilegeLevel
  , sharedNotebook_recipientSettings :: P.Maybe SharedNotebookRecipientSettings
  , sharedNotebook_sharerUserId :: P.Maybe I.Int32
  , sharedNotebook_recipientUsername :: P.Maybe LT.Text
  , sharedNotebook_recipientUserId :: P.Maybe I.Int32
  , sharedNotebook_serviceAssigned :: P.Maybe I.Int64
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable SharedNotebook where
  hashWithSalt salt record = salt   `H.hashWithSalt` sharedNotebook_id record   `H.hashWithSalt` sharedNotebook_userId record   `H.hashWithSalt` sharedNotebook_notebookGuid record   `H.hashWithSalt` sharedNotebook_email record   `H.hashWithSalt` sharedNotebook_recipientIdentityId record   `H.hashWithSalt` sharedNotebook_notebookModifiable record   `H.hashWithSalt` sharedNotebook_serviceCreated record   `H.hashWithSalt` sharedNotebook_serviceUpdated record   `H.hashWithSalt` sharedNotebook_globalId record   `H.hashWithSalt` sharedNotebook_username record   `H.hashWithSalt` sharedNotebook_privilege record   `H.hashWithSalt` sharedNotebook_recipientSettings record   `H.hashWithSalt` sharedNotebook_sharerUserId record   `H.hashWithSalt` sharedNotebook_recipientUsername record   `H.hashWithSalt` sharedNotebook_recipientUserId record   `H.hashWithSalt` sharedNotebook_serviceAssigned record  
instance QC.Arbitrary SharedNotebook where 
  arbitrary = M.liftM SharedNotebook (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_SharedNotebook = []
             | P.otherwise = M.catMaybes
    [ if obj == default_SharedNotebook{sharedNotebook_id = sharedNotebook_id obj} then P.Nothing else P.Just $ default_SharedNotebook{sharedNotebook_id = sharedNotebook_id obj}
    , if obj == default_SharedNotebook{sharedNotebook_userId = sharedNotebook_userId obj} then P.Nothing else P.Just $ default_SharedNotebook{sharedNotebook_userId = sharedNotebook_userId obj}
    , if obj == default_SharedNotebook{sharedNotebook_notebookGuid = sharedNotebook_notebookGuid obj} then P.Nothing else P.Just $ default_SharedNotebook{sharedNotebook_notebookGuid = sharedNotebook_notebookGuid obj}
    , if obj == default_SharedNotebook{sharedNotebook_email = sharedNotebook_email obj} then P.Nothing else P.Just $ default_SharedNotebook{sharedNotebook_email = sharedNotebook_email obj}
    , if obj == default_SharedNotebook{sharedNotebook_recipientIdentityId = sharedNotebook_recipientIdentityId obj} then P.Nothing else P.Just $ default_SharedNotebook{sharedNotebook_recipientIdentityId = sharedNotebook_recipientIdentityId obj}
    , if obj == default_SharedNotebook{sharedNotebook_notebookModifiable = sharedNotebook_notebookModifiable obj} then P.Nothing else P.Just $ default_SharedNotebook{sharedNotebook_notebookModifiable = sharedNotebook_notebookModifiable obj}
    , if obj == default_SharedNotebook{sharedNotebook_serviceCreated = sharedNotebook_serviceCreated obj} then P.Nothing else P.Just $ default_SharedNotebook{sharedNotebook_serviceCreated = sharedNotebook_serviceCreated obj}
    , if obj == default_SharedNotebook{sharedNotebook_serviceUpdated = sharedNotebook_serviceUpdated obj} then P.Nothing else P.Just $ default_SharedNotebook{sharedNotebook_serviceUpdated = sharedNotebook_serviceUpdated obj}
    , if obj == default_SharedNotebook{sharedNotebook_globalId = sharedNotebook_globalId obj} then P.Nothing else P.Just $ default_SharedNotebook{sharedNotebook_globalId = sharedNotebook_globalId obj}
    , if obj == default_SharedNotebook{sharedNotebook_username = sharedNotebook_username obj} then P.Nothing else P.Just $ default_SharedNotebook{sharedNotebook_username = sharedNotebook_username obj}
    , if obj == default_SharedNotebook{sharedNotebook_privilege = sharedNotebook_privilege obj} then P.Nothing else P.Just $ default_SharedNotebook{sharedNotebook_privilege = sharedNotebook_privilege obj}
    , if obj == default_SharedNotebook{sharedNotebook_recipientSettings = sharedNotebook_recipientSettings obj} then P.Nothing else P.Just $ default_SharedNotebook{sharedNotebook_recipientSettings = sharedNotebook_recipientSettings obj}
    , if obj == default_SharedNotebook{sharedNotebook_sharerUserId = sharedNotebook_sharerUserId obj} then P.Nothing else P.Just $ default_SharedNotebook{sharedNotebook_sharerUserId = sharedNotebook_sharerUserId obj}
    , if obj == default_SharedNotebook{sharedNotebook_recipientUsername = sharedNotebook_recipientUsername obj} then P.Nothing else P.Just $ default_SharedNotebook{sharedNotebook_recipientUsername = sharedNotebook_recipientUsername obj}
    , if obj == default_SharedNotebook{sharedNotebook_recipientUserId = sharedNotebook_recipientUserId obj} then P.Nothing else P.Just $ default_SharedNotebook{sharedNotebook_recipientUserId = sharedNotebook_recipientUserId obj}
    , if obj == default_SharedNotebook{sharedNotebook_serviceAssigned = sharedNotebook_serviceAssigned obj} then P.Nothing else P.Just $ default_SharedNotebook{sharedNotebook_serviceAssigned = sharedNotebook_serviceAssigned obj}
    ]
from_SharedNotebook :: SharedNotebook -> T.ThriftVal
from_SharedNotebook record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v386 -> (1, ("id",T.TI64 _v386))) <$> sharedNotebook_id record
  , (\_v386 -> (2, ("userId",T.TI32 _v386))) <$> sharedNotebook_userId record
  , (\_v386 -> (3, ("notebookGuid",T.TString $ E.encodeUtf8 _v386))) <$> sharedNotebook_notebookGuid record
  , (\_v386 -> (4, ("email",T.TString $ E.encodeUtf8 _v386))) <$> sharedNotebook_email record
  , (\_v386 -> (5, ("notebookModifiable",T.TBool _v386))) <$> sharedNotebook_notebookModifiable record
  , (\_v386 -> (7, ("serviceCreated",T.TI64 _v386))) <$> sharedNotebook_serviceCreated record
  , (\_v386 -> (8, ("globalId",T.TString $ E.encodeUtf8 _v386))) <$> sharedNotebook_globalId record
  , (\_v386 -> (9, ("username",T.TString $ E.encodeUtf8 _v386))) <$> sharedNotebook_username record
  , (\_v386 -> (10, ("serviceUpdated",T.TI64 _v386))) <$> sharedNotebook_serviceUpdated record
  , (\_v386 -> (11, ("privilege",T.TI32 $ P.fromIntegral $ P.fromEnum _v386))) <$> sharedNotebook_privilege record
  , (\_v386 -> (13, ("recipientSettings",from_SharedNotebookRecipientSettings _v386))) <$> sharedNotebook_recipientSettings record
  , (\_v386 -> (14, ("sharerUserId",T.TI32 _v386))) <$> sharedNotebook_sharerUserId record
  , (\_v386 -> (15, ("recipientUsername",T.TString $ E.encodeUtf8 _v386))) <$> sharedNotebook_recipientUsername record
  , (\_v386 -> (16, ("serviceAssigned",T.TI64 _v386))) <$> sharedNotebook_serviceAssigned record
  , (\_v386 -> (17, ("recipientUserId",T.TI32 _v386))) <$> sharedNotebook_recipientUserId record
  , (\_v386 -> (18, ("recipientIdentityId",T.TI64 _v386))) <$> sharedNotebook_recipientIdentityId record
  ]
write_SharedNotebook :: T.Protocol p => p -> SharedNotebook -> P.IO ()
write_SharedNotebook oprot record = T.writeVal oprot $ from_SharedNotebook record
encode_SharedNotebook :: T.StatelessProtocol p => p -> SharedNotebook -> LBS.ByteString
encode_SharedNotebook oprot record = T.serializeVal oprot $ from_SharedNotebook record
to_SharedNotebook :: T.ThriftVal -> SharedNotebook
to_SharedNotebook (T.TStruct fields) = SharedNotebook{
  sharedNotebook_id = P.maybe (P.Nothing) (\(_,_val388) -> P.Just (case _val388 of {T.TI64 _val389 -> _val389; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  sharedNotebook_userId = P.maybe (P.Nothing) (\(_,_val388) -> P.Just (case _val388 of {T.TI32 _val390 -> _val390; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  sharedNotebook_notebookGuid = P.maybe (P.Nothing) (\(_,_val388) -> P.Just (case _val388 of {T.TString _val391 -> E.decodeUtf8 _val391; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  sharedNotebook_email = P.maybe (P.Nothing) (\(_,_val388) -> P.Just (case _val388 of {T.TString _val392 -> E.decodeUtf8 _val392; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  sharedNotebook_recipientIdentityId = P.maybe (P.Nothing) (\(_,_val388) -> P.Just (case _val388 of {T.TI64 _val393 -> _val393; _ -> P.error "wrong type"})) (Map.lookup (18) fields),
  sharedNotebook_notebookModifiable = P.maybe (P.Nothing) (\(_,_val388) -> P.Just (case _val388 of {T.TBool _val394 -> _val394; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  sharedNotebook_serviceCreated = P.maybe (P.Nothing) (\(_,_val388) -> P.Just (case _val388 of {T.TI64 _val395 -> _val395; _ -> P.error "wrong type"})) (Map.lookup (7) fields),
  sharedNotebook_serviceUpdated = P.maybe (P.Nothing) (\(_,_val388) -> P.Just (case _val388 of {T.TI64 _val396 -> _val396; _ -> P.error "wrong type"})) (Map.lookup (10) fields),
  sharedNotebook_globalId = P.maybe (P.Nothing) (\(_,_val388) -> P.Just (case _val388 of {T.TString _val397 -> E.decodeUtf8 _val397; _ -> P.error "wrong type"})) (Map.lookup (8) fields),
  sharedNotebook_username = P.maybe (P.Nothing) (\(_,_val388) -> P.Just (case _val388 of {T.TString _val398 -> E.decodeUtf8 _val398; _ -> P.error "wrong type"})) (Map.lookup (9) fields),
  sharedNotebook_privilege = P.maybe (P.Nothing) (\(_,_val388) -> P.Just (case _val388 of {T.TI32 _val399 -> P.toEnum $ P.fromIntegral _val399; _ -> P.error "wrong type"})) (Map.lookup (11) fields),
  sharedNotebook_recipientSettings = P.maybe (P.Nothing) (\(_,_val388) -> P.Just (case _val388 of {T.TStruct _val400 -> (to_SharedNotebookRecipientSettings (T.TStruct _val400)); _ -> P.error "wrong type"})) (Map.lookup (13) fields),
  sharedNotebook_sharerUserId = P.maybe (P.Nothing) (\(_,_val388) -> P.Just (case _val388 of {T.TI32 _val401 -> _val401; _ -> P.error "wrong type"})) (Map.lookup (14) fields),
  sharedNotebook_recipientUsername = P.maybe (P.Nothing) (\(_,_val388) -> P.Just (case _val388 of {T.TString _val402 -> E.decodeUtf8 _val402; _ -> P.error "wrong type"})) (Map.lookup (15) fields),
  sharedNotebook_recipientUserId = P.maybe (P.Nothing) (\(_,_val388) -> P.Just (case _val388 of {T.TI32 _val403 -> _val403; _ -> P.error "wrong type"})) (Map.lookup (17) fields),
  sharedNotebook_serviceAssigned = P.maybe (P.Nothing) (\(_,_val388) -> P.Just (case _val388 of {T.TI64 _val404 -> _val404; _ -> P.error "wrong type"})) (Map.lookup (16) fields)
  }
to_SharedNotebook _ = P.error "not a struct"
read_SharedNotebook :: T.Protocol p => p -> P.IO SharedNotebook
read_SharedNotebook iprot = to_SharedNotebook <$> T.readVal iprot (T.T_STRUCT typemap_SharedNotebook)
decode_SharedNotebook :: T.StatelessProtocol p => p -> LBS.ByteString -> SharedNotebook
decode_SharedNotebook iprot bs = to_SharedNotebook $ T.deserializeVal iprot (T.T_STRUCT typemap_SharedNotebook) bs
typemap_SharedNotebook :: T.TypeMap
typemap_SharedNotebook = Map.fromList [(1,("id",T.T_I64)),(2,("userId",T.T_I32)),(3,("notebookGuid",T.T_STRING)),(4,("email",T.T_STRING)),(5,("notebookModifiable",T.T_BOOL)),(7,("serviceCreated",T.T_I64)),(8,("globalId",T.T_STRING)),(9,("username",T.T_STRING)),(10,("serviceUpdated",T.T_I64)),(11,("privilege",T.T_I32)),(13,("recipientSettings",(T.T_STRUCT typemap_SharedNotebookRecipientSettings))),(14,("sharerUserId",T.T_I32)),(15,("recipientUsername",T.T_STRING)),(16,("serviceAssigned",T.T_I64)),(17,("recipientUserId",T.T_I32)),(18,("recipientIdentityId",T.T_I64))]
default_SharedNotebook :: SharedNotebook
default_SharedNotebook = SharedNotebook{
  sharedNotebook_id = P.Nothing,
  sharedNotebook_userId = P.Nothing,
  sharedNotebook_notebookGuid = P.Nothing,
  sharedNotebook_email = P.Nothing,
  sharedNotebook_notebookModifiable = P.Nothing,
  sharedNotebook_serviceCreated = P.Nothing,
  sharedNotebook_globalId = P.Nothing,
  sharedNotebook_username = P.Nothing,
  sharedNotebook_serviceUpdated = P.Nothing,
  sharedNotebook_privilege = P.Nothing,
  sharedNotebook_recipientSettings = P.Nothing,
  sharedNotebook_sharerUserId = P.Nothing,
  sharedNotebook_recipientUsername = P.Nothing,
  sharedNotebook_serviceAssigned = P.Nothing,
  sharedNotebook_recipientUserId = P.Nothing,
  sharedNotebook_recipientIdentityId = P.Nothing}
data NotebookRestrictions = NotebookRestrictions  { notebookRestrictions_noReadNotes :: P.Maybe P.Bool
  , notebookRestrictions_noCreateNotes :: P.Maybe P.Bool
  , notebookRestrictions_noUpdateNotes :: P.Maybe P.Bool
  , notebookRestrictions_noExpungeNotes :: P.Maybe P.Bool
  , notebookRestrictions_noShareNotes :: P.Maybe P.Bool
  , notebookRestrictions_noEmailNotes :: P.Maybe P.Bool
  , notebookRestrictions_noSendMessageToRecipients :: P.Maybe P.Bool
  , notebookRestrictions_noUpdateNotebook :: P.Maybe P.Bool
  , notebookRestrictions_noExpungeNotebook :: P.Maybe P.Bool
  , notebookRestrictions_noSetDefaultNotebook :: P.Maybe P.Bool
  , notebookRestrictions_noSetNotebookStack :: P.Maybe P.Bool
  , notebookRestrictions_noPublishToPublic :: P.Maybe P.Bool
  , notebookRestrictions_noPublishToBusinessLibrary :: P.Maybe P.Bool
  , notebookRestrictions_noCreateTags :: P.Maybe P.Bool
  , notebookRestrictions_noUpdateTags :: P.Maybe P.Bool
  , notebookRestrictions_noExpungeTags :: P.Maybe P.Bool
  , notebookRestrictions_noSetParentTag :: P.Maybe P.Bool
  , notebookRestrictions_noCreateSharedNotebooks :: P.Maybe P.Bool
  , notebookRestrictions_updateWhichSharedNotebookRestrictions :: P.Maybe SharedNotebookInstanceRestrictions
  , notebookRestrictions_expungeWhichSharedNotebookRestrictions :: P.Maybe SharedNotebookInstanceRestrictions
  , notebookRestrictions_noShareNotesWithBusiness :: P.Maybe P.Bool
  , notebookRestrictions_noRenameNotebook :: P.Maybe P.Bool
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable NotebookRestrictions where
  hashWithSalt salt record = salt   `H.hashWithSalt` notebookRestrictions_noReadNotes record   `H.hashWithSalt` notebookRestrictions_noCreateNotes record   `H.hashWithSalt` notebookRestrictions_noUpdateNotes record   `H.hashWithSalt` notebookRestrictions_noExpungeNotes record   `H.hashWithSalt` notebookRestrictions_noShareNotes record   `H.hashWithSalt` notebookRestrictions_noEmailNotes record   `H.hashWithSalt` notebookRestrictions_noSendMessageToRecipients record   `H.hashWithSalt` notebookRestrictions_noUpdateNotebook record   `H.hashWithSalt` notebookRestrictions_noExpungeNotebook record   `H.hashWithSalt` notebookRestrictions_noSetDefaultNotebook record   `H.hashWithSalt` notebookRestrictions_noSetNotebookStack record   `H.hashWithSalt` notebookRestrictions_noPublishToPublic record   `H.hashWithSalt` notebookRestrictions_noPublishToBusinessLibrary record   `H.hashWithSalt` notebookRestrictions_noCreateTags record   `H.hashWithSalt` notebookRestrictions_noUpdateTags record   `H.hashWithSalt` notebookRestrictions_noExpungeTags record   `H.hashWithSalt` notebookRestrictions_noSetParentTag record   `H.hashWithSalt` notebookRestrictions_noCreateSharedNotebooks record   `H.hashWithSalt` notebookRestrictions_updateWhichSharedNotebookRestrictions record   `H.hashWithSalt` notebookRestrictions_expungeWhichSharedNotebookRestrictions record   `H.hashWithSalt` notebookRestrictions_noShareNotesWithBusiness record   `H.hashWithSalt` notebookRestrictions_noRenameNotebook record  
instance QC.Arbitrary NotebookRestrictions where 
  arbitrary = M.liftM NotebookRestrictions (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_NotebookRestrictions = []
             | P.otherwise = M.catMaybes
    [ if obj == default_NotebookRestrictions{notebookRestrictions_noReadNotes = notebookRestrictions_noReadNotes obj} then P.Nothing else P.Just $ default_NotebookRestrictions{notebookRestrictions_noReadNotes = notebookRestrictions_noReadNotes obj}
    , if obj == default_NotebookRestrictions{notebookRestrictions_noCreateNotes = notebookRestrictions_noCreateNotes obj} then P.Nothing else P.Just $ default_NotebookRestrictions{notebookRestrictions_noCreateNotes = notebookRestrictions_noCreateNotes obj}
    , if obj == default_NotebookRestrictions{notebookRestrictions_noUpdateNotes = notebookRestrictions_noUpdateNotes obj} then P.Nothing else P.Just $ default_NotebookRestrictions{notebookRestrictions_noUpdateNotes = notebookRestrictions_noUpdateNotes obj}
    , if obj == default_NotebookRestrictions{notebookRestrictions_noExpungeNotes = notebookRestrictions_noExpungeNotes obj} then P.Nothing else P.Just $ default_NotebookRestrictions{notebookRestrictions_noExpungeNotes = notebookRestrictions_noExpungeNotes obj}
    , if obj == default_NotebookRestrictions{notebookRestrictions_noShareNotes = notebookRestrictions_noShareNotes obj} then P.Nothing else P.Just $ default_NotebookRestrictions{notebookRestrictions_noShareNotes = notebookRestrictions_noShareNotes obj}
    , if obj == default_NotebookRestrictions{notebookRestrictions_noEmailNotes = notebookRestrictions_noEmailNotes obj} then P.Nothing else P.Just $ default_NotebookRestrictions{notebookRestrictions_noEmailNotes = notebookRestrictions_noEmailNotes obj}
    , if obj == default_NotebookRestrictions{notebookRestrictions_noSendMessageToRecipients = notebookRestrictions_noSendMessageToRecipients obj} then P.Nothing else P.Just $ default_NotebookRestrictions{notebookRestrictions_noSendMessageToRecipients = notebookRestrictions_noSendMessageToRecipients obj}
    , if obj == default_NotebookRestrictions{notebookRestrictions_noUpdateNotebook = notebookRestrictions_noUpdateNotebook obj} then P.Nothing else P.Just $ default_NotebookRestrictions{notebookRestrictions_noUpdateNotebook = notebookRestrictions_noUpdateNotebook obj}
    , if obj == default_NotebookRestrictions{notebookRestrictions_noExpungeNotebook = notebookRestrictions_noExpungeNotebook obj} then P.Nothing else P.Just $ default_NotebookRestrictions{notebookRestrictions_noExpungeNotebook = notebookRestrictions_noExpungeNotebook obj}
    , if obj == default_NotebookRestrictions{notebookRestrictions_noSetDefaultNotebook = notebookRestrictions_noSetDefaultNotebook obj} then P.Nothing else P.Just $ default_NotebookRestrictions{notebookRestrictions_noSetDefaultNotebook = notebookRestrictions_noSetDefaultNotebook obj}
    , if obj == default_NotebookRestrictions{notebookRestrictions_noSetNotebookStack = notebookRestrictions_noSetNotebookStack obj} then P.Nothing else P.Just $ default_NotebookRestrictions{notebookRestrictions_noSetNotebookStack = notebookRestrictions_noSetNotebookStack obj}
    , if obj == default_NotebookRestrictions{notebookRestrictions_noPublishToPublic = notebookRestrictions_noPublishToPublic obj} then P.Nothing else P.Just $ default_NotebookRestrictions{notebookRestrictions_noPublishToPublic = notebookRestrictions_noPublishToPublic obj}
    , if obj == default_NotebookRestrictions{notebookRestrictions_noPublishToBusinessLibrary = notebookRestrictions_noPublishToBusinessLibrary obj} then P.Nothing else P.Just $ default_NotebookRestrictions{notebookRestrictions_noPublishToBusinessLibrary = notebookRestrictions_noPublishToBusinessLibrary obj}
    , if obj == default_NotebookRestrictions{notebookRestrictions_noCreateTags = notebookRestrictions_noCreateTags obj} then P.Nothing else P.Just $ default_NotebookRestrictions{notebookRestrictions_noCreateTags = notebookRestrictions_noCreateTags obj}
    , if obj == default_NotebookRestrictions{notebookRestrictions_noUpdateTags = notebookRestrictions_noUpdateTags obj} then P.Nothing else P.Just $ default_NotebookRestrictions{notebookRestrictions_noUpdateTags = notebookRestrictions_noUpdateTags obj}
    , if obj == default_NotebookRestrictions{notebookRestrictions_noExpungeTags = notebookRestrictions_noExpungeTags obj} then P.Nothing else P.Just $ default_NotebookRestrictions{notebookRestrictions_noExpungeTags = notebookRestrictions_noExpungeTags obj}
    , if obj == default_NotebookRestrictions{notebookRestrictions_noSetParentTag = notebookRestrictions_noSetParentTag obj} then P.Nothing else P.Just $ default_NotebookRestrictions{notebookRestrictions_noSetParentTag = notebookRestrictions_noSetParentTag obj}
    , if obj == default_NotebookRestrictions{notebookRestrictions_noCreateSharedNotebooks = notebookRestrictions_noCreateSharedNotebooks obj} then P.Nothing else P.Just $ default_NotebookRestrictions{notebookRestrictions_noCreateSharedNotebooks = notebookRestrictions_noCreateSharedNotebooks obj}
    , if obj == default_NotebookRestrictions{notebookRestrictions_updateWhichSharedNotebookRestrictions = notebookRestrictions_updateWhichSharedNotebookRestrictions obj} then P.Nothing else P.Just $ default_NotebookRestrictions{notebookRestrictions_updateWhichSharedNotebookRestrictions = notebookRestrictions_updateWhichSharedNotebookRestrictions obj}
    , if obj == default_NotebookRestrictions{notebookRestrictions_expungeWhichSharedNotebookRestrictions = notebookRestrictions_expungeWhichSharedNotebookRestrictions obj} then P.Nothing else P.Just $ default_NotebookRestrictions{notebookRestrictions_expungeWhichSharedNotebookRestrictions = notebookRestrictions_expungeWhichSharedNotebookRestrictions obj}
    , if obj == default_NotebookRestrictions{notebookRestrictions_noShareNotesWithBusiness = notebookRestrictions_noShareNotesWithBusiness obj} then P.Nothing else P.Just $ default_NotebookRestrictions{notebookRestrictions_noShareNotesWithBusiness = notebookRestrictions_noShareNotesWithBusiness obj}
    , if obj == default_NotebookRestrictions{notebookRestrictions_noRenameNotebook = notebookRestrictions_noRenameNotebook obj} then P.Nothing else P.Just $ default_NotebookRestrictions{notebookRestrictions_noRenameNotebook = notebookRestrictions_noRenameNotebook obj}
    ]
from_NotebookRestrictions :: NotebookRestrictions -> T.ThriftVal
from_NotebookRestrictions record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v407 -> (1, ("noReadNotes",T.TBool _v407))) <$> notebookRestrictions_noReadNotes record
  , (\_v407 -> (2, ("noCreateNotes",T.TBool _v407))) <$> notebookRestrictions_noCreateNotes record
  , (\_v407 -> (3, ("noUpdateNotes",T.TBool _v407))) <$> notebookRestrictions_noUpdateNotes record
  , (\_v407 -> (4, ("noExpungeNotes",T.TBool _v407))) <$> notebookRestrictions_noExpungeNotes record
  , (\_v407 -> (5, ("noShareNotes",T.TBool _v407))) <$> notebookRestrictions_noShareNotes record
  , (\_v407 -> (6, ("noEmailNotes",T.TBool _v407))) <$> notebookRestrictions_noEmailNotes record
  , (\_v407 -> (7, ("noSendMessageToRecipients",T.TBool _v407))) <$> notebookRestrictions_noSendMessageToRecipients record
  , (\_v407 -> (8, ("noUpdateNotebook",T.TBool _v407))) <$> notebookRestrictions_noUpdateNotebook record
  , (\_v407 -> (9, ("noExpungeNotebook",T.TBool _v407))) <$> notebookRestrictions_noExpungeNotebook record
  , (\_v407 -> (10, ("noSetDefaultNotebook",T.TBool _v407))) <$> notebookRestrictions_noSetDefaultNotebook record
  , (\_v407 -> (11, ("noSetNotebookStack",T.TBool _v407))) <$> notebookRestrictions_noSetNotebookStack record
  , (\_v407 -> (12, ("noPublishToPublic",T.TBool _v407))) <$> notebookRestrictions_noPublishToPublic record
  , (\_v407 -> (13, ("noPublishToBusinessLibrary",T.TBool _v407))) <$> notebookRestrictions_noPublishToBusinessLibrary record
  , (\_v407 -> (14, ("noCreateTags",T.TBool _v407))) <$> notebookRestrictions_noCreateTags record
  , (\_v407 -> (15, ("noUpdateTags",T.TBool _v407))) <$> notebookRestrictions_noUpdateTags record
  , (\_v407 -> (16, ("noExpungeTags",T.TBool _v407))) <$> notebookRestrictions_noExpungeTags record
  , (\_v407 -> (17, ("noSetParentTag",T.TBool _v407))) <$> notebookRestrictions_noSetParentTag record
  , (\_v407 -> (18, ("noCreateSharedNotebooks",T.TBool _v407))) <$> notebookRestrictions_noCreateSharedNotebooks record
  , (\_v407 -> (19, ("updateWhichSharedNotebookRestrictions",T.TI32 $ P.fromIntegral $ P.fromEnum _v407))) <$> notebookRestrictions_updateWhichSharedNotebookRestrictions record
  , (\_v407 -> (20, ("expungeWhichSharedNotebookRestrictions",T.TI32 $ P.fromIntegral $ P.fromEnum _v407))) <$> notebookRestrictions_expungeWhichSharedNotebookRestrictions record
  , (\_v407 -> (21, ("noShareNotesWithBusiness",T.TBool _v407))) <$> notebookRestrictions_noShareNotesWithBusiness record
  , (\_v407 -> (22, ("noRenameNotebook",T.TBool _v407))) <$> notebookRestrictions_noRenameNotebook record
  ]
write_NotebookRestrictions :: T.Protocol p => p -> NotebookRestrictions -> P.IO ()
write_NotebookRestrictions oprot record = T.writeVal oprot $ from_NotebookRestrictions record
encode_NotebookRestrictions :: T.StatelessProtocol p => p -> NotebookRestrictions -> LBS.ByteString
encode_NotebookRestrictions oprot record = T.serializeVal oprot $ from_NotebookRestrictions record
to_NotebookRestrictions :: T.ThriftVal -> NotebookRestrictions
to_NotebookRestrictions (T.TStruct fields) = NotebookRestrictions{
  notebookRestrictions_noReadNotes = P.maybe (P.Nothing) (\(_,_val409) -> P.Just (case _val409 of {T.TBool _val410 -> _val410; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  notebookRestrictions_noCreateNotes = P.maybe (P.Nothing) (\(_,_val409) -> P.Just (case _val409 of {T.TBool _val411 -> _val411; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  notebookRestrictions_noUpdateNotes = P.maybe (P.Nothing) (\(_,_val409) -> P.Just (case _val409 of {T.TBool _val412 -> _val412; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  notebookRestrictions_noExpungeNotes = P.maybe (P.Nothing) (\(_,_val409) -> P.Just (case _val409 of {T.TBool _val413 -> _val413; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  notebookRestrictions_noShareNotes = P.maybe (P.Nothing) (\(_,_val409) -> P.Just (case _val409 of {T.TBool _val414 -> _val414; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  notebookRestrictions_noEmailNotes = P.maybe (P.Nothing) (\(_,_val409) -> P.Just (case _val409 of {T.TBool _val415 -> _val415; _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  notebookRestrictions_noSendMessageToRecipients = P.maybe (P.Nothing) (\(_,_val409) -> P.Just (case _val409 of {T.TBool _val416 -> _val416; _ -> P.error "wrong type"})) (Map.lookup (7) fields),
  notebookRestrictions_noUpdateNotebook = P.maybe (P.Nothing) (\(_,_val409) -> P.Just (case _val409 of {T.TBool _val417 -> _val417; _ -> P.error "wrong type"})) (Map.lookup (8) fields),
  notebookRestrictions_noExpungeNotebook = P.maybe (P.Nothing) (\(_,_val409) -> P.Just (case _val409 of {T.TBool _val418 -> _val418; _ -> P.error "wrong type"})) (Map.lookup (9) fields),
  notebookRestrictions_noSetDefaultNotebook = P.maybe (P.Nothing) (\(_,_val409) -> P.Just (case _val409 of {T.TBool _val419 -> _val419; _ -> P.error "wrong type"})) (Map.lookup (10) fields),
  notebookRestrictions_noSetNotebookStack = P.maybe (P.Nothing) (\(_,_val409) -> P.Just (case _val409 of {T.TBool _val420 -> _val420; _ -> P.error "wrong type"})) (Map.lookup (11) fields),
  notebookRestrictions_noPublishToPublic = P.maybe (P.Nothing) (\(_,_val409) -> P.Just (case _val409 of {T.TBool _val421 -> _val421; _ -> P.error "wrong type"})) (Map.lookup (12) fields),
  notebookRestrictions_noPublishToBusinessLibrary = P.maybe (P.Nothing) (\(_,_val409) -> P.Just (case _val409 of {T.TBool _val422 -> _val422; _ -> P.error "wrong type"})) (Map.lookup (13) fields),
  notebookRestrictions_noCreateTags = P.maybe (P.Nothing) (\(_,_val409) -> P.Just (case _val409 of {T.TBool _val423 -> _val423; _ -> P.error "wrong type"})) (Map.lookup (14) fields),
  notebookRestrictions_noUpdateTags = P.maybe (P.Nothing) (\(_,_val409) -> P.Just (case _val409 of {T.TBool _val424 -> _val424; _ -> P.error "wrong type"})) (Map.lookup (15) fields),
  notebookRestrictions_noExpungeTags = P.maybe (P.Nothing) (\(_,_val409) -> P.Just (case _val409 of {T.TBool _val425 -> _val425; _ -> P.error "wrong type"})) (Map.lookup (16) fields),
  notebookRestrictions_noSetParentTag = P.maybe (P.Nothing) (\(_,_val409) -> P.Just (case _val409 of {T.TBool _val426 -> _val426; _ -> P.error "wrong type"})) (Map.lookup (17) fields),
  notebookRestrictions_noCreateSharedNotebooks = P.maybe (P.Nothing) (\(_,_val409) -> P.Just (case _val409 of {T.TBool _val427 -> _val427; _ -> P.error "wrong type"})) (Map.lookup (18) fields),
  notebookRestrictions_updateWhichSharedNotebookRestrictions = P.maybe (P.Nothing) (\(_,_val409) -> P.Just (case _val409 of {T.TI32 _val428 -> P.toEnum $ P.fromIntegral _val428; _ -> P.error "wrong type"})) (Map.lookup (19) fields),
  notebookRestrictions_expungeWhichSharedNotebookRestrictions = P.maybe (P.Nothing) (\(_,_val409) -> P.Just (case _val409 of {T.TI32 _val429 -> P.toEnum $ P.fromIntegral _val429; _ -> P.error "wrong type"})) (Map.lookup (20) fields),
  notebookRestrictions_noShareNotesWithBusiness = P.maybe (P.Nothing) (\(_,_val409) -> P.Just (case _val409 of {T.TBool _val430 -> _val430; _ -> P.error "wrong type"})) (Map.lookup (21) fields),
  notebookRestrictions_noRenameNotebook = P.maybe (P.Nothing) (\(_,_val409) -> P.Just (case _val409 of {T.TBool _val431 -> _val431; _ -> P.error "wrong type"})) (Map.lookup (22) fields)
  }
to_NotebookRestrictions _ = P.error "not a struct"
read_NotebookRestrictions :: T.Protocol p => p -> P.IO NotebookRestrictions
read_NotebookRestrictions iprot = to_NotebookRestrictions <$> T.readVal iprot (T.T_STRUCT typemap_NotebookRestrictions)
decode_NotebookRestrictions :: T.StatelessProtocol p => p -> LBS.ByteString -> NotebookRestrictions
decode_NotebookRestrictions iprot bs = to_NotebookRestrictions $ T.deserializeVal iprot (T.T_STRUCT typemap_NotebookRestrictions) bs
typemap_NotebookRestrictions :: T.TypeMap
typemap_NotebookRestrictions = Map.fromList [(1,("noReadNotes",T.T_BOOL)),(2,("noCreateNotes",T.T_BOOL)),(3,("noUpdateNotes",T.T_BOOL)),(4,("noExpungeNotes",T.T_BOOL)),(5,("noShareNotes",T.T_BOOL)),(6,("noEmailNotes",T.T_BOOL)),(7,("noSendMessageToRecipients",T.T_BOOL)),(8,("noUpdateNotebook",T.T_BOOL)),(9,("noExpungeNotebook",T.T_BOOL)),(10,("noSetDefaultNotebook",T.T_BOOL)),(11,("noSetNotebookStack",T.T_BOOL)),(12,("noPublishToPublic",T.T_BOOL)),(13,("noPublishToBusinessLibrary",T.T_BOOL)),(14,("noCreateTags",T.T_BOOL)),(15,("noUpdateTags",T.T_BOOL)),(16,("noExpungeTags",T.T_BOOL)),(17,("noSetParentTag",T.T_BOOL)),(18,("noCreateSharedNotebooks",T.T_BOOL)),(19,("updateWhichSharedNotebookRestrictions",T.T_I32)),(20,("expungeWhichSharedNotebookRestrictions",T.T_I32)),(21,("noShareNotesWithBusiness",T.T_BOOL)),(22,("noRenameNotebook",T.T_BOOL))]
default_NotebookRestrictions :: NotebookRestrictions
default_NotebookRestrictions = NotebookRestrictions{
  notebookRestrictions_noReadNotes = P.Nothing,
  notebookRestrictions_noCreateNotes = P.Nothing,
  notebookRestrictions_noUpdateNotes = P.Nothing,
  notebookRestrictions_noExpungeNotes = P.Nothing,
  notebookRestrictions_noShareNotes = P.Nothing,
  notebookRestrictions_noEmailNotes = P.Nothing,
  notebookRestrictions_noSendMessageToRecipients = P.Nothing,
  notebookRestrictions_noUpdateNotebook = P.Nothing,
  notebookRestrictions_noExpungeNotebook = P.Nothing,
  notebookRestrictions_noSetDefaultNotebook = P.Nothing,
  notebookRestrictions_noSetNotebookStack = P.Nothing,
  notebookRestrictions_noPublishToPublic = P.Nothing,
  notebookRestrictions_noPublishToBusinessLibrary = P.Nothing,
  notebookRestrictions_noCreateTags = P.Nothing,
  notebookRestrictions_noUpdateTags = P.Nothing,
  notebookRestrictions_noExpungeTags = P.Nothing,
  notebookRestrictions_noSetParentTag = P.Nothing,
  notebookRestrictions_noCreateSharedNotebooks = P.Nothing,
  notebookRestrictions_updateWhichSharedNotebookRestrictions = P.Nothing,
  notebookRestrictions_expungeWhichSharedNotebookRestrictions = P.Nothing,
  notebookRestrictions_noShareNotesWithBusiness = P.Nothing,
  notebookRestrictions_noRenameNotebook = P.Nothing}
data Notebook = Notebook  { notebook_guid :: P.Maybe LT.Text
  , notebook_name :: P.Maybe LT.Text
  , notebook_updateSequenceNum :: P.Maybe I.Int32
  , notebook_defaultNotebook :: P.Maybe P.Bool
  , notebook_serviceCreated :: P.Maybe I.Int64
  , notebook_serviceUpdated :: P.Maybe I.Int64
  , notebook_publishing :: P.Maybe Publishing
  , notebook_published :: P.Maybe P.Bool
  , notebook_stack :: P.Maybe LT.Text
  , notebook_sharedNotebookIds :: P.Maybe (Vector.Vector I.Int64)
  , notebook_sharedNotebooks :: P.Maybe (Vector.Vector SharedNotebook)
  , notebook_businessNotebook :: P.Maybe BusinessNotebook
  , notebook_contact :: P.Maybe User
  , notebook_restrictions :: P.Maybe NotebookRestrictions
  , notebook_recipientSettings :: P.Maybe NotebookRecipientSettings
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable Notebook where
  hashWithSalt salt record = salt   `H.hashWithSalt` notebook_guid record   `H.hashWithSalt` notebook_name record   `H.hashWithSalt` notebook_updateSequenceNum record   `H.hashWithSalt` notebook_defaultNotebook record   `H.hashWithSalt` notebook_serviceCreated record   `H.hashWithSalt` notebook_serviceUpdated record   `H.hashWithSalt` notebook_publishing record   `H.hashWithSalt` notebook_published record   `H.hashWithSalt` notebook_stack record   `H.hashWithSalt` notebook_sharedNotebookIds record   `H.hashWithSalt` notebook_sharedNotebooks record   `H.hashWithSalt` notebook_businessNotebook record   `H.hashWithSalt` notebook_contact record   `H.hashWithSalt` notebook_restrictions record   `H.hashWithSalt` notebook_recipientSettings record  
instance QC.Arbitrary Notebook where 
  arbitrary = M.liftM Notebook (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_Notebook = []
             | P.otherwise = M.catMaybes
    [ if obj == default_Notebook{notebook_guid = notebook_guid obj} then P.Nothing else P.Just $ default_Notebook{notebook_guid = notebook_guid obj}
    , if obj == default_Notebook{notebook_name = notebook_name obj} then P.Nothing else P.Just $ default_Notebook{notebook_name = notebook_name obj}
    , if obj == default_Notebook{notebook_updateSequenceNum = notebook_updateSequenceNum obj} then P.Nothing else P.Just $ default_Notebook{notebook_updateSequenceNum = notebook_updateSequenceNum obj}
    , if obj == default_Notebook{notebook_defaultNotebook = notebook_defaultNotebook obj} then P.Nothing else P.Just $ default_Notebook{notebook_defaultNotebook = notebook_defaultNotebook obj}
    , if obj == default_Notebook{notebook_serviceCreated = notebook_serviceCreated obj} then P.Nothing else P.Just $ default_Notebook{notebook_serviceCreated = notebook_serviceCreated obj}
    , if obj == default_Notebook{notebook_serviceUpdated = notebook_serviceUpdated obj} then P.Nothing else P.Just $ default_Notebook{notebook_serviceUpdated = notebook_serviceUpdated obj}
    , if obj == default_Notebook{notebook_publishing = notebook_publishing obj} then P.Nothing else P.Just $ default_Notebook{notebook_publishing = notebook_publishing obj}
    , if obj == default_Notebook{notebook_published = notebook_published obj} then P.Nothing else P.Just $ default_Notebook{notebook_published = notebook_published obj}
    , if obj == default_Notebook{notebook_stack = notebook_stack obj} then P.Nothing else P.Just $ default_Notebook{notebook_stack = notebook_stack obj}
    , if obj == default_Notebook{notebook_sharedNotebookIds = notebook_sharedNotebookIds obj} then P.Nothing else P.Just $ default_Notebook{notebook_sharedNotebookIds = notebook_sharedNotebookIds obj}
    , if obj == default_Notebook{notebook_sharedNotebooks = notebook_sharedNotebooks obj} then P.Nothing else P.Just $ default_Notebook{notebook_sharedNotebooks = notebook_sharedNotebooks obj}
    , if obj == default_Notebook{notebook_businessNotebook = notebook_businessNotebook obj} then P.Nothing else P.Just $ default_Notebook{notebook_businessNotebook = notebook_businessNotebook obj}
    , if obj == default_Notebook{notebook_contact = notebook_contact obj} then P.Nothing else P.Just $ default_Notebook{notebook_contact = notebook_contact obj}
    , if obj == default_Notebook{notebook_restrictions = notebook_restrictions obj} then P.Nothing else P.Just $ default_Notebook{notebook_restrictions = notebook_restrictions obj}
    , if obj == default_Notebook{notebook_recipientSettings = notebook_recipientSettings obj} then P.Nothing else P.Just $ default_Notebook{notebook_recipientSettings = notebook_recipientSettings obj}
    ]
from_Notebook :: Notebook -> T.ThriftVal
from_Notebook record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v434 -> (1, ("guid",T.TString $ E.encodeUtf8 _v434))) <$> notebook_guid record
  , (\_v434 -> (2, ("name",T.TString $ E.encodeUtf8 _v434))) <$> notebook_name record
  , (\_v434 -> (5, ("updateSequenceNum",T.TI32 _v434))) <$> notebook_updateSequenceNum record
  , (\_v434 -> (6, ("defaultNotebook",T.TBool _v434))) <$> notebook_defaultNotebook record
  , (\_v434 -> (7, ("serviceCreated",T.TI64 _v434))) <$> notebook_serviceCreated record
  , (\_v434 -> (8, ("serviceUpdated",T.TI64 _v434))) <$> notebook_serviceUpdated record
  , (\_v434 -> (10, ("publishing",from_Publishing _v434))) <$> notebook_publishing record
  , (\_v434 -> (11, ("published",T.TBool _v434))) <$> notebook_published record
  , (\_v434 -> (12, ("stack",T.TString $ E.encodeUtf8 _v434))) <$> notebook_stack record
  , (\_v434 -> (13, ("sharedNotebookIds",T.TList T.T_I64 $ P.map (\_v436 -> T.TI64 _v436) $ Vector.toList _v434))) <$> notebook_sharedNotebookIds record
  , (\_v434 -> (14, ("sharedNotebooks",T.TList (T.T_STRUCT typemap_SharedNotebook) $ P.map (\_v438 -> from_SharedNotebook _v438) $ Vector.toList _v434))) <$> notebook_sharedNotebooks record
  , (\_v434 -> (15, ("businessNotebook",from_BusinessNotebook _v434))) <$> notebook_businessNotebook record
  , (\_v434 -> (16, ("contact",from_User _v434))) <$> notebook_contact record
  , (\_v434 -> (17, ("restrictions",from_NotebookRestrictions _v434))) <$> notebook_restrictions record
  , (\_v434 -> (18, ("recipientSettings",from_NotebookRecipientSettings _v434))) <$> notebook_recipientSettings record
  ]
write_Notebook :: T.Protocol p => p -> Notebook -> P.IO ()
write_Notebook oprot record = T.writeVal oprot $ from_Notebook record
encode_Notebook :: T.StatelessProtocol p => p -> Notebook -> LBS.ByteString
encode_Notebook oprot record = T.serializeVal oprot $ from_Notebook record
to_Notebook :: T.ThriftVal -> Notebook
to_Notebook (T.TStruct fields) = Notebook{
  notebook_guid = P.maybe (P.Nothing) (\(_,_val440) -> P.Just (case _val440 of {T.TString _val441 -> E.decodeUtf8 _val441; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  notebook_name = P.maybe (P.Nothing) (\(_,_val440) -> P.Just (case _val440 of {T.TString _val442 -> E.decodeUtf8 _val442; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  notebook_updateSequenceNum = P.maybe (P.Nothing) (\(_,_val440) -> P.Just (case _val440 of {T.TI32 _val443 -> _val443; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  notebook_defaultNotebook = P.maybe (P.Nothing) (\(_,_val440) -> P.Just (case _val440 of {T.TBool _val444 -> _val444; _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  notebook_serviceCreated = P.maybe (P.Nothing) (\(_,_val440) -> P.Just (case _val440 of {T.TI64 _val445 -> _val445; _ -> P.error "wrong type"})) (Map.lookup (7) fields),
  notebook_serviceUpdated = P.maybe (P.Nothing) (\(_,_val440) -> P.Just (case _val440 of {T.TI64 _val446 -> _val446; _ -> P.error "wrong type"})) (Map.lookup (8) fields),
  notebook_publishing = P.maybe (P.Nothing) (\(_,_val440) -> P.Just (case _val440 of {T.TStruct _val447 -> (to_Publishing (T.TStruct _val447)); _ -> P.error "wrong type"})) (Map.lookup (10) fields),
  notebook_published = P.maybe (P.Nothing) (\(_,_val440) -> P.Just (case _val440 of {T.TBool _val448 -> _val448; _ -> P.error "wrong type"})) (Map.lookup (11) fields),
  notebook_stack = P.maybe (P.Nothing) (\(_,_val440) -> P.Just (case _val440 of {T.TString _val449 -> E.decodeUtf8 _val449; _ -> P.error "wrong type"})) (Map.lookup (12) fields),
  notebook_sharedNotebookIds = P.maybe (P.Nothing) (\(_,_val440) -> P.Just (case _val440 of {T.TList _ _val450 -> (Vector.fromList $ P.map (\_v451 -> (case _v451 of {T.TI64 _val452 -> _val452; _ -> P.error "wrong type"})) _val450); _ -> P.error "wrong type"})) (Map.lookup (13) fields),
  notebook_sharedNotebooks = P.maybe (P.Nothing) (\(_,_val440) -> P.Just (case _val440 of {T.TList _ _val453 -> (Vector.fromList $ P.map (\_v454 -> (case _v454 of {T.TStruct _val455 -> (to_SharedNotebook (T.TStruct _val455)); _ -> P.error "wrong type"})) _val453); _ -> P.error "wrong type"})) (Map.lookup (14) fields),
  notebook_businessNotebook = P.maybe (P.Nothing) (\(_,_val440) -> P.Just (case _val440 of {T.TStruct _val456 -> (to_BusinessNotebook (T.TStruct _val456)); _ -> P.error "wrong type"})) (Map.lookup (15) fields),
  notebook_contact = P.maybe (P.Nothing) (\(_,_val440) -> P.Just (case _val440 of {T.TStruct _val457 -> (to_User (T.TStruct _val457)); _ -> P.error "wrong type"})) (Map.lookup (16) fields),
  notebook_restrictions = P.maybe (P.Nothing) (\(_,_val440) -> P.Just (case _val440 of {T.TStruct _val458 -> (to_NotebookRestrictions (T.TStruct _val458)); _ -> P.error "wrong type"})) (Map.lookup (17) fields),
  notebook_recipientSettings = P.maybe (P.Nothing) (\(_,_val440) -> P.Just (case _val440 of {T.TStruct _val459 -> (to_NotebookRecipientSettings (T.TStruct _val459)); _ -> P.error "wrong type"})) (Map.lookup (18) fields)
  }
to_Notebook _ = P.error "not a struct"
read_Notebook :: T.Protocol p => p -> P.IO Notebook
read_Notebook iprot = to_Notebook <$> T.readVal iprot (T.T_STRUCT typemap_Notebook)
decode_Notebook :: T.StatelessProtocol p => p -> LBS.ByteString -> Notebook
decode_Notebook iprot bs = to_Notebook $ T.deserializeVal iprot (T.T_STRUCT typemap_Notebook) bs
typemap_Notebook :: T.TypeMap
typemap_Notebook = Map.fromList [(1,("guid",T.T_STRING)),(2,("name",T.T_STRING)),(5,("updateSequenceNum",T.T_I32)),(6,("defaultNotebook",T.T_BOOL)),(7,("serviceCreated",T.T_I64)),(8,("serviceUpdated",T.T_I64)),(10,("publishing",(T.T_STRUCT typemap_Publishing))),(11,("published",T.T_BOOL)),(12,("stack",T.T_STRING)),(13,("sharedNotebookIds",(T.T_LIST T.T_I64))),(14,("sharedNotebooks",(T.T_LIST (T.T_STRUCT typemap_SharedNotebook)))),(15,("businessNotebook",(T.T_STRUCT typemap_BusinessNotebook))),(16,("contact",(T.T_STRUCT typemap_User))),(17,("restrictions",(T.T_STRUCT typemap_NotebookRestrictions))),(18,("recipientSettings",(T.T_STRUCT typemap_NotebookRecipientSettings)))]
default_Notebook :: Notebook
default_Notebook = Notebook{
  notebook_guid = P.Nothing,
  notebook_name = P.Nothing,
  notebook_updateSequenceNum = P.Nothing,
  notebook_defaultNotebook = P.Nothing,
  notebook_serviceCreated = P.Nothing,
  notebook_serviceUpdated = P.Nothing,
  notebook_publishing = P.Nothing,
  notebook_published = P.Nothing,
  notebook_stack = P.Nothing,
  notebook_sharedNotebookIds = P.Nothing,
  notebook_sharedNotebooks = P.Nothing,
  notebook_businessNotebook = P.Nothing,
  notebook_contact = P.Nothing,
  notebook_restrictions = P.Nothing,
  notebook_recipientSettings = P.Nothing}
data LinkedNotebook = LinkedNotebook  { linkedNotebook_shareName :: P.Maybe LT.Text
  , linkedNotebook_username :: P.Maybe LT.Text
  , linkedNotebook_shardId :: P.Maybe LT.Text
  , linkedNotebook_sharedNotebookGlobalId :: P.Maybe LT.Text
  , linkedNotebook_uri :: P.Maybe LT.Text
  , linkedNotebook_guid :: P.Maybe LT.Text
  , linkedNotebook_updateSequenceNum :: P.Maybe I.Int32
  , linkedNotebook_noteStoreUrl :: P.Maybe LT.Text
  , linkedNotebook_webApiUrlPrefix :: P.Maybe LT.Text
  , linkedNotebook_stack :: P.Maybe LT.Text
  , linkedNotebook_businessId :: P.Maybe I.Int32
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable LinkedNotebook where
  hashWithSalt salt record = salt   `H.hashWithSalt` linkedNotebook_shareName record   `H.hashWithSalt` linkedNotebook_username record   `H.hashWithSalt` linkedNotebook_shardId record   `H.hashWithSalt` linkedNotebook_sharedNotebookGlobalId record   `H.hashWithSalt` linkedNotebook_uri record   `H.hashWithSalt` linkedNotebook_guid record   `H.hashWithSalt` linkedNotebook_updateSequenceNum record   `H.hashWithSalt` linkedNotebook_noteStoreUrl record   `H.hashWithSalt` linkedNotebook_webApiUrlPrefix record   `H.hashWithSalt` linkedNotebook_stack record   `H.hashWithSalt` linkedNotebook_businessId record  
instance QC.Arbitrary LinkedNotebook where 
  arbitrary = M.liftM LinkedNotebook (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_LinkedNotebook = []
             | P.otherwise = M.catMaybes
    [ if obj == default_LinkedNotebook{linkedNotebook_shareName = linkedNotebook_shareName obj} then P.Nothing else P.Just $ default_LinkedNotebook{linkedNotebook_shareName = linkedNotebook_shareName obj}
    , if obj == default_LinkedNotebook{linkedNotebook_username = linkedNotebook_username obj} then P.Nothing else P.Just $ default_LinkedNotebook{linkedNotebook_username = linkedNotebook_username obj}
    , if obj == default_LinkedNotebook{linkedNotebook_shardId = linkedNotebook_shardId obj} then P.Nothing else P.Just $ default_LinkedNotebook{linkedNotebook_shardId = linkedNotebook_shardId obj}
    , if obj == default_LinkedNotebook{linkedNotebook_sharedNotebookGlobalId = linkedNotebook_sharedNotebookGlobalId obj} then P.Nothing else P.Just $ default_LinkedNotebook{linkedNotebook_sharedNotebookGlobalId = linkedNotebook_sharedNotebookGlobalId obj}
    , if obj == default_LinkedNotebook{linkedNotebook_uri = linkedNotebook_uri obj} then P.Nothing else P.Just $ default_LinkedNotebook{linkedNotebook_uri = linkedNotebook_uri obj}
    , if obj == default_LinkedNotebook{linkedNotebook_guid = linkedNotebook_guid obj} then P.Nothing else P.Just $ default_LinkedNotebook{linkedNotebook_guid = linkedNotebook_guid obj}
    , if obj == default_LinkedNotebook{linkedNotebook_updateSequenceNum = linkedNotebook_updateSequenceNum obj} then P.Nothing else P.Just $ default_LinkedNotebook{linkedNotebook_updateSequenceNum = linkedNotebook_updateSequenceNum obj}
    , if obj == default_LinkedNotebook{linkedNotebook_noteStoreUrl = linkedNotebook_noteStoreUrl obj} then P.Nothing else P.Just $ default_LinkedNotebook{linkedNotebook_noteStoreUrl = linkedNotebook_noteStoreUrl obj}
    , if obj == default_LinkedNotebook{linkedNotebook_webApiUrlPrefix = linkedNotebook_webApiUrlPrefix obj} then P.Nothing else P.Just $ default_LinkedNotebook{linkedNotebook_webApiUrlPrefix = linkedNotebook_webApiUrlPrefix obj}
    , if obj == default_LinkedNotebook{linkedNotebook_stack = linkedNotebook_stack obj} then P.Nothing else P.Just $ default_LinkedNotebook{linkedNotebook_stack = linkedNotebook_stack obj}
    , if obj == default_LinkedNotebook{linkedNotebook_businessId = linkedNotebook_businessId obj} then P.Nothing else P.Just $ default_LinkedNotebook{linkedNotebook_businessId = linkedNotebook_businessId obj}
    ]
from_LinkedNotebook :: LinkedNotebook -> T.ThriftVal
from_LinkedNotebook record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v462 -> (2, ("shareName",T.TString $ E.encodeUtf8 _v462))) <$> linkedNotebook_shareName record
  , (\_v462 -> (3, ("username",T.TString $ E.encodeUtf8 _v462))) <$> linkedNotebook_username record
  , (\_v462 -> (4, ("shardId",T.TString $ E.encodeUtf8 _v462))) <$> linkedNotebook_shardId record
  , (\_v462 -> (5, ("sharedNotebookGlobalId",T.TString $ E.encodeUtf8 _v462))) <$> linkedNotebook_sharedNotebookGlobalId record
  , (\_v462 -> (6, ("uri",T.TString $ E.encodeUtf8 _v462))) <$> linkedNotebook_uri record
  , (\_v462 -> (7, ("guid",T.TString $ E.encodeUtf8 _v462))) <$> linkedNotebook_guid record
  , (\_v462 -> (8, ("updateSequenceNum",T.TI32 _v462))) <$> linkedNotebook_updateSequenceNum record
  , (\_v462 -> (9, ("noteStoreUrl",T.TString $ E.encodeUtf8 _v462))) <$> linkedNotebook_noteStoreUrl record
  , (\_v462 -> (10, ("webApiUrlPrefix",T.TString $ E.encodeUtf8 _v462))) <$> linkedNotebook_webApiUrlPrefix record
  , (\_v462 -> (11, ("stack",T.TString $ E.encodeUtf8 _v462))) <$> linkedNotebook_stack record
  , (\_v462 -> (12, ("businessId",T.TI32 _v462))) <$> linkedNotebook_businessId record
  ]
write_LinkedNotebook :: T.Protocol p => p -> LinkedNotebook -> P.IO ()
write_LinkedNotebook oprot record = T.writeVal oprot $ from_LinkedNotebook record
encode_LinkedNotebook :: T.StatelessProtocol p => p -> LinkedNotebook -> LBS.ByteString
encode_LinkedNotebook oprot record = T.serializeVal oprot $ from_LinkedNotebook record
to_LinkedNotebook :: T.ThriftVal -> LinkedNotebook
to_LinkedNotebook (T.TStruct fields) = LinkedNotebook{
  linkedNotebook_shareName = P.maybe (P.Nothing) (\(_,_val464) -> P.Just (case _val464 of {T.TString _val465 -> E.decodeUtf8 _val465; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  linkedNotebook_username = P.maybe (P.Nothing) (\(_,_val464) -> P.Just (case _val464 of {T.TString _val466 -> E.decodeUtf8 _val466; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  linkedNotebook_shardId = P.maybe (P.Nothing) (\(_,_val464) -> P.Just (case _val464 of {T.TString _val467 -> E.decodeUtf8 _val467; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  linkedNotebook_sharedNotebookGlobalId = P.maybe (P.Nothing) (\(_,_val464) -> P.Just (case _val464 of {T.TString _val468 -> E.decodeUtf8 _val468; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  linkedNotebook_uri = P.maybe (P.Nothing) (\(_,_val464) -> P.Just (case _val464 of {T.TString _val469 -> E.decodeUtf8 _val469; _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  linkedNotebook_guid = P.maybe (P.Nothing) (\(_,_val464) -> P.Just (case _val464 of {T.TString _val470 -> E.decodeUtf8 _val470; _ -> P.error "wrong type"})) (Map.lookup (7) fields),
  linkedNotebook_updateSequenceNum = P.maybe (P.Nothing) (\(_,_val464) -> P.Just (case _val464 of {T.TI32 _val471 -> _val471; _ -> P.error "wrong type"})) (Map.lookup (8) fields),
  linkedNotebook_noteStoreUrl = P.maybe (P.Nothing) (\(_,_val464) -> P.Just (case _val464 of {T.TString _val472 -> E.decodeUtf8 _val472; _ -> P.error "wrong type"})) (Map.lookup (9) fields),
  linkedNotebook_webApiUrlPrefix = P.maybe (P.Nothing) (\(_,_val464) -> P.Just (case _val464 of {T.TString _val473 -> E.decodeUtf8 _val473; _ -> P.error "wrong type"})) (Map.lookup (10) fields),
  linkedNotebook_stack = P.maybe (P.Nothing) (\(_,_val464) -> P.Just (case _val464 of {T.TString _val474 -> E.decodeUtf8 _val474; _ -> P.error "wrong type"})) (Map.lookup (11) fields),
  linkedNotebook_businessId = P.maybe (P.Nothing) (\(_,_val464) -> P.Just (case _val464 of {T.TI32 _val475 -> _val475; _ -> P.error "wrong type"})) (Map.lookup (12) fields)
  }
to_LinkedNotebook _ = P.error "not a struct"
read_LinkedNotebook :: T.Protocol p => p -> P.IO LinkedNotebook
read_LinkedNotebook iprot = to_LinkedNotebook <$> T.readVal iprot (T.T_STRUCT typemap_LinkedNotebook)
decode_LinkedNotebook :: T.StatelessProtocol p => p -> LBS.ByteString -> LinkedNotebook
decode_LinkedNotebook iprot bs = to_LinkedNotebook $ T.deserializeVal iprot (T.T_STRUCT typemap_LinkedNotebook) bs
typemap_LinkedNotebook :: T.TypeMap
typemap_LinkedNotebook = Map.fromList [(2,("shareName",T.T_STRING)),(3,("username",T.T_STRING)),(4,("shardId",T.T_STRING)),(5,("sharedNotebookGlobalId",T.T_STRING)),(6,("uri",T.T_STRING)),(7,("guid",T.T_STRING)),(8,("updateSequenceNum",T.T_I32)),(9,("noteStoreUrl",T.T_STRING)),(10,("webApiUrlPrefix",T.T_STRING)),(11,("stack",T.T_STRING)),(12,("businessId",T.T_I32))]
default_LinkedNotebook :: LinkedNotebook
default_LinkedNotebook = LinkedNotebook{
  linkedNotebook_shareName = P.Nothing,
  linkedNotebook_username = P.Nothing,
  linkedNotebook_shardId = P.Nothing,
  linkedNotebook_sharedNotebookGlobalId = P.Nothing,
  linkedNotebook_uri = P.Nothing,
  linkedNotebook_guid = P.Nothing,
  linkedNotebook_updateSequenceNum = P.Nothing,
  linkedNotebook_noteStoreUrl = P.Nothing,
  linkedNotebook_webApiUrlPrefix = P.Nothing,
  linkedNotebook_stack = P.Nothing,
  linkedNotebook_businessId = P.Nothing}
data NotebookDescriptor = NotebookDescriptor  { notebookDescriptor_guid :: P.Maybe LT.Text
  , notebookDescriptor_notebookDisplayName :: P.Maybe LT.Text
  , notebookDescriptor_contactName :: P.Maybe LT.Text
  , notebookDescriptor_hasSharedNotebook :: P.Maybe P.Bool
  , notebookDescriptor_joinedUserCount :: P.Maybe I.Int32
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable NotebookDescriptor where
  hashWithSalt salt record = salt   `H.hashWithSalt` notebookDescriptor_guid record   `H.hashWithSalt` notebookDescriptor_notebookDisplayName record   `H.hashWithSalt` notebookDescriptor_contactName record   `H.hashWithSalt` notebookDescriptor_hasSharedNotebook record   `H.hashWithSalt` notebookDescriptor_joinedUserCount record  
instance QC.Arbitrary NotebookDescriptor where 
  arbitrary = M.liftM NotebookDescriptor (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_NotebookDescriptor = []
             | P.otherwise = M.catMaybes
    [ if obj == default_NotebookDescriptor{notebookDescriptor_guid = notebookDescriptor_guid obj} then P.Nothing else P.Just $ default_NotebookDescriptor{notebookDescriptor_guid = notebookDescriptor_guid obj}
    , if obj == default_NotebookDescriptor{notebookDescriptor_notebookDisplayName = notebookDescriptor_notebookDisplayName obj} then P.Nothing else P.Just $ default_NotebookDescriptor{notebookDescriptor_notebookDisplayName = notebookDescriptor_notebookDisplayName obj}
    , if obj == default_NotebookDescriptor{notebookDescriptor_contactName = notebookDescriptor_contactName obj} then P.Nothing else P.Just $ default_NotebookDescriptor{notebookDescriptor_contactName = notebookDescriptor_contactName obj}
    , if obj == default_NotebookDescriptor{notebookDescriptor_hasSharedNotebook = notebookDescriptor_hasSharedNotebook obj} then P.Nothing else P.Just $ default_NotebookDescriptor{notebookDescriptor_hasSharedNotebook = notebookDescriptor_hasSharedNotebook obj}
    , if obj == default_NotebookDescriptor{notebookDescriptor_joinedUserCount = notebookDescriptor_joinedUserCount obj} then P.Nothing else P.Just $ default_NotebookDescriptor{notebookDescriptor_joinedUserCount = notebookDescriptor_joinedUserCount obj}
    ]
from_NotebookDescriptor :: NotebookDescriptor -> T.ThriftVal
from_NotebookDescriptor record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v478 -> (1, ("guid",T.TString $ E.encodeUtf8 _v478))) <$> notebookDescriptor_guid record
  , (\_v478 -> (2, ("notebookDisplayName",T.TString $ E.encodeUtf8 _v478))) <$> notebookDescriptor_notebookDisplayName record
  , (\_v478 -> (3, ("contactName",T.TString $ E.encodeUtf8 _v478))) <$> notebookDescriptor_contactName record
  , (\_v478 -> (4, ("hasSharedNotebook",T.TBool _v478))) <$> notebookDescriptor_hasSharedNotebook record
  , (\_v478 -> (5, ("joinedUserCount",T.TI32 _v478))) <$> notebookDescriptor_joinedUserCount record
  ]
write_NotebookDescriptor :: T.Protocol p => p -> NotebookDescriptor -> P.IO ()
write_NotebookDescriptor oprot record = T.writeVal oprot $ from_NotebookDescriptor record
encode_NotebookDescriptor :: T.StatelessProtocol p => p -> NotebookDescriptor -> LBS.ByteString
encode_NotebookDescriptor oprot record = T.serializeVal oprot $ from_NotebookDescriptor record
to_NotebookDescriptor :: T.ThriftVal -> NotebookDescriptor
to_NotebookDescriptor (T.TStruct fields) = NotebookDescriptor{
  notebookDescriptor_guid = P.maybe (P.Nothing) (\(_,_val480) -> P.Just (case _val480 of {T.TString _val481 -> E.decodeUtf8 _val481; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  notebookDescriptor_notebookDisplayName = P.maybe (P.Nothing) (\(_,_val480) -> P.Just (case _val480 of {T.TString _val482 -> E.decodeUtf8 _val482; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  notebookDescriptor_contactName = P.maybe (P.Nothing) (\(_,_val480) -> P.Just (case _val480 of {T.TString _val483 -> E.decodeUtf8 _val483; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  notebookDescriptor_hasSharedNotebook = P.maybe (P.Nothing) (\(_,_val480) -> P.Just (case _val480 of {T.TBool _val484 -> _val484; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  notebookDescriptor_joinedUserCount = P.maybe (P.Nothing) (\(_,_val480) -> P.Just (case _val480 of {T.TI32 _val485 -> _val485; _ -> P.error "wrong type"})) (Map.lookup (5) fields)
  }
to_NotebookDescriptor _ = P.error "not a struct"
read_NotebookDescriptor :: T.Protocol p => p -> P.IO NotebookDescriptor
read_NotebookDescriptor iprot = to_NotebookDescriptor <$> T.readVal iprot (T.T_STRUCT typemap_NotebookDescriptor)
decode_NotebookDescriptor :: T.StatelessProtocol p => p -> LBS.ByteString -> NotebookDescriptor
decode_NotebookDescriptor iprot bs = to_NotebookDescriptor $ T.deserializeVal iprot (T.T_STRUCT typemap_NotebookDescriptor) bs
typemap_NotebookDescriptor :: T.TypeMap
typemap_NotebookDescriptor = Map.fromList [(1,("guid",T.T_STRING)),(2,("notebookDisplayName",T.T_STRING)),(3,("contactName",T.T_STRING)),(4,("hasSharedNotebook",T.T_BOOL)),(5,("joinedUserCount",T.T_I32))]
default_NotebookDescriptor :: NotebookDescriptor
default_NotebookDescriptor = NotebookDescriptor{
  notebookDescriptor_guid = P.Nothing,
  notebookDescriptor_notebookDisplayName = P.Nothing,
  notebookDescriptor_contactName = P.Nothing,
  notebookDescriptor_hasSharedNotebook = P.Nothing,
  notebookDescriptor_joinedUserCount = P.Nothing}
data UserProfile = UserProfile  { userProfile_id :: P.Maybe I.Int32
  , userProfile_name :: P.Maybe LT.Text
  , userProfile_email :: P.Maybe LT.Text
  , userProfile_username :: P.Maybe LT.Text
  , userProfile_attributes :: P.Maybe BusinessUserAttributes
  , userProfile_joined :: P.Maybe I.Int64
  , userProfile_photoLastUpdated :: P.Maybe I.Int64
  , userProfile_photoUrl :: P.Maybe LT.Text
  , userProfile_role :: P.Maybe BusinessUserRole
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UserProfile where
  hashWithSalt salt record = salt   `H.hashWithSalt` userProfile_id record   `H.hashWithSalt` userProfile_name record   `H.hashWithSalt` userProfile_email record   `H.hashWithSalt` userProfile_username record   `H.hashWithSalt` userProfile_attributes record   `H.hashWithSalt` userProfile_joined record   `H.hashWithSalt` userProfile_photoLastUpdated record   `H.hashWithSalt` userProfile_photoUrl record   `H.hashWithSalt` userProfile_role record  
instance QC.Arbitrary UserProfile where 
  arbitrary = M.liftM UserProfile (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_UserProfile = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UserProfile{userProfile_id = userProfile_id obj} then P.Nothing else P.Just $ default_UserProfile{userProfile_id = userProfile_id obj}
    , if obj == default_UserProfile{userProfile_name = userProfile_name obj} then P.Nothing else P.Just $ default_UserProfile{userProfile_name = userProfile_name obj}
    , if obj == default_UserProfile{userProfile_email = userProfile_email obj} then P.Nothing else P.Just $ default_UserProfile{userProfile_email = userProfile_email obj}
    , if obj == default_UserProfile{userProfile_username = userProfile_username obj} then P.Nothing else P.Just $ default_UserProfile{userProfile_username = userProfile_username obj}
    , if obj == default_UserProfile{userProfile_attributes = userProfile_attributes obj} then P.Nothing else P.Just $ default_UserProfile{userProfile_attributes = userProfile_attributes obj}
    , if obj == default_UserProfile{userProfile_joined = userProfile_joined obj} then P.Nothing else P.Just $ default_UserProfile{userProfile_joined = userProfile_joined obj}
    , if obj == default_UserProfile{userProfile_photoLastUpdated = userProfile_photoLastUpdated obj} then P.Nothing else P.Just $ default_UserProfile{userProfile_photoLastUpdated = userProfile_photoLastUpdated obj}
    , if obj == default_UserProfile{userProfile_photoUrl = userProfile_photoUrl obj} then P.Nothing else P.Just $ default_UserProfile{userProfile_photoUrl = userProfile_photoUrl obj}
    , if obj == default_UserProfile{userProfile_role = userProfile_role obj} then P.Nothing else P.Just $ default_UserProfile{userProfile_role = userProfile_role obj}
    ]
from_UserProfile :: UserProfile -> T.ThriftVal
from_UserProfile record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v488 -> (1, ("id",T.TI32 _v488))) <$> userProfile_id record
  , (\_v488 -> (2, ("name",T.TString $ E.encodeUtf8 _v488))) <$> userProfile_name record
  , (\_v488 -> (3, ("email",T.TString $ E.encodeUtf8 _v488))) <$> userProfile_email record
  , (\_v488 -> (4, ("username",T.TString $ E.encodeUtf8 _v488))) <$> userProfile_username record
  , (\_v488 -> (5, ("attributes",from_BusinessUserAttributes _v488))) <$> userProfile_attributes record
  , (\_v488 -> (6, ("joined",T.TI64 _v488))) <$> userProfile_joined record
  , (\_v488 -> (7, ("photoLastUpdated",T.TI64 _v488))) <$> userProfile_photoLastUpdated record
  , (\_v488 -> (8, ("photoUrl",T.TString $ E.encodeUtf8 _v488))) <$> userProfile_photoUrl record
  , (\_v488 -> (9, ("role",T.TI32 $ P.fromIntegral $ P.fromEnum _v488))) <$> userProfile_role record
  ]
write_UserProfile :: T.Protocol p => p -> UserProfile -> P.IO ()
write_UserProfile oprot record = T.writeVal oprot $ from_UserProfile record
encode_UserProfile :: T.StatelessProtocol p => p -> UserProfile -> LBS.ByteString
encode_UserProfile oprot record = T.serializeVal oprot $ from_UserProfile record
to_UserProfile :: T.ThriftVal -> UserProfile
to_UserProfile (T.TStruct fields) = UserProfile{
  userProfile_id = P.maybe (P.Nothing) (\(_,_val490) -> P.Just (case _val490 of {T.TI32 _val491 -> _val491; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  userProfile_name = P.maybe (P.Nothing) (\(_,_val490) -> P.Just (case _val490 of {T.TString _val492 -> E.decodeUtf8 _val492; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  userProfile_email = P.maybe (P.Nothing) (\(_,_val490) -> P.Just (case _val490 of {T.TString _val493 -> E.decodeUtf8 _val493; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  userProfile_username = P.maybe (P.Nothing) (\(_,_val490) -> P.Just (case _val490 of {T.TString _val494 -> E.decodeUtf8 _val494; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  userProfile_attributes = P.maybe (P.Nothing) (\(_,_val490) -> P.Just (case _val490 of {T.TStruct _val495 -> (to_BusinessUserAttributes (T.TStruct _val495)); _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  userProfile_joined = P.maybe (P.Nothing) (\(_,_val490) -> P.Just (case _val490 of {T.TI64 _val496 -> _val496; _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  userProfile_photoLastUpdated = P.maybe (P.Nothing) (\(_,_val490) -> P.Just (case _val490 of {T.TI64 _val497 -> _val497; _ -> P.error "wrong type"})) (Map.lookup (7) fields),
  userProfile_photoUrl = P.maybe (P.Nothing) (\(_,_val490) -> P.Just (case _val490 of {T.TString _val498 -> E.decodeUtf8 _val498; _ -> P.error "wrong type"})) (Map.lookup (8) fields),
  userProfile_role = P.maybe (P.Nothing) (\(_,_val490) -> P.Just (case _val490 of {T.TI32 _val499 -> P.toEnum $ P.fromIntegral _val499; _ -> P.error "wrong type"})) (Map.lookup (9) fields)
  }
to_UserProfile _ = P.error "not a struct"
read_UserProfile :: T.Protocol p => p -> P.IO UserProfile
read_UserProfile iprot = to_UserProfile <$> T.readVal iprot (T.T_STRUCT typemap_UserProfile)
decode_UserProfile :: T.StatelessProtocol p => p -> LBS.ByteString -> UserProfile
decode_UserProfile iprot bs = to_UserProfile $ T.deserializeVal iprot (T.T_STRUCT typemap_UserProfile) bs
typemap_UserProfile :: T.TypeMap
typemap_UserProfile = Map.fromList [(1,("id",T.T_I32)),(2,("name",T.T_STRING)),(3,("email",T.T_STRING)),(4,("username",T.T_STRING)),(5,("attributes",(T.T_STRUCT typemap_BusinessUserAttributes))),(6,("joined",T.T_I64)),(7,("photoLastUpdated",T.T_I64)),(8,("photoUrl",T.T_STRING)),(9,("role",T.T_I32))]
default_UserProfile :: UserProfile
default_UserProfile = UserProfile{
  userProfile_id = P.Nothing,
  userProfile_name = P.Nothing,
  userProfile_email = P.Nothing,
  userProfile_username = P.Nothing,
  userProfile_attributes = P.Nothing,
  userProfile_joined = P.Nothing,
  userProfile_photoLastUpdated = P.Nothing,
  userProfile_photoUrl = P.Nothing,
  userProfile_role = P.Nothing}
data RelatedContentImage = RelatedContentImage  { relatedContentImage_url :: P.Maybe LT.Text
  , relatedContentImage_width :: P.Maybe I.Int32
  , relatedContentImage_height :: P.Maybe I.Int32
  , relatedContentImage_pixelRatio :: P.Maybe P.Double
  , relatedContentImage_fileSize :: P.Maybe I.Int32
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RelatedContentImage where
  hashWithSalt salt record = salt   `H.hashWithSalt` relatedContentImage_url record   `H.hashWithSalt` relatedContentImage_width record   `H.hashWithSalt` relatedContentImage_height record   `H.hashWithSalt` relatedContentImage_pixelRatio record   `H.hashWithSalt` relatedContentImage_fileSize record  
instance QC.Arbitrary RelatedContentImage where 
  arbitrary = M.liftM RelatedContentImage (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_RelatedContentImage = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RelatedContentImage{relatedContentImage_url = relatedContentImage_url obj} then P.Nothing else P.Just $ default_RelatedContentImage{relatedContentImage_url = relatedContentImage_url obj}
    , if obj == default_RelatedContentImage{relatedContentImage_width = relatedContentImage_width obj} then P.Nothing else P.Just $ default_RelatedContentImage{relatedContentImage_width = relatedContentImage_width obj}
    , if obj == default_RelatedContentImage{relatedContentImage_height = relatedContentImage_height obj} then P.Nothing else P.Just $ default_RelatedContentImage{relatedContentImage_height = relatedContentImage_height obj}
    , if obj == default_RelatedContentImage{relatedContentImage_pixelRatio = relatedContentImage_pixelRatio obj} then P.Nothing else P.Just $ default_RelatedContentImage{relatedContentImage_pixelRatio = relatedContentImage_pixelRatio obj}
    , if obj == default_RelatedContentImage{relatedContentImage_fileSize = relatedContentImage_fileSize obj} then P.Nothing else P.Just $ default_RelatedContentImage{relatedContentImage_fileSize = relatedContentImage_fileSize obj}
    ]
from_RelatedContentImage :: RelatedContentImage -> T.ThriftVal
from_RelatedContentImage record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v502 -> (1, ("url",T.TString $ E.encodeUtf8 _v502))) <$> relatedContentImage_url record
  , (\_v502 -> (2, ("width",T.TI32 _v502))) <$> relatedContentImage_width record
  , (\_v502 -> (3, ("height",T.TI32 _v502))) <$> relatedContentImage_height record
  , (\_v502 -> (4, ("pixelRatio",T.TDouble _v502))) <$> relatedContentImage_pixelRatio record
  , (\_v502 -> (5, ("fileSize",T.TI32 _v502))) <$> relatedContentImage_fileSize record
  ]
write_RelatedContentImage :: T.Protocol p => p -> RelatedContentImage -> P.IO ()
write_RelatedContentImage oprot record = T.writeVal oprot $ from_RelatedContentImage record
encode_RelatedContentImage :: T.StatelessProtocol p => p -> RelatedContentImage -> LBS.ByteString
encode_RelatedContentImage oprot record = T.serializeVal oprot $ from_RelatedContentImage record
to_RelatedContentImage :: T.ThriftVal -> RelatedContentImage
to_RelatedContentImage (T.TStruct fields) = RelatedContentImage{
  relatedContentImage_url = P.maybe (P.Nothing) (\(_,_val504) -> P.Just (case _val504 of {T.TString _val505 -> E.decodeUtf8 _val505; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  relatedContentImage_width = P.maybe (P.Nothing) (\(_,_val504) -> P.Just (case _val504 of {T.TI32 _val506 -> _val506; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  relatedContentImage_height = P.maybe (P.Nothing) (\(_,_val504) -> P.Just (case _val504 of {T.TI32 _val507 -> _val507; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  relatedContentImage_pixelRatio = P.maybe (P.Nothing) (\(_,_val504) -> P.Just (case _val504 of {T.TDouble _val508 -> _val508; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  relatedContentImage_fileSize = P.maybe (P.Nothing) (\(_,_val504) -> P.Just (case _val504 of {T.TI32 _val509 -> _val509; _ -> P.error "wrong type"})) (Map.lookup (5) fields)
  }
to_RelatedContentImage _ = P.error "not a struct"
read_RelatedContentImage :: T.Protocol p => p -> P.IO RelatedContentImage
read_RelatedContentImage iprot = to_RelatedContentImage <$> T.readVal iprot (T.T_STRUCT typemap_RelatedContentImage)
decode_RelatedContentImage :: T.StatelessProtocol p => p -> LBS.ByteString -> RelatedContentImage
decode_RelatedContentImage iprot bs = to_RelatedContentImage $ T.deserializeVal iprot (T.T_STRUCT typemap_RelatedContentImage) bs
typemap_RelatedContentImage :: T.TypeMap
typemap_RelatedContentImage = Map.fromList [(1,("url",T.T_STRING)),(2,("width",T.T_I32)),(3,("height",T.T_I32)),(4,("pixelRatio",T.T_DOUBLE)),(5,("fileSize",T.T_I32))]
default_RelatedContentImage :: RelatedContentImage
default_RelatedContentImage = RelatedContentImage{
  relatedContentImage_url = P.Nothing,
  relatedContentImage_width = P.Nothing,
  relatedContentImage_height = P.Nothing,
  relatedContentImage_pixelRatio = P.Nothing,
  relatedContentImage_fileSize = P.Nothing}
data RelatedContent = RelatedContent  { relatedContent_contentId :: P.Maybe LT.Text
  , relatedContent_title :: P.Maybe LT.Text
  , relatedContent_url :: P.Maybe LT.Text
  , relatedContent_sourceId :: P.Maybe LT.Text
  , relatedContent_sourceUrl :: P.Maybe LT.Text
  , relatedContent_sourceFaviconUrl :: P.Maybe LT.Text
  , relatedContent_sourceName :: P.Maybe LT.Text
  , relatedContent_date :: P.Maybe I.Int64
  , relatedContent_teaser :: P.Maybe LT.Text
  , relatedContent_thumbnails :: P.Maybe (Vector.Vector RelatedContentImage)
  , relatedContent_contentType :: P.Maybe RelatedContentType
  , relatedContent_accessType :: P.Maybe RelatedContentAccess
  , relatedContent_visibleUrl :: P.Maybe LT.Text
  , relatedContent_clipUrl :: P.Maybe LT.Text
  , relatedContent_contact :: P.Maybe Contact
  , relatedContent_authors :: P.Maybe (Vector.Vector LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable RelatedContent where
  hashWithSalt salt record = salt   `H.hashWithSalt` relatedContent_contentId record   `H.hashWithSalt` relatedContent_title record   `H.hashWithSalt` relatedContent_url record   `H.hashWithSalt` relatedContent_sourceId record   `H.hashWithSalt` relatedContent_sourceUrl record   `H.hashWithSalt` relatedContent_sourceFaviconUrl record   `H.hashWithSalt` relatedContent_sourceName record   `H.hashWithSalt` relatedContent_date record   `H.hashWithSalt` relatedContent_teaser record   `H.hashWithSalt` relatedContent_thumbnails record   `H.hashWithSalt` relatedContent_contentType record   `H.hashWithSalt` relatedContent_accessType record   `H.hashWithSalt` relatedContent_visibleUrl record   `H.hashWithSalt` relatedContent_clipUrl record   `H.hashWithSalt` relatedContent_contact record   `H.hashWithSalt` relatedContent_authors record  
instance QC.Arbitrary RelatedContent where 
  arbitrary = M.liftM RelatedContent (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_RelatedContent = []
             | P.otherwise = M.catMaybes
    [ if obj == default_RelatedContent{relatedContent_contentId = relatedContent_contentId obj} then P.Nothing else P.Just $ default_RelatedContent{relatedContent_contentId = relatedContent_contentId obj}
    , if obj == default_RelatedContent{relatedContent_title = relatedContent_title obj} then P.Nothing else P.Just $ default_RelatedContent{relatedContent_title = relatedContent_title obj}
    , if obj == default_RelatedContent{relatedContent_url = relatedContent_url obj} then P.Nothing else P.Just $ default_RelatedContent{relatedContent_url = relatedContent_url obj}
    , if obj == default_RelatedContent{relatedContent_sourceId = relatedContent_sourceId obj} then P.Nothing else P.Just $ default_RelatedContent{relatedContent_sourceId = relatedContent_sourceId obj}
    , if obj == default_RelatedContent{relatedContent_sourceUrl = relatedContent_sourceUrl obj} then P.Nothing else P.Just $ default_RelatedContent{relatedContent_sourceUrl = relatedContent_sourceUrl obj}
    , if obj == default_RelatedContent{relatedContent_sourceFaviconUrl = relatedContent_sourceFaviconUrl obj} then P.Nothing else P.Just $ default_RelatedContent{relatedContent_sourceFaviconUrl = relatedContent_sourceFaviconUrl obj}
    , if obj == default_RelatedContent{relatedContent_sourceName = relatedContent_sourceName obj} then P.Nothing else P.Just $ default_RelatedContent{relatedContent_sourceName = relatedContent_sourceName obj}
    , if obj == default_RelatedContent{relatedContent_date = relatedContent_date obj} then P.Nothing else P.Just $ default_RelatedContent{relatedContent_date = relatedContent_date obj}
    , if obj == default_RelatedContent{relatedContent_teaser = relatedContent_teaser obj} then P.Nothing else P.Just $ default_RelatedContent{relatedContent_teaser = relatedContent_teaser obj}
    , if obj == default_RelatedContent{relatedContent_thumbnails = relatedContent_thumbnails obj} then P.Nothing else P.Just $ default_RelatedContent{relatedContent_thumbnails = relatedContent_thumbnails obj}
    , if obj == default_RelatedContent{relatedContent_contentType = relatedContent_contentType obj} then P.Nothing else P.Just $ default_RelatedContent{relatedContent_contentType = relatedContent_contentType obj}
    , if obj == default_RelatedContent{relatedContent_accessType = relatedContent_accessType obj} then P.Nothing else P.Just $ default_RelatedContent{relatedContent_accessType = relatedContent_accessType obj}
    , if obj == default_RelatedContent{relatedContent_visibleUrl = relatedContent_visibleUrl obj} then P.Nothing else P.Just $ default_RelatedContent{relatedContent_visibleUrl = relatedContent_visibleUrl obj}
    , if obj == default_RelatedContent{relatedContent_clipUrl = relatedContent_clipUrl obj} then P.Nothing else P.Just $ default_RelatedContent{relatedContent_clipUrl = relatedContent_clipUrl obj}
    , if obj == default_RelatedContent{relatedContent_contact = relatedContent_contact obj} then P.Nothing else P.Just $ default_RelatedContent{relatedContent_contact = relatedContent_contact obj}
    , if obj == default_RelatedContent{relatedContent_authors = relatedContent_authors obj} then P.Nothing else P.Just $ default_RelatedContent{relatedContent_authors = relatedContent_authors obj}
    ]
from_RelatedContent :: RelatedContent -> T.ThriftVal
from_RelatedContent record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v512 -> (1, ("contentId",T.TString $ E.encodeUtf8 _v512))) <$> relatedContent_contentId record
  , (\_v512 -> (2, ("title",T.TString $ E.encodeUtf8 _v512))) <$> relatedContent_title record
  , (\_v512 -> (3, ("url",T.TString $ E.encodeUtf8 _v512))) <$> relatedContent_url record
  , (\_v512 -> (4, ("sourceId",T.TString $ E.encodeUtf8 _v512))) <$> relatedContent_sourceId record
  , (\_v512 -> (5, ("sourceUrl",T.TString $ E.encodeUtf8 _v512))) <$> relatedContent_sourceUrl record
  , (\_v512 -> (6, ("sourceFaviconUrl",T.TString $ E.encodeUtf8 _v512))) <$> relatedContent_sourceFaviconUrl record
  , (\_v512 -> (7, ("sourceName",T.TString $ E.encodeUtf8 _v512))) <$> relatedContent_sourceName record
  , (\_v512 -> (8, ("date",T.TI64 _v512))) <$> relatedContent_date record
  , (\_v512 -> (9, ("teaser",T.TString $ E.encodeUtf8 _v512))) <$> relatedContent_teaser record
  , (\_v512 -> (10, ("thumbnails",T.TList (T.T_STRUCT typemap_RelatedContentImage) $ P.map (\_v514 -> from_RelatedContentImage _v514) $ Vector.toList _v512))) <$> relatedContent_thumbnails record
  , (\_v512 -> (11, ("contentType",T.TI32 $ P.fromIntegral $ P.fromEnum _v512))) <$> relatedContent_contentType record
  , (\_v512 -> (12, ("accessType",T.TI32 $ P.fromIntegral $ P.fromEnum _v512))) <$> relatedContent_accessType record
  , (\_v512 -> (13, ("visibleUrl",T.TString $ E.encodeUtf8 _v512))) <$> relatedContent_visibleUrl record
  , (\_v512 -> (14, ("clipUrl",T.TString $ E.encodeUtf8 _v512))) <$> relatedContent_clipUrl record
  , (\_v512 -> (15, ("contact",from_Contact _v512))) <$> relatedContent_contact record
  , (\_v512 -> (16, ("authors",T.TList T.T_STRING $ P.map (\_v516 -> T.TString $ E.encodeUtf8 _v516) $ Vector.toList _v512))) <$> relatedContent_authors record
  ]
write_RelatedContent :: T.Protocol p => p -> RelatedContent -> P.IO ()
write_RelatedContent oprot record = T.writeVal oprot $ from_RelatedContent record
encode_RelatedContent :: T.StatelessProtocol p => p -> RelatedContent -> LBS.ByteString
encode_RelatedContent oprot record = T.serializeVal oprot $ from_RelatedContent record
to_RelatedContent :: T.ThriftVal -> RelatedContent
to_RelatedContent (T.TStruct fields) = RelatedContent{
  relatedContent_contentId = P.maybe (P.Nothing) (\(_,_val518) -> P.Just (case _val518 of {T.TString _val519 -> E.decodeUtf8 _val519; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  relatedContent_title = P.maybe (P.Nothing) (\(_,_val518) -> P.Just (case _val518 of {T.TString _val520 -> E.decodeUtf8 _val520; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  relatedContent_url = P.maybe (P.Nothing) (\(_,_val518) -> P.Just (case _val518 of {T.TString _val521 -> E.decodeUtf8 _val521; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  relatedContent_sourceId = P.maybe (P.Nothing) (\(_,_val518) -> P.Just (case _val518 of {T.TString _val522 -> E.decodeUtf8 _val522; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  relatedContent_sourceUrl = P.maybe (P.Nothing) (\(_,_val518) -> P.Just (case _val518 of {T.TString _val523 -> E.decodeUtf8 _val523; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  relatedContent_sourceFaviconUrl = P.maybe (P.Nothing) (\(_,_val518) -> P.Just (case _val518 of {T.TString _val524 -> E.decodeUtf8 _val524; _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  relatedContent_sourceName = P.maybe (P.Nothing) (\(_,_val518) -> P.Just (case _val518 of {T.TString _val525 -> E.decodeUtf8 _val525; _ -> P.error "wrong type"})) (Map.lookup (7) fields),
  relatedContent_date = P.maybe (P.Nothing) (\(_,_val518) -> P.Just (case _val518 of {T.TI64 _val526 -> _val526; _ -> P.error "wrong type"})) (Map.lookup (8) fields),
  relatedContent_teaser = P.maybe (P.Nothing) (\(_,_val518) -> P.Just (case _val518 of {T.TString _val527 -> E.decodeUtf8 _val527; _ -> P.error "wrong type"})) (Map.lookup (9) fields),
  relatedContent_thumbnails = P.maybe (P.Nothing) (\(_,_val518) -> P.Just (case _val518 of {T.TList _ _val528 -> (Vector.fromList $ P.map (\_v529 -> (case _v529 of {T.TStruct _val530 -> (to_RelatedContentImage (T.TStruct _val530)); _ -> P.error "wrong type"})) _val528); _ -> P.error "wrong type"})) (Map.lookup (10) fields),
  relatedContent_contentType = P.maybe (P.Nothing) (\(_,_val518) -> P.Just (case _val518 of {T.TI32 _val531 -> P.toEnum $ P.fromIntegral _val531; _ -> P.error "wrong type"})) (Map.lookup (11) fields),
  relatedContent_accessType = P.maybe (P.Nothing) (\(_,_val518) -> P.Just (case _val518 of {T.TI32 _val532 -> P.toEnum $ P.fromIntegral _val532; _ -> P.error "wrong type"})) (Map.lookup (12) fields),
  relatedContent_visibleUrl = P.maybe (P.Nothing) (\(_,_val518) -> P.Just (case _val518 of {T.TString _val533 -> E.decodeUtf8 _val533; _ -> P.error "wrong type"})) (Map.lookup (13) fields),
  relatedContent_clipUrl = P.maybe (P.Nothing) (\(_,_val518) -> P.Just (case _val518 of {T.TString _val534 -> E.decodeUtf8 _val534; _ -> P.error "wrong type"})) (Map.lookup (14) fields),
  relatedContent_contact = P.maybe (P.Nothing) (\(_,_val518) -> P.Just (case _val518 of {T.TStruct _val535 -> (to_Contact (T.TStruct _val535)); _ -> P.error "wrong type"})) (Map.lookup (15) fields),
  relatedContent_authors = P.maybe (P.Nothing) (\(_,_val518) -> P.Just (case _val518 of {T.TList _ _val536 -> (Vector.fromList $ P.map (\_v537 -> (case _v537 of {T.TString _val538 -> E.decodeUtf8 _val538; _ -> P.error "wrong type"})) _val536); _ -> P.error "wrong type"})) (Map.lookup (16) fields)
  }
to_RelatedContent _ = P.error "not a struct"
read_RelatedContent :: T.Protocol p => p -> P.IO RelatedContent
read_RelatedContent iprot = to_RelatedContent <$> T.readVal iprot (T.T_STRUCT typemap_RelatedContent)
decode_RelatedContent :: T.StatelessProtocol p => p -> LBS.ByteString -> RelatedContent
decode_RelatedContent iprot bs = to_RelatedContent $ T.deserializeVal iprot (T.T_STRUCT typemap_RelatedContent) bs
typemap_RelatedContent :: T.TypeMap
typemap_RelatedContent = Map.fromList [(1,("contentId",T.T_STRING)),(2,("title",T.T_STRING)),(3,("url",T.T_STRING)),(4,("sourceId",T.T_STRING)),(5,("sourceUrl",T.T_STRING)),(6,("sourceFaviconUrl",T.T_STRING)),(7,("sourceName",T.T_STRING)),(8,("date",T.T_I64)),(9,("teaser",T.T_STRING)),(10,("thumbnails",(T.T_LIST (T.T_STRUCT typemap_RelatedContentImage)))),(11,("contentType",T.T_I32)),(12,("accessType",T.T_I32)),(13,("visibleUrl",T.T_STRING)),(14,("clipUrl",T.T_STRING)),(15,("contact",(T.T_STRUCT typemap_Contact))),(16,("authors",(T.T_LIST T.T_STRING)))]
default_RelatedContent :: RelatedContent
default_RelatedContent = RelatedContent{
  relatedContent_contentId = P.Nothing,
  relatedContent_title = P.Nothing,
  relatedContent_url = P.Nothing,
  relatedContent_sourceId = P.Nothing,
  relatedContent_sourceUrl = P.Nothing,
  relatedContent_sourceFaviconUrl = P.Nothing,
  relatedContent_sourceName = P.Nothing,
  relatedContent_date = P.Nothing,
  relatedContent_teaser = P.Nothing,
  relatedContent_thumbnails = P.Nothing,
  relatedContent_contentType = P.Nothing,
  relatedContent_accessType = P.Nothing,
  relatedContent_visibleUrl = P.Nothing,
  relatedContent_clipUrl = P.Nothing,
  relatedContent_contact = P.Nothing,
  relatedContent_authors = P.Nothing}
data BusinessInvitation = BusinessInvitation  { businessInvitation_businessId :: P.Maybe I.Int32
  , businessInvitation_email :: P.Maybe LT.Text
  , businessInvitation_role :: P.Maybe BusinessUserRole
  , businessInvitation_status :: P.Maybe BusinessInvitationStatus
  , businessInvitation_requesterId :: P.Maybe I.Int32
  , businessInvitation_fromWorkChat :: P.Maybe P.Bool
  , businessInvitation_created :: P.Maybe I.Int64
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable BusinessInvitation where
  hashWithSalt salt record = salt   `H.hashWithSalt` businessInvitation_businessId record   `H.hashWithSalt` businessInvitation_email record   `H.hashWithSalt` businessInvitation_role record   `H.hashWithSalt` businessInvitation_status record   `H.hashWithSalt` businessInvitation_requesterId record   `H.hashWithSalt` businessInvitation_fromWorkChat record   `H.hashWithSalt` businessInvitation_created record  
instance QC.Arbitrary BusinessInvitation where 
  arbitrary = M.liftM BusinessInvitation (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_BusinessInvitation = []
             | P.otherwise = M.catMaybes
    [ if obj == default_BusinessInvitation{businessInvitation_businessId = businessInvitation_businessId obj} then P.Nothing else P.Just $ default_BusinessInvitation{businessInvitation_businessId = businessInvitation_businessId obj}
    , if obj == default_BusinessInvitation{businessInvitation_email = businessInvitation_email obj} then P.Nothing else P.Just $ default_BusinessInvitation{businessInvitation_email = businessInvitation_email obj}
    , if obj == default_BusinessInvitation{businessInvitation_role = businessInvitation_role obj} then P.Nothing else P.Just $ default_BusinessInvitation{businessInvitation_role = businessInvitation_role obj}
    , if obj == default_BusinessInvitation{businessInvitation_status = businessInvitation_status obj} then P.Nothing else P.Just $ default_BusinessInvitation{businessInvitation_status = businessInvitation_status obj}
    , if obj == default_BusinessInvitation{businessInvitation_requesterId = businessInvitation_requesterId obj} then P.Nothing else P.Just $ default_BusinessInvitation{businessInvitation_requesterId = businessInvitation_requesterId obj}
    , if obj == default_BusinessInvitation{businessInvitation_fromWorkChat = businessInvitation_fromWorkChat obj} then P.Nothing else P.Just $ default_BusinessInvitation{businessInvitation_fromWorkChat = businessInvitation_fromWorkChat obj}
    , if obj == default_BusinessInvitation{businessInvitation_created = businessInvitation_created obj} then P.Nothing else P.Just $ default_BusinessInvitation{businessInvitation_created = businessInvitation_created obj}
    ]
from_BusinessInvitation :: BusinessInvitation -> T.ThriftVal
from_BusinessInvitation record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v541 -> (1, ("businessId",T.TI32 _v541))) <$> businessInvitation_businessId record
  , (\_v541 -> (2, ("email",T.TString $ E.encodeUtf8 _v541))) <$> businessInvitation_email record
  , (\_v541 -> (3, ("role",T.TI32 $ P.fromIntegral $ P.fromEnum _v541))) <$> businessInvitation_role record
  , (\_v541 -> (4, ("status",T.TI32 $ P.fromIntegral $ P.fromEnum _v541))) <$> businessInvitation_status record
  , (\_v541 -> (5, ("requesterId",T.TI32 _v541))) <$> businessInvitation_requesterId record
  , (\_v541 -> (6, ("fromWorkChat",T.TBool _v541))) <$> businessInvitation_fromWorkChat record
  , (\_v541 -> (7, ("created",T.TI64 _v541))) <$> businessInvitation_created record
  ]
write_BusinessInvitation :: T.Protocol p => p -> BusinessInvitation -> P.IO ()
write_BusinessInvitation oprot record = T.writeVal oprot $ from_BusinessInvitation record
encode_BusinessInvitation :: T.StatelessProtocol p => p -> BusinessInvitation -> LBS.ByteString
encode_BusinessInvitation oprot record = T.serializeVal oprot $ from_BusinessInvitation record
to_BusinessInvitation :: T.ThriftVal -> BusinessInvitation
to_BusinessInvitation (T.TStruct fields) = BusinessInvitation{
  businessInvitation_businessId = P.maybe (P.Nothing) (\(_,_val543) -> P.Just (case _val543 of {T.TI32 _val544 -> _val544; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  businessInvitation_email = P.maybe (P.Nothing) (\(_,_val543) -> P.Just (case _val543 of {T.TString _val545 -> E.decodeUtf8 _val545; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  businessInvitation_role = P.maybe (P.Nothing) (\(_,_val543) -> P.Just (case _val543 of {T.TI32 _val546 -> P.toEnum $ P.fromIntegral _val546; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  businessInvitation_status = P.maybe (P.Nothing) (\(_,_val543) -> P.Just (case _val543 of {T.TI32 _val547 -> P.toEnum $ P.fromIntegral _val547; _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  businessInvitation_requesterId = P.maybe (P.Nothing) (\(_,_val543) -> P.Just (case _val543 of {T.TI32 _val548 -> _val548; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  businessInvitation_fromWorkChat = P.maybe (P.Nothing) (\(_,_val543) -> P.Just (case _val543 of {T.TBool _val549 -> _val549; _ -> P.error "wrong type"})) (Map.lookup (6) fields),
  businessInvitation_created = P.maybe (P.Nothing) (\(_,_val543) -> P.Just (case _val543 of {T.TI64 _val550 -> _val550; _ -> P.error "wrong type"})) (Map.lookup (7) fields)
  }
to_BusinessInvitation _ = P.error "not a struct"
read_BusinessInvitation :: T.Protocol p => p -> P.IO BusinessInvitation
read_BusinessInvitation iprot = to_BusinessInvitation <$> T.readVal iprot (T.T_STRUCT typemap_BusinessInvitation)
decode_BusinessInvitation :: T.StatelessProtocol p => p -> LBS.ByteString -> BusinessInvitation
decode_BusinessInvitation iprot bs = to_BusinessInvitation $ T.deserializeVal iprot (T.T_STRUCT typemap_BusinessInvitation) bs
typemap_BusinessInvitation :: T.TypeMap
typemap_BusinessInvitation = Map.fromList [(1,("businessId",T.T_I32)),(2,("email",T.T_STRING)),(3,("role",T.T_I32)),(4,("status",T.T_I32)),(5,("requesterId",T.T_I32)),(6,("fromWorkChat",T.T_BOOL)),(7,("created",T.T_I64))]
default_BusinessInvitation :: BusinessInvitation
default_BusinessInvitation = BusinessInvitation{
  businessInvitation_businessId = P.Nothing,
  businessInvitation_email = P.Nothing,
  businessInvitation_role = P.Nothing,
  businessInvitation_status = P.Nothing,
  businessInvitation_requesterId = P.Nothing,
  businessInvitation_fromWorkChat = P.Nothing,
  businessInvitation_created = P.Nothing}
data UserIdentity = UserIdentity  { userIdentity_type :: P.Maybe UserIdentityType
  , userIdentity_stringIdentifier :: P.Maybe LT.Text
  , userIdentity_longIdentifier :: P.Maybe I.Int64
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable UserIdentity where
  hashWithSalt salt record = salt   `H.hashWithSalt` userIdentity_type record   `H.hashWithSalt` userIdentity_stringIdentifier record   `H.hashWithSalt` userIdentity_longIdentifier record  
instance QC.Arbitrary UserIdentity where 
  arbitrary = M.liftM UserIdentity (M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_UserIdentity = []
             | P.otherwise = M.catMaybes
    [ if obj == default_UserIdentity{userIdentity_type = userIdentity_type obj} then P.Nothing else P.Just $ default_UserIdentity{userIdentity_type = userIdentity_type obj}
    , if obj == default_UserIdentity{userIdentity_stringIdentifier = userIdentity_stringIdentifier obj} then P.Nothing else P.Just $ default_UserIdentity{userIdentity_stringIdentifier = userIdentity_stringIdentifier obj}
    , if obj == default_UserIdentity{userIdentity_longIdentifier = userIdentity_longIdentifier obj} then P.Nothing else P.Just $ default_UserIdentity{userIdentity_longIdentifier = userIdentity_longIdentifier obj}
    ]
from_UserIdentity :: UserIdentity -> T.ThriftVal
from_UserIdentity record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v553 -> (1, ("type",T.TI32 $ P.fromIntegral $ P.fromEnum _v553))) <$> userIdentity_type record
  , (\_v553 -> (2, ("stringIdentifier",T.TString $ E.encodeUtf8 _v553))) <$> userIdentity_stringIdentifier record
  , (\_v553 -> (3, ("longIdentifier",T.TI64 _v553))) <$> userIdentity_longIdentifier record
  ]
write_UserIdentity :: T.Protocol p => p -> UserIdentity -> P.IO ()
write_UserIdentity oprot record = T.writeVal oprot $ from_UserIdentity record
encode_UserIdentity :: T.StatelessProtocol p => p -> UserIdentity -> LBS.ByteString
encode_UserIdentity oprot record = T.serializeVal oprot $ from_UserIdentity record
to_UserIdentity :: T.ThriftVal -> UserIdentity
to_UserIdentity (T.TStruct fields) = UserIdentity{
  userIdentity_type = P.maybe (P.Nothing) (\(_,_val555) -> P.Just (case _val555 of {T.TI32 _val556 -> P.toEnum $ P.fromIntegral _val556; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  userIdentity_stringIdentifier = P.maybe (P.Nothing) (\(_,_val555) -> P.Just (case _val555 of {T.TString _val557 -> E.decodeUtf8 _val557; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  userIdentity_longIdentifier = P.maybe (P.Nothing) (\(_,_val555) -> P.Just (case _val555 of {T.TI64 _val558 -> _val558; _ -> P.error "wrong type"})) (Map.lookup (3) fields)
  }
to_UserIdentity _ = P.error "not a struct"
read_UserIdentity :: T.Protocol p => p -> P.IO UserIdentity
read_UserIdentity iprot = to_UserIdentity <$> T.readVal iprot (T.T_STRUCT typemap_UserIdentity)
decode_UserIdentity :: T.StatelessProtocol p => p -> LBS.ByteString -> UserIdentity
decode_UserIdentity iprot bs = to_UserIdentity $ T.deserializeVal iprot (T.T_STRUCT typemap_UserIdentity) bs
typemap_UserIdentity :: T.TypeMap
typemap_UserIdentity = Map.fromList [(1,("type",T.T_I32)),(2,("stringIdentifier",T.T_STRING)),(3,("longIdentifier",T.T_I64))]
default_UserIdentity :: UserIdentity
default_UserIdentity = UserIdentity{
  userIdentity_type = P.Nothing,
  userIdentity_stringIdentifier = P.Nothing,
  userIdentity_longIdentifier = P.Nothing}
